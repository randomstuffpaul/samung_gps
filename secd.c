/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __libc_init();
__int64 __cxa_atexit();
__int64 __register_atfork();
__int64 __strrchr_chk();
__int64 Suntory_FreeBlobStatusList();
__int64 Suntory_GetAllBlobStatus();
void *__fastcall malloc(size_t size);
void *__fastcall memset(void *s, int c, size_t n);
void *__fastcall memcpy(void *dest, const void *src, size_t n);
__int64 __fastcall strncmp(const char *s1, const char *s2, size_t n);
__int64 __fastcall std::__1::ios_base::init(std::__1::ios_base *__hidden this, void *); // idb
__int64 __fastcall std::__1::locale::locale(std::__1::locale *__hidden this); // idb
void __fastcall operator delete(void *); // idb
size_t __fastcall strlen(const char *s);
void __fastcall free(void *ptr);
__int64 property_get();
__int64 __fastcall strcmp(const char *s1, const char *s2);
__int64 __memcpy_chk();
__int64 libasb_get_startup_reason();
DIR *__fastcall opendir(const char *name);
struct dirent *__fastcall readdir(DIR *dirp);
__int64 __fastcall closedir(DIR *dirp);
__int64 __fastcall std::__1::locale::~locale(std::__1::locale *__hidden this); // idb
__int64 __fastcall std::__1::ios_base::~ios_base(std::__1::ios_base *__hidden this); // idb
__int64 __fastcall std::__1::ios_base::getloc(std::__1::ios_base *__hidden this); // idb
__int64 std::__1::locale::use_facet();
__int64 __fastcall std::__1::ios_base::clear(std::__1::ios_base *__hidden this, unsigned int); // idb
__int64 std::uncaught_exception(void); // idb
__int64 __fastcall operator new(unsigned __int64); // idb
void __noreturn abort();
void *__fastcall memmove(void *dest, const void *src, size_t n);
__int64 __errno();
char *__fastcall strerror(int errnum);
__int64 __fastcall pthread_mutex_lock(pthread_mutex_t *mutex);
__int64 __fastcall pthread_mutex_unlock(pthread_mutex_t *mutex);
__int64 idd_create();
__int64 idd_add_event();
__int64 idd_destroy();
__sighandler_t __fastcall signal(int sig, __sighandler_t handler);
__int64 __FD_SET_chk();
__int64 __fastcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
__int64 __FD_ISSET_chk();
size_t __fastcall strnlen(const char *string, size_t maxlen);
__int64 __vsnprintf_chk();
__int64 __android_log_buf_print();
void *__fastcall realloc(void *ptr, size_t size);
__int64 android_get_control_socket();
__int64 __fastcall listen(int fd, int n);
__int64 __fastcall close(int fd);
__int64 __fastcall accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
ssize_t __fastcall recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
ssize_t __fastcall sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
__int64 QSEECom_start_app();
__int64 QSEECom_set_bandwidth();
__int64 QSEECom_send_cmd();
__int64 QSEECom_shutdown_app();
__int64 __strncpy_chk2();
__int64 __memset_chk();
__int64 property_set();
__int64 Suntory_ConvertAllBlobs();
__int64 __fastcall sleep(unsigned int seconds);
__int64 SuntoryTee_LoadBlob();
__int64 Suntory_GetBlobType();
__int64 SuntoryTee_Sign();
__int64 SuntoryTee_Verify();
__int64 SuntoryTee_GetKey();
__int64 SuntoryTee_GetCert();
__int64 SuntoryTee_GetCredential();
__int64 SuntoryTee_GetAllCredentialData();
__int64 __android_log_write();
__int64 sqlite3_open_v2();
__int64 sqlite3_prepare_v2();
__int64 sqlite3_errmsg();
__int64 sqlite3_step();
__int64 __fastcall chmod(const char *file, __mode_t mode);
__int64 sqlite3_finalize();
__int64 sqlite3_close();
__int64 sqlite3_exec();
__int64 __fastcall remove(const char *filename);
__int64 sqlite3_bind_blob();
__int64 sqlite3_column_blob();
__int64 sqlite3_column_bytes();
FILE *__fastcall fopen(const char *filename, const char *modes);
__int64 __fastcall fseek(FILE *stream, __int64 off, int whence);
__int64 __fastcall fclose(FILE *stream);
__int64 __fastcall ftell(FILE *stream);
size_t __fastcall fread(void *ptr, size_t size, size_t n, FILE *stream);
__int64 miscta_write_unit_critical();
__int64 miscta_get_unit_size();
__int64 miscta_read_unit();
size_t __fastcall fwrite(const void *ptr, size_t size, size_t n, FILE *s);
__int64 protobuf_c_message_get_packed_size();
__int64 protobuf_c_message_pack();
__int64 __fastcall memcmp(const void *s1, const void *s2, size_t n);
__int64 __snprintf_chk();
__int64 __fastcall atoi(const char *nptr);
char *__fastcall strchr(const char *s, int c);
void *__fastcall bsearch(const void *key, const void *base, size_t nmemb, size_t size, __compar_fn_t compar);
__int64 __strlen_chk();
__int64 __fastcall fputs(const char *s, FILE *stream);
char *__fastcall strdup(const char *s);
__int64 __fastcall strcasecmp(const char *s1, const char *s2);
__int64 __fastcall strncasecmp(const char *s1, const char *s2, size_t n);
__int64 __fastcall dup(int fd);
__int64 __fastcall syscall(__int64 sysno);
__int64 __open_2();
__int64 __fastcall fcntl(int fd, int cmd);
ssize_t __fastcall read(int fd, void *buf, size_t nbytes);
__int64 __fastcall pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
__int64 __fastcall pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
__int64 __fastcall pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
__int64 __fastcall pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
__int64 __fastcall pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
__int64 __fastcall pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
void *__fastcall pthread_getspecific(pthread_key_t key);
__int64 __fastcall pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
__int64 __fastcall pthread_setspecific(pthread_key_t key, const void *pointer);
void *__fastcall memchr(const void *s, int c, size_t n);
unsigned __int64 __fastcall getauxval(unsigned __int64 type);
void __fastcall qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
__int64 __fastcall isxdigit(int a1);
time_t __fastcall time(time_t *timer);
__int64 __fastcall isspace(int a1);
__int64 __fastcall tolower(int c);
__int64 __fastcall isupper(int a1);
__int64 __fastcall sscanf(const char *s, const char *format);
unsigned __int64 __fastcall strtoul(const char *nptr, char **endptr, int base);
struct tm *__fastcall gmtime_r(const time_t *timer, struct tm *tp);
__int64 __fastcall ferror(FILE *stream);
char *__fastcall fgets(char *s, int n, FILE *stream);
__int64 __fastcall feof(FILE *stream);
__int64 __fastcall fflush(FILE *stream);
__int64 __strcat_chk();
char *__fastcall strncpy(char *dest, const char *src, size_t n);
__int64 __strchr_chk();
void __fastcall start(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 (*__fastcall sub_3321C(__int64 (*result)(void)))(void);
__int64 __fastcall sub_332B0(_QWORD *a1, _DWORD *a2);
__int64 __fastcall sub_3364C(_DWORD *a1);
void __fastcall sub_33870(void **a1);
__int64 __fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::operator<<(__int64 result);
__int64 __fastcall sub_34A48(__int64 a1);
__int64 __fastcall sub_34AB4(_QWORD *a1);
__int64 __fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(__int64 a1);
void __fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(__int64 a1);
__int64 __fastcall `virtual thunk to'std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(_QWORD *a1);
void __fastcall `virtual thunk to'std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(_QWORD *a1);
void __fastcall sub_34BA4(__int64 a1);
void __fastcall sub_34C18(_QWORD *a1);
__int64 __fastcall sub_34C9C(__int64 a1);
void __fastcall sub_34CEC(__int64 a1);
__int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(_QWORD); // weak
__int64 __fastcall sub_34D48(__int64 a1, signed __int64 a2, int a3, char a4);
__int64 __fastcall sub_34EA8(__int64 a1);
__int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::sync();
__int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::showmanyc();
signed __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsgetn(_QWORD *a1, _BYTE *a2, signed __int64 a3);
signed __int64 __fastcall sub_34F8C(__int64 a1);
signed __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::uflow(__int64 a1);
signed __int64 __fastcall sub_3502C(__int64 a1, unsigned int a2);
signed __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsputn(_QWORD *a1, unsigned __int8 *a2, signed __int64 a3);
__int64 __fastcall sub_35168(__int64 a1, int a2);
__int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::~basic_streambuf(_QWORD *a1);
void __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::~basic_streambuf(_QWORD *a1);
__int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::seekpos();
signed __int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::underflow();
void __fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::__grow_by(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, size_t a5, __int64 a6, __int64 a7);
void __noreturn std::__1::__basic_string_common<true>::__throw_length_error();
_QWORD *__fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::append(_QWORD *a1, size_t a2, int a3);
_QWORD *__fastcall sub_3563C(_QWORD *result, unsigned __int8 *a2);
_QWORD *__fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::assign(_QWORD *a1, const void *a2, size_t a3);
void __fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::__grow_by_and_replace(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, size_t a5, __int64 a6, size_t a7, const void *a8);
void __fastcall sub_359A8(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall sub_35B48(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6);
_QWORD *__fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::flush(_QWORD *a1);
// __int64 __usercall sub_35DCC@<X0>(__int64 result@<X0>, _QWORD *a2@<X8>);
__int64 __fastcall sub_35FF8(__int64 result, _DWORD *a2);
__int64 __fastcall sub_36278(_DWORD *a1);
__int64 __fastcall sub_362A0(int a1, __int64 *a2, _DWORD *a3);
__int64 __fastcall sub_3635C(void **a1);
__int64 __fastcall sub_36400(_DWORD *a1);
__int64 __fastcall sub_364A4(_DWORD *a1);
__int64 __fastcall sub_36548(unsigned int a1, unsigned int a2, char *a3, unsigned int a4, _BYTE *a5);
__int64 __fastcall sub_3661C(unsigned int a1, unsigned int a2, __int64 a3, unsigned int a4, _BYTE *a5);
__int64 __fastcall sub_366F0(unsigned int a1, __int64 a2);
signed __int64 __fastcall sub_3679C(_DWORD *a1);
__int64 __fastcall sub_36824(_DWORD *a1);
__int64 __fastcall sub_368C8(_QWORD *a1, _DWORD *a2);
__int64 __fastcall sub_36974(size_t a1, unsigned int a2, _QWORD *a3, _DWORD *a4);
__int64 __fastcall sub_36A38(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_36AE4(void **a1);
__int64 __fastcall sub_36B88(unsigned int a1, _DWORD *a2);
__int64 __fastcall sub_36C34(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4);
void __fastcall sub_36EE8(int a1);
__int64 sub_37008();
void __fastcall sub_3717C(__int64 a1);
void __fastcall sub_37364(__int64 a1);
char *__fastcall sub_379C4(unsigned int a1);
__int64 sub_379E4(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, ...);
signed __int64 __fastcall sub_37AF8(__int64 a1, int a2);
signed __int64 __fastcall sub_37BB0(__int64 a1, int a2, unsigned int a3, const void *a4);
signed __int64 __fastcall sub_37F74(__int64 a1, int a2, _DWORD *a3, signed __int64 *a4);
void __fastcall sub_3825C(__int64 a1);
__int64 sub_3828C();
__int64 __fastcall sub_38398(unsigned __int8 *a1, int a2, int *a3);
signed __int64 __fastcall sub_38640(int a1, char *a2, unsigned int a3);
__int64 __fastcall sub_38710(char *a1, int a2);
signed __int64 __fastcall sub_387E8(int a1, char *a2, unsigned int a3);
__int64 __fastcall sub_388B0(int a1);
signed __int64 __fastcall sub_388CC(__int64 a1, unsigned int a2, _BYTE *a3);
__int64 __fastcall sub_38DF0(__int64 a1, unsigned __int128 *a2);
char *__fastcall sub_38F2C(unsigned int a1);
__int64 __fastcall sub_38F4C(__int64 a1, int a2, const void *a3, unsigned int a4, void *a5, int a6);
size_t __fastcall sub_39240(size_t result, unsigned int a2, _QWORD *a3, _DWORD *a4);
__int64 __fastcall sub_39C10(void **a1);
__int64 __fastcall sub_39E6C(int a1, __int64 *a2, _DWORD *a3);
__int64 __fastcall sub_3A478(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_3A734(_DWORD *a1);
__int64 __fastcall sub_3A99C(_DWORD *a1);
__int64 __fastcall sub_3ABDC(_DWORD *a1);
signed __int64 sub_3ACD4();
__int64 __fastcall sub_3ACDC(__int64 a1, unsigned int a2, char *a3, unsigned int a4, _BYTE *a5);
__int64 __fastcall sub_3B14C(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4, _BYTE *a5);
__int64 __fastcall sub_3B4DC(unsigned int a1, __int64 a2);
void __fastcall sub_3B69C(__int64 a1);
__int64 sub_3BB6C();
__int64 __fastcall sub_3C170(_DWORD *a1);
__int64 __fastcall sub_3C198(const char *a1, const char *a2, unsigned int a3, const char *a4, int a5, void **a6, unsigned int *a7);
__int64 __fastcall sub_3C30C(unsigned int a1, const char *a2, int a3, _QWORD *a4, __int64 a5);
__int64 __fastcall sub_3C534(__int64 a1, int a2);
__int64 __fastcall sub_3C660(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_3C79C(__int64 a1, int a2, __int64 a3, int a4, _QWORD *a5, int *a6);
__int64 __fastcall sub_3C910(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6);
void sub_3CA6C();
__int64 __fastcall sub_3CB24(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
void __fastcall sub_3CBCC(const char *a1, int a2, const char *a3, const char *a4, unsigned int a5, void **a6, unsigned int *a7);
__int64 __fastcall sub_3CD30(__int64 a1, int a2);
__int64 __fastcall sub_3CE50(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_3CF74(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6);
__int64 __fastcall sub_3D0B8(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6);
__int64 __fastcall sub_3D1FC(const char *a1, int a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_3D420(__int64 a1, int a2, __int64 a3, _QWORD *a4);
signed __int64 sub_3D558();
__int64 __fastcall sub_3D560(__int64 result);
__int64 __fastcall sub_3D70C(__int64 result);
__int64 __fastcall sub_3D8CC(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_3DA74(__int64 *a1);
__int64 __fastcall sub_3DB88(__int64 result);
__int64 sub_3DD1C();
__int64 __fastcall sub_3DE88(void **a1, _DWORD *a2);
int *__fastcall sub_3E02C(int a1);
__int64 sub_3E16C();
__int64 sub_3E18C();
__int64 __fastcall sub_3E3C8(__int64 result, __int64 a2, unsigned int a3);
__int64 __fastcall sub_3E520(_QWORD *a1);
__int64 __fastcall sub_3E6FC(__int64 a1);
__int64 sub_3E8CC();
__int64 __fastcall sub_3E97C(__int64 a1, __int64 a2, int a3, __int64 a4, int a5, __int64 a6, int a7, __int64 a8, __int64 a9, __int64 a10, int a11);
__int64 __fastcall sub_3EE18(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_3EF6C(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6, _QWORD *a7, unsigned int *a8, _QWORD *a9, unsigned int *a10);
__int64 __fastcall sub_3F110(__int64 a1, int a2, __int64 a3, int a4, _QWORD *a5, unsigned int *a6, _QWORD *a7, unsigned int *a8);
size_t __fastcall sub_3F674(const char *a1, int a2, const char *a3, int a4, _DWORD *a5);
__int64 __fastcall sub_3F950(const char *a1, int a2, const char *a3, unsigned int a4, __int64 a5, __int64 a6);
void sub_3FD98();
__int64 sub_4010C();
void sub_40450();
long double __fastcall sub_4057C(__int64 a1);
__int64 __fastcall j__protobuf_c_message_get_packed_size(_QWORD); // weak
__int64 __fastcall j__protobuf_c_message_pack(_QWORD, _QWORD); // weak
void sub_405A0();
void __fastcall sub_40D9C(_QWORD *a1);
void __fastcall sub_410C8(_QWORD *a1);
void __fastcall sub_4117C(__int64 a1, const char *a2, int a3, __int64 a4, int a5, const char *a6, unsigned int a7, __int64 a8, __int64 a9, void **a10, unsigned int *a11);
void __fastcall sub_42060(const void *a1, unsigned int a2, const void *a3, unsigned int a4, const void *a5, unsigned int a6, const void *a7, unsigned int a8, __int64 a9, int a10, unsigned int a11, _QWORD *a12, _DWORD *a13);
void __fastcall sub_4238C(_DWORD *a1, int a2, __int64 a3, _QWORD *a4, unsigned int *a5, _QWORD *a6, unsigned int *a7, _QWORD *a8, unsigned int *a9, _QWORD *a10, unsigned int *a11, _DWORD *a12, _DWORD *a13);
__int64 __fastcall sub_426D0(_QWORD *a1, unsigned int *a2, const void **a3);
__int64 __fastcall sub_42848(__int64 a1, unsigned int a2, __int64 a3, int a4, __int64 a5, _DWORD *a6, unsigned int a7);
__int64 __fastcall sub_42B80(__int64 a1, int a2, char *a3, unsigned int a4, __int64 a5, _DWORD *a6, unsigned int a7);
__int64 __fastcall sub_42ED4(__int64 a1, int a2, char *a3, unsigned int a4, void *a5, _DWORD *a6, unsigned int a7);
void *__fastcall EVP_get_cipherbynid(signed int a1);
void *__fastcall EVP_CIPHER_CTX_init(void *a1);
void *EVP_CIPHER_CTX_new();
signed __int64 __fastcall EVP_CIPHER_CTX_cleanup(void **a1);
void __fastcall EVP_CIPHER_CTX_free(void **a1);
__int64 __fastcall EVP_CIPHER_CTX_copy(__int64 *a1, const void **a2);
__int64 __fastcall EVP_CipherInit_ex(unsigned int **a1, unsigned int *a2, __int64 a3, __int64 a4, const void *a5, int a6);
__int64 __fastcall EVP_CIPHER_CTX_ctrl(__int64 a1);
__int64 __fastcall EVP_CIPHER_CTX_flags(__int64 a1);
__int64 __fastcall EVP_CIPHER_CTX_mode(__int64 a1);
__int64 __fastcall EVP_CIPHER_CTX_iv_length(__int64 a1);
__int64 __fastcall EVP_EncryptInit_ex(unsigned int **a1, unsigned int *a2, __int64 a3, __int64 a4, const void *a5);
__int64 __fastcall EVP_DecryptInit_ex(unsigned int **a1, unsigned int *a2, __int64 a3, __int64 a4, const void *a5);
__int64 __fastcall EVP_EncryptUpdate(signed int *a1, __int64 a2, int *a3, char *a4, int a5);
__int64 __fastcall EVP_EncryptFinal_ex(__int64 *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall EVP_DecryptUpdate(signed int *a1, void *a2, int *a3, char *a4, int a5);
signed __int64 __fastcall EVP_DecryptFinal_ex(__int64 *a1, unsigned __int64 a2, unsigned int *a3);
__int64 __fastcall EVP_Cipher(__int64 a1);
__int64 __fastcall EVP_CipherUpdate(signed int *a1, __int64 a2, int *a3, char *a4, int a5);
__int64 __fastcall EVP_CipherFinal_ex(__int64 *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall lh_num_items(__int64 a1);
__int64 __fastcall EVP_MD_CTX_type(unsigned int **a1);
__int64 __fastcall EVP_MD_CTX_size(__int64 a1);
__int64 __fastcall EVP_CIPHER_CTX_key_length(__int64 a1);
__int64 __fastcall EVP_CIPHER_CTX_get_app_data(__int64 a1);
__int64 __fastcall X509_STORE_CTX_set_cert(__int64 result, __int64 a2);
signed __int64 __fastcall EVP_CIPHER_CTX_set_padding(__int64 a1, int a2);
signed __int64 __fastcall EVP_CIPHER_CTX_set_key_length(_DWORD *a1, int a2);
__int64 __fastcall X509_TRUST_get_trust(unsigned int *a1);
__int64 __fastcall X509_TRUST_get_flags(__int64 a1);
__int64 __fastcall EVP_MD_flags(__int64 a1);
__int64 __fastcall EVP_CIPHER_iv_length(__int64 a1);
__int64 __fastcall EVP_CIPHER_flags(__int64 a1);
__int64 __fastcall EVP_CIPHER_mode(__int64 a1);
__int64 __fastcall EVP_CipherInit(unsigned int **a1, unsigned int *a2, __int64 a3, const void *a4, int a5);
__int64 __fastcall EVP_EncryptInit(unsigned int **a1, unsigned int *a2, __int64 a3, const void *a4);
__int64 __fastcall EVP_DecryptInit(unsigned int **a1, unsigned int *a2, __int64 a3, const void *a4);
signed __int64 X509V3_add_standard_extensions();
void *__fastcall EVP_get_cipherbyname(__int64 a1);
void *EVP_aes_128_cbc();
void *EVP_aes_128_ctr();
void *EVP_aes_128_ecb();
void *EVP_aes_128_ofb();
void *EVP_aes_128_gcm();
void *EVP_aes_192_cbc();
void *EVP_aes_192_ctr();
void *EVP_aes_192_ecb();
void *EVP_aes_192_gcm();
void *EVP_aes_256_cbc();
void *EVP_aes_256_ctr();
void *EVP_aes_256_ecb();
void *EVP_aes_256_ofb();
void *EVP_aes_256_gcm();
void *EVP_aead_aes_128_gcm();
void *EVP_aead_aes_256_gcm();
void *EVP_aead_aes_128_ctr_hmac_sha256();
void *EVP_aead_aes_256_ctr_hmac_sha256();
__int64 EVP_has_aes_hardware();
signed __int64 __fastcall sub_44218(_QWORD *a1, unsigned __int8 *a2, __int64 a3, int a4);
signed __int64 __fastcall sub_443A0(__int64 a1, long double *a2, _QWORD *a3, unsigned __int64 a4);
signed __int64 __fastcall sub_44404(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4);
signed __int64 __fastcall sub_44458(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_444C8(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_444FC(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3);
__int64 __fastcall sub_4462C(__int64 a1, _BYTE *a2, int8x16_t *a3, unsigned __int64 a4);
void __fastcall sub_44758(__int64 a1);
void *__fastcall sub_447A0(__int64 a1, int a2, size_t a3, _QWORD *a4);
signed __int64 __fastcall sub_44AA4(__int64 a1, unsigned __int8 *a2, __int64 a3, unsigned __int64 a4);
void __fastcall sub_44BC4(__int64 a1);
signed __int64 __fastcall sub_44BF0(__int64 a1, _BYTE *a2, _QWORD *a3, unsigned __int64 a4, unsigned __int64 a5, unsigned __int64 a6, char *a7, unsigned __int64 a8, int8x16_t *a9, unsigned __int64 a10);
signed __int64 __fastcall sub_44D64(__int64 a1, _BYTE *a2, __int64 *a3, unsigned __int64 a4, unsigned __int64 a5, unsigned __int64 a6, char *a7, unsigned __int64 a8, int8x16_t *a9, unsigned __int64 a10);
signed __int64 __fastcall sub_44EEC(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, unsigned __int64 a4);
void __fastcall sub_45100(__int64 a1);
signed __int64 __fastcall sub_4512C(__int64 a1, char *a2, _QWORD *a3, unsigned __int64 a4, __int64 a5, __int64 a6, char *a7, unsigned __int64 a8, char *a9, size_t a10);
signed __int64 __fastcall sub_452DC(__int64 a1, _BYTE *a2, unsigned __int64 *a3, unsigned __int64 a4, char *a5, __int64 a6, char *a7, unsigned __int64 a8, char *a9, size_t a10);
signed __int64 __fastcall sub_45478(_BYTE *a1, const void *a2, const void *a3, char *a4, size_t a5, char *a6, char *a7, size_t a8);
void *EVP_des_cbc();
void *EVP_des_ecb();
void *EVP_des_ede3_cbc();
void *EVP_des_ede_cbc();
void *EVP_des_ede();
signed __int64 __fastcall sub_4566C(__int64 a1, unsigned __int8 *a2);
signed __int64 __fastcall sub_45690(__int64 a1, unsigned __int64 a2, unsigned int *a3, unsigned __int64 a4);
signed __int64 __fastcall sub_456C0(int *a1, __int64 a2, __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_4573C(__int64 a1, unsigned __int8 *a2);
signed __int64 __fastcall sub_45784(__int64 a1, _BYTE *a2, unsigned __int8 *a3, unsigned __int64 a4);
signed __int64 __fastcall sub_457BC(__int64 a1, unsigned __int8 *a2);
signed __int64 __fastcall sub_45804(int *a1, __int64 a2, __int64 a3, unsigned __int64 a4);
void *sub_45898();
void *EVP_rc2_cbc();
signed __int64 __fastcall sub_458B0(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_45A94(__int64 a1, unsigned __int64 a2, int *a3, unsigned __int64 a4);
signed __int64 __fastcall sub_45B78(__int64 a1, int a2, int a3);
int *__fastcall sub_45BB8(int *result, unsigned __int64 a2, __int64 a3, unsigned __int16 *a4, unsigned __int8 *a5, int a6);
int *__fastcall sub_46010(int *result, unsigned __int16 *a2);
int *__fastcall sub_4614C(int *result, __int64 a2);
void *EVP_rc4();
signed __int64 __fastcall sub_462B8(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_462F0(__int64 a1, _BYTE *a2, char *a3, __int64 a4);
__int64 CRYPTO_is_NEON_capable_at_runtime();
__int64 sub_4632C();
__int64 sub_46340();
const char *SSLeay_version();
signed __int64 SSLeay();
__int64 __fastcall DES_set_key(unsigned __int8 *a1, __int64 a2);
unsigned __int8 *__fastcall DES_set_odd_parity(unsigned __int8 *result);
_DWORD *__fastcall DES_encrypt3(int *a1, __int64 a2, __int64 a3, __int64 a4);
_DWORD *__fastcall sub_466B0(_DWORD *result, __int64 a2, int a3);
_DWORD *__fastcall DES_decrypt3(int *a1, __int64 a2, __int64 a3, __int64 a4);
unsigned int *__fastcall DES_ecb_encrypt(unsigned __int8 *a1, __int64 a2, __int64 a3, int a4);
unsigned int *__fastcall sub_470A8(unsigned int *result, __int64 a2, int a3);
unsigned int *__fastcall DES_ncbc_encrypt(unsigned int *result, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, unsigned __int8 *a5, int a6);
_DWORD *__fastcall DES_ecb3_encrypt(unsigned __int8 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6);
unsigned __int8 *__fastcall DES_ede3_cbc_encrypt(unsigned __int8 *result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int8 *a7, int a8);
unsigned __int8 *__fastcall DES_ede2_cbc_encrypt(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned __int8 *a6, int a7);
void *EVP_md4();
void *EVP_md5();
void *EVP_sha1();
void *EVP_sha224();
void *EVP_sha256();
void *EVP_sha384();
void *EVP_sha512();
void *EVP_md5_sha1();
__int64 __fastcall EVP_get_digestbynid(signed int a1);
__int64 __fastcall EVP_get_digestbyobj(__int64 a1);
__int64 __fastcall sub_48524(__int64 a1);
void __fastcall sub_486EC(unsigned __int8 **a1);
__int64 __fastcall EVP_get_digestbyname(const char *a1);
signed __int64 __fastcall sub_488A8(__int64 a1);
signed __int64 __fastcall sub_488B0(__int64 a1, unsigned __int8 *a2, size_t a3);
signed __int64 __fastcall sub_488B8(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_488C8(__int64 a1, unsigned __int8 *a2, size_t a3);
signed __int64 __fastcall sub_488D0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_488E0(__int64 a1);
signed __int64 __fastcall sub_488E8(__int64 a1, char *a2, size_t a3);
signed __int64 __fastcall sub_488F0(__int64 a1, _BYTE *a2);
signed __int64 __fastcall sub_48900(__int64 a1);
signed __int64 __fastcall sub_48908(__int64 a1, char *a2, size_t a3);
__int64 __fastcall sub_48910(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_48920(__int64 a1);
signed __int64 __fastcall sub_48928(__int64 a1, char *a2, size_t a3);
signed __int64 __fastcall sub_48930(__int64 a1, _BYTE *a2);
signed __int64 __fastcall sub_48940(__int64 a1);
signed __int64 __fastcall sub_48948(__int64 a1, unsigned __int64 *a2, size_t a3);
__int64 __fastcall sub_48950(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_48960(__int64 a1);
signed __int64 __fastcall sub_48968(__int64 a1, unsigned __int64 *a2, size_t a3);
signed __int64 __fastcall sub_48970(__int64 a1, _BYTE *a2);
signed __int64 __fastcall sub_48980(__int64 a1);
signed __int64 __fastcall sub_489B8(__int64 a1, unsigned __int8 *a2, size_t a3);
signed __int64 __fastcall sub_48A0C(__int64 a1, __int64 a2);
__int64 ERR_get_error();
__int64 __fastcall sub_48A6C(int a1, int a2, _QWORD *a3, _DWORD *a4, _QWORD *a5, int *a6);
__int64 __fastcall ERR_get_error_line(_QWORD *a1, _DWORD *a2);
__int64 __fastcall ERR_get_error_line_data(_QWORD *a1, _DWORD *a2, _QWORD *a3, int *a4);
signed __int64 ERR_peek_error();
__int64 __fastcall ERR_peek_error_line(_QWORD *a1, _DWORD *a2);
__int64 __fastcall ERR_peek_error_line_data(_QWORD *a1, _DWORD *a2, _QWORD *a3, int *a4);
signed __int64 ERR_peek_last_error();
__int64 __fastcall ERR_peek_last_error_line(_QWORD *a1, _DWORD *a2);
__int64 __fastcall ERR_peek_last_error_line_data(_QWORD *a1, _DWORD *a2, _QWORD *a3, int *a4);
void ERR_clear_error();
void __fastcall ERR_remove_thread_state(__int64 a1);
__int64 ERR_get_next_error_library();
_DWORD *ERR_clear_system_error();
const char *__fastcall ERR_error_string(char *a1, const char *a2);
char *__fastcall ERR_error_string_n(char *result, const char *a2, unsigned __int64 a3);
char *__fastcall ERR_lib_error_string(unsigned int a1);
char *__fastcall ERR_reason_error_string(char *result);
const char *ERR_func_error_string();
char *__fastcall ERR_print_errors_cb(__int64 (__fastcall *a1)(char *, __int64, __int64), __int64 a2);
char *__fastcall ERR_print_errors_fp(__int64 a1);
__int64 __fastcall sub_4940C(const char *a1, __int64 a2, FILE *a3);
void __fastcall ERR_put_error(int a1, __int64 a2, int a3, __int64 a4, __int16 a5);
void __fastcall ERR_add_error_data(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
void ERR_add_error_dataf(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, ...);
signed __int64 ERR_set_mark();
signed __int64 ERR_pop_to_mark();
void __fastcall sub_49A74(void **a1);
signed __int64 __fastcall sub_49AF4(_DWORD *a1, _DWORD *a2);
void *__fastcall HMAC(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, void *a6, _DWORD *a7);
_QWORD *__fastcall HMAC_CTX_init(_QWORD *a1);
bool __fastcall HMAC_Init_ex(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 a4);
signed __int64 __fastcall HMAC_Update(__int64 a1);
signed __int64 __fastcall HMAC_Final(__int64 a1, __int64 a2, _DWORD *a3);
void *__fastcall HMAC_CTX_cleanup(_QWORD *a1);
__int64 __fastcall HMAC_size(__int64 *a1);
signed __int64 __fastcall HMAC_CTX_copy_ex(_QWORD *a1, _QWORD *a2);
bool __fastcall HMAC_Init(__int64 *a1, __int64 a2, int a3, __int64 a4);
signed __int64 __fastcall HMAC_CTX_copy(_QWORD *a1, _QWORD *a2);
signed __int64 __fastcall MD4(unsigned __int8 *a1, size_t a2, __int64 a3);
signed __int64 __fastcall MD5_Init(_OWORD *a1);
signed __int64 __fastcall MD4_Update(_DWORD *a1, unsigned __int8 *a2, size_t a3);
signed __int64 __fastcall MD4_Final(__int64 a1, __int64 a2);
int *__fastcall sub_4A4C0(int *result, unsigned __int8 *a2, __int64 a3);
int *__fastcall MD4_Transform(int *a1, unsigned __int8 *a2);
signed __int64 __fastcall MD5(unsigned __int8 *a1, size_t a2, void *a3);
signed __int64 __fastcall MD5_Update(_DWORD *a1, unsigned __int8 *a2, size_t a3);
signed __int64 __fastcall MD5_Final(__int64 a1, __int64 a2);
int *__fastcall sub_4AF40(int *result, unsigned __int8 *a2, __int64 a3);
int *__fastcall MD5_Transform(int *a1, unsigned __int8 *a2);
void *__fastcall sub_4BAEC(void *a1, size_t a2, size_t a3);
void *__fastcall OPENSSL_cleanse(void *result, size_t a2);
__int64 __fastcall CRYPTO_memcmp(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall OPENSSL_hash32(unsigned __int8 *a1, __int64 a2);
unsigned __int64 __fastcall OPENSSL_strnlen(__int64 a1, unsigned __int64 a2);
__int64 OPENSSL_strdup(void); // weak
__int64 __fastcall OPENSSL_strcasecmp(_QWORD, _QWORD); // weak
__int64 __fastcall OPENSSL_strncasecmp(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall BIO_snprintf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall BIO_vsnprintf(__int64 a1, __int64 a2, __int64 a3, __int128 *a4);
long double __fastcall sub_4BDC0(_QWORD *a1, long double *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(long double *, long double *, __int64));
unsigned __int64 __fastcall sub_4BFD4(unsigned __int64 result, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, __int64 (__fastcall *a6)(_QWORD *, __int64 *, __int64));
char *__fastcall sub_4C3D8(char *result, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, _BYTE *a5, _QWORD *a6, unsigned int *a7, void (__fastcall *a8)(_BYTE *, _QWORD *, __int64));
_BYTE *__fastcall sub_4C544(_BYTE *result);
__int64 __fastcall sub_4C608(__int64 result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, char *a6, unsigned int *a7, __int64 (__fastcall *a8)(char *, char *, unsigned __int64, __int64, _BYTE *));
void __fastcall sub_4C8BC(_QWORD *a1, int8x16_t (__fastcall **a2)(int8x16_t *a1, uint64x2_t *a2, int8x16_t *a3, unsigned __int64 a4), __int128 *a3, __int64 a4, __int128 *a5);
__int64 __fastcall sub_4CA60(__int64 result, __int64 a2);
__int64 __fastcall sub_4CAEC(); // weak
void __fastcall CRYPTO_gcm128_init(void *a1, __int64 a2, void (__fastcall *a3)(__int64 *, __int64 *, __int64));
__int64 __fastcall CRYPTO_gcm128_setiv(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall CRYPTO_gcm128_aad(int8x16_t *a1, int8x16_t *a2, unsigned __int64 a3);
signed __int64 __fastcall CRYPTO_gcm128_encrypt(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5);
signed __int64 __fastcall CRYPTO_gcm128_decrypt(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5);
signed __int64 __fastcall CRYPTO_gcm128_encrypt_ctr32(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5, void (__fastcall *a6)(char *, _BYTE *, signed __int64, __int64, __int64));
signed __int64 __fastcall CRYPTO_gcm128_decrypt_ctr32(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5, void (__fastcall *a6)(char *, _BYTE *, signed __int64, __int64, __int64));
bool __fastcall CRYPTO_gcm128_finish(__int64 a1, __int64 a2, unsigned __int64 a3);
void *__fastcall CRYPTO_gcm128_tag(__int64 a1, void *a2, unsigned __int64 a3);
__int64 __fastcall sub_4DCBC(__int64 result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6, __int64 (__fastcall *a7)(__int64, __int64, __int64));
signed __int64 __fastcall RAND_pseudo_bytes(signed __int64 a1, size_t a2);
signed __int64 RAND_seed();
signed __int64 __fastcall RAND_load_file(__int64 a1, signed __int64 a2);
signed __int64 RAND_egd();
__int64 (__fastcall **RAND_SSLeay())();
__int64 __fastcall RAND_set_urandom_fd(int a1);
_DWORD *sub_4DF68();
__int64 __fastcall RAND_enable_fork_unsafe_buffering(int a1);
signed __int64 __fastcall sub_4E1C0(signed __int64 result, size_t a2);
signed __int64 __fastcall sub_4E320(char *a1, size_t a2);
_DWORD *__fastcall RC4(_DWORD *result, __int64 a2, char *a3, _BYTE *a4);
_QWORD *__fastcall RC4_set_key(_QWORD *result, int a2, __int64 a3);
signed __int64 __fastcall SHA1_Init(_DWORD *a1);
void *__fastcall SHA1(char *a1, size_t a2, _BYTE *a3);
signed __int64 __fastcall SHA1_Update(_DWORD *a1, char *a2, size_t a3);
signed __int64 __fastcall SHA1_Final(_BYTE *a1, int *a2);
void __fastcall SHA1_Transform(__int128 *a1, _OWORD *a2);
signed __int64 __fastcall SHA224_Init(_DWORD *a1);
signed __int64 __fastcall SHA256_Init(_DWORD *a1);
void *__fastcall SHA224(char *a1, size_t a2, _BYTE *a3);
signed __int64 __fastcall SHA224_Update(_DWORD *a1, char *a2, size_t a3);
__int64 __fastcall SHA224_Final(_QWORD, _QWORD); // weak
void *__fastcall SHA256(char *a1, size_t a2, _BYTE *a3);
signed __int64 __fastcall SHA256_Update(_DWORD *a1, char *a2, size_t a3);
signed __int64 __fastcall SHA256_Final(_BYTE *a1, int *a2);
void __fastcall SHA256_Transform(int *a1, signed __int64 a2);
signed __int64 __fastcall SHA384_Init(_QWORD *a1);
signed __int64 __fastcall SHA512_Init(_QWORD *a1);
void *__fastcall SHA384(unsigned __int64 *a1, size_t a2, _BYTE *a3);
signed __int64 __fastcall SHA384_Update(__int64 a1, unsigned __int64 *a2, size_t a3);
__int64 __fastcall SHA384_Final(_QWORD, _QWORD); // weak
void *__fastcall SHA512(unsigned __int64 *a1, size_t a2, _BYTE *a3);
signed __int64 __fastcall SHA512_Update(__int64 a1, unsigned __int64 *a2, size_t a3);
signed __int64 __fastcall SHA512_Final(_BYTE *a1, __int64 a2);
unsigned __int64 *__fastcall SHA512_Transform(unsigned __int64 *a1, unsigned __int64 *a2);
__int64 __fastcall CRYPTO_MUTEX_init(pthread_rwlock_t *a1);
__int64 __fastcall CRYPTO_STATIC_MUTEX_lock_read(pthread_rwlock_t *a1);
__int64 __fastcall CRYPTO_STATIC_MUTEX_lock_write(pthread_rwlock_t *a1);
__int64 __fastcall CRYPTO_STATIC_MUTEX_unlock_write(pthread_rwlock_t *a1);
__int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD); // weak
__int64 __fastcall CRYPTO_once(pthread_once_t *a1, void (*a2)(void));
_QWORD *__fastcall CRYPTO_get_thread_local(int a1);
__int64 sub_4F974();
signed __int64 __fastcall CRYPTO_set_thread_local(unsigned int a1, __int64 a2, void (__fastcall *a3)(__int64));
void __fastcall sub_4FA90(_QWORD *a1);
uint64x2_t __fastcall sub_50590(int8x16_t *a1, int8x16_t *a2);
int8x16_t __fastcall sub_50630(int8x16_t *a1, __int64 a2);
int8x16_t __fastcall sub_506A0(int8x16_t *a1, uint64x2_t *a2, int8x16_t *a3, unsigned __int64 a4);
unsigned __int64 *__fastcall sub_52CC0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3);
__int64 __fastcall sub_53DD4(__int64 result, signed __int64 a2, _BYTE *a3, __int64 a4, char *a5, __int64 a6);
signed __int64 __fastcall AES_set_encrypt_key(unsigned __int8 *a1, int a2, unsigned int *a3);
signed __int64 __fastcall AES_set_decrypt_key(unsigned __int8 *a1, int a2, unsigned int *a3);
__int64 __fastcall AES_encrypt(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3);
__int64 __fastcall AES_decrypt(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3);
char *__fastcall AES_ctr128_encrypt(char *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, _BYTE *a5, _QWORD *a6, unsigned int *a7);
__int64 __fastcall AES_ecb_encrypt(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3, int a4);
void __fastcall AES_cbc_encrypt(_QWORD *a1, long double *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6);
__int64 __fastcall AES_ofb128_encrypt(__int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, int *a6);
__int64 __fastcall AES_cfb128_encrypt(__int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, int *a6, int a7);
_QWORD *__fastcall CBS_init(_QWORD *result, __int64 a2, __int64 a3);
signed __int64 __fastcall CBS_skip(__int64 *a1, unsigned __int64 a2);
void *__fastcall CBS_stow(__int64 a1, void **a2, _QWORD *a3);
bool __fastcall CBS_strdup(__int64 a1, void **a2);
bool __fastcall CBS_contains_zero_byte(__int64 a1);
bool __fastcall CBS_mem_equal(__int64 *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall CBS_get_u8(__int64 a1, _BYTE *a2);
signed __int64 __fastcall CBS_get_u16(__int64 a1, _WORD *a2);
signed __int64 __fastcall CBS_get_u24(__int64 *a1, int *a2);
signed __int64 __fastcall CBS_get_u32(__int64 a1, int *a2);
signed __int64 __fastcall CBS_get_last_u8(_QWORD *a1, _BYTE *a2);
signed __int64 __fastcall CBS_get_bytes(__int64 *a1, _QWORD *a2, unsigned __int64 a3);
signed __int64 __fastcall CBS_copy_bytes(__int64 a1, void *a2, size_t a3);
signed __int64 __fastcall CBS_get_u8_length_prefixed(signed __int64 *a1, signed __int64 *a2);
signed __int64 __fastcall CBS_get_u16_length_prefixed(signed __int64 *a1, signed __int64 *a2);
signed __int64 __fastcall CBS_get_u24_length_prefixed(signed __int64 *a1, signed __int64 *a2);
unsigned __int8 **__fastcall CBS_get_any_asn1(unsigned __int8 **a1, char *a2, _DWORD *a3);
unsigned __int8 **__fastcall CBS_get_any_asn1_element(unsigned __int8 **a1, char *a2, _DWORD *a3, signed __int64 *a4);
unsigned __int8 **__fastcall sub_552D8(unsigned __int8 **result, char *a2, _DWORD *a3, signed __int64 *a4, int a5);
unsigned __int8 **__fastcall CBS_get_any_ber_asn1_element(unsigned __int8 **a1, char *a2, _DWORD *a3, signed __int64 *a4);
signed __int64 __fastcall CBS_get_asn1(unsigned __int8 **a1, char *a2, int a3);
unsigned __int8 **__fastcall CBS_get_asn1_element(unsigned __int8 **a1, char *a2, int a3);
bool __fastcall CBS_peek_asn1_tag(unsigned __int8 **a1, int a2);
signed __int64 __fastcall CBS_get_asn1_uint64(unsigned __int8 **a1, unsigned __int64 *a2);
signed __int64 __fastcall CBS_get_optional_asn1(unsigned __int8 **a1, char *a2, _DWORD *a3, int a4);
signed __int64 __fastcall CBS_get_optional_asn1_octet_string(unsigned __int8 **a1, char *a2, signed int *a3, int a4);
signed __int64 __fastcall CBS_get_optional_asn1_uint64(unsigned __int8 **a1, unsigned __int64 *a2, int a3, unsigned __int64 a4);
signed __int64 __fastcall CBS_get_optional_asn1_bool(unsigned __int8 **a1, _DWORD *a2, int a3, int a4);
bool __fastcall CBS_is_valid_asn1_bitstring(unsigned __int8 **a1);
bool __fastcall CBS_asn1_bitstring_has_bit(unsigned __int8 **a1, unsigned int a2);
unsigned __int64 sub_55BB0();
__int64 __fastcall X509_VERIFY_PARAM_get_depth(__int64 a1);
_QWORD *__fastcall EVP_MD_CTX_init(_QWORD *result);
_QWORD *EVP_MD_CTX_create();
signed __int64 __fastcall EVP_MD_CTX_cleanup(_QWORD *a1);
void __fastcall EVP_MD_CTX_destroy(void **a1);
signed __int64 __fastcall EVP_MD_CTX_copy_ex(_QWORD *a1, _QWORD *a2);
signed __int64 __fastcall EVP_MD_CTX_copy(_QWORD *a1, _QWORD *a2);
signed __int64 __fastcall EVP_DigestInit_ex(__int64 *a1, __int64 a2);
signed __int64 __fastcall EVP_DigestInit(_QWORD *a1, __int64 a2);
signed __int64 __fastcall EVP_DigestUpdate(__int64 a1);
signed __int64 __fastcall EVP_DigestFinal_ex(void **a1, __int64 a2, _DWORD *a3);
signed __int64 __fastcall EVP_DigestFinal(__int64 a1, __int64 a2, _DWORD *a3);
void __fastcall EVP_Digest(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5);
_QWORD *__fastcall sk_num(_QWORD *result);
__int64 __fastcall EVP_MD_CTX_block_size(__int64 a1);
__int64 __fastcall sub_56234(__int64 result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6, int a7, __int64 (__fastcall *a8)(__int64, __int64, __int64));
__int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(void); // weak
__int64 __fastcall sub_564EC(__int64 *a1, const void *a2, size_t a3, signed int a4);
void __fastcall sub_566B8(__int64 a1);
void __fastcall sub_56728(__int64 a1);
void __fastcall sub_56C98(_QWORD *a1);
void __fastcall sub_56E8C(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_57020(__int64 a1, __int64 a2);
void __fastcall sub_570E4(__int64 a1, const void *a2, size_t a3, __int64 a4, _BYTE *a5);
__int64 __fastcall sub_57204(_QWORD *a1, _BYTE *a2, unsigned __int64 a3);
__int64 __fastcall sub_57508(_QWORD *a1);
signed __int64 __fastcall sub_57540(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_5755C(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_5757C(__int64 a1, _DWORD *a2);
signed __int64 __fastcall sub_5759C(__int64 a1, unsigned int a2, _QWORD *a3);
signed __int64 __fastcall sub_575E0(__int64 a1, int a2, _QWORD *a3, _DWORD *a4);
__int64 __fastcall sub_57618(__int64 a1, unsigned __int64 a2, signed __int64 a3, _BYTE *a4, unsigned int a5, _QWORD *a6);
_QWORD *BUF_MEM_new();
void __fastcall BUF_MEM_free(__int64 a1);
signed __int64 __fastcall BUF_MEM_reserve(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_57854(__int64 a1, unsigned __int64 a2, int a3);
unsigned __int64 __fastcall BUF_MEM_grow(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall BUF_MEM_grow_clean(__int64 a1, unsigned __int64 a2);
_BYTE *__fastcall BUF_strdup(const char *a1);
_BYTE *__fastcall BUF_strndup(const void *a1, size_t a2);
unsigned __int64 __fastcall BUF_strnlen(__int64 a1, unsigned __int64 a2);
size_t __fastcall BUF_strlcpy(_BYTE *a1, const char *a2, unsigned __int64 a3);
size_t __fastcall BUF_strlcat(_BYTE *a1, const char *a2, __int64 a3);
void *__fastcall BUF_memdup(const void *a1, size_t a2);
char *EVP_PKEY_new();
void __fastcall EVP_PKEY_free(int *a1);
signed __int64 __fastcall EVP_PKEY_up_ref(_DWORD *a1);
__int64 __fastcall EVP_PKEY_is_opaque(__int64 a1);
__int64 __fastcall EVP_PKEY_supports_digest(__int64 a1);
__int64 __fastcall EVP_PKEY_cmp(__int64 a1, __int64 a2);
__int64 __fastcall EVP_PKEY_copy_parameters(__int64 a1, __int64 a2);
__int64 __fastcall EVP_PKEY_missing_parameters(__int64 a1);
__int64 __fastcall EVP_PKEY_size(__int64 a1);
__int64 __fastcall EVP_PKEY_bits(__int64 a1);
signed __int64 __fastcall EVP_PKEY_type(int a1);
signed __int64 __fastcall EVP_PKEY_set1_RSA(__int64 a1, __int64 a2);
bool __fastcall EVP_PKEY_assign_RSA(__int64 a1, __int64 a2);
bool __fastcall EVP_PKEY_assign(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall EVP_PKEY_get0_RSA(__int64 a1);
__int64 __fastcall EVP_PKEY_get1_RSA(__int64 a1);
signed __int64 __fastcall EVP_PKEY_set1_DSA(__int64 a1, __int64 a2);
bool __fastcall EVP_PKEY_assign_DSA(__int64 a1, __int64 a2);
__int64 __fastcall EVP_PKEY_get0_DSA(__int64 a1);
__int64 __fastcall EVP_PKEY_get1_DSA(__int64 a1);
signed __int64 __fastcall EVP_PKEY_set1_EC_KEY(__int64 a1, __int64 a2);
bool __fastcall EVP_PKEY_assign_EC_KEY(__int64 a1, __int64 a2);
__int64 __fastcall EVP_PKEY_get0_EC_KEY(__int64 a1);
__int64 __fastcall EVP_PKEY_get1_EC_KEY(__int64 a1);
signed __int64 __fastcall EVP_PKEY_set_type(__int64 a1, unsigned int a2);
__int64 __fastcall EVP_PKEY_cmp_parameters(__int64 a1, __int64 a2);
__int64 __fastcall EVP_PKEY_CTX_set_signature_md(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_get_signature_md(__int64 *a1);
int **__fastcall EVP_PKEY_CTX_new(__int64 a1, int *a2);
void EVP_PKEY_CTX_new_id();
void __fastcall EVP_PKEY_CTX_free(int **a1);
void *__fastcall EVP_PKEY_CTX_dup(_QWORD *a1);
__int64 __fastcall X509_TRUST_get0_name(__int64 a1);
__int64 __fastcall EVP_PKEY_CTX_ctrl(__int64 *a1, int a2, int a3);
signed __int64 __fastcall EVP_PKEY_sign_init(_DWORD *a1);
__int64 __fastcall EVP_PKEY_sign(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_verify_init(_DWORD *a1);
__int64 __fastcall EVP_PKEY_verify(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_encrypt_init(_DWORD *a1);
__int64 __fastcall EVP_PKEY_encrypt(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_decrypt_init(_DWORD *a1);
__int64 __fastcall EVP_PKEY_decrypt(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_verify_recover_init(_DWORD *a1);
__int64 __fastcall EVP_PKEY_verify_recover(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_derive_init(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_derive_set_peer(__int64 *a1, _DWORD *a2);
__int64 __fastcall EVP_PKEY_derive(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_keygen_init(_DWORD *a1);
signed __int64 __fastcall EVP_PKEY_keygen(_DWORD *a1, int **a2);
signed __int64 __fastcall sub_590F0(__int64 a1, __int64 a2, unsigned __int8 **a3);
signed __int64 __fastcall sub_591D0(__int64 *a1, __int64 a2);
bool __fastcall sub_5931C(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_59348(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3);
signed __int64 __fastcall sub_59458(__int64 *a1, __int64 a2);
__int64 __fastcall sub_59598(__int64 a1);
__int64 __fastcall sub_595A0(__int64 a1);
bool __fastcall sub_595AC(__int64 a1);
signed __int64 __fastcall sub_595D8(__int64 a1, __int64 a2);
bool __fastcall sub_59678(__int64 a1, __int64 a2);
void __fastcall sub_596F4(__int64 a1);
_QWORD *__fastcall sub_596FC(__int64 a1);
_QWORD *__fastcall sub_59730(__int64 a1, __int64 a2);
void __fastcall sub_59774(__int64 a1);
signed __int64 __fastcall sub_59784(__int64 a1, __int64 a2);
void __fastcall sub_59828(__int64 a1, __int64 a2, __int64 *a3, unsigned __int8 *a4, size_t a5);
void __fastcall sub_5990C(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4, __int64 a5);
signed __int64 __fastcall sub_59934(__int64 a1, void *a2, unsigned __int64 *a3);
signed __int64 __fastcall sub_599E0(__int64 a1, int a2, __int64 a3, unsigned int *a4);
signed __int64 __fastcall sub_59ACC(__int64 a1, unsigned __int8 **a2, __int64 a3);
signed __int64 __fastcall sub_59BF4(__int64 *a1, __int64 a2);
signed __int64 __fastcall sub_59D3C(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_59DB0(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3);
signed __int64 __fastcall sub_59E84(__int64 *a1, __int64 a2);
__int64 __fastcall sub_59FC0(__int64 a1);
__int64 __fastcall sub_59FC8(__int64 a1);
__int64 __fastcall sub_59FE0(__int64 a1);
bool __fastcall sub_5A010(__int64 a1);
__int64 __fastcall sub_5A030(__int64 a1, __int64 a2);
bool __fastcall sub_5A088(__int64 a1, __int64 a2);
void __fastcall sub_5A0D4(__int64 a1);
signed __int64 __fastcall sub_5A0DC(__int64 a1);
void *__fastcall sub_5A13C(__int64 a1, __int64 a2);
void __fastcall sub_5A20C(__int64 a1);
signed __int64 __fastcall sub_5A254(__int64 a1, __int64 a2);
void __fastcall sub_5A2E4(__int64 a1, _BYTE *a2, size_t *a3, const void *a4, size_t a5);
void __fastcall sub_5A4C8(__int64 a1, unsigned __int8 *a2, size_t a3, const void *a4, size_t a5);
signed __int64 __fastcall sub_5A698(__int64 a1, void *a2, size_t *a3, unsigned __int8 *a4, size_t a5);
void __fastcall sub_5A8A0(__int64 a1, _BYTE *a2, size_t *a3, const void *a4, size_t a5);
__int64 __fastcall sub_5A9D4(__int64 a1, unsigned __int8 *a2, _QWORD *a3, unsigned __int8 *a4, size_t a5);
signed __int64 __fastcall sub_5AB34(__int64 a1, int a2, signed int a3, _QWORD *a4);
__int64 __fastcall EVP_PKEY_CTX_set_rsa_padding(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_get_rsa_padding(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_set_rsa_pss_saltlen(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_get_rsa_pss_saltlen(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_set_rsa_keygen_bits(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_set_rsa_keygen_pubexp(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_set_rsa_oaep_md(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_get_rsa_oaep_md(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_set_rsa_mgf1_md(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_get_rsa_mgf1_md(__int64 *a1);
__int64 __fastcall EVP_PKEY_CTX_set0_rsa_oaep_label(__int64 *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall EVP_PKEY_CTX_get0_rsa_oaep_label(__int64 *a1, __int64 *a2);
signed __int64 __fastcall sub_5B028(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3);
signed __int64 __fastcall sub_5B124(__int64 *a1, __int64 a2);
bool __fastcall sub_5B240(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_5B29C(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3);
signed __int64 __fastcall sub_5B398(__int64 *a1, __int64 a2);
__int64 __fastcall sub_5B4B4(__int64 a1);
__int64 __fastcall sub_5B4BC(__int64 a1);
__int64 __fastcall sub_5B4C4(__int64 a1);
void __fastcall sub_5B4CC(__int64 a1);
__int64 __fastcall CRYPTO_refcount_inc(_DWORD *a1);
__int64 __fastcall CRYPTO_refcount_dec_and_test_zero(int *a1);
signed __int64 __fastcall sub_5B578(_WORD *a1, unsigned __int64 a2, const void *a3, unsigned __int64 a4);
__int64 __fastcall sub_5B644(void *a1, unsigned int a2, _BYTE *a3, unsigned int a4);
signed __int64 __fastcall sub_5B7A4(_WORD *a1, unsigned __int64 a2, const void *a3, unsigned __int64 a4);
__int64 __fastcall sub_5B8B4(void *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4);
signed __int64 __fastcall sub_5B9FC(void *a1, size_t a2, const void *a3, size_t a4);
void __fastcall RSA_padding_add_PKCS1_OAEP_mgf1(_BYTE *a1, unsigned __int64 a2, const void *a3, size_t a4, __int64 a5, __int64 a6, void *a7, __int64 a8);
signed __int64 __fastcall sub_5BDB8(char *a1, size_t a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall sub_5BF08(void *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4, __int64 a5, unsigned int a6, void *a7, __int64 a8);
signed __int64 __fastcall RSA_verify_PKCS1_PSS_mgf1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int8 *a5, signed int a6);
void __fastcall RSA_padding_add_PKCS1_PSS_mgf1(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5, int a6);
_QWORD *RSA_new();
_QWORD *__fastcall RSA_new_method(__int64 a1);
void __fastcall sub_5CAE4(void ***a1);
void __fastcall RSA_free(int *a1);
signed __int64 __fastcall RSA_up_ref(__int64 a1);
_QWORD *__fastcall RSA_get0_key(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall RSA_get0_factors(__int64 result, _QWORD *a2, _QWORD *a3);
_QWORD *__fastcall RSA_get0_crt_params(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall RSA_generate_key_ex(__int64 a1);
__int64 __fastcall RSA_generate_multi_prime_key(__int64 a1, int a2, signed int a3, __int64 a4, __int64 a5);
__int64 __fastcall RSA_encrypt(__int64 a1, size_t *a2, _BYTE *a3, size_t a4, const void *a5, size_t a6, int a7);
signed __int64 __fastcall RSA_public_encrypt(size_t a1, const void *a2, _BYTE *a3, __int64 a4, unsigned int a5);
__int64 __fastcall RSA_size(__int64 a1);
__int64 __fastcall RSA_sign_raw(__int64 a1, size_t *a2, _BYTE *a3, unsigned __int64 a4, const void *a5, size_t a6, int a7);
signed __int64 __fastcall RSA_private_encrypt(size_t a1, const void *a2, _BYTE *a3, __int64 a4, unsigned int a5);
__int64 __fastcall RSA_decrypt(__int64 a1, _QWORD *a2, unsigned __int8 *a3, unsigned __int64 a4, unsigned __int8 *a5, size_t a6, int a7);
signed __int64 __fastcall RSA_private_decrypt(size_t a1, unsigned __int8 *a2, unsigned __int8 *a3, __int64 a4, unsigned int a5);
signed __int64 __fastcall RSA_public_decrypt(size_t a1, unsigned __int8 *a2, _BYTE *a3, __int64 a4, int a5);
__int64 __fastcall RSA_supports_digest(__int64 a1);
signed __int64 __fastcall RSA_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall RSA_set_ex_data(__int64 a1, int a2, __int64 a3);
unsigned __int64 *__fastcall RSA_get_ex_data(__int64 a1, int a2);
signed __int64 __fastcall RSA_add_pkcs1_prefix(_QWORD *a1, size_t *a2, _DWORD *a3, signed int a4, const void *a5, size_t a6);
void __fastcall RSA_sign(unsigned int a1, const void *a2, unsigned int a3, _BYTE *a4, _DWORD *a5, __int64 a6);
void __fastcall RSA_verify(signed int a1, const void *a2, size_t a3, unsigned __int8 *a4, size_t a5, _QWORD *a6);
__int64 __fastcall RSA_check_key(_QWORD *a1);
signed __int64 __fastcall RSA_recover_crt_params(__int64 *a1);
__int64 __fastcall sub_5E038(__int64 a1, _BYTE *a2, unsigned __int8 *a3, size_t a4);
void __fastcall RSA_parse_public_key(unsigned __int8 **a1);
void __fastcall sub_5E054(unsigned __int8 **a1, int a2);
void __fastcall RSA_parse_public_key_buggy(unsigned __int8 **a1);
void __fastcall RSA_public_key_from_bytes(__int64 a1, __int64 a2);
signed __int64 __fastcall RSA_marshal_public_key(__int64 *a1, __int64 a2);
signed __int64 __fastcall RSA_public_key_to_bytes(_QWORD *a1, _QWORD *a2, __int64 a3);
int *__fastcall RSA_parse_private_key(unsigned __int8 **a1);
void __fastcall RSA_private_key_from_bytes(__int64 a1, __int64 a2);
signed __int64 __fastcall RSA_marshal_private_key(__int64 *a1, __int64 a2);
signed __int64 __fastcall RSA_private_key_to_bytes(_QWORD *a1, _QWORD *a2, __int64 a3);
void __fastcall d2i_RSAPublicKey(int **a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_RSAPublicKey(__int64 a1, void **a2);
__int64 __fastcall d2i_RSAPrivateKey(__int64 result, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_RSAPrivateKey(__int64 a1, void **a2);
void __fastcall RSAPublicKey_dup(__int64 a1);
void __fastcall RSAPrivateKey_dup(__int64 a1);
__int64 __fastcall sub_5EF6C(__int64 a1);
__int64 __fastcall sub_5EF88(__int64 a1, size_t *a2, _BYTE *a3, size_t a4, const void *a5, size_t a6, int a7);
signed __int64 __fastcall sub_5F210(__int64 a1);
__int64 __fastcall sub_5F2B0(__int64 a1, size_t *a2, _BYTE *a3, unsigned __int64 a4, const void *a5, size_t a6, int a7);
__int64 __fastcall sub_5F400(__int64 a1, _QWORD *a2, unsigned __int8 *a3, unsigned __int64 a4, unsigned __int8 *a5, size_t a6, int a7);
__int64 __fastcall RSA_verify_raw(__int64 a1, _QWORD *a2, _BYTE *a3, unsigned __int64 a4, unsigned __int8 *a5, size_t a6, int a7);
_QWORD *__fastcall sk_new(__int64 a1);
_QWORD *sk_new_null();
void **__fastcall sk_zero(void **result);
unsigned __int64 *__fastcall sk_value(unsigned __int64 *result, unsigned __int64 a2);
__int64 __fastcall sk_set(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3);
void __fastcall sk_free(void **a1);
void __fastcall sk_pop_free(unsigned __int64 *a1, void (*a2)(void));
char *__fastcall sk_insert(_QWORD *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sk_delete(unsigned __int64 *a1, unsigned __int64 a2);
__int64 __fastcall sk_delete_ptr(unsigned __int64 *a1, __int64 a2);
_BYTE *__fastcall sk_find(__int64 a1, signed __int64 *a2, __int64 a3);
void __fastcall sk_sort(__int64 a1);
__int64 __fastcall sk_shift(signed __int64 *a1);
char *__fastcall sk_push(unsigned __int64 *a1, __int64 a2);
signed __int64 __fastcall sk_pop(signed __int64 *a1);
_QWORD *__fastcall sk_dup(__int64 a1);
signed __int64 __fastcall sk_is_sorted(__int64 a1);
__int64 __fastcall sk_set_cmp_func(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall sk_deep_copy(__int64 a1, __int64 (*a2)(void), void (*a3)(void));
void __fastcall sub_61098(__int64 a1, unsigned __int64 a2, signed __int64 a3, unsigned __int8 *a4, unsigned __int64 a5, __int64 a6, int a7);
void __fastcall sub_612B0(__int64 a1, unsigned __int64 a2, signed __int64 a3, unsigned __int64 a4, signed __int64 a5);
void __fastcall sub_61470(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_DWORD *sub_6162C();
_QWORD *sub_61654();
_QWORD *sub_61678();
__int64 __fastcall sub_616A0(__int64 result);
__int64 __fastcall sub_616BC(__int64 a1, _QWORD *a2);
void __fastcall sub_616F0(_QWORD *a1);
_QWORD *__fastcall sub_61740(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_6179C(_QWORD *a1, __int64 a2, size_t a3, const void *a4, __int64 a5);
void __fastcall sub_61844(_QWORD *a1);
__int64 __fastcall sub_618A4(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_61B40(void ****a1);
void __fastcall sub_61C14(__int64 a1);
signed __int64 __fastcall sub_61C54(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_61C90(__int64 a1, __int64 *a2, _DWORD *a3);
signed __int64 __fastcall sub_61D2C(__int64 *a1, unsigned __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_61E04(int a1, __int64 a2);
signed __int64 __fastcall i2d_ASN1_OBJECT(signed __int64 result, void **a2);
void __fastcall a2d_ASN1_OBJECT(__int64 a1, int a2, const char *a3, int a4);
void __fastcall i2t_ASN1_OBJECT(_BYTE *a1, signed int a2, unsigned int *a3);
void __fastcall i2a_ASN1_OBJECT(_QWORD *a1, __int64 a2);
_QWORD *__fastcall d2i_ASN1_OBJECT(_QWORD *a1, __int64 *a2, __int64 a3);
_QWORD *__fastcall c2i_ASN1_OBJECT(_QWORD *a1, const void **a2, __int64 a3);
_QWORD *ASN1_OBJECT_new();
void __fastcall ASN1_OBJECT_free(void **a1);
__int64 *__fastcall ASN1_OBJECT_create(int a1, __int64 a2, int a3, __int64 a4, __int64 a5);
signed __int64 __fastcall ASN1_const_check_infinite_end(_QWORD *a1, signed __int64 a2);
signed __int64 __fastcall ASN1_get_object(unsigned __int8 **a1, signed __int64 *a2, _DWORD *a3, int *a4, __int64 a5);
_BYTE **__fastcall ASN1_put_object(_BYTE **result, int a2, signed int a3, signed int a4, char a5);
signed __int64 __fastcall ASN1_put_eoc(_BYTE **a1);
signed __int64 __fastcall ASN1_object_size(int a1, signed int a2, signed int a3);
signed __int64 __fastcall asn1_const_Finish(__int64 a1);
signed __int64 __fastcall ASN1_STRING_copy(__int64 a1, __int64 a2);
signed __int64 __fastcall ASN1_STRING_set(__int64 a1, const char *a2, int a3);
_BYTE *__fastcall ASN1_STRING_dup(__int64 a1);
_QWORD *ASN1_STRING_new();
void __fastcall ASN1_STRING_free(__int64 a1);
void __fastcall ASN1_STRING_set0(__int64 a1, __int64 a2, int a3);
_DWORD *__fastcall ASN1_STRING_type_new(int a1);
__int64 __fastcall ASN1_STRING_cmp(const void **a1, __int64 a2);
_DWORD *__fastcall ASN1_STRING_length_set(_DWORD *result, int a2);
unsigned __int64 *__fastcall d2i_ASN1_OCTET_STRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_OCTET_STRING();
_DWORD *ASN1_OCTET_STRING_new();
__int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD); // weak
unsigned __int64 *__fastcall d2i_ASN1_INTEGER(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_INTEGER();
_DWORD *ASN1_INTEGER_new();
unsigned __int64 *__fastcall d2i_ASN1_ENUMERATED(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_ENUMERATED();
_DWORD *ASN1_ENUMERATED_new();
unsigned __int64 *__fastcall d2i_ASN1_BIT_STRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_BIT_STRING();
_DWORD *ASN1_BIT_STRING_new();
unsigned __int64 *__fastcall d2i_ASN1_UTF8STRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_UTF8STRING();
_DWORD *ASN1_UTF8STRING_new();
unsigned __int64 *__fastcall d2i_ASN1_PRINTABLESTRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_PRINTABLESTRING();
_DWORD *ASN1_PRINTABLESTRING_new();
unsigned __int64 *__fastcall d2i_ASN1_T61STRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_T61STRING();
_DWORD *ASN1_T61STRING_new();
unsigned __int64 *__fastcall d2i_ASN1_IA5STRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_IA5STRING();
_DWORD *ASN1_IA5STRING_new();
unsigned __int64 *__fastcall d2i_ASN1_GENERALSTRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_GENERALSTRING();
_DWORD *ASN1_GENERALSTRING_new();
unsigned __int64 *__fastcall d2i_ASN1_UTCTIME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_UTCTIME();
_DWORD *ASN1_UTCTIME_new();
unsigned __int64 *__fastcall d2i_ASN1_GENERALIZEDTIME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_GENERALIZEDTIME();
_DWORD *ASN1_GENERALIZEDTIME_new();
unsigned __int64 *__fastcall d2i_ASN1_VISIBLESTRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_VISIBLESTRING();
_DWORD *ASN1_VISIBLESTRING_new();
unsigned __int64 *__fastcall d2i_ASN1_UNIVERSALSTRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_UNIVERSALSTRING();
_DWORD *ASN1_UNIVERSALSTRING_new();
unsigned __int64 *__fastcall d2i_ASN1_BMPSTRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_BMPSTRING();
_DWORD *ASN1_BMPSTRING_new();
unsigned __int64 *__fastcall d2i_ASN1_NULL(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_NULL();
__int64 ASN1_NULL_new();
void __fastcall ASN1_NULL_free(__int64 a1);
unsigned __int64 *__fastcall d2i_ASN1_TYPE(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_TYPE();
__int64 ASN1_TYPE_new();
void __fastcall ASN1_TYPE_free(__int64 a1);
unsigned __int64 *__fastcall d2i_ASN1_PRINTABLE(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_PRINTABLE();
__int64 ASN1_PRINTABLE_new();
void __fastcall ASN1_PRINTABLE_free(__int64 a1);
unsigned __int64 *__fastcall d2i_DISPLAYTEXT(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_DISPLAYTEXT();
__int64 DISPLAYTEXT_new();
void __fastcall DISPLAYTEXT_free(__int64 a1);
unsigned __int64 *__fastcall d2i_DIRECTORYSTRING(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_DIRECTORYSTRING();
__int64 DIRECTORYSTRING_new();
void __fastcall DIRECTORYSTRING_free(__int64 a1);
unsigned __int64 *__fastcall d2i_ASN1_SEQUENCE_ANY(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_SEQUENCE_ANY();
unsigned __int64 *__fastcall d2i_ASN1_SET_ANY(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_SET_ANY();
_DWORD *__fastcall BIO_new(__int64 a1);
__int64 __fastcall BIO_free(__int64 a1);
__int64 __fastcall BIO_pop(__int64 a1);
signed __int64 __fastcall BIO_up_ref(__int64 a1);
void __fastcall BIO_vfree(__int64 a1);
__int64 __fastcall BIO_read(_QWORD *a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_637EC(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, int a5, _QWORD *a6);
__int64 __fastcall BIO_gets(_QWORD *a1, __int64 a2, unsigned int a3);
__int64 __fastcall BIO_write(_QWORD *a1, __int64 a2, unsigned int a3);
__int64 __fastcall BIO_puts(_QWORD *a1, const char *a2);
__int64 __fastcall BIO_flush(_QWORD *a1);
__int64 __fastcall BIO_ctrl(_QWORD *a1, unsigned int a2, __int64 a3, __int64 a4);
__int64 __fastcall BIO_ptr_ctrl(_QWORD *a1, unsigned int a2, __int64 a3);
void __fastcall BIO_int_ctrl(_QWORD *a1, unsigned int a2, __int64 a3, int a4);
__int64 __fastcall BIO_reset(_QWORD *a1);
__int64 __fastcall BIO_eof(_QWORD *a1);
__int64 __fastcall BIO_set_flags(__int64 result, int a2);
__int64 __fastcall BIO_test_flags(__int64 a1, unsigned int a2);
__int64 __fastcall BIO_should_read(__int64 a1);
__int64 __fastcall BIO_should_write(__int64 a1);
__int64 __fastcall BIO_should_retry(__int64 a1);
__int64 __fastcall BIO_should_io_special(__int64 a1);
__int64 __fastcall BIO_get_retry_reason(__int64 a1);
__int64 __fastcall BIO_clear_flags(__int64 result, int a2);
__int64 __fastcall BIO_set_retry_read(__int64 result);
__int64 __fastcall BIO_set_retry_write(__int64 result);
__int64 __fastcall BIO_get_retry_flags(__int64 a1);
__int64 __fastcall BIO_clear_retry_flags(__int64 result);
__int64 __fastcall BIO_copy_next_retry(__int64 result);
__int64 __fastcall BIO_callback_ctrl(_QWORD *a1, unsigned int a2, __int64 a3);
__int64 __fastcall BIO_pending(_QWORD *a1);
__int64 __fastcall BIO_wpending(_QWORD *a1);
__int64 __fastcall BIO_set_close(_QWORD *a1, int a2);
__int64 __fastcall X509_STORE_CTX_set_chain(__int64 result, __int64 a2);
__int64 __fastcall BIO_number_read(__int64 a1);
__int64 __fastcall BIO_number_written(__int64 a1);
__int64 __fastcall BIO_push(__int64 result, __int64 a2);
__int64 __fastcall BIO_next(__int64 result);
int *__fastcall BIO_find_type(int *result, int a2);
signed __int64 __fastcall BIO_indent(_QWORD *a1, int a2, int a3);
char *__fastcall ERR_print_errors(__int64 a1);
__int64 __fastcall sub_64490(__int64 a1, unsigned int a2, _QWORD *a3);
_WORD *__fastcall BIO_read_asn1(_QWORD *a1, void **a2, _QWORD *a3, unsigned __int64 a4);
__int64 __fastcall BIO_set_retry_special(__int64 result);
__int64 __fastcall BN_add(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall BN_usub(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall BN_uadd(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall BN_add_word(__int64 a1, __int64 a2);
__int64 __fastcall BN_sub_word(__int64 a1, unsigned __int64 a2);
__int64 __fastcall BN_sub(__int64 a1, __int64 a2, __int64 a3);
_QWORD *BN_new();
_QWORD *__fastcall BN_init(_QWORD *result);
void __fastcall BN_free(_DWORD *a1);
void __fastcall BN_clear_free(void **a1);
signed int *__fastcall BN_dup(signed int *a1);
__int64 __fastcall BN_copy(__int64 a1, __int64 a2);
__int64 __fastcall bn_wexpand(__int64 a1, unsigned __int64 a2);
void *__fastcall BN_clear(void **a1);
void **BN_value_one();
__int64 __fastcall BN_num_bits_word(unsigned __int64 a1);
__int64 __fastcall BN_num_bits(__int64 a1);
__int64 __fastcall BN_num_bytes(__int64 a1);
__int64 __fastcall BN_zero(__int64 result);
__int64 __fastcall BN_one(__int64 a1);
__int64 __fastcall BN_set_word(__int64 a1, __int64 a2);
__int64 __fastcall bn_correct_top(__int64 result);
bool __fastcall BN_is_negative(__int64 a1);
__int64 __fastcall BN_set_negative(__int64 result, int a2);
__int64 __fastcall sub_6534C(__int64 a1, unsigned __int64 a2);
bool __fastcall BN_parse_asn1_unsigned(unsigned __int8 **a1, __int64 a2);
bool __fastcall BN_parse_asn1_unsigned_buggy(unsigned __int8 **a1, __int64 a2);
signed __int64 __fastcall BN_marshal_asn1(__int64 *a1, __int64 a2);
__int64 __fastcall BN_ucmp(__int64 a1, __int64 a2);
signed __int64 __fastcall BN_cmp(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_6575C(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_657B8(__int64 a1, __int64 a2, int a3, int a4);
bool __fastcall BN_abs_is_word(__int64 a1, __int64 a2);
signed __int64 __fastcall BN_cmp_word(__int64 a1, unsigned __int64 a2);
bool __fastcall BN_is_zero(__int64 a1);
bool __fastcall BN_is_one(__int64 a1);
bool __fastcall BN_is_word(__int64 a1, __int64 a2);
__int64 __fastcall BN_is_odd(__int64 a1);
bool __fastcall BN_is_pow2(__int64 *a1);
__int64 __fastcall BN_equal_consttime(__int64 a1, __int64 a2);
__int64 __fastcall BN_bin2bn(unsigned __int8 *a1, __int64 a2, __int64 a3);
__int64 __fastcall BN_le2bn(const void *a1, size_t a2, __int64 a3);
__int64 __fastcall BN_bn2bin(__int64 a1, _BYTE *a2);
signed __int64 __fastcall BN_bn2le_padded(char *a1, size_t a2, __int64 a3);
signed __int64 __fastcall BN_bn2bin_padded(_BYTE *a1, size_t a2, __int64 a3);
signed __int64 __fastcall BN_bn2cbb_padded(__int64 *a1, __int64 a2, __int64 a3);
_BYTE *__fastcall BN_bn2hex(__int64 a1);
__int64 __fastcall BN_hex2bn(__int64 *a1, _BYTE *a2);
__int64 __fastcall BN_bn2dec(signed int *a1);
__int64 __fastcall BN_dec2bn(__int64 *a1, _BYTE *a2);
__int64 __fastcall BN_asc2bn(__int64 *a1, _BYTE *a2);
signed __int64 __fastcall BN_print(_QWORD *a1, __int64 a2);
__int64 __fastcall BN_print_fp(__int64 a1, __int64 a2);
signed __int64 __fastcall BN_get_word(_DWORD *a1);
signed __int64 __fastcall BN_get_u64(__int64 **a1, _QWORD *a2);
signed __int64 __fastcall BN_bn2mpi(__int64 a1, _BYTE *a2);
_DWORD *__fastcall BN_mpi2bn(unsigned __int8 *a1, unsigned __int64 a2, _DWORD *a3);
_DWORD *BN_CTX_new();
void __fastcall BN_CTX_free(__int64 a1);
void __fastcall BN_CTX_start(__int64 a1);
_QWORD *__fastcall BN_CTX_get(__int64 a1);
__int64 __fastcall BN_CTX_end(__int64 result);
signed __int64 __fastcall BN_div(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall BN_nnmod(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall BN_mod_add(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall BN_mod_add_quick(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall BN_mod_sub(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall BN_mod_sub_quick(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall BN_mod_mul(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall BN_mod_sqr(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall BN_mod_lshift(__int64 a1, __int64 a2, signed int a3, __int64 a4, __int64 a5);
__int64 __fastcall BN_mod_lshift_quick(__int64 a1, __int64 a2, signed int a3, __int64 a4);
__int64 __fastcall BN_mod_lshift1(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall BN_mod_lshift1_quick(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall BN_div_word(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall BN_mod_word(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall BN_mod_pow2(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall BN_nnmod_pow2(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall BN_exp(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall BN_mod_exp(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall BN_mod_exp_mont(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall BN_mod_exp_mont_consttime(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_68F3C(__int64 a1, signed int a2, __int64 a3, int a4, signed int a5);
void __fastcall BN_mod_exp_mont_word(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall BN_mod_exp2_mont(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall sub_69364(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall BN_gcd(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_69844(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall BN_mod_inverse(_QWORD *a1, signed int *a2, __int64 a3, __int64 a4);
void __fastcall sub_69E64(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_69FB8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_6A064(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_6A110(_QWORD *a1, unsigned __int64 *a2, unsigned int a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_6A220(_QWORD *a1, unsigned __int64 *a2, unsigned int a3, unsigned __int64 a4);
double *__fastcall sub_6A2FC(double *result, int8x16_t *a2, unsigned int a3);
unsigned __int64 __fastcall sub_6A448(_QWORD *a1, unsigned __int64 *a2, _QWORD *a3, unsigned int a4);
__int64 __fastcall sub_6A564(__int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned int a4);
__int64 __fastcall sub_6A684(_QWORD, _QWORD, _QWORD); // weak
_QWORD *__fastcall sub_6AE9C(_QWORD *result, unsigned __int64 *a2, unsigned __int64 *a3);
__int64 __fastcall sub_6B094(_QWORD, _QWORD); // weak
_QWORD *__fastcall sub_6B72C(_QWORD *result, unsigned __int64 *a2);
_QWORD *BN_MONT_CTX_new();
void __fastcall BN_MONT_CTX_free(_DWORD *a1);
__int64 __fastcall BN_MONT_CTX_copy(__int64 a1, __int64 a2);
bool __fastcall BN_MONT_CTX_set(__int64 a1, __int64 a2);
bool __fastcall sub_6BAC4(__int64 *a1, pthread_rwlock_t *a2, __int64 a3);
__int64 __fastcall BN_to_montgomery(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall BN_mod_mul_montgomery(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall BN_from_montgomery(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_6BD98(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_6C0A4(__int64 **a1);
__int64 __fastcall sub_6C0E8(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall BN_mul(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_6C3EC(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, signed int a4, int a5, int a6, __int64 *a7);
__int64 __fastcall sub_6C8BC(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, signed int a4, unsigned int a5, unsigned int a6, __int64 *a7);
unsigned __int64 __fastcall sub_6CD30(_QWORD *a1, unsigned __int64 *a2, signed int a3, unsigned __int64 *a4, signed int a5);
__int64 __fastcall BN_mul_word(unsigned __int64 **a1, unsigned __int64 a2);
__int64 __fastcall BN_sqr(__int64 result, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_6D0FC(unsigned __int64 *a1, unsigned __int64 *a2, signed int a3, double *a4);
_QWORD *__fastcall sub_6D1F8(unsigned __int64 *a1, unsigned __int64 *a2, signed int a3, double *a4);
__int64 __fastcall sub_6D40C(__int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned int a4, signed int a5);
_QWORD *__fastcall BN_GENCB_set(_QWORD *result, __int64 a2, __int64 a3);
__int64 __fastcall BN_GENCB_call(__int64 a1, unsigned int a2, unsigned int a3);
void __fastcall BN_generate_prime_ex(__int64 *a1, signed int a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall BN_is_prime_fasttest_ex(__int64 a1, signed int a2, _DWORD *a3, int a4, __int64 a5);
signed __int64 __fastcall BN_primality_test(signed int *a1, __int64 a2, signed int a3, _DWORD *a4, int a5, __int64 a6);
__int64 __fastcall BN_is_prime_ex(__int64 a1, signed int a2, _DWORD *a3, __int64 a4);
__int64 __fastcall BN_rand(__int64 a1, signed int a2, int a3, unsigned int a4);
__int64 __fastcall BN_pseudo_rand(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall BN_rand_range_ex(__int64 a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall BN_rand_range(__int64 a1, __int64 a2);
void __fastcall BN_generate_dsa_nonce(__int64 a1, __int64 a2, __int64 *a3, unsigned __int64 *a4, size_t a5);
__int64 __fastcall BN_lshift(__int64 a1, __int64 *a2, unsigned int a3);
__int64 __fastcall BN_lshift1(__int64 a1, __int64 a2);
__int64 __fastcall BN_rshift(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall BN_rshift1(__int64 a1, __int64 a2);
__int64 __fastcall BN_set_bit(__int64 a1, unsigned int a2);
__int64 __fastcall BN_clear_bit(__int64 a1, unsigned int a2);
signed __int64 __fastcall BN_is_bit_set(__int64 a1, unsigned int a2);
signed __int64 __fastcall BN_mask_bits(__int64 a1, unsigned int a2);
void **__fastcall BN_mod_sqrt(void **a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall BN_sqrt(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_6F744(__int64 a1, void **a2);
signed __int64 __fastcall CBB_init(_QWORD *a1, size_t a2);
__int64 __fastcall CBB_init_fixed(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall CBB_cleanup(__int64 *a1);
signed __int64 __fastcall CBB_finish(__int64 a1, _QWORD *a2, _QWORD *a3);
signed __int64 __fastcall CBB_flush(_QWORD *a1);
__int64 __fastcall CBB_data(__int64 a1);
__int64 __fastcall CBB_len(__int64 a1);
signed __int64 __fastcall CBB_add_u8_length_prefixed(char ***a1, char **a2);
void CBB_add_u16_length_prefixed();
void CBB_add_u24_length_prefixed();
signed __int64 __fastcall CBB_add_asn1(__int64 *a1, __int64 *a2, unsigned int a3);
signed __int64 __fastcall CBB_add_u8(__int64 *a1, char a2);
signed __int64 __fastcall CBB_add_bytes(char ***a1, const void *a2, size_t a3);
signed __int64 __fastcall CBB_add_space(__int64 *a1, _QWORD *a2, __int64 a3);
signed __int64 __fastcall CBB_reserve(__int64 *a1, _QWORD *a2, __int64 a3);
signed __int64 __fastcall CBB_did_write(__int64 *a1, __int64 a2);
signed __int64 __fastcall CBB_add_u16(char ***a1, __int16 a2);
signed __int64 __fastcall CBB_add_u24(char ***a1, unsigned int a2);
signed __int64 __fastcall CBB_add_u32(char ***a1, int a2);
_QWORD *__fastcall CBB_discard_child(_QWORD *result);
signed __int64 __fastcall CBB_add_asn1_uint64(__int64 *a1, unsigned __int64 a2);
char *DSA_new();
void __fastcall DSA_free(__int64 a1);
signed __int64 __fastcall DSA_up_ref(__int64 a1);
void __fastcall DSA_generate_parameters_ex(_DWORD **a1, unsigned int a2, __int64 a3, unsigned __int64 a4, signed int *a5, _QWORD *a6, __int64 a7);
__int64 __fastcall DSAparams_dup(signed int **a1);
__int64 __fastcall DSA_generate_key(__int64 a1);
_QWORD *ENGINE_new();
void __fastcall ECDSA_SIG_free(_DWORD **a1);
void __fastcall DSA_do_sign(unsigned __int8 *a1, unsigned __int64 a2, _QWORD *a3);
void __fastcall DSA_sign_setup(_QWORD *a1, _DWORD *a2, void ***a3, void ***a4);
signed __int64 __fastcall DSA_do_verify(unsigned __int8 *a1, unsigned __int64 a2, __int64 *a3, _QWORD *a4);
void __fastcall DSA_do_check_signature(_DWORD *a1, unsigned __int8 *a2, unsigned __int64 a3, __int64 *a4, _QWORD *a5);
signed __int64 __fastcall DSA_sign(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, __int64 a4, _DWORD *a5, _QWORD *a6);
signed __int64 __fastcall DSA_verify(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, char *a4, size_t a5, _QWORD *a6);
void __fastcall DSA_check_signature(_DWORD *a1, unsigned __int8 *a2, unsigned __int64 a3, char *a4, size_t a5, _QWORD *a6);
__int64 __fastcall DSA_size(__int64 a1);
signed __int64 __fastcall DSA_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall DSA_set_ex_data(__int64 a1, int a2, __int64 a3);
unsigned __int64 *__fastcall DSA_get_ex_data(__int64 a1, int a2);
char *__fastcall DSA_dup_DH(__int64 a1);
void __fastcall DSA_SIG_parse(unsigned __int8 **a1);
signed __int64 __fastcall DSA_SIG_marshal(__int64 *a1, __int64 *a2);
void __fastcall DSA_parse_public_key(unsigned __int8 **a1);
signed __int64 __fastcall DSA_marshal_public_key(__int64 *a1, _QWORD *a2);
void __fastcall DSA_parse_parameters(unsigned __int8 **a1);
signed __int64 __fastcall DSA_marshal_parameters(__int64 *a1, _QWORD *a2);
void __fastcall DSA_parse_private_key(unsigned __int8 **a1);
signed __int64 __fastcall DSA_marshal_private_key(__int64 *a1, _QWORD *a2);
void __fastcall d2i_DSA_SIG(_DWORD ***a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_DSA_SIG(__int64 *a1, void **a2);
void __fastcall d2i_DSAPublicKey(__int64 *a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_DSAPublicKey(_QWORD *a1, void **a2);
void __fastcall d2i_DSAPrivateKey(__int64 *a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_DSAPrivateKey(_QWORD *a1, void **a2);
void __fastcall d2i_DSAparams(__int64 *a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_DSAparams(_QWORD *a1, void **a2);
_QWORD *__fastcall sub_7290C(_QWORD *a1);
_QWORD *EC_GROUP_new_curve_GFp();
void __fastcall EC_GROUP_free(__int64 a1);
__int64 __fastcall EC_GROUP_set_generator(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
void *__fastcall EC_POINT_new(_QWORD *a1);
bool __fastcall EC_POINT_copy(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall EC_GROUP_new_by_curve_name(signed int a1);
void __fastcall EC_POINT_free(__int64 a1);
__int64 __fastcall sub_73140(__int64 a1);
_QWORD *__fastcall EC_GROUP_dup(_QWORD **a1);
_QWORD *__fastcall EC_POINT_dup(_QWORD *a1, _QWORD *a2);
signed __int64 __fastcall EC_GROUP_cmp(__int64 a1, __int64 a2);
signed __int64 __fastcall EC_GROUP_get0_order(__int64 a1);
bool __fastcall EC_GROUP_get_order(__int64 a1, __int64 a2);
__int64 __fastcall EC_GROUP_get_cofactor(__int64 a1, __int64 a2);
__int64 __fastcall EC_GROUP_get_degree(_QWORD); // weak
void __fastcall EC_POINT_clear_free(__int64 a1);
signed __int64 __fastcall EC_POINT_set_to_infinity(_QWORD *a1, _QWORD *a2);
bool __fastcall EC_POINT_is_at_infinity(_QWORD *a1, _QWORD *a2);
__int64 __fastcall EC_POINT_is_on_curve(_QWORD *a1, _QWORD *a2, __int64 a3);
signed __int64 __fastcall EC_POINT_cmp(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4);
__int64 __fastcall EC_POINT_make_affine(_QWORD *a1, _QWORD *a2, _DWORD *a3);
void __fastcall EC_POINTs_make_affine(_QWORD *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall EC_POINT_get_affine_coordinates_GFp(__int64 a1, _QWORD *a2);
__int64 __fastcall EC_POINT_set_affine_coordinates_GFp(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall EC_POINT_add(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, __int64 a5);
__int64 __fastcall EC_POINT_dbl(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4);
__int64 __fastcall EC_POINT_invert(_QWORD *a1, _QWORD *a2);
__int64 __fastcall EC_POINT_mul(__int64 *a1, _QWORD *a2, __int64 a3, _QWORD *a4, __int64 a5);
__int64 __fastcall sub_737F8(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6);
signed __int64 EC_METHOD_get_field_type();
void __fastcall EC_GROUP_set_point_conversion_form(__int64 a1, int a2);
signed __int64 __fastcall EC_get_builtin_curves(__int64 a1, unsigned __int64 a2);
void sub_738AC();
void __fastcall EC_KEY_parse_private_key(unsigned __int8 **a1, __int64 a2);
_QWORD *__fastcall EC_KEY_parse_parameters(unsigned __int8 **a1);
signed __int64 __fastcall EC_KEY_marshal_private_key(__int64 *a1, _QWORD *a2, char a3);
signed __int64 __fastcall EC_KEY_marshal_curve_name(__int64 *a1, __int64 a2);
_QWORD *__fastcall EC_KEY_parse_curve_name(unsigned __int8 **a1);
bool __fastcall sub_74588(__int128 *a1, _BYTE *a2, __int64 a3);
void __fastcall d2i_ECPrivateKey(__int64 *a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_ECPrivateKey(_QWORD *a1, void **a2);
void __fastcall d2i_ECParameters(__int64 *a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_ECParameters(__int64 *a1, void **a2);
__int64 __fastcall o2i_ECPublicKey(__int64 *a1, unsigned __int8 **a2, __int64 a3);
__int64 __fastcall i2o_ECPublicKey(__int64 a1, void **a2);
_QWORD *EC_KEY_new();
_QWORD *__fastcall EC_KEY_new_method(__int64 a1);
_QWORD *__fastcall EC_KEY_new_by_curve_name(signed int a1);
void __fastcall EC_KEY_free(__int64 a1);
__int64 __fastcall EC_KEY_copy(__int64 *a1, _QWORD *a2);
__int64 __fastcall EC_KEY_dup(_QWORD *a1);
signed __int64 __fastcall EC_KEY_up_ref(__int64 a1);
__int64 __fastcall EC_KEY_is_opaque(__int64 a1);
__int64 __fastcall EC_KEY_set_group(__int64 *a1, _QWORD **a2);
bool __fastcall EC_KEY_set_private_key(__int64 *a1, signed int *a2);
bool __fastcall EC_KEY_set_public_key(__int64 a1, _QWORD *a2);
__int64 __fastcall EC_KEY_set_enc_flags(__int64 result, int a2);
__int64 __fastcall EC_KEY_get_conv_form(__int64 a1);
__int64 __fastcall EC_KEY_set_conv_form(__int64 result, int a2);
__int64 __fastcall EC_KEY_check_key(__int64 *a1);
__int64 __fastcall EC_KEY_set_public_key_affine_coordinates(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall EC_KEY_generate_key(__int64 *a1);
signed __int64 __fastcall EC_KEY_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall EC_KEY_set_ex_data(__int64 a1, int a2, __int64 a3);
unsigned __int64 *__fastcall EC_KEY_get_ex_data(__int64 a1, int a2);
signed __int64 __fastcall sub_754A4(__int64 a1);
void __fastcall sub_754C8(__int64 a1);
signed __int64 __fastcall sub_754F4(__int64 a1, __int64 a2);
__int64 __fastcall sub_75568(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall sub_75674(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_756C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_7570C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_75754(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_7579C(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall EC_POINT_oct2point(_QWORD *a1, _QWORD *a2, unsigned __int8 *a3, __int64 a4, _DWORD *a5);
unsigned __int64 __fastcall EC_POINT_point2oct(_QWORD *a1, _QWORD *a2, int a3, char *a4, unsigned __int64 a5, __int64 a6);
signed __int64 __fastcall EC_POINT_point2cbb(__int64 *a1, _QWORD *a2, _QWORD *a3, int a4, __int64 a5);
__int64 __fastcall sub_75F58(_DWORD *a1, _QWORD *a2, __int64 a3, int a4, _DWORD *a5);
__int64 __fastcall EC_POINT_set_compressed_coordinates_GFp(_DWORD *a1, _QWORD *a2, __int64 a3, int a4, _DWORD *a5);
signed __int64 __fastcall sub_781A8(__int64 *a1, __int64 a2);
__int64 __fastcall sub_78324(_QWORD, _QWORD); // weak
_QWORD *__fastcall sub_7D358(_QWORD *result, __int64 a2);
__int64 __fastcall sub_7D534(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_7D6A0(_QWORD *result, unsigned __int64 *a2, unsigned __int64 *a3);
__int64 __fastcall sub_7D8E4(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_80A6C(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
unsigned __int64 __fastcall sub_821C4(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 *a4);
signed __int64 __fastcall sub_82314(__int64 a1);
void __fastcall sub_82358(_DWORD *a1);
__int64 __fastcall sub_82390(__int64 a1, __int64 a2);
__int64 __fastcall sub_823FC(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall EC_GROUP_get_curve_GFp_0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall EC_GROUP_get_degree_0(__int64 a1);
signed __int64 __fastcall sub_82740(__int64 a1);
void __fastcall sub_82778(__int64 a1);
void __fastcall sub_827A8(__int64 a1);
bool __fastcall sub_827D8(__int64 a1, __int64 a2);
__int64 __fastcall sub_8291C(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_829D8(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, _DWORD *a5);
__int64 __fastcall sub_834FC(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_84028(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_84040(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_BYTE *__fastcall sub_84054(_BYTE *result, _BYTE *a2, unsigned __int8 a3);
__int64 __fastcall sub_84090(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6);
void __fastcall ECDH_compute_key(void *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, __int64 (__fastcall *a5)(void *, size_t, void *, unsigned __int64 *));
void __fastcall ECDSA_sign(__int64 a1, unsigned __int8 *a2, size_t a3, __int64 a4, int *a5, __int64 a6);
void __fastcall ECDSA_sign_ex(__int64 a1, unsigned __int8 *a2, size_t a3, __int64 a4, int *a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall ECDSA_verify(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall ECDSA_do_verify(unsigned __int8 *a1, __int64 a2, __int64 *a3, __int64 a4);
void __fastcall ECDSA_do_sign(unsigned __int8 *a1, size_t a2, __int64 a3);
void __fastcall ECDSA_do_sign_ex(unsigned __int8 *a1, size_t a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_85618(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4);
__int64 __fastcall ECDSA_sign_setup(__int64 a1, _DWORD *a2, void ***a3, void ***a4);
__int64 __fastcall sub_856F4(__int64 a1, _DWORD *a2, void ***a3, void ***a4, unsigned __int64 *a5, size_t a6);
__int64 __fastcall ECDSA_size(__int64 result);
unsigned __int64 __fastcall ECDSA_SIG_max_len(unsigned __int64 a1);
_QWORD *ECDSA_SIG_new();
void __fastcall ECDSA_SIG_parse(unsigned __int8 **a1);
void __fastcall ECDSA_SIG_from_bytes(__int64 a1, __int64 a2);
signed __int64 __fastcall ECDSA_SIG_marshal(__int64 *a1, __int64 *a2);
signed __int64 __fastcall ECDSA_SIG_to_bytes(_QWORD *a1, _QWORD *a2, __int64 *a3);
void __fastcall d2i_ECDSA_SIG(_DWORD ***a1, __int64 *a2, __int64 a3);
signed __int64 __fastcall i2d_ECDSA_SIG(__int64 *a1, void **a2);
signed __int64 __fastcall ENGINE_set_RSA_method(_QWORD *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall ENGINE_set_ECDSA_method(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall CRYPTO_get_ex_new_index(pthread_rwlock_t *a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
signed __int64 __fastcall CRYPTO_set_ex_data(unsigned __int64 **a1, int a2, __int64 a3);
unsigned __int64 *__fastcall CRYPTO_get_ex_data(unsigned __int64 **a1, int a2);
_QWORD *__fastcall CRYPTO_new_ex_data(_QWORD *result);
signed __int64 __fastcall CRYPTO_dup_ex_data(pthread_rwlock_t *a1, unsigned __int64 **a2, unsigned __int64 **a3);
signed __int64 __fastcall sub_8645C(_QWORD *a1, pthread_rwlock_t *a2);
void __fastcall CRYPTO_free_ex_data(pthread_rwlock_t *a1, __int64 a2, unsigned __int64 **a3);
__int64 *__fastcall OBJ_dup(__int64 a1);
__int64 __fastcall OBJ_cmp(__int64 a1, __int64 a2);
unsigned int *__fastcall OBJ_obj2nid(unsigned int *a1);
__int64 __fastcall sub_86828(__int64 a1, unsigned int *a2);
unsigned int *__fastcall OBJ_cbs2nid(__int64 a1);
unsigned int *__fastcall OBJ_sn2nid(const void *a1);
__int64 __fastcall sub_869DC(const char *a1, unsigned int *a2);
unsigned int *__fastcall OBJ_ln2nid(const void *a1);
__int64 __fastcall sub_86AC8(const char *a1, unsigned int *a2);
__int64 __fastcall OBJ_txt2nid(const char *a1);
void __fastcall OBJ_txt2obj(const char *a1, int a2);
signed __int64 __fastcall OBJ_nid2cbb(__int64 *a1, unsigned int a2);
void __fastcall OBJ_nid2obj(unsigned int a1);
void __fastcall OBJ_nid2sn(unsigned int a1);
void __fastcall OBJ_nid2ln(unsigned int a1);
void __fastcall OBJ_obj2txt(_BYTE *a1, signed int a2, unsigned int *a3, int a4);
void __fastcall OBJ_create(const char *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_873C8(__int64 a1);
__int64 __fastcall sub_873D0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_873E0(__int64 a1);
__int64 __fastcall sub_873F0(__int64 a1, __int64 a2);
_BYTE *__fastcall sub_87424(_BYTE **a1);
__int64 __fastcall sub_8742C(const char **a1, const char **a2);
_BYTE *__fastcall sub_87438(__int64 a1);
__int64 __fastcall sub_87440(__int64 a1, __int64 a2);
_QWORD *sub_8744C();
void __fastcall sub_874E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_87724(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall X509at_get_attr_count(_QWORD *a1);
__int64 __fastcall X509v3_get_ext_by_NID(unsigned __int64 *a1, unsigned int a2, int a3);
__int64 __fastcall X509v3_get_ext_by_OBJ(unsigned __int64 *a1, __int64 a2, int a3);
unsigned __int64 *__fastcall X509v3_get_ext(unsigned __int64 *a1, int a2);
__int64 __fastcall X509v3_delete_ext(unsigned __int64 *a1, int a2);
void **__fastcall X509at_add1_attr(void ***a1, __int64 a2);
void **__fastcall X509at_add1_attr_by_OBJ(void ***a1, __int64 a2, int a3, const char *a4, signed int a5);
void ***__fastcall X509_ATTRIBUTE_create_by_OBJ(void ****a1, __int64 a2, int a3, const char *a4, signed int a5);
void **__fastcall X509at_add1_attr_by_NID(void ***a1, unsigned int a2, int a3, const char *a4, signed int a5);
void ***__fastcall X509_ATTRIBUTE_create_by_NID(void ****a1, unsigned int a2, int a3, const char *a4, signed int a5);
void **__fastcall X509at_add1_attr_by_txt(void ***a1, const char *a2, int a3, const char *a4, signed int a5);
void ***__fastcall X509_ATTRIBUTE_create_by_txt(void ****a1, const char *a2, int a3, const char *a4, signed int a5);
unsigned __int64 __fastcall X509at_get0_data_by_OBJ(unsigned __int64 *a1, __int64 a2, int a3, int a4);
_QWORD *__fastcall X509_ATTRIBUTE_count(__int64 a1);
unsigned __int64 __fastcall X509_ATTRIBUTE_get0_data(__int64 a1, signed int a2, int a3);
bool __fastcall X509_EXTENSION_set_object(void ***a1, __int64 a2);
signed __int64 __fastcall X509_ATTRIBUTE_set1_data(unsigned int **a1, int a2, const char *a3, signed int a4);
unsigned __int64 *__fastcall X509_ATTRIBUTE_get0_type(__int64 a1, signed int a2);
__int64 __fastcall X509_issuer_and_serial_cmp(__int64 *a1, __int64 *a2);
__int64 __fastcall X509_NAME_cmp(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_issuer_and_serial_hash(__int64 a1);
__int64 __fastcall X509_issuer_name_cmp(__int64 a1, __int64 a2);
__int64 __fastcall X509_subject_name_cmp(__int64 a1, __int64 a2);
__int64 __fastcall X509_CRL_cmp(__int64 a1, __int64 a2);
__int64 __fastcall X509_CRL_match(__int64 a1, __int64 a2);
__int64 __fastcall X509_get_issuer_name(__int64 a1);
unsigned __int64 __fastcall X509_issuer_name_hash(__int64 a1);
unsigned __int64 __fastcall X509_NAME_hash(__int64 a1);
signed __int64 __fastcall X509_issuer_name_hash_old(__int64 a1);
signed __int64 __fastcall X509_NAME_hash_old(__int64 a1);
__int64 __fastcall X509_get_subject_name(__int64 a1);
__int64 __fastcall X509_get_serialNumber(__int64 a1);
unsigned __int64 __fastcall X509_subject_name_hash(__int64 a1);
signed __int64 __fastcall X509_subject_name_hash_old(__int64 a1);
__int64 __fastcall X509_cmp(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall X509_find_by_issuer_and_serial(unsigned __int64 *a1, __int64 a2, __int64 a3);
unsigned __int64 *__fastcall X509_find_by_subject(unsigned __int64 *a1, __int64 a2);
void __fastcall X509_get_pubkey(__int64 a1);
__int64 __fastcall X509_get0_pubkey_bitstr(__int64 result);
bool __fastcall X509_check_private_key(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_chain_check_suiteb(_DWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
signed __int64 __fastcall X509_CRL_check_suiteb(__int64 a1, __int64 a2, int a3);
unsigned __int64 *__fastcall X509_chain_up_ref(__int64 a1);
_QWORD *__fastcall X509_CRL_get_ext_count(__int64 a1);
__int64 __fastcall X509_REQ_get_attr_by_NID(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall X509_REQ_get_attr_by_OBJ(__int64 a1, __int64 a2, int a3);
__int64 __fastcall X509_CRL_get_ext_by_critical(__int64 a1, int a2, int a3);
unsigned __int64 *__fastcall X509_REQ_get_attr(__int64 a1, int a2);
__int64 __fastcall X509_REQ_delete_attr(__int64 a1, int a2);
unsigned __int64 *__fastcall X509_CRL_get_ext_d2i(__int64 a1, int a2, signed int *a3, _DWORD *a4);
__int64 __fastcall X509_CRL_add1_ext_i2d(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5);
bool __fastcall X509_CRL_add_ext(__int64 a1, __int64 a2, int a3);
_QWORD *__fastcall X509_get_ext_count(__int64 a1);
__int64 __fastcall X509_get_ext_by_NID(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall X509_get_ext_by_OBJ(__int64 a1, __int64 a2, int a3);
__int64 __fastcall X509_get_ext_by_critical(__int64 a1, int a2, int a3);
unsigned __int64 *__fastcall X509_get_ext(__int64 a1, int a2);
__int64 __fastcall X509_delete_ext(__int64 a1, int a2);
bool __fastcall X509_add_ext(__int64 a1, __int64 a2, int a3);
unsigned __int64 *__fastcall X509_get_ext_d2i(__int64 a1, int a2, signed int *a3, _DWORD *a4);
__int64 __fastcall X509_add1_ext_i2d(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5);
_QWORD *__fastcall X509_REVOKED_get_ext_count(__int64 a1);
__int64 __fastcall X509_REVOKED_get_ext_by_NID(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall X509_REVOKED_get_ext_by_OBJ(__int64 a1, __int64 a2, int a3);
__int64 __fastcall X509_REVOKED_get_ext_by_critical(__int64 a1, int a2, int a3);
unsigned __int64 *__fastcall X509_REVOKED_get_ext(__int64 a1, int a2);
__int64 __fastcall X509_REVOKED_delete_ext(__int64 a1, int a2);
bool __fastcall X509_REVOKED_add_ext(__int64 a1, __int64 a2, int a3);
unsigned __int64 *__fastcall X509_REVOKED_get_ext_d2i(__int64 a1, int a2, signed int *a3, _DWORD *a4);
__int64 __fastcall X509_REVOKED_add1_ext_i2d(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5);
void *__fastcall X509_LOOKUP_new(__int64 a1);
void __fastcall X509_LOOKUP_free(_QWORD *a1);
__int64 __fastcall X509_LOOKUP_init(__int64 a1);
__int64 __fastcall X509_LOOKUP_shutdown(__int64 a1);
__int64 __fastcall X509_LOOKUP_ctrl(__int64 a1);
bool __fastcall X509_LOOKUP_by_subject(__int64 a1, __int64 a2);
bool __fastcall X509_LOOKUP_by_issuer_serial(__int64 a1);
bool __fastcall X509_LOOKUP_by_fingerprint(__int64 a1);
bool __fastcall X509_LOOKUP_by_alias(__int64 a1);
_DWORD *X509_STORE_new();
__int64 __fastcall sub_89188(int **a1, int **a2);
signed __int64 __fastcall X509_STORE_up_ref(__int64 a1);
void __fastcall X509_STORE_free(__int64 a1);
void __fastcall sub_892D8(__int64 *a1);
unsigned __int64 *__fastcall X509_STORE_add_lookup(unsigned __int64 a1, unsigned __int64 a2);
signed __int64 __fastcall X509_STORE_get_by_subject(_QWORD *a1, int a2, __int64 a3, __int64 a4);
unsigned __int64 *__fastcall X509_OBJECT_retrieve_by_subject(__int64 a1, int a2, __int64 a3);
signed __int64 __fastcall X509_OBJECT_up_ref_count(__int64 a1);
__int64 __fastcall X509_STORE_add_cert(__int64 a1, __int64 a2);
unsigned __int64 __fastcall X509_OBJECT_retrieve_match(__int64 a1, __int64 a2);
void __fastcall X509_OBJECT_free_contents(__int64 a1);
__int64 __fastcall X509_STORE_add_crl(__int64 a1, __int64 a2);
__int64 __fastcall X509_STORE_set0_additional_untrusted(__int64 result, __int64 a2);
signed __int64 __fastcall X509_OBJECT_idx_by_subject(__int64 a1, int a2, __int64 a3);
signed __int64 __fastcall sub_89B8C(__int64 a1, int a2, __int64 a3, _DWORD *a4);
void __fastcall X509_STORE_get1_certs(_QWORD *a1, __int64 a2);
void __fastcall X509_STORE_get1_crls(_QWORD *a1, __int64 a2);
signed __int64 __fastcall X509_STORE_CTX_get1_issuer(__int64 *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall X509_STORE_set_flags(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_STORE_set_depth(__int64 a1, int a2);
signed __int64 __fastcall X509_STORE_set_purpose(__int64 a1, int a2);
signed __int64 __fastcall X509_STORE_set_trust(__int64 a1, int a2);
signed __int64 __fastcall X509_STORE_set1_param(__int64 a1, __int64 a2);
__int64 __fastcall X509_STORE_set_verify_cb(__int64 result, __int64 a2);
__int64 __fastcall X509_STORE_set_lookup_crls_cb(__int64 result, __int64 a2);
void __fastcall X509_NAME_oneline(unsigned __int64 **a1, _BYTE *a2, signed int a3);
_QWORD *__fastcall X509v3_get_ext_count(_QWORD *result);
__int64 __fastcall X509v3_get_ext_by_critical(unsigned __int64 *a1, int a2, int a3);
void **__fastcall X509v3_add_ext(void ***a1, __int64 a2, int a3);
__int64 __fastcall X509_EXTENSION_create_by_NID(__int64 *a1, unsigned int a2, int a3, __int64 a4);
__int64 __fastcall X509_EXTENSION_create_by_OBJ(__int64 *a1, __int64 a2, int a3, __int64 a4);
signed __int64 __fastcall X509_EXTENSION_set_critical(signed __int64 result, int a2);
__int64 __fastcall X509_EXTENSION_set_data(__int64 result, __int64 a2);
__int64 __fastcall X509_EXTENSION_get_data(__int64 result);
__int64 __fastcall X509_EXTENSION_get_critical(__int64 result);
void __fastcall X509_verify_cert(_QWORD *a1);
__int64 __fastcall sub_8B73C(__int64 a1);
void __fastcall X509_cmp_current_time(int *a1);
void __fastcall X509_cmp_time(int *a1, __int64 *a2);
void __fastcall X509_time_adj(__int64 a1, __int64 a2, __int64 *a3);
void __fastcall X509_gmtime_adj(__int64 a1, __int64 a2);
void __fastcall X509_time_adj_ex(__int64 a1, int a2, __int64 a3, __int64 *a4);
void __fastcall X509_CRL_diff(_QWORD *a1, __int64 *a2, __int64 a3, __int64 a4);
bool __fastcall sub_8C16C(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall X509_STORE_CTX_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall X509_STORE_CTX_set_ex_data(__int64 a1, int a2, __int64 a3);
unsigned __int64 *__fastcall X509_STORE_CTX_get_ex_data(__int64 a1, int a2);
__int64 __fastcall X509_STORE_CTX_get_error(__int64 a1);
__int64 __fastcall X509_STORE_CTX_set_error(__int64 result, int a2);
__int64 __fastcall X509_STORE_CTX_get_error_depth(__int64 a1);
__int64 __fastcall X509_STORE_CTX_get_current_cert(__int64 a1);
__int64 __fastcall X509_STORE_CTX_get_chain(__int64 a1);
unsigned __int64 *__fastcall X509_STORE_CTX_get1_chain(__int64 a1);
__int64 __fastcall X509_STORE_CTX_get0_current_issuer(__int64 a1);
__int64 __fastcall X509_STORE_CTX_get0_current_crl(__int64 a1);
__int64 __fastcall X509_STORE_CTX_get0_parent_ctx(__int64 a1);
__int64 __fastcall X509_STORE_CTX_set0_crls(__int64 result, __int64 a2);
signed __int64 __fastcall X509_STORE_CTX_set_purpose(__int64 a1, int a2);
signed __int64 __fastcall X509_STORE_CTX_purpose_inherit(__int64 a1, int a2, int a3, int a4);
signed __int64 __fastcall X509_STORE_CTX_set_trust(__int64 a1, int a2);
void *X509_STORE_CTX_new();
void __fastcall X509_STORE_CTX_free(__int64 a1);
void __fastcall X509_STORE_CTX_cleanup(__int64 a1);
signed __int64 __fastcall X509_STORE_CTX_init(unsigned __int64 **a1, __int64 *a2, unsigned __int64 *a3, unsigned __int64 *a4);
__int64 __fastcall sub_8C804(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall nullsub_1(); // weak
signed __int64 __fastcall sub_8C87C(__int64 a1);
void __fastcall sub_8CB58(__int64 a1, __int64 a2);
__int64 __fastcall sub_8CEFC(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_8CFD0(__int64 a1);
__int64 __fastcall X509_STORE_CTX_trusted_stack(__int64 result, __int64 a2);
signed __int64 __fastcall sub_8D120(unsigned __int64 **a1, __int64 a2, __int64 a3);
__int64 __fastcall X509_STORE_CTX_set_depth(__int64 a1, int a2);
signed __int64 __fastcall X509_STORE_CTX_set_flags(__int64 a1, __int64 a2);
__int64 __fastcall X509_STORE_CTX_set_time(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall X509_STORE_CTX_set_verify_cb(__int64 result, __int64 a2);
__int64 __fastcall X509_STORE_CTX_get0_policy_tree(__int64 a1);
__int64 __fastcall X509_STORE_CTX_get_explicit_policy(__int64 a1);
signed __int64 __fastcall X509_STORE_CTX_set_default(__int64 a1, __int64 a2);
__int64 __fastcall X509_STORE_CTX_get0_param(__int64 a1);
void __fastcall X509_STORE_CTX_set0_param(__int64 a1, __int64 a2);
bool __fastcall sub_8D27C(__int64 a1, __int64 *a2, __int64 *a3, unsigned __int64 **a4, int *a5, _DWORD *a6, unsigned __int64 *a7);
_QWORD *X509_VERIFY_PARAM_new();
void __fastcall sub_8DADC(__int64 a1);
void __fastcall X509_VERIFY_PARAM_free(__int64 a1);
signed __int64 __fastcall X509_VERIFY_PARAM_inherit(__int64 a1, __int64 a2);
_QWORD *__fastcall X509_VERIFY_PARAM_set1_policies(__int64 a1, unsigned __int64 *a2);
__int64 __fastcall j__free_0(); // weak
__int64 __fastcall j_OPENSSL_strdup(); // weak
signed __int64 __fastcall X509_VERIFY_PARAM_set1_email(__int64 a1, const char *a2, size_t a3);
signed __int64 __fastcall X509_VERIFY_PARAM_set1_ip(__int64 a1, const char *a2, size_t a3);
signed __int64 __fastcall X509_VERIFY_PARAM_set1(__int64 a1, __int64 a2);
bool __fastcall X509_VERIFY_PARAM_set1_name(void **a1, const char *a2);
signed __int64 __fastcall X509_VERIFY_PARAM_set_flags(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_VERIFY_PARAM_clear_flags(__int64 a1, __int64 a2);
__int64 __fastcall X509_VERIFY_PARAM_get_flags(__int64 a1);
signed __int64 __fastcall X509_VERIFY_PARAM_set_purpose(__int64 a1, int a2);
signed __int64 __fastcall X509_VERIFY_PARAM_set_trust(__int64 a1, int a2);
__int64 __fastcall X509_VERIFY_PARAM_set_depth(__int64 result, int a2);
__int64 __fastcall X509_VERIFY_PARAM_set_time(__int64 result, __int64 a2);
unsigned __int64 *__fastcall X509_VERIFY_PARAM_add0_policy(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_VERIFY_PARAM_set1_host(__int64 a1, const void *a2, size_t a3);
void __fastcall X509_VERIFY_PARAM_add1_host(__int64 a1);
__int64 __fastcall X509_VERIFY_PARAM_set_hostflags(__int64 result, int a2);
__int64 __fastcall X509_VERIFY_PARAM_get0_peername(__int64 a1);
signed __int64 __fastcall sub_8E1D0(void **a1, size_t *a2, const char *a3, size_t a4);
signed __int64 __fastcall X509_VERIFY_PARAM_set1_ip_asc(__int64 a1, const char *a2);
__int64 __fastcall X509_VERIFY_PARAM_add0_table(__int64 a1);
__int64 __fastcall sub_8E3EC(const char ***a1, const char ***a2);
signed __int64 X509_VERIFY_PARAM_get_count();
unsigned __int64 *__fastcall X509_VERIFY_PARAM_get0(signed int a1);
__int64 __fastcall X509_VERIFY_PARAM_lookup(__int64 a1);
void X509_VERIFY_PARAM_table_cleanup();
signed __int64 __fastcall X509_CRL_set_version(__int64 **a1, __int64 a2);
bool __fastcall X509_CRL_set_issuer_name(__int64 a1, __int64 a2);
bool __fastcall X509_CRL_set_lastUpdate(__int64 a1, __int64 a2);
bool __fastcall X509_CRL_set_nextUpdate(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_CRL_sort(__int64 *a1);
signed __int64 __fastcall X509_up_ref(__int64 a1);
bool __fastcall X509_REVOKED_set_revocationDate(__int64 a1, __int64 a2);
bool __fastcall X509_REVOKED_set_serialNumber(__int64 *a1, __int64 a2);
signed __int64 __fastcall X509_NAME_get_text_by_NID(unsigned __int64 **a1, unsigned int a2, void *a3, int a4);
signed __int64 __fastcall X509_NAME_get_index_by_OBJ(unsigned __int64 **a1, __int64 a2, signed int a3);
__int64 __fastcall X509_policy_node_get0_parent(__int64 result);
unsigned __int64 *__fastcall X509_NAME_get_entry(unsigned __int64 **a1, int a2);
_QWORD *__fastcall X509_NAME_entry_count(_QWORD *result);
signed __int64 __fastcall X509_NAME_get_index_by_NID(unsigned __int64 **a1, unsigned int a2, signed int a3);
__int64 __fastcall X509_NAME_delete_entry(unsigned __int64 **a1, int a2);
__int64 __fastcall X509_NAME_add_entry_by_OBJ(unsigned __int64 **a1, __int64 a2, signed int a3, const char *a4, signed int a5, int a6, int a7);
void ***__fastcall X509_NAME_ENTRY_create_by_OBJ(void ****a1, __int64 a2, signed int a3, const char *a4, signed int a5);
signed __int64 __fastcall X509_NAME_add_entry(unsigned __int64 **a1, __int64 a2, int a3, int a4);
__int64 __fastcall X509_NAME_add_entry_by_NID(unsigned __int64 **a1, unsigned int a2, signed int a3, const char *a4, signed int a5, int a6, int a7);
void ***__fastcall X509_NAME_ENTRY_create_by_NID(void ****a1, unsigned int a2, signed int a3, const char *a4, signed int a5);
__int64 __fastcall X509_NAME_add_entry_by_txt(unsigned __int64 **a1, const char *a2, signed int a3, const char *a4, signed int a5, int a6, int a7);
void ***__fastcall X509_NAME_ENTRY_create_by_txt(void ****a1, const char *a2, signed int a3, const char *a4, signed int a5);
bool __fastcall X509_NAME_ENTRY_set_object(void ***a1, __int64 a2);
signed __int64 __fastcall X509_NAME_ENTRY_set_data(unsigned int **a1, signed int a2, const char *a3, signed int a4);
void __fastcall X509_verify(__int64 **a1, __int64 a2);
void __fastcall X509_REQ_verify(__int64 a1, __int64 a2);
__int64 __fastcall X509_sign(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall X509_sign_ctx(__int64 *a1, _QWORD *a2);
__int64 __fastcall X509_REQ_sign(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall X509_REQ_sign_ctx(__int64 *a1, _QWORD *a2);
__int64 __fastcall X509_CRL_sign(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall X509_CRL_sign_ctx(__int64 *a1, _QWORD *a2);
__int64 __fastcall NETSCAPE_SPKI_sign(__int64 *a1, __int64 a2, __int64 a3);
void __fastcall NETSCAPE_SPKI_verify(__int64 a1, __int64 a2);
void __fastcall d2i_X509_fp(__int64 a1, unsigned __int64 **a2);
__int64 __fastcall i2d_X509_fp(__int64 a1);
void __fastcall d2i_X509_bio(_QWORD *a1, unsigned __int64 **a2);
void i2d_X509_bio();
void __fastcall d2i_X509_CRL_fp(__int64 a1, unsigned __int64 **a2);
__int64 __fastcall i2d_X509_CRL_fp(__int64 a1);
void __fastcall d2i_X509_CRL_bio(_QWORD *a1, unsigned __int64 **a2);
void i2d_X509_CRL_bio();
void __fastcall d2i_X509_REQ_fp(__int64 a1, unsigned __int64 **a2);
__int64 __fastcall i2d_X509_REQ_fp(__int64 a1);
void __fastcall d2i_X509_REQ_bio(_QWORD *a1, unsigned __int64 **a2);
void i2d_X509_REQ_bio();
void __fastcall d2i_RSAPrivateKey_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_RSAPrivateKey_fp(__int64 a1, __int64 a2);
void __fastcall d2i_RSAPublicKey_fp(__int64 a1, __int64 a2);
void __fastcall d2i_RSA_PUBKEY_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_RSAPublicKey_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_RSA_PUBKEY_fp(__int64 a1, __int64 a2);
void __fastcall d2i_RSAPrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_RSAPrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_RSAPublicKey_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_RSA_PUBKEY_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_RSAPublicKey_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_RSA_PUBKEY_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_DSAPrivateKey_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_DSAPrivateKey_fp(__int64 a1, __int64 a2);
void __fastcall d2i_DSA_PUBKEY_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_DSA_PUBKEY_fp(__int64 a1, __int64 a2);
void __fastcall d2i_DSAPrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_DSAPrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_DSA_PUBKEY_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_DSA_PUBKEY_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_EC_PUBKEY_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_EC_PUBKEY_fp(__int64 a1, __int64 a2);
void __fastcall d2i_ECPrivateKey_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_ECPrivateKey_fp(__int64 a1, __int64 a2);
void __fastcall d2i_EC_PUBKEY_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_EC_PUBKEY_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_ECPrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_ECPrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall X509_pubkey_digest(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4);
void X509_digest();
void X509_CRL_digest();
void X509_REQ_digest();
void X509_NAME_digest();
void __fastcall d2i_PKCS8_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_PKCS8_fp(__int64 a1, __int64 a2);
void __fastcall d2i_PKCS8_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_PKCS8_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_PKCS8_PRIV_KEY_INFO_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_PKCS8_PRIV_KEY_INFO_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_PKCS8PrivateKeyInfo_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_PrivateKey_fp(__int64 a1, __int64 a2);
void __fastcall d2i_PrivateKey_fp(__int64 a1, __int64 a2);
__int64 __fastcall i2d_PUBKEY_fp(__int64 a1, __int64 a2);
void __fastcall d2i_PUBKEY_fp(__int64 a1, __int64 a2);
void __fastcall d2i_PKCS8_PRIV_KEY_INFO_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_PKCS8_PRIV_KEY_INFO_bio(_QWORD *a1, __int64 a2);
__int64 __fastcall i2d_PKCS8PrivateKeyInfo_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_PrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_PrivateKey_bio(_QWORD *a1, __int64 a2);
void __fastcall i2d_PUBKEY_bio(_QWORD *a1, __int64 a2);
void __fastcall d2i_PUBKEY_bio(_QWORD *a1, __int64 a2);
unsigned __int64 *__fastcall d2i_X509_ATTRIBUTE(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_ATTRIBUTE();
__int64 X509_ATTRIBUTE_new();
void __fastcall X509_ATTRIBUTE_free(__int64 a1);
void __fastcall X509_ATTRIBUTE_dup(__int64 a1);
__int64 __fastcall X509_ATTRIBUTE_create(unsigned int a1, int a2, __int64 a3);
unsigned __int64 *__fastcall d2i_X509_REVOKED(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_REVOKED();
__int64 X509_REVOKED_new();
void __fastcall X509_REVOKED_free(__int64 a1);
void __fastcall X509_REVOKED_dup(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_CRL_INFO(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_CRL_INFO();
__int64 X509_CRL_INFO_new();
void __fastcall X509_CRL_INFO_free(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_CRL(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_CRL();
__int64 X509_CRL_new();
void __fastcall X509_CRL_free(__int64 a1);
void __fastcall X509_CRL_dup(__int64 a1);
signed __int64 __fastcall X509_CRL_add0_revoked(__int64 *a1, __int64 a2);
__int64 __fastcall sub_90064(const void ****a1, __int64 **a2);
__int64 __fastcall X509_CRL_verify(__int64 a1);
__int64 __fastcall X509_CRL_get0_by_serial(__int64 a1);
__int64 __fastcall X509_CRL_get0_by_cert(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall X509_CRL_set_default_method(void *result);
_QWORD *__fastcall X509_CRL_METHOD_new(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall X509_CRL_METHOD_free(void *ptr);
__int64 __fastcall X509_CRL_set_meth_data(__int64 result, __int64 a2);
__int64 __fastcall X509_CRL_get_meth_data(__int64 a1);
signed __int64 __fastcall sub_901B4(int a1, __int64 a2);
__int64 __fastcall sub_901EC(int a1, __int64 *a2);
_BYTE *__fastcall sub_90674(__int64 *a1, unsigned __int64 **a2, __int64 a3, __int64 a4);
void __fastcall sub_90848(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall d2i_X509_EXTENSION(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_EXTENSION();
__int64 X509_EXTENSION_new();
void __fastcall X509_EXTENSION_free(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_EXTENSIONS(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_EXTENSIONS();
void __fastcall X509_EXTENSION_dup(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_NAME_ENTRY(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_NAME_ENTRY();
__int64 X509_NAME_ENTRY_new();
void __fastcall X509_NAME_ENTRY_free(__int64 a1);
void __fastcall X509_NAME_ENTRY_dup(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_NAME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_NAME();
__int64 X509_NAME_new();
void __fastcall X509_NAME_free(__int64 a1);
void __fastcall X509_NAME_dup(__int64 a1);
bool __fastcall X509_NAME_set(__int64 *a1, __int64 a2);
signed __int64 __fastcall sub_909CC(_QWORD *a1);
void __fastcall sub_90A7C(_QWORD *a1);
void __fastcall sub_90AD4(__int64 *a1, const void **a2, __int64 a3, __int64 a4, signed int a5, int a6, char a7, __int64 a8);
void __fastcall sub_90CE8(unsigned __int64 ***a1, void **a2);
void __fastcall sub_90EE8(__int64 a1);
__int64 __fastcall j_sk_free(); // weak
void __fastcall sub_912B8(unsigned __int64 *a1);
unsigned __int64 *__fastcall d2i_X509_PUBKEY(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_PUBKEY();
__int64 X509_PUBKEY_new();
void __fastcall X509_PUBKEY_free(__int64 a1);
signed __int64 __fastcall X509_PUBKEY_set(__int64 *a1, __int64 a2);
void __fastcall X509_PUBKEY_get(__int64 a1);
int *__fastcall d2i_PUBKEY(int **a1, const void **a2, __int64 a3);
void __fastcall i2d_PUBKEY(__int64 a1);
void __fastcall d2i_RSA_PUBKEY(int **a1, __int64 *a2, __int64 a3);
void __fastcall i2d_RSA_PUBKEY(__int64 a1);
void __fastcall d2i_DSA_PUBKEY(__int64 *a1, __int64 *a2, __int64 a3);
void __fastcall i2d_DSA_PUBKEY(__int64 a1);
void __fastcall d2i_EC_PUBKEY(__int64 *a1, __int64 *a2, __int64 a3);
void __fastcall i2d_EC_PUBKEY(__int64 a1);
__int64 __fastcall X509_PUBKEY_set0_param(__int64 *a1, __int64 a2, int a3, __int64 a4, __int64 a5, int a6);
signed __int64 __fastcall X509_PUBKEY_get0_param(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5);
signed __int64 __fastcall sub_91CC0(int a1, __int64 a2);
unsigned __int64 *__fastcall d2i_X509_REQ_INFO(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_REQ_INFO();
__int64 X509_REQ_INFO_new();
void __fastcall X509_REQ_INFO_free(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_REQ(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_REQ();
__int64 X509_REQ_new();
void __fastcall X509_REQ_free(__int64 a1);
void __fastcall X509_REQ_dup(__int64 a1);
_QWORD *__fastcall sub_91D60(int a1, __int64 *a2);
unsigned __int64 *__fastcall d2i_X509_SIG(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_SIG();
__int64 X509_SIG_new();
void __fastcall X509_SIG_free(__int64 a1);
unsigned __int64 *__fastcall d2i_NETSCAPE_SPKAC(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_NETSCAPE_SPKAC();
__int64 NETSCAPE_SPKAC_new();
void __fastcall NETSCAPE_SPKAC_free(__int64 a1);
unsigned __int64 *__fastcall d2i_NETSCAPE_SPKI(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_NETSCAPE_SPKI();
__int64 NETSCAPE_SPKI_new();
void __fastcall NETSCAPE_SPKI_free(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_CINF(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_CINF();
__int64 X509_CINF_new();
void __fastcall X509_CINF_free(__int64 a1);
unsigned __int64 *__fastcall d2i_X509(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509();
__int64 X509_new();
void __fastcall X509_free(__int64 a1);
void __fastcall X509_dup(__int64 a1);
void __fastcall X509_parse_from_buffer(__int64 a1);
signed __int64 __fastcall X509_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall X509_set_ex_data(__int64 a1, int a2, __int64 a3);
unsigned __int64 *__fastcall X509_get_ex_data(__int64 a1, int a2);
void __fastcall d2i_X509_AUX(unsigned __int64 **a1, __int64 *a2, __int64 a3);
void __fastcall i2d_X509_AUX(__int64 a1, void **a2);
_QWORD *__fastcall X509_get0_signature(_QWORD *result, _QWORD *a2, __int64 a3);
unsigned int *__fastcall X509_get_signature_nid(__int64 a1);
signed __int64 __fastcall sub_922DC(int a1, __int64 *a2);
unsigned __int64 *__fastcall d2i_X509_CERT_AUX(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_CERT_AUX();
__int64 X509_CERT_AUX_new();
void __fastcall X509_CERT_AUX_free(__int64 a1);
__int64 __fastcall X509_alias_set1(__int64 a1, const char *a2, int a3);
__int64 __fastcall X509_keyid_set1(__int64 a1, const char *a2, int a3);
__int64 __fastcall X509_alias_get0(__int64 a1, _DWORD *a2);
__int64 __fastcall X509_keyid_get0(__int64 a1, _DWORD *a2);
signed __int64 __fastcall X509_add1_trust_object(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_add1_reject_object(__int64 a1, __int64 a2);
void __fastcall X509_trust_clear(__int64 a1);
void __fastcall X509_reject_clear(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_CERT_PAIR(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_CERT_PAIR();
__int64 X509_CERT_PAIR_new();
void __fastcall X509_CERT_PAIR_free(__int64 a1);
void __fastcall sub_927B4(void ****a1);
__int64 __fastcall sub_92804(__int64 a1);
unsigned __int64 *__fastcall sub_92B60(__int64 a1, __int64 a2);
__int64 __fastcall sub_92BD4(__int64 a1, __int64 a2);
void __fastcall sub_92BE8(void ***a1);
_QWORD *__fastcall sub_92C38(_QWORD *a1, __int64 a2, int a3);
__int64 __fastcall sub_92D18(__int64 a1, unsigned __int64 *a2);
void __fastcall X509_policy_tree_free(__int64 a1);
void __fastcall sub_92F3C(void *ptr);
signed __int64 __fastcall X509_policy_check(__int64 *a1, _DWORD *a2, unsigned __int64 *a3, unsigned __int64 *a4, __int16 a5);
unsigned __int64 *__fastcall d2i_AUTHORITY_KEYID(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_AUTHORITY_KEYID();
__int64 AUTHORITY_KEYID_new();
void __fastcall AUTHORITY_KEYID_free(__int64 a1);
signed __int64 __fastcall sub_939A4(__int64 a1, unsigned __int64 *a2, _QWORD *a3, unsigned int a4);
unsigned __int64 *__fastcall sub_93A7C(__int64 a1, __int64 a2, const char *a3);
unsigned __int64 *__fastcall d2i_CERTIFICATEPOLICIES(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_CERTIFICATEPOLICIES();
__int64 CERTIFICATEPOLICIES_new();
void __fastcall CERTIFICATEPOLICIES_free(__int64 a1);
unsigned __int64 *__fastcall d2i_POLICYINFO(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_POLICYINFO();
__int64 POLICYINFO_new();
void __fastcall POLICYINFO_free(__int64 a1);
unsigned __int64 *__fastcall d2i_POLICYQUALINFO(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_POLICYQUALINFO();
__int64 POLICYQUALINFO_new();
void __fastcall POLICYQUALINFO_free(__int64 a1);
unsigned __int64 *__fastcall d2i_USERNOTICE(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_USERNOTICE();
__int64 USERNOTICE_new();
void __fastcall USERNOTICE_free(__int64 a1);
unsigned __int64 *__fastcall d2i_NOTICEREF(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_NOTICEREF();
__int64 NOTICEREF_new();
void __fastcall NOTICEREF_free(__int64 a1);
void __fastcall X509_POLICY_NODE_print(_QWORD *a1, __int64 *a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
_QWORD *__fastcall sub_944E8(_QWORD *a1, unsigned __int64 *a2, unsigned int a3);
unsigned __int64 *__fastcall sub_94718(__int64 a1, __int64 a2, unsigned __int64 *a3);
signed __int64 __fastcall sub_949DC(__int64 a1, unsigned __int64 *a2, _QWORD *a3, unsigned int a4);
unsigned __int64 *__fastcall d2i_DIST_POINT_NAME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_DIST_POINT_NAME();
__int64 DIST_POINT_NAME_new();
void __fastcall DIST_POINT_NAME_free(__int64 a1);
unsigned __int64 *__fastcall d2i_DIST_POINT(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_DIST_POINT();
__int64 DIST_POINT_new();
void __fastcall DIST_POINT_free(__int64 a1);
unsigned __int64 *__fastcall d2i_CRL_DIST_POINTS(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_CRL_DIST_POINTS();
__int64 CRL_DIST_POINTS_new();
void __fastcall CRL_DIST_POINTS_free(__int64 a1);
unsigned __int64 *__fastcall d2i_ISSUING_DIST_POINT(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ISSUING_DIST_POINT();
__int64 ISSUING_DIST_POINT_new();
void __fastcall ISSUING_DIST_POINT_free(__int64 a1);
__int64 __fastcall sub_94B9C(__int64 a1, __int64 a2, unsigned __int64 *a3);
signed __int64 __fastcall sub_94DA4(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 *a10, _QWORD *a11, unsigned int a12);
void __fastcall DIST_POINT_set_dpname(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_94FBC(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_951A0(signed int **a1, const char *a2);
unsigned __int64 *__fastcall sub_953B8(__int64 a1, const char *a2);
signed __int64 __fastcall sub_9547C(int a1, __int64 *a2);
__int64 __fastcall sub_954BC(_QWORD *a1, __int64 a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_955A0(_QWORD *a1, __int64 a2, __int64 a3, unsigned int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
_QWORD *__fastcall sub_95668(_QWORD *a1, unsigned __int64 *a2, int a3);
unsigned __int64 *__fastcall d2i_OTHERNAME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_OTHERNAME();
__int64 OTHERNAME_new();
void __fastcall OTHERNAME_free(__int64 a1);
unsigned __int64 *__fastcall d2i_EDIPARTYNAME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_EDIPARTYNAME();
__int64 EDIPARTYNAME_new();
void __fastcall EDIPARTYNAME_free(__int64 a1);
unsigned __int64 *__fastcall d2i_GENERAL_NAME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_GENERAL_NAME();
__int64 GENERAL_NAME_new();
void __fastcall GENERAL_NAME_free(__int64 a1);
unsigned __int64 *__fastcall d2i_GENERAL_NAMES(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_GENERAL_NAMES();
__int64 GENERAL_NAMES_new();
void __fastcall GENERAL_NAMES_free(__int64 a1);
void __fastcall GENERAL_NAME_dup(__int64 a1);
__int64 __fastcall GENERAL_NAME_cmp(__int64 a1, __int64 a2);
__int64 __fastcall OTHERNAME_cmp(__int64 a1, __int64 *a2);
__int64 __fastcall GENERAL_NAME_set0_value(__int64 result, unsigned int a2, __int64 a3);
__int64 __fastcall GENERAL_NAME_get0_value(__int64 a1, _DWORD *a2);
_QWORD *__fastcall GENERAL_NAME_set0_othername(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall GENERAL_NAME_get0_otherName(__int64 a1, _QWORD *a2, _QWORD *a3);
signed __int64 __fastcall X509V3_EXT_add(_BYTE *a1);
__int64 __fastcall sub_95AA0(_DWORD **a1, _DWORD **a2);
void __fastcall sub_95AB8(void *ptr);
unsigned __int64 *__fastcall X509V3_EXT_get_nid(int a1);
__int64 __fastcall sub_95B78(_DWORD **a1, _DWORD **a2);
unsigned __int64 *__fastcall X509V3_EXT_get(unsigned int **a1);
signed __int64 __fastcall X509V3_EXT_free(int a1, __int64 a2);
signed __int64 __fastcall X509V3_EXT_add_list(_DWORD *a1);
signed __int64 __fastcall X509V3_EXT_add_alias(int a1, int a2);
void X509V3_EXT_cleanup();
unsigned __int64 *__fastcall X509V3_EXT_d2i(unsigned int **a1);
unsigned __int64 *__fastcall X509V3_get_d2i(unsigned __int64 *a1, int a2, signed int *a3, _DWORD *a4);
__int64 __fastcall X509V3_add1_i2d(unsigned __int64 **a1, unsigned int a2, __int64 a3, int a4, char a5);
void __fastcall sub_962D0(__int64 a1, __int64 a2, unsigned __int64 *a3);
signed __int64 __fastcall sub_964C8(__int64 a1, unsigned __int64 **a2, _QWORD *a3, unsigned int a4);
__int64 GENERAL_SUBTREE_new();
void __fastcall GENERAL_SUBTREE_free(__int64 a1);
__int64 NAME_CONSTRAINTS_new();
void __fastcall NAME_CONSTRAINTS_free(__int64 a1);
unsigned __int64 __fastcall NAME_CONSTRAINTS_check(__int64 a1, unsigned __int64 **a2);
signed __int64 __fastcall sub_966C8(_DWORD *a1, unsigned __int64 **a2);
_QWORD *__fastcall sub_96804(unsigned __int64 *a1, _QWORD *a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_969F4(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_96CC4(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, _QWORD *a11, unsigned int a12);
void __fastcall sub_96DB0(__int64 a1, __int64 a2, const char *a3);
signed __int64 __fastcall sub_97054(__int64 a1, _QWORD *a2, _QWORD *a3, _DWORD **a4);
unsigned __int64 *__fastcall d2i_PROXY_POLICY(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_PROXY_POLICY();
__int64 PROXY_POLICY_new();
void __fastcall PROXY_POLICY_free(__int64 a1);
unsigned __int64 *__fastcall d2i_PROXY_CERT_INFO_EXTENSION(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_PROXY_CERT_INFO_EXTENSION();
__int64 PROXY_CERT_INFO_EXTENSION_new();
void __fastcall PROXY_CERT_INFO_EXTENSION_free(__int64 a1);
__int64 __fastcall sub_97480(__int64 a1, unsigned __int8 ***a2, __int64 a3);
_QWORD *__fastcall sub_974F4(__int64 a1, __int64 a2, unsigned __int64 *a3);
__int64 POLICY_CONSTRAINTS_new();
void __fastcall POLICY_CONSTRAINTS_free(__int64 a1);
signed __int64 __fastcall sub_97698(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, signed int **a10, _QWORD *a11, unsigned int a12);
unsigned __int64 *__fastcall d2i_PKEY_USAGE_PERIOD(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_PKEY_USAGE_PERIOD();
__int64 PKEY_USAGE_PERIOD_new();
void __fastcall PKEY_USAGE_PERIOD_free(__int64 a1);
_QWORD *__fastcall sub_97788(__int64 a1, unsigned __int64 *a2, __int64 a3);
unsigned __int64 *__fastcall sub_9784C(__int64 a1, __int64 a2, unsigned __int64 *a3);
__int64 POLICY_MAPPING_new();
void __fastcall POLICY_MAPPING_free(__int64 a1);
__int64 __fastcall X509_check_purpose(__int64 a1, int a2);
__int64 __fastcall sub_97B0C(__int64 a1);
signed __int64 __fastcall X509_PURPOSE_get_by_id(int a1);
unsigned __int64 *__fastcall X509_PURPOSE_get0(signed int a1);
signed __int64 __fastcall X509_PURPOSE_set(int *a1, int a2);
signed __int64 X509_PURPOSE_get_count();
signed __int64 __fastcall X509_PURPOSE_get_by_sname(const char *a1);
signed __int64 __fastcall X509_PURPOSE_add(int a1, int a2, int a3, unsigned __int64 a4, const char *a5, const char *a6, unsigned __int64 a7);
__int64 __fastcall sub_985F0(_DWORD **a1, _DWORD **a2);
void __fastcall sub_98608(__int64 a1);
void X509_PURPOSE_cleanup();
unsigned int *__fastcall X509_supported_extension(_QWORD *a1);
__int64 __fastcall sub_98748(_DWORD *a1, _DWORD *a2);
signed __int64 __fastcall X509_check_ca(__int64 a1);
signed __int64 __fastcall X509_check_issued(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_check_akid(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_98960(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_98A48(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_98B38(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_98B78(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_98C38(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_98CF4(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_98D78(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_98DDC(__int64 a1, __int64 a2, int a3);
char *__fastcall i2s_ASN1_OCTET_STRING(__int64 a1, unsigned __int8 **a2);
void __fastcall sub_98EC8(__int64 a1, __int64 a2, const char *a3);
void __fastcall s2i_ASN1_OCTET_STRING(__int64 a1, __int64 a2, const char *a3);
_QWORD *__fastcall sub_9912C(__int64 a1, __int64 a2, unsigned __int64 *a3);
signed __int64 __fastcall sub_99204(__int64 a1, signed __int64 *a2, _QWORD *a3, unsigned int a4);
unsigned __int64 *__fastcall d2i_SXNETID(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_SXNETID();
__int64 SXNETID_new();
void __fastcall SXNETID_free(__int64 a1);
unsigned __int64 *__fastcall d2i_SXNET(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_SXNET();
__int64 SXNET_new();
void __fastcall SXNET_free(__int64 a1);
signed __int64 __fastcall sub_99354(__int64 *a1, __int64 a2, const char *a3, int a4);
signed __int64 __fastcall X509V3_add_value(const char *a1, char *a2, unsigned __int64 **a3);
__int64 __fastcall X509V3_add_value_uchar(_QWORD, _QWORD, _QWORD); // weak
void __fastcall X509V3_conf_free(__int64 a1);
signed __int64 __fastcall X509V3_add_value_bool(const char *a1, int a2, unsigned __int64 **a3);
signed __int64 __fastcall X509V3_add_value_bool_nf(const char *a1, int a2, unsigned __int64 **a3);
__int64 __fastcall i2s_ASN1_ENUMERATED(__int64 a1, unsigned __int8 **a2);
__int64 __fastcall i2s_ASN1_INTEGER(__int64 a1, unsigned __int8 **a2);
void __fastcall s2i_ASN1_INTEGER(__int64 a1, unsigned __int8 *a2);
signed __int64 __fastcall X509V3_add_value_int(const char *a1, unsigned __int8 **a2, unsigned __int64 **a3);
signed __int64 __fastcall X509V3_get_value_bool(__int64 a1, _DWORD *a2);
signed __int64 __fastcall X509V3_get_value_int(__int64 a1, _QWORD *a2);
unsigned __int64 *__fastcall X509V3_parse_list(const char *a1);
const char *__fastcall sub_99DEC(const char *a1);
char *__fastcall sub_99E68(unsigned __int8 *a1, signed __int64 a2);
_BYTE *__fastcall sub_99F20(const char *a1, _QWORD *a2);
__int64 __fastcall sub_9A0D4(const char *a1, const char *a2);
__int64 __fastcall X509_get1_email(__int64 a1);
__int64 __fastcall sub_9A18C(unsigned __int64 **a1, unsigned __int64 *a2);
void __fastcall X509_get1_ocsp(__int64 a1);
unsigned __int64 *__fastcall sub_9A35C(unsigned __int64 **a1, __int64 a2);
__int64 __fastcall X509_REQ_get1_email(__int64 *a1);
void __fastcall X509_email_free(unsigned __int64 *a1);
__int64 __fastcall j__free_1(); // weak
void __fastcall X509_check_host(__int64 a1, _BYTE *a2, size_t a3, int a4, _QWORD *a5);
void __fastcall sub_9A520(__int64 a1, _BYTE *a2, unsigned __int64 a3, int a4, int a5, _QWORD *a6);
void __fastcall X509_check_email(__int64 a1, _BYTE *a2, size_t a3, int a4);
void __fastcall X509_check_ip(__int64 a1, _BYTE *a2, unsigned __int64 a3, int a4);
void __fastcall X509_check_ip_asc(__int64 a1, const char *a2, int a3);
__int64 __fastcall a2i_ipadd(_BYTE *a1, const char *a2);
__int64 __fastcall a2i_IPADDRESS(const char *a1);
void __fastcall a2i_IPADDRESS_NC(const char *a1);
__int64 __fastcall X509V3_NAME_from_section(unsigned __int64 **a1, unsigned __int64 *a2, signed int a3);
__int64 __fastcall sub_9AD8C(const char **a1, const char **a2);
bool __fastcall sub_9AD98(unsigned __int8 *a1, size_t a2, unsigned __int8 *a3, __int64 a4);
__int64 __fastcall sub_9AEA0(); // weak
__int64 __fastcall sub_9AF84(); // weak
__int64 __fastcall sub_9B3F4(); // weak
__int64 __fastcall sub_9B4A0(); // weak
__int64 __fastcall sub_9B640(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
signed __int64 __fastcall sub_9C8B0(unsigned __int8 **a1, unsigned __int8 *a2, unsigned __int64 a3);
__int64 __fastcall sub_9C968(__int64 a1, _QWORD *a2, _QWORD *a3);
signed __int64 __fastcall sub_9CA58(__int64 a1, _BYTE *a2);
signed __int64 __fastcall sub_9CA88(__int64 a1, _QWORD *a2, _QWORD *a3);
signed __int64 __fastcall sub_9CAD8(int **a1, _QWORD *a2, __int64 a3);
signed __int64 __fastcall sub_9CCD0(int **a1, unsigned __int64 *a2, _BYTE *a3, signed int *a4, signed int *a5);
signed __int64 __fastcall sub_9D114(int **a1, _QWORD *a2, _DWORD *a3);
signed __int64 __fastcall sub_9D274(signed __int64 result, _QWORD *a2, __int64 a3);
signed __int64 __fastcall sub_9D418(signed __int64 result, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_9D644(__int64 *a1, _QWORD *a2, __int64 a3);
signed __int64 __fastcall sub_9D830(int **a1, _QWORD *a2, __int64 a3);
signed __int64 __fastcall sub_9DA44(int **a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_9DC6C(unsigned __int8 **a1, unsigned int *a2, int **a3);
signed __int64 __fastcall sub_9DD84(_QWORD *a1, _QWORD *a2);
__int64 ASN1_OCTET_STRING_set(void); // weak
__int64 __fastcall i2c_ASN1_BIT_STRING(int *a1, char **a2);
_DWORD *__fastcall c2i_ASN1_BIT_STRING(_DWORD **a1, _QWORD *a2, signed __int64 a3);
signed __int64 __fastcall ASN1_BIT_STRING_set_bit(signed int *a1, int a2, int a3);
__int64 __fastcall ASN1_BIT_STRING_get_bit(__int64 result, int a2);
bool __fastcall ASN1_BIT_STRING_check(signed int *a1, __int64 a2, int a3);
void __fastcall ASN1_d2i_fp(__int64 a1, void (__fastcall *a2)(__int64, __int64 *, _QWORD), __int64 a3, __int64 a4);
void __fastcall ASN1_d2i_bio(__int64 a1, void (__fastcall *a2)(__int64, __int64 *, _QWORD), _QWORD *a3, __int64 a4);
void __fastcall sub_9E48C(_QWORD *a1, _QWORD *a2);
void __fastcall ASN1_item_d2i_bio(unsigned __int8 *a1, _QWORD *a2, unsigned __int64 **a3);
void __fastcall ASN1_item_d2i_fp(unsigned __int8 *a1, __int64 a2, unsigned __int64 **a3);
void __fastcall ASN1_dup(__int64 (__fastcall *a1)(__int64, void **), void (__fastcall *a2)(_QWORD, void **, _QWORD), __int64 a3);
void __fastcall ASN1_item_dup(unsigned __int8 *a1, __int64 a2);
signed __int64 __fastcall ASN1_ENUMERATED_set(__int64 a1, __int64 a2);
signed __int64 __fastcall ASN1_ENUMERATED_get(signed __int64 result);
int *__fastcall BN_to_ASN1_ENUMERATED(__int64 a1, int *a2);
__int64 __fastcall ASN1_ENUMERATED_to_BN(unsigned __int8 **a1, __int64 a2);
__int64 __fastcall sub_9EE60(int *a1, signed int *a2);
__int64 __fastcall ASN1_GENERALIZEDTIME_check(signed int *a1);
__int64 __fastcall ASN1_GENERALIZEDTIME_set_string(__int64 a1, const char *a2);
void __fastcall ASN1_GENERALIZEDTIME_set(_DWORD *a1, __int64 a2);
void __fastcall ASN1_GENERALIZEDTIME_adj(_DWORD *a1, __int64 a2, int a3, __int64 a4);
__int64 __fastcall ASN1_i2d_fp(void (__fastcall *a1)(__int64, void **), __int64 a2, __int64 a3);
void __fastcall ASN1_i2d_bio(void (__fastcall *a1)(__int64, void **), _QWORD *a2, __int64 a3);
__int64 __fastcall ASN1_item_i2d_fp(__int64 a1, __int64 a2);
void ASN1_item_i2d_bio();
__int64 __fastcall ASN1_INTEGER_cmp(__int64 a1, __int64 a2);
__int64 __fastcall i2c_ASN1_INTEGER(__int64 a1, _BYTE **a2);
__int64 __fastcall c2i_ASN1_INTEGER(__int64 *a1, _BYTE **a2, __int64 a3);
void __fastcall d2i_ASN1_UINTEGER(__int64 *a1, char **a2, __int64 a3);
signed __int64 __fastcall ASN1_INTEGER_set(__int64 a1, __int64 a2);
signed __int64 __fastcall ASN1_INTEGER_get(signed __int64 result);
int *__fastcall BN_to_ASN1_INTEGER(__int64 a1, int *a2);
__int64 __fastcall ASN1_INTEGER_to_BN(unsigned __int8 **a1, __int64 a2);
__int64 __fastcall ASN1_OCTET_STRING_cmp(_QWORD, _QWORD); // weak
signed __int64 __fastcall ASN1_PRINTABLE_type(_BYTE *a1, signed int a2);
__int64 __fastcall ASN1_STRING_set_default_mask(__int64 result);
__int64 ASN1_STRING_get_default_mask();
signed __int64 __fastcall ASN1_STRING_set_default_mask_asc(const char *a1);
__int64 __fastcall ASN1_STRING_set_by_NID(__int64 *a1, const char *a2, signed int a3, int a4, int a5);
void *__fastcall ASN1_STRING_TABLE_get(int a1);
__int64 __fastcall sub_A04A0(_DWORD *a1, _DWORD *a2);
signed __int64 __fastcall ASN1_STRING_TABLE_add(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_A0648(_DWORD **a1, _DWORD **a2);
void ASN1_STRING_TABLE_cleanup();
void __fastcall sub_A0680(void *ptr);
unsigned __int64 *__fastcall d2i_ASN1_TIME(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ASN1_TIME();
__int64 ASN1_TIME_new();
void __fastcall ASN1_TIME_free(__int64 a1);
void __fastcall ASN1_TIME_set(_DWORD *a1, __int64 a2);
void __fastcall ASN1_TIME_adj(_DWORD *a1, __int64 a2, int a3, __int64 a4);
__int64 __fastcall ASN1_TIME_check(signed int *a1);
_DWORD *__fastcall ASN1_TIME_to_generalizedtime(signed int *a1, _DWORD **a2);
signed __int64 __fastcall ASN1_TIME_set_string(__int64 a1, const char *a2);
__int64 __fastcall ASN1_TIME_diff(_DWORD *a1, int *a2, signed int *a3, signed int *a4);
__int64 __fastcall ASN1_TYPE_get(unsigned int *a1);
void __fastcall __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> ASN1_TYPE_set(__int64 a1, int a2, __int64 a3);
signed __int64 __fastcall ASN1_TYPE_set1(__int64 a1, int a2, __int64 a3);
signed __int64 __fastcall ASN1_TYPE_cmp(int *a1, __int64 a2);
__int64 __fastcall sub_A0D10(int *a1, signed int *a2);
__int64 __fastcall ASN1_UTCTIME_check(signed int *a1);
__int64 __fastcall ASN1_UTCTIME_set_string(__int64 a1, const char *a2);
void __fastcall ASN1_UTCTIME_set(_DWORD *a1, __int64 a2);
void __fastcall ASN1_UTCTIME_adj(_DWORD *a1, __int64 a2, int a3, __int64 a4);
signed __int64 __fastcall ASN1_UTCTIME_cmp_time_t(signed int *a1, __int64 a2);
__int64 __fastcall i2a_ASN1_INTEGER(__int64 result, __int64 a2);
__int64 __fastcall ASN1_tag2bit(unsigned int a1);
unsigned __int64 *__fastcall ASN1_item_d2i(unsigned __int64 **a1, const void **a2, __int64 a3, unsigned __int8 *a4);
void __fastcall sub_A14A0(unsigned __int64 **a1, const void **a2, __int64 a3, unsigned __int8 *a4, signed int a5, int a6, char a7, __int64 a8);
void __fastcall sub_A1E88(unsigned __int64 **a1, _BYTE **a2, __int64 a3, __int64 a4, char a5, __int64 a6);
void __fastcall sub_A206C(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, signed int a5, int a6, char a7, __int64 a8);
signed __int64 __fastcall sub_A2510(_QWORD *a1, _DWORD *a2, _BYTE *a3, _BYTE *a4, _BYTE *a5, _QWORD *a6, __int64 a7, int a8, int a9, char a10, __int64 a11);
__int64 __fastcall sub_A2770(__int64 *a1, const char *a2, int a3, int a4, _BYTE *a5, __int64 a6);
void __fastcall sub_A2A74(unsigned __int64 **a1, _BYTE **a2, __int64 a3, unsigned int *a4, char a5, __int64 a6);
__int64 __fastcall sub_A2DAC(signed int *a1, signed __int64 *a2, signed __int64 a3, char a4, signed int a5);
void __fastcall ASN1_item_ndef_i2d(__int64 a1, _BYTE **a2, unsigned __int8 *a3);
void ASN1_item_i2d();
void __fastcall sub_A3124(unsigned __int64 **a1, _BYTE **a2, unsigned __int8 *a3, signed int a4, unsigned int a5);
void __fastcall sub_A3504(unsigned __int64 **a1, _BYTE **a2, unsigned int *a3, unsigned int a4, unsigned int a5);
signed __int64 __fastcall sub_A39E0(signed __int64 a1, void **a2, __int64 a3, signed int a4, char a5);
signed __int64 __fastcall sub_A3B3C(signed __int64 result, void *a2, int *a3, __int64 a4);
__int64 __fastcall sub_A3CFC(__int64 a1, __int64 a2);
void __fastcall ASN1_item_free(__int64 a1, unsigned __int8 *a2);
void __fastcall sub_A3D90(void **a1, unsigned __int8 *a2, int a3);
void __fastcall sub_A3FF8(void **a1, unsigned __int8 *a2);
void __fastcall sub_A4000(_QWORD **a1, _QWORD *a2);
void __fastcall sub_A40C8(void **a1, __int64 a2);
__int64 __fastcall ASN1_item_new(unsigned __int8 *a1);
__int64 __fastcall sub_A4218(__int64 *a1, unsigned __int8 *a2);
__int64 __fastcall sub_A4220(__int64 *a1, unsigned __int8 *a2, int a3);
__int64 __fastcall sub_A44B0(_QWORD *a1, __int64 *a2);
_QWORD *__fastcall sub_A4544(_QWORD *result, __int64 a2);
__int64 __fastcall sub_A45E4(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A46E0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_A46F0(__int64 *a1, int a2, __int64 a3);
_QWORD *__fastcall sub_A4704(_QWORD *result, unsigned __int8 *a2);
__int64 __fastcall sub_A4744(_QWORD *a1, unsigned __int8 *a2);
long double __fastcall sub_A4784(_QWORD *a1, __int64 a2);
void __fastcall sub_A47CC(_QWORD *a1, __int64 a2);
void *__fastcall sub_A483C(_QWORD *a1, const void *a2, int a3, __int64 a4);
signed __int64 __fastcall sub_A48F0(_DWORD *a1, void **a2, _QWORD *a3, __int64 a4);
_QWORD *__fastcall sub_A4998(_QWORD *result, __int64 a2);
_QWORD *__fastcall sub_A49B0(_QWORD *a1, _QWORD *a2, int a3);
__int64 __fastcall j__gmtime_r(_QWORD, _QWORD); // weak
signed __int64 __fastcall sub_A4A7C(int *a1, int a2, __int64 a3);
signed __int64 __fastcall sub_A4D64(_DWORD *a1, int *a2, _DWORD *a3, _DWORD *a4);
_QWORD *__fastcall BIO_new_file(const char *a1, const char *a2);
void *BIO_s_file();
__int64 __fastcall BIO_set_fp(_QWORD *a1, __int64 a2, int a3);
_QWORD *__fastcall BIO_new_fp(__int64 a1, int a2);
__int64 __fastcall BIO_get_fp(_QWORD *a1, __int64 a2);
__int64 __fastcall BIO_read_filename(_QWORD *a1, __int64 a2);
__int64 __fastcall BIO_write_filename(_QWORD *a1, __int64 a2);
__int64 __fastcall BIO_append_filename(_QWORD *a1, __int64 a2);
__int64 __fastcall BIO_rw_filename(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_A5218(__int64 a1, const void *a2, int a3);
__int64 __fastcall sub_A5264(__int64 a1, void *a2, int a3);
char *__fastcall sub_A52FC(__int64 a1, char *a2, int a3);
signed __int64 __fastcall sub_A534C(__int64 a1, int a2, __int64 a3, FILE **a4);
signed __int64 __fastcall sub_A55CC(__int64 a1);
void BIO_printf(_QWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, ...);
__int64 __fastcall BN_kronecker(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall NCONF_new(__int64 a1);
__int64 __fastcall sub_A5A88(_BYTE **a1);
__int64 __fastcall sub_A5AC0(const char **a1, const char **a2);
_QWORD *sub_A5B28();
void __fastcall NCONF_free(__int64 *a1);
void __fastcall sub_A5BC0(void **a1);
__int64 __fastcall sub_A5C14(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A5C6C(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_A5CC4(const char *a1, unsigned __int8 a2, int a3, __int64 (__fastcall *a4)(const char *, __int64, __int64), __int64 a5);
char *DH_new();
void __fastcall DH_free(__int64 a1);
__int64 __fastcall DH_get0_key(__int64 result, _QWORD *a2, _QWORD *a3);
_QWORD *__fastcall DH_get0_pqg(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall DH_generate_parameters_ex(__int64 a1, signed int a2, int a3, __int64 a4);
__int64 __fastcall DH_generate_key(__int64 *a1);
void __fastcall DH_compute_key(_BYTE *a1, __int64 a2, __int64 *a3);
__int64 __fastcall DH_size(__int64 *a1);
__int64 __fastcall DH_num_bits(__int64 *a1);
signed __int64 __fastcall DH_up_ref(__int64 a1);
__int64 __fastcall DHparams_dup(__int64 a1);
signed __int64 __fastcall DH_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall EVP_parse_public_key(unsigned __int8 **a1);
signed __int64 __fastcall sub_A679C(unsigned __int8 **a1, int *a2);
__int64 __fastcall EVP_marshal_public_key(__int64 a1, __int64 a2);
void __fastcall EVP_parse_private_key(unsigned __int8 **a1);
__int64 __fastcall EVP_marshal_private_key(__int64 a1, __int64 a2);
void __fastcall d2i_PrivateKey(int a1, int **a2, __int64 *a3, __int64 a4);
void __fastcall d2i_AutoPrivateKey(int **a1, __int64 *a2, __int64 a3);
__int64 __fastcall i2d_PublicKey(__int64 a1, void **a2);
_QWORD *__fastcall lh_new(__int64 a1, __int64 a2);
void __fastcall lh_free(_QWORD *a1);
__int64 __fastcall lh_retrieve(__int64 a1, __int64 a2);
_DWORD *__fastcall lh_insert(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall lh_delete(__int64 a1, __int64 a2);
void __fastcall lh_doall(__int64 a1, void (__fastcall *a2)(__int64, _QWORD, __int64, __int64));
void lh_doall_arg();
_BYTE *__fastcall lh_strhash(_BYTE *result);
void __fastcall sub_A7380(__int64 a1, unsigned __int64 a2);
unsigned __int64 *__fastcall d2i_PKCS8_PRIV_KEY_INFO(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_PKCS8_PRIV_KEY_INFO();
__int64 PKCS8_PRIV_KEY_INFO_new();
void __fastcall PKCS8_PRIV_KEY_INFO_free(__int64 a1);
void EVP_PKCS82PKEY();
void __fastcall EVP_PKEY2PKCS8(__int64 a1);
void __fastcall PKCS8_decrypt(__int64 a1, const char *a2, int a3);
void __fastcall PKCS8_encrypt(int a1, __int64 a2, const char *a3, int a4, const void *a5, size_t a6, unsigned int a7);
signed __int64 __fastcall PKCS12_get_key_and_certs(int **a1, signed __int64 *a2, __int64 a3, const char *a4);
void __fastcall sub_A7D58(__int64 a1, __int64 a2, unsigned int (__fastcall *a3)(char *, __int64));
void __fastcall sub_A7EC0(unsigned __int8 **a1, __int64 a2);
void **__fastcall d2i_PKCS12(void ***a1, const void **a2, size_t a3);
void __fastcall PKCS12_free(void **a1);
void __fastcall d2i_PKCS12_bio(_QWORD *a1, void ***a2);
__int64 __fastcall d2i_PKCS12_fp(__int64 a1, void ***a2);
signed __int64 __fastcall PKCS12_parse(__int64 *a1, const char *a2, int **a3, __int64 *a4, signed __int64 **a5);
signed __int64 __fastcall PKCS12_verify_mac(__int64 *a1, const char *a2, int a3);
signed __int64 __fastcall sub_A8560(int a1, __int64 a2);
__int64 __fastcall sub_A85A8(); // weak
char *CRYPTO_BUFFER_POOL_new();
signed __int64 __fastcall sub_A88A4(__int64 a1);
__int64 __fastcall sub_A88B0(__int64 a1, __int64 a2);
void __fastcall CRYPTO_BUFFER_POOL_free(char *a1);
void __fastcall CRYPTO_BUFFER_new(__int64 a1, __int64 a2, __int64 a3);
void __fastcall CRYPTO_BUFFER_new_from_CBS(__int64 a1, __int64 a2);
void __fastcall CRYPTO_BUFFER_free(int *a1);
_QWORD *__fastcall CRYPTO_BUFFER_init_CBS(__int64 a1, _QWORD *a2);
void __fastcall ASN1_digest(void (__fastcall *a1)(__int64, void **), __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
void ASN1_item_digest();
__int64 __fastcall ASN1_item_sign(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall ASN1_item_sign_ctx(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6);
void __fastcall X509_NAME_print_ex(_QWORD *a1, unsigned __int64 **a2, signed int a3, __int64 a4);
bool __fastcall sub_A93D0(_QWORD *a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall X509_NAME_print_ex_fp(__int64 a1, unsigned __int64 **a2, __int64 a3, __int64 a4);
bool __fastcall sub_A94A0(FILE *a1, const void *a2, int a3);
void __fastcall ASN1_STRING_print_ex(__int64 a1, signed int *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall sub_A950C(unsigned int (__fastcall *a1)(__int64, const char *, signed __int64), __int64 a2, __int16 a3, signed int *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall ASN1_STRING_print_ex_fp(__int64 a1, signed int *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall ASN1_STRING_to_UTF8(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_A9910(unsigned __int8 *a1, signed int a2, char a3, int a4, _BYTE *a5, __int64 a6, __int64 a7, __int64 a8);
signed __int64 __fastcall sub_A9B2C(unsigned __int64 a1, char a2, _BYTE *a3, unsigned int (__fastcall *a4)(__int64, const char *, signed __int64), __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall ASN1_item_verify(__int64 a1, unsigned int **a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall sub_A9EA4(_QWORD *a1, __int64 a2);
void __fastcall sub_A9FF0(__int64 a1, unsigned int **a2, __int64 a3);
signed __int64 __fastcall i2d_PrivateKey(__int64 a1, void **a2);
unsigned __int64 *__fastcall d2i_RSA_PSS_PARAMS(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_RSA_PSS_PARAMS();
__int64 RSA_PSS_PARAMS_new();
void __fastcall RSA_PSS_PARAMS_free(__int64 a1);
void __fastcall sub_AA200(__int64 a1, __int64 a2);
void __fastcall sub_AA47C(__int64 a1, unsigned __int64 *a2);
unsigned __int64 *__fastcall sub_AA6C0(unsigned __int64 *result, unsigned __int64 **a2);
void __fastcall sub_AA7B8(_QWORD *a1, unsigned __int64 *a2, int a3);
__int64 __fastcall X509_print_ex_fp(__int64 a1, signed __int64 **a2, __int64 a3, unsigned int a4);
void __fastcall X509_print_ex(_QWORD *a1, signed __int64 **a2, __int64 a3, unsigned int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall X509_print_fp(__int64 a1, signed __int64 **a2);
void __fastcall X509_print(_QWORD *a1, signed __int64 **a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void __fastcall X509_signature_print(_QWORD *a1, __int64 *a2, unsigned int *a3);
bool __fastcall ASN1_TIME_print(_QWORD *a1, signed int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void __fastcall X509_ocspid_print(_QWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
signed __int64 __fastcall ASN1_STRING_print(_QWORD *a1, __int64 a2);
bool __fastcall ASN1_UTCTIME_print(_QWORD *a1, int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
bool __fastcall ASN1_GENERALIZEDTIME_print(_QWORD *a1, signed int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall X509_NAME_print(_QWORD *a1, unsigned __int64 **a2);
void __fastcall X509_CERT_AUX_print(_QWORD *a1, unsigned __int64 **a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
signed __int64 __fastcall PKCS8_pkey_set0(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, int a7);
signed __int64 __fastcall PKCS8_pkey_get0(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5);
bool __fastcall X509_signature_dump(_QWORD *a1, unsigned int *a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 *__fastcall X509_to_X509_REQ(__int64 a1, __int64 a2, __int64 a3);
void __fastcall X509_REQ_get_pubkey(__int64 a1);
__int64 __fastcall X509_REQ_check_private_key(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_REQ_extension_nid(int a1);
__int64 X509_REQ_get_extension_nids();
__int64 __fastcall X509_REQ_set_extension_nids(__int64 result);
unsigned __int64 *__fastcall X509_REQ_get_extensions(_QWORD *a1);
signed __int64 __fastcall X509_REQ_add_extensions_nid(__int64 *a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall X509_REQ_add_extensions(__int64 *a1, __int64 a2);
_QWORD *__fastcall X509_REQ_get_attr_count(__int64 a1);
bool __fastcall X509_REQ_add1_attr(__int64 a1, __int64 a2);
bool __fastcall X509_REQ_add1_attr_by_OBJ(__int64 a1, __int64 a2, int a3, const char *a4, signed int a5);
bool __fastcall X509_REQ_add1_attr_by_NID(__int64 a1, unsigned int a2, int a3, const char *a4, signed int a5);
bool __fastcall X509_REQ_add1_attr_by_txt(__int64 a1, const char *a2, int a3, const char *a4, signed int a5);
__int64 (__fastcall *__fastcall X509_TRUST_set_default(__int64 (__fastcall *a1)()))();
__int64 __fastcall X509_check_trust(__int64 a1, int a2, unsigned int a3);
signed __int64 __fastcall sub_AC634(int a1, __int64 a2);
__int64 __fastcall sub_AC6FC(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_TRUST_get_by_id(int a1);
unsigned __int64 *__fastcall X509_TRUST_get0(signed int a1);
signed __int64 X509_TRUST_get_count();
signed __int64 __fastcall X509_TRUST_set(int *a1, int a2);
signed __int64 __fastcall X509_TRUST_add(int a1, int a2, unsigned __int64 a3, const char *a4, int a5, unsigned __int64 a6);
__int64 __fastcall sub_ACB30(_DWORD **a1, _DWORD **a2);
void __fastcall sub_ACB48(__int64 a1);
void X509_TRUST_cleanup();
signed __int64 __fastcall sub_ACBFC(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_ACC64(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_REQ_set_version(signed __int64 result, __int64 a2);
bool __fastcall X509_REQ_set_subject_name(__int64 a1, __int64 a2);
signed __int64 __fastcall X509_REQ_set_pubkey(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall d2i_X509_ALGOR(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_ALGOR();
__int64 X509_ALGOR_new();
void __fastcall X509_ALGOR_free(__int64 a1);
unsigned __int64 *__fastcall d2i_X509_ALGORS(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_ALGORS();
void __fastcall X509_ALGOR_dup(__int64 a1);
__int64 __fastcall X509_ALGOR_set0(__int64 a1, __int64 a2, int a3, __int64 a4);
_QWORD *__fastcall X509_ALGOR_get0(_QWORD *result, _DWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall X509_ALGOR_set_md(__int64 a1, __int64 a2);
__int64 __fastcall X509_ALGOR_cmp(__int64 *a1, __int64 *a2);
unsigned __int64 *__fastcall d2i_X509_VAL(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_X509_VAL();
__int64 X509_VAL_new();
void __fastcall X509_VAL_free(__int64 a1);
__int64 __fastcall X509_policy_tree_level_count(__int64 result);
signed __int64 __fastcall X509_policy_tree_get0_level(__int64 a1, int a2);
__int64 __fastcall X509_policy_tree_get0_policies(__int64 result);
__int64 __fastcall X509_policy_tree_get0_user_policies(__int64 result);
__int64 __fastcall X509_policy_level_node_count(__int64 result);
unsigned __int64 *__fastcall X509_policy_level_get0_node(__int64 a1, int a2);
__int64 __fastcall X509_policy_node_get0_policy(__int64 result);
__int64 __fastcall X509_policy_node_get0_qualifiers(__int64 result);
_QWORD *sub_ACFE4();
__int64 __fastcall sub_ACFF0(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall sub_AD00C(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall sub_AD084(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall sub_AD114(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 j__free(void); // weak
_QWORD *__fastcall sub_AD200(__int64 a1, __int64 *a2, __int64 a3);
__int64 __fastcall sub_AD29C(__int64 a1, signed int **a2, __int64 a3);
__int64 __fastcall sub_AD36C(__int64 a1, __int64 a2, unsigned __int64 *a3);
__int64 __fastcall i2v_GENERAL_NAMES(__int64 a1, unsigned __int64 *a2, __int64 a3);
unsigned __int64 *__fastcall sub_AD708(__int64 a1, __int64 a2, unsigned __int64 *a3);
unsigned __int64 *__fastcall sub_AD880(__int64 a1, __int64 a2, unsigned __int64 *a3);
__int64 __fastcall i2v_GENERAL_NAME(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
signed __int64 __fastcall GENERAL_NAME_print(_QWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
unsigned __int64 *__fastcall v2i_GENERAL_NAMES(__int64 a1, __int64 a2, unsigned __int64 *a3);
__int64 __fastcall v2i_GENERAL_NAME(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall v2i_GENERAL_NAME_ex(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall a2i_GENERAL_NAME(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5, int a6);
signed __int64 __fastcall sub_AE464(__int64 a1, unsigned __int64 *a2, int a3);
__int64 __fastcall sub_AE5E0(__int64 a1, int *a2, __int64 a3);
__int64 __fastcall sub_AE654(__int64 a1, __int64 a2, unsigned __int64 *a3);
unsigned __int64 *__fastcall d2i_BASIC_CONSTRAINTS(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_BASIC_CONSTRAINTS();
__int64 BASIC_CONSTRAINTS_new();
void __fastcall BASIC_CONSTRAINTS_free(__int64 a1);
__int64 __fastcall i2v_ASN1_BIT_STRING(__int64 result, __int64 a2, __int64 a3);
signed int *__fastcall v2i_ASN1_BIT_STRING(__int64 a1, __int64 a2, unsigned __int64 *a3);
void __fastcall X509V3_EXT_nconf(__int64 *a1, __int64 a2, const char *a3, const char *a4);
__int64 __fastcall sub_AEB28(const char **a1);
void __fastcall sub_AEBD8(const char *a1, const char *a2, int a3, int a4, __int64 a5);
__int64 __fastcall sub_AEDA0(__int64 *a1, __int64 a2, int a3, int a4, const char *a5);
void __fastcall X509V3_EXT_nconf_nid(__int64 *a1, __int64 a2, unsigned int a3, const char *a4);
void __fastcall X509V3_EXT_i2d(int a1, int a2, __int64 a3);
void __fastcall sub_AF14C(__int64 a1, unsigned int a2, int a3, __int64 a4);
signed __int64 __fastcall X509V3_EXT_add_nconf_sk(__int64 *a1, __int64 a2, __int64 a3, void ***a4);
signed __int64 __fastcall X509V3_EXT_add_nconf(__int64 *a1, __int64 a2, __int64 a3, void ***a4);
signed __int64 __fastcall X509V3_EXT_CRL_add_nconf(__int64 *a1, __int64 a2, __int64 a3, void ***a4);
void __fastcall X509V3_EXT_REQ_add_nconf(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall X509V3_get_string(__int64 a1);
__int64 __fastcall X509V3_get_section(__int64 a1);
__int64 __fastcall X509V3_string_free(__int64 result, __int64 a2);
__int64 __fastcall X509V3_section_free(__int64 result, __int64 a2);
__int64 __fastcall X509V3_set_nconf(__int64 result, __int64 a2);
__int64 __fastcall X509V3_set_ctx(__int64 result, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6);
_BYTE *__fastcall i2s_ASN1_ENUMERATED_TABLE(__int64 a1, signed __int64 a2);
_QWORD *__fastcall sub_AF548(__int64 a1, unsigned __int64 *a2, __int64 a3);
unsigned __int64 *__fastcall sub_AF5F0(__int64 a1, __int64 a2, unsigned __int64 *a3);
unsigned __int64 *__fastcall d2i_EXTENDED_KEY_USAGE(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_EXTENDED_KEY_USAGE();
__int64 EXTENDED_KEY_USAGE_new();
void __fastcall EXTENDED_KEY_USAGE_free(__int64 a1);
_BYTE *__fastcall sub_AF72C(__int64 a1, const void **a2);
_DWORD *__fastcall sub_AF7B0(__int64 a1, __int64 a2, const char *a3);
void __fastcall sub_AF840(__int64 a1, unsigned __int64 *a2, __int64 a3);
void __fastcall sub_AF9D4(__int64 a1, __int64 a2, unsigned __int64 *a3);
unsigned __int64 *__fastcall d2i_ACCESS_DESCRIPTION(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_ACCESS_DESCRIPTION();
__int64 ACCESS_DESCRIPTION_new();
void __fastcall ACCESS_DESCRIPTION_free(__int64 a1);
unsigned __int64 *__fastcall d2i_AUTHORITY_INFO_ACCESS(unsigned __int64 **a1, const void **a2, __int64 a3);
void i2d_AUTHORITY_INFO_ACCESS();
__int64 AUTHORITY_INFO_ACCESS_new();
void __fastcall AUTHORITY_INFO_ACCESS_free(__int64 a1);
signed __int64 __fastcall i2a_ACCESS_DESCRIPTION(_QWORD *a1, __int64 *a2);
void __fastcall sub_AFC84(__int64 a1, __int64 a2, unsigned __int8 *a3);
_QWORD *__fastcall X509V3_EXT_val_prn(_QWORD *result, unsigned __int64 *a2, unsigned int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
void __fastcall X509V3_EXT_print(_QWORD *a1, unsigned int **a2, unsigned int a3, unsigned int a4);
signed __int64 __fastcall X509V3_extensions_print(_QWORD *a1, __int64 a2, unsigned __int64 *a3, unsigned int a4, unsigned int a5);
__int64 __fastcall X509V3_EXT_print_fp(__int64 a1, unsigned int **a2, unsigned int a3, unsigned int a4);
void __fastcall ASN1_mbstring_copy(__int64 *a1, const char *a2, signed int a3, int a4, __int64 a5);
void __fastcall ASN1_mbstring_ncopy(__int64 *a1, const char *a2, signed int a3, int a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_B0768(char *a1, signed int a2, int a3, __int64 (__fastcall *a4)(unsigned __int64, __int64), __int64 a5);
signed __int64 __fastcall sub_B08C0(unsigned __int64 a1, unsigned __int64 *a2);
signed __int64 __fastcall sub_B099C(char a1, _BYTE **a2);
signed __int64 __fastcall sub_B09B8(__int16 a1, _BYTE **a2);
signed __int64 __fastcall sub_B09DC(int a1, _BYTE **a2);
__int64 __fastcall sub_B0A10(); // weak
signed __int64 __fastcall UTF8_getc(char *a1, signed int a2, unsigned __int64 *a3);
signed __int64 __fastcall UTF8_putc(_BYTE *a1, signed int a2, unsigned __int64 a3);
const char *__fastcall ASN1_tag2str(unsigned int a1);
_QWORD *__fastcall ASN1_item_pack(__int64 a1, __int64 a2, _QWORD *a3);
void __fastcall ASN1_item_unpack(signed int *a1, unsigned __int8 *a2);
bool __fastcall BIO_hexdump(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4);
__int64 __fastcall CBS_asn1_ber_to_der(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_B14B0(__int64 a1, _BYTE *a2, unsigned int a3);
__int64 __fastcall sub_B1608(__int64 result, __int64 *a2, unsigned int a3, unsigned __int8 a4, unsigned int a5);
signed __int64 __fastcall CBS_get_asn1_implicit_string(unsigned __int8 **a1, char *a2, _QWORD *a3, int a4, int a5);
__int64 __fastcall DH_check_pub_key(__int64 *a1, __int64 a2, _DWORD *a3);
__int64 __fastcall DH_check(__int64 *a1, int *a2);
signed __int64 __fastcall EVP_DigestSignInit(__int64 a1, _QWORD *a2, __int64 a3, int *a4, __int64 a5);
void EVP_DigestVerifyInit();
__int64 __fastcall EVP_DigestVerifyUpdate(_QWORD); // weak
signed __int64 __fastcall EVP_DigestSignFinal(__int64 *a1, __int64 a2);
signed __int64 __fastcall EVP_DigestVerifyFinal(__int64 a1);
signed __int64 __fastcall EVP_PKEY_print_public(_QWORD *a1, __int64 a2, int a3);
signed __int64 __fastcall EVP_PKEY_print_private(_QWORD *a1, __int64 a2, int a3);
signed __int64 __fastcall EVP_PKEY_print_params(_QWORD *a1, __int64 a2, int a3);
signed __int64 __fastcall sub_B26D4(_QWORD *a1, __int64 a2, __int64 **a3, _BYTE *a4, int a5);
signed __int64 __fastcall OBJ_find_sigid_algs(signed int a1, _DWORD *a2, _DWORD *a3);
signed __int64 __fastcall OBJ_find_sigid_by_algs(_DWORD *a1, int a2, int a3);
void __fastcall sub_B2FE8(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, unsigned int a6, unsigned __int64 a7, char *a8, __int64 a9);
signed __int64 __fastcall sub_B35E0(_QWORD *a1, _QWORD *a2, unsigned __int8 **a3, __int64 a4, __int64 a5, char *a6, size_t a7);
void __fastcall PKCS8_parse_encrypted_private_key(unsigned __int8 **a1, __int64 a2, __int64 a3);
signed __int64 __fastcall PKCS8_marshal_encrypted_private_key(__int64 *a1, int a2, __int64 a3, __int64 a4, unsigned __int64 a5, const void *a6, size_t a7, unsigned int a8, __int64 a9);
void __fastcall sub_B3CC4(__int64 a1, unsigned int **a2, __int64 a3, unsigned __int64 a4, unsigned __int8 **a5);
void __fastcall sub_B3E04(__int64 a1, unsigned int **a2, unsigned int a3, __int64 a4, unsigned __int64 a5, __int64 a6, unsigned __int64 a7, int a8);
void __fastcall ASN1_generate_nconf(const char *a1, __int64 *a2);
void __fastcall ASN1_generate_v3(const char *a1, __int64 a2);
signed __int64 __fastcall sub_B47E4(const char *a1, signed int a2, int *a3);
signed __int64 __fastcall sub_B4CD4(const char *a1, int a2, _DWORD *a3, signed int *a4);
void __fastcall sub_B4E38(const char *a1, int a2, signed int *a3);
void __fastcall sub_B4F1C(__int64 *a1, unsigned int **a2, unsigned int *a3, unsigned int a4, __int64 a5, unsigned __int64 a6, const void *a7, size_t a8);
void __fastcall sub_B5224(unsigned int **a1, __int64 a2, unsigned int a3, __int64 a4, unsigned __int64 a5, __int64 a6, __int64 a7, const void *a8, __int64 a9, int a10);
void __fastcall sub_B534C(__int64 a1, unsigned int **a2, __int64 a3, unsigned __int64 a4, unsigned __int8 **a5);
bool __fastcall PKCS5_PBKDF2_HMAC(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, unsigned __int64 a7, int8x16_t *a8);
bool __fastcall PKCS5_PBKDF2_HMAC_SHA1(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned __int64 a6, int8x16_t *a7);
unsigned __int64 __fastcall _udivti3(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
unsigned __int64 __fastcall _umodti3(unsigned __int64 result, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
// __int64 _libc_init(void); weak
// __int64 _register_atfork(void); weak
// __int64 _cxa_atexit(void); weak
// __int64 _strchr_chk(void); weak
// __int64 Suntory_FreeBlobStatusList(void); weak
// __int64 Suntory_GetAllBlobStatus(void); weak
// __int64 _strrchr_chk(void); weak
// void *malloc(size_t size);
// void *memcpy(void *dest, const void *src, size_t n);
// void *memset(void *s, int c, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// __int64 std::__1::locale::use_facet(void); weak
// _QWORD std::__1::ios_base::getloc(std::__1::ios_base *__hidden this); idb
// _QWORD std::__1::locale::locale(std::__1::locale *__hidden this); idb
// _QWORD __cdecl std::__1::locale::~locale(std::__1::locale *__hidden this); idb
// _QWORD __cdecl std::__1::ios_base::init(std::__1::ios_base *__hidden this, void *); idb
// _QWORD __cdecl std::__1::ios_base::clear(std::__1::ios_base *__hidden this, unsigned int); idb
// _QWORD __cdecl std::__1::ios_base::~ios_base(std::__1::ios_base *__hidden this); idb
// _QWORD std::uncaught_exception(void); idb
// void __cdecl operator delete(void *); idb
// _QWORD __cdecl operator new(unsigned __int64); idb
// __int64 _memcpy_chk(void); weak
// void __noreturn abort(void);
// int closedir(DIR *dirp);
// void free(void *ptr);
// __int64 libasb_get_startup_reason(void); weak
// void *memmove(void *dest, const void *src, size_t n);
// DIR *opendir(const char *name);
// __int64 property_get(void); weak
// struct dirent *readdir(DIR *dirp);
// int strcmp(const char *s1, const char *s2);
// size_t strlen(const char *s);
// __int64 _errno(void); weak
// char *strerror(int errnum);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// __int64 idd_add_event(void); weak
// __int64 idd_create(void); weak
// __int64 idd_destroy(void); weak
// __int64 _FD_ISSET_chk(void); weak
// __int64 _FD_SET_chk(void); weak
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// __sighandler_t signal(int sig, __sighandler_t handler);
// size_t strnlen(const char *string, size_t maxlen);
// __int64 _android_log_buf_print(void); weak
// __int64 _vsnprintf_chk(void); weak
// void *realloc(void *ptr, size_t size);
// __int64 miscta_get_unit_size(void); weak
// __int64 miscta_read_unit(void); weak
// __int64 miscta_write_unit_critical(void); weak
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// __int64 android_get_control_socket(void); weak
// int close(int fd);
// int listen(int fd, int n);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// __int64 QSEECom_send_cmd(void); weak
// __int64 QSEECom_set_bandwidth(void); weak
// __int64 QSEECom_shutdown_app(void); weak
// __int64 QSEECom_start_app(void); weak
// __int64 _strncpy_chk2(void); weak
// __int64 _memset_chk(void); weak
// __int64 Suntory_ConvertAllBlobs(void); weak
// __int64 property_set(void); weak
// unsigned int sleep(unsigned int seconds);
// __int64 SuntoryTee_GetCert(void); weak
// __int64 SuntoryTee_GetKey(void); weak
// __int64 SuntoryTee_LoadBlob(void); weak
// char *strncpy(char *dest, const char *src, size_t n);
// __int64 SuntoryTee_Sign(void); weak
// __int64 SuntoryTee_Verify(void); weak
// __int64 Suntory_GetBlobType(void); weak
// __int64 _strcat_chk(void); weak
// __int64 SuntoryTee_GetAllCredentialData(void); weak
// __int64 SuntoryTee_GetCredential(void); weak
// __int64 _android_log_write(void); weak
// int chmod(const char *file, __mode_t mode);
// int remove(const char *filename);
// __int64 sqlite3_bind_blob(void); weak
// __int64 sqlite3_close(void); weak
// __int64 sqlite3_column_blob(void); weak
// __int64 sqlite3_column_bytes(void); weak
// __int64 sqlite3_errmsg(void); weak
// __int64 sqlite3_exec(void); weak
// __int64 sqlite3_finalize(void); weak
// __int64 sqlite3_open_v2(void); weak
// __int64 sqlite3_prepare_v2(void); weak
// __int64 sqlite3_step(void); weak
// int fclose(FILE *stream);
// FILE *fopen(const char *filename, const char *modes);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int fseek(FILE *stream, __int64 off, int whence);
// __int64 ftell(FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __int64 protobuf_c_message_get_packed_size(void); weak
// __int64 protobuf_c_message_pack(void); weak
// __int64 _snprintf_chk(void); weak
// int atoi(const char *nptr);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned __int64 strtoul(const char *nptr, char **endptr, int base);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// char *fgets(char *s, int n, FILE *stream);
// int ferror(FILE *stream);
// int fflush(FILE *stream);
// int feof(FILE *stream);
// __int64 _strlen_chk(void); weak
// void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int fputs(const char *s, FILE *stream);
// char *strchr(const char *s, int c);
// int sscanf(const char *s, const char *format, ...);
// int strcasecmp(const char *s1, const char *s2);
// int isupper(int);
// char *strdup(const char *s);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// __int64 _open_2(void); weak
// int dup(int fd);
// int fcntl(int fd, int cmd, ...);
// ssize_t read(int fd, void *buf, size_t nbytes);
// __int64 syscall(__int64 sysno, ...);
// void *pthread_getspecific(pthread_key_t key);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// void *memchr(const void *s, int c, size_t n);
// unsigned __int64 getauxval(unsigned __int64 type);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int isxdigit(int);
// time_t time(time_t *timer);
// int isspace(int);
// int tolower(int c);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_8[] = { '\0' }; // weak
Elf64_Sym stru_288 = { 0u, 0u, 0u, 0u, 0uLL, 0uLL }; // weak
_UNKNOWN loc_4FBA0; // weak
_UNKNOWN loc_4FDC0; // weak
__int64 qword_4FE40[12] =
{
  5539278286070280259LL,
  5836674339646238722LL,
  5631830508743653441LL,
  5539278284273510466LL,
  5631830646788720739LL,
  5539278288568477762LL,
  5631830508880002860LL,
  5494523762976516162LL,
  7935373614531495970LL,
  -2999674702361759710LL,
  -3097596797610942433LL,
  -3097596797610942433LL
}; // weak
__int64 qword_4FEA0[12] =
{
  5539278286070280259LL,
  5836674339646238722LL,
  5631848100929697857LL,
  5539278284273514562LL,
  5631848238974765155LL,
  5539278288568481858LL,
  5631848101066047276LL,
  5494523762976520258LL,
  7935373614531500066LL,
  -2999674702361759710LL,
  -3097596797610942433LL,
  -3097596797610942433LL
}; // weak
__int64 qword_4FF00[128] =
{
  -7998388550200493059LL,
  -3278618291299401662LL,
  -7311589698659410301LL,
  -5097810459705212737LL,
  5494515268677594178LL,
  5494576745670012928LL,
  -8429313091627378523LL,
  5539331825383508133LL,
  5539331842494146804LL,
  -7998251757060720409LL,
  6052850406835684326LL,
  7937062181508483263LL,
  6052845460176444933LL,
  -7998322125804885790LL,
  -7998040628199882650LL,
  5631865684547357184LL,
  -7997899929366200210LL,
  -3097596800849149947LL,
  5631865684547357184LL,
  5631832836611731494LL,
  5631830775053182976LL,
  5494524381451806720LL,
  5631830913076695231LL,
  5494525210380494848LL,
  5631832699296547072LL,
  5494525480963434496LL,
  5631865684547357216LL,
  -3097596799905400719LL,
  5631865684547357184LL,
  5631832839369539650LL,
  -7311589698757433344LL,
  5631865684547357248LL,
  5631865684547357280LL,
  5631833248931278864LL,
  7936782973689948160LL,
  5631865684547357344LL,
  5631833523800275185LL,
  5631833661271205888LL,
  6124889868664773638LL,
  1441152603598581798LL,
  5631832699166566626LL,
  1441151899249698816LL,
  5631865684547357184LL,
  5631832836611731494LL,
  -1080793257045628928LL,
  5631865684547356736LL,
  5631830913773470696LL,
  5631832974076438528LL,
  5631833111515392000LL,
  5532795357557712896LL,
  5631865684547357312LL,
  5631865684547357344LL,
  5631865684547357376LL,
  5631833661807861264LL,
  6124892067688029190LL,
  1441152466159628326LL,
  -1080722888323010542LL,
  5665559130727778470LL,
  5670628223963110401LL,
  5670628146743872067LL,
  5665559127437307922LL,
  5670628223963175971LL,
  5631883276733405696LL,
  5631883418467326465LL,
  5631885827943979538LL,
  8142517774072117488LL,
  5631883276733405728LL,
  5631883418467326497LL,
  5631885827943979570LL,
  6124893484468893937LL,
  5631883276733405696LL,
  5631883418467326465LL,
  5631885827943979538LL,
  -1080652519020487484LL,
  -7312103865935520699LL,
  5631883276733405728LL,
  5631883418467326497LL,
  5631885827943979570LL,
  -8429049650729247631LL,
  -6196104370338980250LL,
  5631883276733405824LL,
  5631883418467326593LL,
  5631885827943979666LL,
  5631850978557784066LL,
  5631850982874314752LL,
  5631851055888758817LL,
  5539269226187487826LL,
  5631883276733405888LL,
  5631883418467326657LL,
  5631885827943979730LL,
  5631851253435691027LL,
  5631851330766658273LL,
  1224988608992082160LL,
  7935655515246304388LL,
  5539279045020163666LL,
  5666122343674507300LL,
  5666403960385138725LL,
  5670909832050208818LL,
  -5692338413315819774LL,
  -3097596799775406560LL,
  5631883418467326465LL,
  5631885827943979538LL,
  8142517774072117488LL,
  5631883418467326497LL,
  5631885827943979570LL,
  6124894034224707825LL,
  5631883418467326465LL,
  5631885827943979538LL,
  5631883418467326497LL,
  5631885827943979570LL,
  5631883418467326593LL,
  5631885827943979666LL,
  5631850984532639839LL,
  5631851055888758817LL,
  7937344502009199186LL,
  5631883418467326657LL,
  5631885827943979730LL,
  5631851258289003633LL,
  6052838862569888498LL,
  7940442290657500325LL,
  5521254973715979878LL,
  1441151899223945265LL,
  5670909781073861797LL,
  5476500868995969061LL,
  -2999674699471845379LL,
  -3097596797610942433LL,
  -3097596797610942433LL,
  -3097596797610942433LL
}; // weak
__int64 qword_50300[82] =
{
  -7998388550200493059LL,
  -5098060996820275099LL,
  5494576745661102208LL,
  -3278618276803899227LL,
  -8429313088943028129LL,
  5539331833973442725LL,
  5494524480214509814LL,
  3027830613286617191LL,
  6539236591499228140LL,
  1224984640471702529LL,
  1224989029928279058LL,
  6539236873693305862LL,
  6052850446095883585LL,
  -3386693440652703476LL,
  1441151894953926034LL,
  -3097596797610942433LL,
  5631865684547357184LL,
  5631865826281277953LL,
  5631868235757931026LL,
  8142517774072117488LL,
  5631865684547357216LL,
  5631865826281277985LL,
  5631868235757931058LL,
  6124893484468893937LL,
  5631865701727226368LL,
  5631865843461147137LL,
  5667248793341358082LL,
  5631868235757931026LL,
  5667248797636325379LL,
  5631866251483040292LL,
  5631866393216961061LL,
  -6196104370369630189LL,
  5631868231462963762LL,
  1224984636177128658LL,
  5631866251483040388LL,
  5631866393216961157LL,
  1224989039047154754LL,
  5631868094024010385LL,
  1224993428503731299LL,
  5631866251483040420LL,
  5631866393216961189LL,
  6539236732488326771LL,
  5631868094024010417LL,
  6539236873684655392LL,
  5631866251483040452LL,
  5631866393216961221LL,
  6539236607396683073LL,
  5631868094024010449LL,
  -1080850431651078766LL,
  5631833682746034916LL,
  7936499514438339313LL,
  5521254960800430320LL,
  3027830612701813859LL,
  7940161098586484771LL,
  5521255033814874353LL,
  -5692536449962871230LL,
  -1080859103091227136LL,
  -7310463779450387956LL,
  5631865684547357184LL,
  5631865826281277953LL,
  8142517774072117488LL,
  5631865684547357216LL,
  5631865826281277985LL,
  6124894034224707825LL,
  5631865684547357184LL,
  5631865826281277953LL,
  5631865684547357216LL,
  5631865826281277985LL,
  5631833248931540994LL,
  5631833253249312768LL,
  5494514704890488865LL,
  5631865684547357344LL,
  5631865826281278113LL,
  5631833524369038402LL,
  5631833528127219712LL,
  7937344081102399521LL,
  5631833665566165728LL,
  7935373617263543391LL,
  5521254961358380131LL,
  5476500443917975616LL,
  -2999674699471845379LL,
  0LL
}; // weak
_UNKNOWN loc_50840; // weak
int dword_51884 = 1579681795; // weak
_UNKNOWN loc_51B00; // weak
int dword_52940 = 1116352408; // weak
int dword_52AFC = 1579690148; // weak
__int64 qword_53B00 = 4794697086780616226LL; // weak
_UNKNOWN loc_58658; // weak
_UNKNOWN loc_5FFC4; // weak
_UNKNOWN loc_6FC40; // weak
_UNKNOWN loc_8E088; // weak
_UNKNOWN loc_A302C; // weak
_UNKNOWN loc_A71EC; // weak
_UNKNOWN loc_A8FE0; // weak
_UNKNOWN loc_B1D70; // weak
char a0123456789abcd_0[17] = "0123456789ABCDEF"; // weak
_UNKNOWN unk_B8A4C; // weak
char a0123456789abcd_1[17] = "0123456789abcdef"; // weak
_UNKNOWN unk_C11A8; // weak
_UNKNOWN unk_C124C; // weak
unsigned int dword_C14F4[4] = { 6u, 4u, 3u, 2u }; // idb
_UNKNOWN unk_C1544; // weak
_UNKNOWN unk_C1554; // weak
_DWORD dword_C1564[8] = { 0, 1, 1, 0, 0, 0, 0, 0 }; // idb
_DWORD dword_C1584[8] = { 99, 12, 31, 23, 59, 59, 12, 59 }; // idb
_DWORD dword_C15A4[8] = { 0, 1, 0, 4294967295, 0, 4294967295, 0, 1 }; // idb
_UNKNOWN unk_C15C4; // weak
_UNKNOWN unk_C16C4; // weak
_UNKNOWN unk_C182C; // weak
_UNKNOWN unk_C1AD7; // weak
_DWORD dword_C1DC0[7] = { 16, 1, 1, 3, 2, 1, 0 }; // idb
_UNKNOWN unk_C8D4A; // weak
_UNKNOWN unk_CFCC7; // weak
_UNKNOWN unk_CFD6A; // weak
_BYTE byte_CFE30[256] =
{
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
}; // idb
_DWORD dword_CFFA0[512] =
{
  0,
  16,
  536870912,
  536870928,
  65536,
  65552,
  536936448,
  536936464,
  2048,
  2064,
  536872960,
  536872976,
  67584,
  67600,
  536938496,
  536938512,
  32,
  48,
  536870944,
  536870960,
  65568,
  65584,
  536936480,
  536936496,
  2080,
  2096,
  536872992,
  536873008,
  67616,
  67632,
  536938528,
  536938544,
  524288,
  524304,
  537395200,
  537395216,
  589824,
  589840,
  537460736,
  537460752,
  526336,
  526352,
  537397248,
  537397264,
  591872,
  591888,
  537462784,
  537462800,
  524320,
  524336,
  537395232,
  537395248,
  589856,
  589872,
  537460768,
  537460784,
  526368,
  526384,
  537397280,
  537397296,
  591904,
  591920,
  537462816,
  537462832,
  0,
  33554432,
  8192,
  33562624,
  2097152,
  35651584,
  2105344,
  35659776,
  4,
  33554436,
  8196,
  33562628,
  2097156,
  35651588,
  2105348,
  35659780,
  1024,
  33555456,
  9216,
  33563648,
  2098176,
  35652608,
  2106368,
  35660800,
  1028,
  33555460,
  9220,
  33563652,
  2098180,
  35652612,
  2106372,
  35660804,
  268435456,
  301989888,
  268443648,
  301998080,
  270532608,
  304087040,
  270540800,
  304095232,
  268435460,
  301989892,
  268443652,
  301998084,
  270532612,
  304087044,
  270540804,
  304095236,
  268436480,
  301990912,
  268444672,
  301999104,
  270533632,
  304088064,
  270541824,
  304096256,
  268436484,
  301990916,
  268444676,
  301999108,
  270533636,
  304088068,
  270541828,
  304096260,
  0,
  1,
  262144,
  262145,
  16777216,
  16777217,
  17039360,
  17039361,
  2,
  3,
  262146,
  262147,
  16777218,
  16777219,
  17039362,
  17039363,
  512,
  513,
  262656,
  262657,
  16777728,
  16777729,
  17039872,
  17039873,
  514,
  515,
  262658,
  262659,
  16777730,
  16777731,
  17039874,
  17039875,
  134217728,
  134217729,
  134479872,
  134479873,
  150994944,
  150994945,
  151257088,
  151257089,
  134217730,
  134217731,
  134479874,
  134479875,
  150994946,
  150994947,
  151257090,
  151257091,
  134218240,
  134218241,
  134480384,
  134480385,
  150995456,
  150995457,
  151257600,
  151257601,
  134218242,
  134218243,
  134480386,
  134480387,
  150995458,
  150995459,
  151257602,
  151257603,
  0,
  1048576,
  256,
  1048832,
  8,
  1048584,
  264,
  1048840,
  4096,
  1052672,
  4352,
  1052928,
  4104,
  1052680,
  4360,
  1052936,
  67108864,
  68157440,
  67109120,
  68157696,
  67108872,
  68157448,
  67109128,
  68157704,
  67112960,
  68161536,
  67113216,
  68161792,
  67112968,
  68161544,
  67113224,
  68161800,
  131072,
  1179648,
  131328,
  1179904,
  131080,
  1179656,
  131336,
  1179912,
  135168,
  1183744,
  135424,
  1184000,
  135176,
  1183752,
  135432,
  1184008,
  67239936,
  68288512,
  67240192,
  68288768,
  67239944,
  68288520,
  67240200,
  68288776,
  67244032,
  68292608,
  67244288,
  68292864,
  67244040,
  68292616,
  67244296,
  68292872,
  0,
  268435456,
  65536,
  268500992,
  4,
  268435460,
  65540,
  268500996,
  536870912,
  805306368,
  536936448,
  805371904,
  536870916,
  805306372,
  536936452,
  805371908,
  1048576,
  269484032,
  1114112,
  269549568,
  1048580,
  269484036,
  1114116,
  269549572,
  537919488,
  806354944,
  537985024,
  806420480,
  537919492,
  806354948,
  537985028,
  806420484,
  4096,
  268439552,
  69632,
  268505088,
  4100,
  268439556,
  69636,
  268505092,
  536875008,
  805310464,
  536940544,
  805376000,
  536875012,
  805310468,
  536940548,
  805376004,
  1052672,
  269488128,
  1118208,
  269553664,
  1052676,
  269488132,
  1118212,
  269553668,
  537923584,
  806359040,
  537989120,
  806424576,
  537923588,
  806359044,
  537989124,
  806424580,
  0,
  134217728,
  8,
  134217736,
  1024,
  134218752,
  1032,
  134218760,
  131072,
  134348800,
  131080,
  134348808,
  132096,
  134349824,
  132104,
  134349832,
  1,
  134217729,
  9,
  134217737,
  1025,
  134218753,
  1033,
  134218761,
  131073,
  134348801,
  131081,
  134348809,
  132097,
  134349825,
  132105,
  134349833,
  33554432,
  167772160,
  33554440,
  167772168,
  33555456,
  167773184,
  33555464,
  167773192,
  33685504,
  167903232,
  33685512,
  167903240,
  33686528,
  167904256,
  33686536,
  167904264,
  33554433,
  167772161,
  33554441,
  167772169,
  33555457,
  167773185,
  33555465,
  167773193,
  33685505,
  167903233,
  33685513,
  167903241,
  33686529,
  167904257,
  33686537,
  167904265,
  0,
  256,
  524288,
  524544,
  16777216,
  16777472,
  17301504,
  17301760,
  16,
  272,
  524304,
  524560,
  16777232,
  16777488,
  17301520,
  17301776,
  2097152,
  2097408,
  2621440,
  2621696,
  18874368,
  18874624,
  19398656,
  19398912,
  2097168,
  2097424,
  2621456,
  2621712,
  18874384,
  18874640,
  19398672,
  19398928,
  512,
  768,
  524800,
  525056,
  16777728,
  16777984,
  17302016,
  17302272,
  528,
  784,
  524816,
  525072,
  16777744,
  16778000,
  17302032,
  17302288,
  2097664,
  2097920,
  2621952,
  2622208,
  18874880,
  18875136,
  19399168,
  19399424,
  2097680,
  2097936,
  2621968,
  2622224,
  18874896,
  18875152,
  19399184,
  19399440,
  0,
  67108864,
  262144,
  67371008,
  2,
  67108866,
  262146,
  67371010,
  8192,
  67117056,
  270336,
  67379200,
  8194,
  67117058,
  270338,
  67379202,
  32,
  67108896,
  262176,
  67371040,
  34,
  67108898,
  262178,
  67371042,
  8224,
  67117088,
  270368,
  67379232,
  8226,
  67117090,
  270370,
  67379234,
  2048,
  67110912,
  264192,
  67373056,
  2050,
  67110914,
  264194,
  67373058,
  10240,
  67119104,
  272384,
  67381248,
  10242,
  67119106,
  272386,
  67381250,
  2080,
  67110944,
  264224,
  67373088,
  2082,
  67110946,
  264226,
  67373090,
  10272,
  67119136,
  272416,
  67381280,
  10274,
  67119138,
  272418,
  67381282
}; // idb
_BYTE byte_D07A0[256] =
{
  1,
  1,
  2,
  2,
  4,
  4,
  7,
  7,
  8,
  8,
  11,
  11,
  13,
  13,
  14,
  14,
  16,
  16,
  19,
  19,
  21,
  21,
  22,
  22,
  25,
  25,
  26,
  26,
  28,
  28,
  31,
  31,
  32,
  32,
  35,
  35,
  37,
  37,
  38,
  38,
  41,
  41,
  42,
  42,
  44,
  44,
  47,
  47,
  49,
  49,
  50,
  50,
  52,
  52,
  55,
  55,
  56,
  56,
  59,
  59,
  61,
  61,
  62,
  62,
  64,
  64,
  67,
  67,
  69,
  69,
  70,
  70,
  73,
  73,
  74,
  74,
  76,
  76,
  79,
  79,
  81,
  81,
  82,
  82,
  84,
  84,
  87,
  87,
  88,
  88,
  91,
  91,
  93,
  93,
  94,
  94,
  97,
  97,
  98,
  98,
  100,
  100,
  103,
  103,
  104,
  104,
  107,
  107,
  109,
  109,
  110,
  110,
  112,
  112,
  115,
  115,
  117,
  117,
  118,
  118,
  121,
  121,
  122,
  122,
  124,
  124,
  127,
  127,
  128,
  128,
  131,
  131,
  133,
  133,
  134,
  134,
  137,
  137,
  138,
  138,
  140,
  140,
  143,
  143,
  145,
  145,
  146,
  146,
  148,
  148,
  151,
  151,
  152,
  152,
  155,
  155,
  157,
  157,
  158,
  158,
  161,
  161,
  162,
  162,
  164,
  164,
  167,
  167,
  168,
  168,
  171,
  171,
  173,
  173,
  174,
  174,
  176,
  176,
  179,
  179,
  181,
  181,
  182,
  182,
  185,
  185,
  186,
  186,
  188,
  188,
  191,
  191,
  193,
  193,
  194,
  194,
  196,
  196,
  199,
  199,
  200,
  200,
  203,
  203,
  205,
  205,
  206,
  206,
  208,
  208,
  211,
  211,
  213,
  213,
  214,
  214,
  217,
  217,
  218,
  218,
  220,
  220,
  223,
  223,
  224,
  224,
  227,
  227,
  229,
  229,
  230,
  230,
  233,
  233,
  234,
  234,
  236,
  236,
  239,
  239,
  241,
  241,
  242,
  242,
  244,
  244,
  247,
  247,
  248,
  248,
  251,
  251,
  253,
  253,
  254,
  254
}; // idb
_DWORD dword_D08A0[512] =
{
  34080768,
  524288,
  33554434,
  34080770,
  33554432,
  526338,
  524290,
  33554434,
  526338,
  34080768,
  34078720,
  2050,
  33556482,
  33554432,
  0,
  524290,
  524288,
  2,
  33556480,
  526336,
  34080770,
  34078720,
  2050,
  33556480,
  2,
  2048,
  526336,
  34078722,
  2048,
  33556482,
  34078722,
  0,
  0,
  34080770,
  33556480,
  524290,
  34080768,
  524288,
  2050,
  33556480,
  34078722,
  2048,
  526336,
  33554434,
  526338,
  2,
  33554434,
  34078720,
  34080770,
  526336,
  34078720,
  33556482,
  33554432,
  2050,
  524290,
  0,
  524288,
  33554432,
  33556482,
  34080768,
  2,
  34078722,
  2048,
  526338,
  1074823184,
  0,
  1081344,
  1074790400,
  1073741840,
  32784,
  1073774592,
  1081344,
  32768,
  1074790416,
  16,
  1073774592,
  1048592,
  1074823168,
  1074790400,
  16,
  1048576,
  1073774608,
  1074790416,
  32768,
  1081360,
  1073741824,
  0,
  1048592,
  1073774608,
  1081360,
  1074823168,
  1073741840,
  1073741824,
  1048576,
  32784,
  1074823184,
  1048592,
  1074823168,
  1073774592,
  1081360,
  1074823184,
  1048592,
  1073741840,
  0,
  1073741824,
  32784,
  1048576,
  1074790416,
  32768,
  1073741824,
  1081360,
  1073774608,
  1074823168,
  32768,
  0,
  1073741840,
  16,
  1074823184,
  1081344,
  1074790400,
  1074790416,
  1048576,
  32784,
  1073774592,
  1073774608,
  16,
  1074790400,
  1081344,
  67108865,
  67371264,
  256,
  67109121,
  262145,
  67108864,
  67109121,
  262400,
  67109120,
  262144,
  67371008,
  1,
  67371265,
  257,
  1,
  67371009,
  0,
  262145,
  67371264,
  256,
  257,
  67371265,
  262144,
  67108865,
  67371009,
  67109120,
  262401,
  67371008,
  262400,
  0,
  67108864,
  262401,
  67371264,
  256,
  1,
  262144,
  257,
  262145,
  67371008,
  67109121,
  0,
  67371264,
  262400,
  67371009,
  262145,
  67108864,
  67371265,
  1,
  262401,
  67108865,
  67108864,
  67371265,
  262144,
  67109120,
  67109121,
  262400,
  67109120,
  0,
  67371009,
  257,
  67108865,
  262401,
  256,
  67371008,
  4198408,
  268439552,
  8,
  272633864,
  0,
  272629760,
  268439560,
  4194312,
  272633856,
  268435464,
  268435456,
  4104,
  268435464,
  4198408,
  4194304,
  268435456,
  272629768,
  4198400,
  4096,
  8,
  4198400,
  268439560,
  272629760,
  4096,
  4104,
  0,
  4194312,
  272633856,
  268439552,
  272629768,
  272633864,
  4194304,
  272629768,
  4104,
  4194304,
  268435464,
  4198400,
  268439552,
  8,
  272629760,
  268439560,
  0,
  4096,
  4194312,
  0,
  272629768,
  272633856,
  4096,
  268435456,
  272633864,
  4198408,
  4194304,
  272633864,
  8,
  268439552,
  4198408,
  4194312,
  4198400,
  272629760,
  268439560,
  4104,
  268435456,
  268435464,
  272633856,
  134217728,
  65536,
  1024,
  134284320,
  134283296,
  134218752,
  66592,
  134283264,
  65536,
  32,
  134217760,
  66560,
  134218784,
  134283296,
  134284288,
  0,
  66560,
  134217728,
  65568,
  1056,
  134218752,
  66592,
  0,
  134217760,
  32,
  134218784,
  134284320,
  65568,
  134283264,
  1024,
  1056,
  134284288,
  134284288,
  134218784,
  65568,
  134283264,
  65536,
  32,
  134217760,
  134218752,
  134217728,
  66560,
  134284320,
  0,
  66592,
  134217728,
  1024,
  65568,
  134218784,
  1024,
  0,
  134284320,
  134283296,
  134284288,
  1056,
  65536,
  66560,
  134283296,
  134218752,
  1056,
  32,
  66592,
  134283264,
  134217760,
  2147483712,
  2097216,
  0,
  2149588992,
  2097216,
  8192,
  2147491904,
  2097152,
  8256,
  2149589056,
  2105344,
  2147483648,
  2147491840,
  2147483712,
  2149580800,
  2105408,
  2097152,
  2147491904,
  2149580864,
  0,
  8192,
  64,
  2149588992,
  2149580864,
  2149589056,
  2149580800,
  2147483648,
  8256,
  64,
  2105344,
  2105408,
  2147491840,
  8256,
  2147483648,
  2147491840,
  2105408,
  2149588992,
  2097216,
  0,
  2147491840,
  2147483648,
  8192,
  2149580864,
  2097152,
  2097216,
  2149589056,
  2105344,
  64,
  2149589056,
  2105344,
  2097152,
  2147491904,
  2147483712,
  2149580800,
  2105408,
  0,
  8192,
  2147483712,
  2147491904,
  2149588992,
  2149580800,
  8256,
  64,
  2149580864,
  16384,
  512,
  16777728,
  16777220,
  16794116,
  16388,
  16896,
  0,
  16777216,
  16777732,
  516,
  16793600,
  4,
  16794112,
  16793600,
  516,
  16777732,
  16384,
  16388,
  16794116,
  0,
  16777728,
  16777220,
  16896,
  16793604,
  16900,
  16794112,
  4,
  16900,
  16793604,
  512,
  16777216,
  16900,
  16793600,
  16793604,
  516,
  16384,
  512,
  16777216,
  16793604,
  16777732,
  16900,
  16896,
  0,
  512,
  16777220,
  4,
  16777728,
  0,
  16777732,
  16777728,
  16896,
  516,
  16384,
  16794116,
  16777216,
  16794112,
  4,
  16388,
  16794116,
  16777220,
  16794112,
  16793600,
  16388,
  545259648,
  545390592,
  131200,
  0,
  537001984,
  8388736,
  545259520,
  545390720,
  128,
  536870912,
  8519680,
  131200,
  8519808,
  537002112,
  536871040,
  545259520,
  131072,
  8519808,
  8388736,
  537001984,
  545390720,
  536871040,
  0,
  8519680,
  536870912,
  8388608,
  537002112,
  545259648,
  8388608,
  131072,
  545390592,
  128,
  8388608,
  131072,
  536871040,
  545390720,
  131200,
  536870912,
  0,
  8519680,
  545259648,
  537002112,
  537001984,
  8388736,
  545390592,
  128,
  8388736,
  537001984,
  545390720,
  8388608,
  545259520,
  536871040,
  8519680,
  131200,
  537002112,
  545259520,
  128,
  545390592,
  8519808,
  0,
  536870912,
  545259648,
  131072,
  8519808
}; // idb
__int128 xmmword_D10C0 = 0x1032547698BADCFEEFCDAB8967452301LL; // weak
__int128 xmmword_D10D0 = 0x3000000020000000100000000LL; // weak
__int128 xmmword_D10E0 = 0xF70E59393070DD17367CD507C1059ED8LL; // weak
__int128 xmmword_D10F0 = 0xBEFA4FA464F98FA768581511FFC00B31LL; // weak
__int128 xmmword_D1100 = 0xA54FF53A3C6EF372BB67AE856A09E667LL; // weak
__int128 xmmword_D1110 = 0x5BE0CD191F83D9AB9B05688C510E527FLL; // weak
__int128 xmmword_D1120 = 0x102030405060708090A0B0C0D0E0FLL; // weak
_QWORD qword_D1130[16] =
{
  0LL,
  2026619832316723200LL,
  4053239664633446400LL,
  2621094983129628672LL,
  8106479329266892800LL,
  7827256152369922048LL,
  5242189966259257344LL,
  6115888293969133568LL,
  -2233785415175766016LL,
  -207165582859042816LL,
  -2792231768969707520LL,
  -4224376450473525248LL,
  -7962364141191036928LL,
  -8241587318088007680LL,
  -6214967485771284480LL,
  -5341269158061408256LL
}; // idb
_UNKNOWN unk_D11B0; // weak
char aAsn1LengthMism[21] = "ASN1_LENGTH_MISMATCH"; // weak
_DWORD dword_D4E4C[256] =
{
  1671808611,
  2089089148,
  2006576759,
  2072901243,
  4061003762,
  1807603307,
  1873927791,
  3310653893,
  810573872,
  16974337,
  1739181671,
  729634347,
  4263110654,
  3613570519,
  2883997099,
  1989864566,
  3393556426,
  2191335298,
  3376449993,
  2106063485,
  4195741690,
  1508618841,
  1204391495,
  4027317232,
  2917941677,
  3563566036,
  2734514082,
  2951366063,
  2629772188,
  2767672228,
  1922491506,
  3227229120,
  3082974647,
  4246528509,
  2477669779,
  644500518,
  911895606,
  1061256767,
  4144166391,
  3427763148,
  878471220,
  2784252325,
  3845444069,
  4043897329,
  1905517169,
  3631459288,
  827548209,
  356461077,
  67897348,
  3344078279,
  593839651,
  3277757891,
  405286936,
  2527147926,
  84871685,
  2595565466,
  118033927,
  305538066,
  2157648768,
  3795705826,
  3945188843,
  661212711,
  2999812018,
  1973414517,
  152769033,
  2208177539,
  745822252,
  439235610,
  455947803,
  1857215598,
  1525593178,
  2700827552,
  1391895634,
  994932283,
  3596728278,
  3016654259,
  695947817,
  3812548067,
  795958831,
  2224493444,
  1408607827,
  3513301457,
  0,
  3979133421,
  543178784,
  4229948412,
  2982705585,
  1542305371,
  1790891114,
  3410398667,
  3201918910,
  961245753,
  1256100938,
  1289001036,
  1491644504,
  3477767631,
  3496721360,
  4012557807,
  2867154858,
  4212583931,
  1137018435,
  1305975373,
  861234739,
  2241073541,
  1171229253,
  4178635257,
  33948674,
  2139225727,
  1357946960,
  1011120188,
  2679776671,
  2833468328,
  1374921297,
  2751356323,
  1086357568,
  2408187279,
  2460827538,
  2646352285,
  944271416,
  4110742005,
  3168756668,
  3066132406,
  3665145818,
  560153121,
  271589392,
  4279952895,
  4077846003,
  3530407890,
  3444343245,
  202643468,
  322250259,
  3962553324,
  1608629855,
  2543990167,
  1154254916,
  389623319,
  3294073796,
  2817676711,
  2122513534,
  1028094525,
  1689045092,
  1575467613,
  422261273,
  1939203699,
  1621147744,
  2174228865,
  1339137615,
  3699352540,
  577127458,
  712922154,
  2427141008,
  2290289544,
  1187679302,
  3995715566,
  3100863416,
  339486740,
  3732514782,
  1591917662,
  186455563,
  3681988059,
  3762019296,
  844522546,
  978220090,
  169743370,
  1239126601,
  101321734,
  611076132,
  1558493276,
  3260915650,
  3547250131,
  2901361580,
  1655096418,
  2443721105,
  2510565781,
  3828863972,
  2039214713,
  3878868455,
  3359869896,
  928607799,
  1840765549,
  2374762893,
  3580146133,
  1322425422,
  2850048425,
  1823791212,
  1459268694,
  4094161908,
  3928346602,
  1706019429,
  2056189050,
  2934523822,
  135794696,
  3134549946,
  2022240376,
  628050469,
  779246638,
  472135708,
  2800834470,
  3032970164,
  3327236038,
  3894660072,
  3715932637,
  1956440180,
  522272287,
  1272813131,
  3185336765,
  2340818315,
  2323976074,
  1888542832,
  1044544574,
  3049550261,
  1722469478,
  1222152264,
  50660867,
  4127324150,
  236067854,
  1638122081,
  895445557,
  1475980887,
  3117443513,
  2257655686,
  3243809217,
  489110045,
  2662934430,
  3778599393,
  4162055160,
  2561878936,
  288563729,
  1773916777,
  3648039385,
  2391345038,
  2493985684,
  2612407707,
  505560094,
  2274497927,
  3911240169,
  3460925390,
  1442818645,
  678973480,
  3749357023,
  2358182796,
  2717407649,
  2306869641,
  219617805,
  3218761151,
  3862026214,
  1120306242,
  1756942440,
  1103331905,
  2578459033,
  762796589,
  252780047,
  2966125488,
  1425844308,
  3151392187,
  372911126
}; // idb
_DWORD dword_D524C[256] =
{
  1667474886,
  2088535288,
  2004326894,
  2071694838,
  4075949567,
  1802223062,
  1869591006,
  3318043793,
  808472672,
  16843522,
  1734846926,
  724270422,
  4278065639,
  3621216949,
  2880169549,
  1987484396,
  3402253711,
  2189597983,
  3385409673,
  2105378810,
  4210693615,
  1499065266,
  1195886990,
  4042263547,
  2913856577,
  3570689971,
  2728590687,
  2947541573,
  2627518243,
  2762274643,
  1920112356,
  3233831835,
  3082273397,
  4261223649,
  2475929149,
  640051788,
  909531756,
  1061110142,
  4160160501,
  3435941763,
  875846760,
  2779116625,
  3857003729,
  4059105529,
  1903268834,
  3638064043,
  825316194,
  353713962,
  67374088,
  3351728789,
  589522246,
  3284360861,
  404236336,
  2526454071,
  84217610,
  2593830191,
  117901582,
  303183396,
  2155911963,
  3806477791,
  3958056653,
  656894286,
  2998062463,
  1970642922,
  151591698,
  2206440989,
  741110872,
  437923380,
  454765878,
  1852748508,
  1515908788,
  2694904667,
  1381168804,
  993742198,
  3604373943,
  3014905469,
  690584402,
  3823320797,
  791638366,
  2223281939,
  1398011302,
  3520161977,
  0,
  3991743681,
  538992704,
  4244381667,
  2981218425,
  1532751286,
  1785380564,
  3419096717,
  3200178535,
  960056178,
  1246420628,
  1280103576,
  1482221744,
  3486468741,
  3503319995,
  4025428677,
  2863326543,
  4227536621,
  1128514950,
  1296947098,
  859002214,
  2240123921,
  1162203018,
  4193849577,
  33687044,
  2139062782,
  1347481760,
  1010582648,
  2678045221,
  2829640523,
  1364325282,
  2745433693,
  1077985408,
  2408548869,
  2459086143,
  2644360225,
  943212656,
  4126475505,
  3166494563,
  3065430391,
  3671750063,
  555836226,
  269496352,
  4294908645,
  4092792573,
  3537006015,
  3452783745,
  202118168,
  320025894,
  3974901699,
  1600119230,
  2543297077,
  1145359496,
  387397934,
  3301201811,
  2812801621,
  2122220284,
  1027426170,
  1684319432,
  1566435258,
  421079858,
  1936954854,
  1616945344,
  2172753945,
  1330631070,
  3705438115,
  572679748,
  707427924,
  2425400123,
  2290647819,
  1179044492,
  4008585671,
  3099120491,
  336870440,
  3739122087,
  1583276732,
  185277718,
  3688593069,
  3772791771,
  842159716,
  976899700,
  168435220,
  1229577106,
  101059084,
  606366792,
  1549591736,
  3267517855,
  3553849021,
  2897014595,
  1650632388,
  2442242105,
  2509612081,
  3840161747,
  2038008818,
  3890688725,
  3368567691,
  926374254,
  1835907034,
  2374863873,
  3587531953,
  1313788572,
  2846482505,
  1819063512,
  1448540844,
  4109633523,
  3941213647,
  1701162954,
  2054852340,
  2930698567,
  134748176,
  3132806511,
  2021165296,
  623210314,
  774795868,
  471606328,
  2795958615,
  3031746419,
  3334885783,
  3907527627,
  3722280097,
  1953799400,
  522133822,
  1263263126,
  3183336545,
  2341176845,
  2324333839,
  1886425312,
  1044267644,
  3048588401,
  1718004428,
  1212733584,
  50529542,
  4143317495,
  235803164,
  1633788866,
  892690282,
  1465383342,
  3115962473,
  2256965911,
  3250673817,
  488449850,
  2661202215,
  3789633753,
  4177007595,
  2560144171,
  286339874,
  1768537042,
  3654906025,
  2391705863,
  2492770099,
  2610673197,
  505291324,
  2273808917,
  3924369609,
  3469625735,
  1431699370,
  673740880,
  3755965093,
  2358021891,
  2711746649,
  2307489801,
  218961690,
  3217021541,
  3873845719,
  1111672452,
  1751693520,
  1094828930,
  2576986153,
  757954394,
  252645662,
  2964376443,
  1414855848,
  3149649517,
  370555436
}; // idb
_DWORD dword_D564C[256] =
{
  3328402341,
  4168907908,
  4000806809,
  4135287693,
  4294111757,
  3597364157,
  3731845041,
  2445657428,
  1613770832,
  33620227,
  3462883241,
  1445669757,
  3892248089,
  3050821474,
  1303096294,
  3967186586,
  2412431941,
  528646813,
  2311702848,
  4202528135,
  4026202645,
  2992200171,
  2387036105,
  4226871307,
  1101901292,
  3017069671,
  1604494077,
  1169141738,
  597466303,
  1403299063,
  3832705686,
  2613100635,
  1974974402,
  3791519004,
  1033081774,
  1277568618,
  1815492186,
  2118074177,
  4126668546,
  2211236943,
  1748251740,
  1369810420,
  3521504564,
  4193382664,
  3799085459,
  2883115123,
  1647391059,
  706024767,
  134480908,
  2512897874,
  1176707941,
  2646852446,
  806885416,
  932615841,
  168101135,
  798661301,
  235341577,
  605164086,
  461406363,
  3756188221,
  3454790438,
  1311188841,
  2142417613,
  3933566367,
  302582043,
  495158174,
  1479289972,
  874125870,
  907746093,
  3698224818,
  3025820398,
  1537253627,
  2756858614,
  1983593293,
  3084310113,
  2108928974,
  1378429307,
  3722699582,
  1580150641,
  327451799,
  2790478837,
  3117535592,
  0,
  3253595436,
  1075847264,
  3825007647,
  2041688520,
  3059440621,
  3563743934,
  2378943302,
  1740553945,
  1916352843,
  2487896798,
  2555137236,
  2958579944,
  2244988746,
  3151024235,
  3320835882,
  1336584933,
  3992714006,
  2252555205,
  2588757463,
  1714631509,
  293963156,
  2319795663,
  3925473552,
  67240454,
  4269768577,
  2689618160,
  2017213508,
  631218106,
  1269344483,
  2723238387,
  1571005438,
  2151694528,
  93294474,
  1066570413,
  563977660,
  1882732616,
  4059428100,
  1673313503,
  2008463041,
  2950355573,
  1109467491,
  537923632,
  3858759450,
  4260623118,
  3218264685,
  2177748300,
  403442708,
  638784309,
  3287084079,
  3193921505,
  899127202,
  2286175436,
  773265209,
  2479146071,
  1437050866,
  4236148354,
  2050833735,
  3362022572,
  3126681063,
  840505643,
  3866325909,
  3227541664,
  427917720,
  2655997905,
  2749160575,
  1143087718,
  1412049534,
  999329963,
  193497219,
  2353415882,
  3354324521,
  1807268051,
  672404540,
  2816401017,
  3160301282,
  369822493,
  2916866934,
  3688947771,
  1681011286,
  1949973070,
  336202270,
  2454276571,
  201721354,
  1210328172,
  3093060836,
  2680341085,
  3184776046,
  1135389935,
  3294782118,
  965841320,
  831886756,
  3554993207,
  4068047243,
  3588745010,
  2345191491,
  1849112409,
  3664604599,
  26054028,
  2983581028,
  2622377682,
  1235855840,
  3630984372,
  2891339514,
  4092916743,
  3488279077,
  3395642799,
  4101667470,
  1202630377,
  268961816,
  1874508501,
  4034427016,
  1243948399,
  1546530418,
  941366308,
  1470539505,
  1941222599,
  2546386513,
  3421038627,
  2715671932,
  3899946140,
  1042226977,
  2521517021,
  1639824860,
  227249030,
  260737669,
  3765465232,
  2084453954,
  1907733956,
  3429263018,
  2420656344,
  100860677,
  4160157185,
  470683154,
  3261161891,
  1781871967,
  2924959737,
  1773779408,
  394692241,
  2579611992,
  974986535,
  664706745,
  3655459128,
  3958962195,
  731420851,
  571543859,
  3530123707,
  2849626480,
  126783113,
  865375399,
  765172662,
  1008606754,
  361203602,
  3387549984,
  2278477385,
  2857719295,
  1344809080,
  2782912378,
  59542671,
  1503764984,
  160008576,
  437062935,
  1707065306,
  3622233649,
  2218934982,
  3496503480,
  2185314755,
  697932208,
  1512910199,
  504303377,
  2075177163,
  2824099068,
  1841019862,
  739644986
}; // idb
unsigned __int8 byte_D5A4C[1024] =
{
  99u,
  99u,
  198u,
  165u,
  124u,
  124u,
  248u,
  132u,
  119u,
  119u,
  238u,
  153u,
  123u,
  123u,
  246u,
  141u,
  242u,
  242u,
  255u,
  13u,
  107u,
  107u,
  214u,
  189u,
  111u,
  111u,
  222u,
  177u,
  197u,
  197u,
  145u,
  84u,
  48u,
  48u,
  96u,
  80u,
  1u,
  1u,
  2u,
  3u,
  103u,
  103u,
  206u,
  169u,
  43u,
  43u,
  86u,
  125u,
  254u,
  254u,
  231u,
  25u,
  215u,
  215u,
  181u,
  98u,
  171u,
  171u,
  77u,
  230u,
  118u,
  118u,
  236u,
  154u,
  202u,
  202u,
  143u,
  69u,
  130u,
  130u,
  31u,
  157u,
  201u,
  201u,
  137u,
  64u,
  125u,
  125u,
  250u,
  135u,
  250u,
  250u,
  239u,
  21u,
  89u,
  89u,
  178u,
  235u,
  71u,
  71u,
  142u,
  201u,
  240u,
  240u,
  251u,
  11u,
  173u,
  173u,
  65u,
  236u,
  212u,
  212u,
  179u,
  103u,
  162u,
  162u,
  95u,
  253u,
  175u,
  175u,
  69u,
  234u,
  156u,
  156u,
  35u,
  191u,
  164u,
  164u,
  83u,
  247u,
  114u,
  114u,
  228u,
  150u,
  192u,
  192u,
  155u,
  91u,
  183u,
  183u,
  117u,
  194u,
  253u,
  253u,
  225u,
  28u,
  147u,
  147u,
  61u,
  174u,
  38u,
  38u,
  76u,
  106u,
  54u,
  54u,
  108u,
  90u,
  63u,
  63u,
  126u,
  65u,
  247u,
  247u,
  245u,
  2u,
  204u,
  204u,
  131u,
  79u,
  52u,
  52u,
  104u,
  92u,
  165u,
  165u,
  81u,
  244u,
  229u,
  229u,
  209u,
  52u,
  241u,
  241u,
  249u,
  8u,
  113u,
  113u,
  226u,
  147u,
  216u,
  216u,
  171u,
  115u,
  49u,
  49u,
  98u,
  83u,
  21u,
  21u,
  42u,
  63u,
  4u,
  4u,
  8u,
  12u,
  199u,
  199u,
  149u,
  82u,
  35u,
  35u,
  70u,
  101u,
  195u,
  195u,
  157u,
  94u,
  24u,
  24u,
  48u,
  40u,
  150u,
  150u,
  55u,
  161u,
  5u,
  5u,
  10u,
  15u,
  154u,
  154u,
  47u,
  181u,
  7u,
  7u,
  14u,
  9u,
  18u,
  18u,
  36u,
  54u,
  128u,
  128u,
  27u,
  155u,
  226u,
  226u,
  223u,
  61u,
  235u,
  235u,
  205u,
  38u,
  39u,
  39u,
  78u,
  105u,
  178u,
  178u,
  127u,
  205u,
  117u,
  117u,
  234u,
  159u,
  9u,
  9u,
  18u,
  27u,
  131u,
  131u,
  29u,
  158u,
  44u,
  44u,
  88u,
  116u,
  26u,
  26u,
  52u,
  46u,
  27u,
  27u,
  54u,
  45u,
  110u,
  110u,
  220u,
  178u,
  90u,
  90u,
  180u,
  238u,
  160u,
  160u,
  91u,
  251u,
  82u,
  82u,
  164u,
  246u,
  59u,
  59u,
  118u,
  77u,
  214u,
  214u,
  183u,
  97u,
  179u,
  179u,
  125u,
  206u,
  41u,
  41u,
  82u,
  123u,
  227u,
  227u,
  221u,
  62u,
  47u,
  47u,
  94u,
  113u,
  132u,
  132u,
  19u,
  151u,
  83u,
  83u,
  166u,
  245u,
  209u,
  209u,
  185u,
  104u,
  0u,
  0u,
  0u,
  0u,
  237u,
  237u,
  193u,
  44u,
  32u,
  32u,
  64u,
  96u,
  252u,
  252u,
  227u,
  31u,
  177u,
  177u,
  121u,
  200u,
  91u,
  91u,
  182u,
  237u,
  106u,
  106u,
  212u,
  190u,
  203u,
  203u,
  141u,
  70u,
  190u,
  190u,
  103u,
  217u,
  57u,
  57u,
  114u,
  75u,
  74u,
  74u,
  148u,
  222u,
  76u,
  76u,
  152u,
  212u,
  88u,
  88u,
  176u,
  232u,
  207u,
  207u,
  133u,
  74u,
  208u,
  208u,
  187u,
  107u,
  239u,
  239u,
  197u,
  42u,
  170u,
  170u,
  79u,
  229u,
  251u,
  251u,
  237u,
  22u,
  67u,
  67u,
  134u,
  197u,
  77u,
  77u,
  154u,
  215u,
  51u,
  51u,
  102u,
  85u,
  133u,
  133u,
  17u,
  148u,
  69u,
  69u,
  138u,
  207u,
  249u,
  249u,
  233u,
  16u,
  2u,
  2u,
  4u,
  6u,
  127u,
  127u,
  254u,
  129u,
  80u,
  80u,
  160u,
  240u,
  60u,
  60u,
  120u,
  68u,
  159u,
  159u,
  37u,
  186u,
  168u,
  168u,
  75u,
  227u,
  81u,
  81u,
  162u,
  243u,
  163u,
  163u,
  93u,
  254u,
  64u,
  64u,
  128u,
  192u,
  143u,
  143u,
  5u,
  138u,
  146u,
  146u,
  63u,
  173u,
  157u,
  157u,
  33u,
  188u,
  56u,
  56u,
  112u,
  72u,
  245u,
  245u,
  241u,
  4u,
  188u,
  188u,
  99u,
  223u,
  182u,
  182u,
  119u,
  193u,
  218u,
  218u,
  175u,
  117u,
  33u,
  33u,
  66u,
  99u,
  16u,
  16u,
  32u,
  48u,
  255u,
  255u,
  229u,
  26u,
  243u,
  243u,
  253u,
  14u,
  210u,
  210u,
  191u,
  109u,
  205u,
  205u,
  129u,
  76u,
  12u,
  12u,
  24u,
  20u,
  19u,
  19u,
  38u,
  53u,
  236u,
  236u,
  195u,
  47u,
  95u,
  95u,
  190u,
  225u,
  151u,
  151u,
  53u,
  162u,
  68u,
  68u,
  136u,
  204u,
  23u,
  23u,
  46u,
  57u,
  196u,
  196u,
  147u,
  87u,
  167u,
  167u,
  85u,
  242u,
  126u,
  126u,
  252u,
  130u,
  61u,
  61u,
  122u,
  71u,
  100u,
  100u,
  200u,
  172u,
  93u,
  93u,
  186u,
  231u,
  25u,
  25u,
  50u,
  43u,
  115u,
  115u,
  230u,
  149u,
  96u,
  96u,
  192u,
  160u,
  129u,
  129u,
  25u,
  152u,
  79u,
  79u,
  158u,
  209u,
  220u,
  220u,
  163u,
  127u,
  34u,
  34u,
  68u,
  102u,
  42u,
  42u,
  84u,
  126u,
  144u,
  144u,
  59u,
  171u,
  136u,
  136u,
  11u,
  131u,
  70u,
  70u,
  140u,
  202u,
  238u,
  238u,
  199u,
  41u,
  184u,
  184u,
  107u,
  211u,
  20u,
  20u,
  40u,
  60u,
  222u,
  222u,
  167u,
  121u,
  94u,
  94u,
  188u,
  226u,
  11u,
  11u,
  22u,
  29u,
  219u,
  219u,
  173u,
  118u,
  224u,
  224u,
  219u,
  59u,
  50u,
  50u,
  100u,
  86u,
  58u,
  58u,
  116u,
  78u,
  10u,
  10u,
  20u,
  30u,
  73u,
  73u,
  146u,
  219u,
  6u,
  6u,
  12u,
  10u,
  36u,
  36u,
  72u,
  108u,
  92u,
  92u,
  184u,
  228u,
  194u,
  194u,
  159u,
  93u,
  211u,
  211u,
  189u,
  110u,
  172u,
  172u,
  67u,
  239u,
  98u,
  98u,
  196u,
  166u,
  145u,
  145u,
  57u,
  168u,
  149u,
  149u,
  49u,
  164u,
  228u,
  228u,
  211u,
  55u,
  121u,
  121u,
  242u,
  139u,
  231u,
  231u,
  213u,
  50u,
  200u,
  200u,
  139u,
  67u,
  55u,
  55u,
  110u,
  89u,
  109u,
  109u,
  218u,
  183u,
  141u,
  141u,
  1u,
  140u,
  213u,
  213u,
  177u,
  100u,
  78u,
  78u,
  156u,
  210u,
  169u,
  169u,
  73u,
  224u,
  108u,
  108u,
  216u,
  180u,
  86u,
  86u,
  172u,
  250u,
  244u,
  244u,
  243u,
  7u,
  234u,
  234u,
  207u,
  37u,
  101u,
  101u,
  202u,
  175u,
  122u,
  122u,
  244u,
  142u,
  174u,
  174u,
  71u,
  233u,
  8u,
  8u,
  16u,
  24u,
  186u,
  186u,
  111u,
  213u,
  120u,
  120u,
  240u,
  136u,
  37u,
  37u,
  74u,
  111u,
  46u,
  46u,
  92u,
  114u,
  28u,
  28u,
  56u,
  36u,
  166u,
  166u,
  87u,
  241u,
  180u,
  180u,
  115u,
  199u,
  198u,
  198u,
  151u,
  81u,
  232u,
  232u,
  203u,
  35u,
  221u,
  221u,
  161u,
  124u,
  116u,
  116u,
  232u,
  156u,
  31u,
  31u,
  62u,
  33u,
  75u,
  75u,
  150u,
  221u,
  189u,
  189u,
  97u,
  220u,
  139u,
  139u,
  13u,
  134u,
  138u,
  138u,
  15u,
  133u,
  112u,
  112u,
  224u,
  144u,
  62u,
  62u,
  124u,
  66u,
  181u,
  181u,
  113u,
  196u,
  102u,
  102u,
  204u,
  170u,
  72u,
  72u,
  144u,
  216u,
  3u,
  3u,
  6u,
  5u,
  246u,
  246u,
  247u,
  1u,
  14u,
  14u,
  28u,
  18u,
  97u,
  97u,
  194u,
  163u,
  53u,
  53u,
  106u,
  95u,
  87u,
  87u,
  174u,
  249u,
  185u,
  185u,
  105u,
  208u,
  134u,
  134u,
  23u,
  145u,
  193u,
  193u,
  153u,
  88u,
  29u,
  29u,
  58u,
  39u,
  158u,
  158u,
  39u,
  185u,
  225u,
  225u,
  217u,
  56u,
  248u,
  248u,
  235u,
  19u,
  152u,
  152u,
  43u,
  179u,
  17u,
  17u,
  34u,
  51u,
  105u,
  105u,
  210u,
  187u,
  217u,
  217u,
  169u,
  112u,
  142u,
  142u,
  7u,
  137u,
  148u,
  148u,
  51u,
  167u,
  155u,
  155u,
  45u,
  182u,
  30u,
  30u,
  60u,
  34u,
  135u,
  135u,
  21u,
  146u,
  233u,
  233u,
  201u,
  32u,
  206u,
  206u,
  135u,
  73u,
  85u,
  85u,
  170u,
  255u,
  40u,
  40u,
  80u,
  120u,
  223u,
  223u,
  165u,
  122u,
  140u,
  140u,
  3u,
  143u,
  161u,
  161u,
  89u,
  248u,
  137u,
  137u,
  9u,
  128u,
  13u,
  13u,
  26u,
  23u,
  191u,
  191u,
  101u,
  218u,
  230u,
  230u,
  215u,
  49u,
  66u,
  66u,
  132u,
  198u,
  104u,
  104u,
  208u,
  184u,
  65u,
  65u,
  130u,
  195u,
  153u,
  153u,
  41u,
  176u,
  45u,
  45u,
  90u,
  119u,
  15u,
  15u,
  30u,
  17u,
  176u,
  176u,
  123u,
  203u,
  84u,
  84u,
  168u,
  252u,
  187u,
  187u,
  109u,
  214u,
  22u,
  22u,
  44u,
  58u
}; // idb
_UNKNOWN unk_D5E4C; // weak
_DWORD dword_D5E74[256] =
{
  1374988112,
  2118214995,
  437757123,
  975658646,
  1001089995,
  530400753,
  2902087851,
  1273168787,
  540080725,
  2910219766,
  2295101073,
  4110568485,
  1340463100,
  3307916247,
  641025152,
  3043140495,
  3736164937,
  632953703,
  1172967064,
  1576976609,
  3274667266,
  2169303058,
  2370213795,
  1809054150,
  59727847,
  361929877,
  3211623147,
  2505202138,
  3569255213,
  1484005843,
  1239443753,
  2395588676,
  1975683434,
  4102977912,
  2572697195,
  666464733,
  3202437046,
  4035489047,
  3374361702,
  2110667444,
  1675577880,
  3843699074,
  2538681184,
  1649639237,
  2976151520,
  3144396420,
  4269907996,
  4178062228,
  1883793496,
  2403728665,
  2497604743,
  1383856311,
  2876494627,
  1917518562,
  3810496343,
  1716890410,
  3001755655,
  800440835,
  2261089178,
  3543599269,
  807962610,
  599762354,
  33778362,
  3977675356,
  2328828971,
  2809771154,
  4077384432,
  1315562145,
  1708848333,
  101039829,
  3509871135,
  3299278474,
  875451293,
  2733856160,
  92987698,
  2767645557,
  193195065,
  1080094634,
  1584504582,
  3178106961,
  1042385657,
  2531067453,
  3711829422,
  1306967366,
  2438237621,
  1908694277,
  67556463,
  1615861247,
  429456164,
  3602770327,
  2302690252,
  1742315127,
  2968011453,
  126454664,
  3877198648,
  2043211483,
  2709260871,
  2084704233,
  4169408201,
  0,
  159417987,
  841739592,
  504459436,
  1817866830,
  4245618683,
  260388950,
  1034867998,
  908933415,
  168810852,
  1750902305,
  2606453969,
  607530554,
  202008497,
  2472011535,
  3035535058,
  463180190,
  2160117071,
  1641816226,
  1517767529,
  470948374,
  3801332234,
  3231722213,
  1008918595,
  303765277,
  235474187,
  4069246893,
  766945465,
  337553864,
  1475418501,
  2943682380,
  4003061179,
  2743034109,
  4144047775,
  1551037884,
  1147550661,
  1543208500,
  2336434550,
  3408119516,
  3069049960,
  3102011747,
  3610369226,
  1113818384,
  328671808,
  2227573024,
  2236228733,
  3535486456,
  2935566865,
  3341394285,
  496906059,
  3702665459,
  226906860,
  2009195472,
  733156972,
  2842737049,
  294930682,
  1206477858,
  2835123396,
  2700099354,
  1451044056,
  573804783,
  2269728455,
  3644379585,
  2362090238,
  2564033334,
  2801107407,
  2776292904,
  3669462566,
  1068351396,
  742039012,
  1350078989,
  1784663195,
  1417561698,
  4136440770,
  2430122216,
  775550814,
  2193862645,
  2673705150,
  1775276924,
  1876241833,
  3475313331,
  3366754619,
  270040487,
  3902563182,
  3678124923,
  3441850377,
  1851332852,
  3969562369,
  2203032232,
  3868552805,
  2868897406,
  566021896,
  4011190502,
  3135740889,
  1248802510,
  3936291284,
  699432150,
  832877231,
  708780849,
  3332740144,
  899835584,
  1951317047,
  4236429990,
  3767586992,
  866637845,
  4043610186,
  1106041591,
  2144161806,
  395441711,
  1984812685,
  1139781709,
  3433712980,
  3835036895,
  2664543715,
  1282050075,
  3240894392,
  1181045119,
  2640243204,
  25965917,
  4203181171,
  4211818798,
  3009879386,
  2463879762,
  3910161971,
  1842759443,
  2597806476,
  933301370,
  1509430414,
  3943906441,
  3467192302,
  3076639029,
  3776767469,
  2051518780,
  2631065433,
  1441952575,
  404016761,
  1942435775,
  1408749034,
  1610459739,
  3745345300,
  2017778566,
  3400528769,
  3110650942,
  941896748,
  3265478751,
  371049330,
  3168937228,
  675039627,
  4279080257,
  967311729,
  135050206,
  3635733660,
  1683407248,
  2076935265,
  3576870512,
  1215061108,
  3501741890
}; // idb
_DWORD dword_D6274[256] =
{
  1347548327,
  1400783205,
  3273267108,
  2520393566,
  3409685355,
  4045380933,
  2880240216,
  2471224067,
  1428173050,
  4138563181,
  2441661558,
  636813900,
  4233094615,
  3620022987,
  2149987652,
  2411029155,
  1239331162,
  1730525723,
  2554718734,
  3781033664,
  46346101,
  310463728,
  2743944855,
  3328955385,
  3875770207,
  2501218972,
  3955191162,
  3667219033,
  768917123,
  3545789473,
  692707433,
  1150208456,
  1786102409,
  2029293177,
  1805211710,
  3710368113,
  3065962831,
  401639597,
  1724457132,
  3028143674,
  409198410,
  2196052529,
  1620529459,
  1164071807,
  3769721975,
  2226875310,
  486441376,
  2499348523,
  1483753576,
  428819965,
  2274680428,
  3075636216,
  598438867,
  3799141122,
  1474502543,
  711349675,
  129166120,
  53458370,
  2592523643,
  2782082824,
  4063242375,
  2988687269,
  3120694122,
  1559041666,
  730517276,
  2460449204,
  4042459122,
  2706270690,
  3446004468,
  3573941694,
  533804130,
  2328143614,
  2637442643,
  2695033685,
  839224033,
  1973745387,
  957055980,
  2856345839,
  106852767,
  1371368976,
  4181598602,
  1033297158,
  2933734917,
  1179510461,
  3046200461,
  91341917,
  1862534868,
  4284502037,
  605657339,
  2547432937,
  3431546947,
  2003294622,
  3182487618,
  2282195339,
  954669403,
  3682191598,
  1201765386,
  3917234703,
  3388507166,
  0,
  2198438022,
  1211247597,
  2887651696,
  1315723890,
  4227665663,
  1443857720,
  507358933,
  657861945,
  1678381017,
  560487590,
  3516619604,
  975451694,
  2970356327,
  261314535,
  3535072918,
  2652609425,
  1333838021,
  2724322336,
  1767536459,
  370938394,
  182621114,
  3854606378,
  1128014560,
  487725847,
  185469197,
  2918353863,
  3106780840,
  3356761769,
  2237133081,
  1286567175,
  3152976349,
  4255350624,
  2683765030,
  3160175349,
  3309594171,
  878443390,
  1988838185,
  3704300486,
  1756818940,
  1673061617,
  3403100636,
  272786309,
  1075025698,
  545572369,
  2105887268,
  4174560061,
  296679730,
  1841768865,
  1260232239,
  4091327024,
  3960309330,
  3497509347,
  1814803222,
  2578018489,
  4195456072,
  575138148,
  3299409036,
  446754879,
  3629546796,
  4011996048,
  3347532110,
  3252238545,
  4270639778,
  915985419,
  3483825537,
  681933534,
  651868046,
  2755636671,
  3828103837,
  223377554,
  2607439820,
  1649704518,
  3270937875,
  3901806776,
  1580087799,
  4118987695,
  3198115200,
  2087309459,
  2842678573,
  3016697106,
  1003007129,
  2802849917,
  1860738147,
  2077965243,
  164439672,
  4100872472,
  32283319,
  2827177882,
  1709610350,
  2125135846,
  136428751,
  3874428392,
  3652904859,
  3460984630,
  3572145929,
  3593056380,
  2939266226,
  824852259,
  818324884,
  3224740454,
  930369212,
  2801566410,
  2967507152,
  355706840,
  1257309336,
  4148292826,
  243256656,
  790073846,
  2373340630,
  1296297904,
  1422699085,
  3756299780,
  3818836405,
  457992840,
  3099667487,
  2135319889,
  77422314,
  1560382517,
  1945798516,
  788204353,
  1521706781,
  1385356242,
  870912086,
  325965383,
  2358957921,
  2050466060,
  2388260884,
  2313884476,
  4006521127,
  901210569,
  3990953189,
  1014646705,
  1503449823,
  1062597235,
  2031621326,
  3212035895,
  3931371469,
  1533017514,
  350174575,
  2256028891,
  2177544179,
  1052338372,
  741876788,
  1606591296,
  1914052035,
  213705253,
  2334669897,
  1107234197,
  1899603969,
  3725069491,
  2631447780,
  2422494913,
  1635502980,
  1893020342,
  1950903388,
  1120974935
}; // idb
_DWORD dword_D6674[256] =
{
  2807058932,
  1699970625,
  2764249623,
  1586903591,
  1808481195,
  1173430173,
  1487645946,
  59984867,
  4199882800,
  1844882806,
  1989249228,
  1277555970,
  3623636965,
  3419915562,
  1149249077,
  2744104290,
  1514790577,
  459744698,
  244860394,
  3235995134,
  1963115311,
  4027744588,
  2544078150,
  4190530515,
  1608975247,
  2627016082,
  2062270317,
  1507497298,
  2200818878,
  567498868,
  1764313568,
  3359936201,
  2305455554,
  2037970062,
  1047239000,
  1910319033,
  1337376481,
  2904027272,
  2892417312,
  984907214,
  1243112415,
  830661914,
  861968209,
  2135253587,
  2011214180,
  2927934315,
  2686254721,
  731183368,
  1750626376,
  4246310725,
  1820824798,
  4172763771,
  3542330227,
  48394827,
  2404901663,
  2871682645,
  671593195,
  3254988725,
  2073724613,
  145085239,
  2280796200,
  2779915199,
  1790575107,
  2187128086,
  472615631,
  3029510009,
  4075877127,
  3802222185,
  4107101658,
  3201631749,
  1646252340,
  4270507174,
  1402811438,
  1436590835,
  3778151818,
  3950355702,
  3963161475,
  4020912224,
  2667994737,
  273792366,
  2331590177,
  104699613,
  95345982,
  3175501286,
  2377486676,
  1560637892,
  3564045318,
  369057872,
  4213447064,
  3919042237,
  1137477952,
  2658625497,
  1119727848,
  2340947849,
  1530455833,
  4007360968,
  172466556,
  266959938,
  516552836,
  0,
  2256734592,
  3980931627,
  1890328081,
  1917742170,
  4294704398,
  945164165,
  3575528878,
  958871085,
  3647212047,
  2787207260,
  1423022939,
  775562294,
  1739656202,
  3876557655,
  2530391278,
  2443058075,
  3310321856,
  547512796,
  1265195639,
  437656594,
  3121275539,
  719700128,
  3762502690,
  387781147,
  218828297,
  3350065803,
  2830708150,
  2848461854,
  428169201,
  122466165,
  3720081049,
  1627235199,
  648017665,
  4122762354,
  1002783846,
  2117360635,
  695634755,
  3336358691,
  4234721005,
  4049844452,
  3704280881,
  2232435299,
  574624663,
  287343814,
  612205898,
  1039717051,
  840019705,
  2708326185,
  793451934,
  821288114,
  1391201670,
  3822090177,
  376187827,
  3113855344,
  1224348052,
  1679968233,
  2361698556,
  1058709744,
  752375421,
  2431590963,
  1321699145,
  3519142200,
  2734591178,
  188127444,
  2177869557,
  3727205754,
  2384911031,
  3215212461,
  2648976442,
  2450346104,
  3432737375,
  1180849278,
  331544205,
  3102249176,
  4150144569,
  2952102595,
  2159976285,
  2474404304,
  766078933,
  313773861,
  2570832044,
  2108100632,
  1668212892,
  3145456443,
  2013908262,
  418672217,
  3070356634,
  2594734927,
  1852171925,
  3867060991,
  3473416636,
  3907448597,
  2614737639,
  919489135,
  164948639,
  2094410160,
  2997825956,
  590424639,
  2486224549,
  1723872674,
  3157750862,
  3399941250,
  3501252752,
  3625268135,
  2555048196,
  3673637356,
  1343127501,
  4130281361,
  3599595085,
  2957853679,
  1297403050,
  81781910,
  3051593425,
  2283490410,
  532201772,
  1367295589,
  3926170974,
  895287692,
  1953757831,
  1093597963,
  492483431,
  3528626907,
  1446242576,
  1192455638,
  1636604631,
  209336225,
  344873464,
  1015671571,
  669961897,
  3375740769,
  3857572124,
  2973530695,
  3747192018,
  1933530610,
  3464042516,
  935293895,
  3454686199,
  2858115069,
  1863638845,
  3683022916,
  4085369519,
  3292445032,
  875313188,
  1080017571,
  3279033885,
  621591778,
  1233856572,
  2504130317,
  24197544,
  3017672716,
  3835484340,
  3247465558,
  2220981195,
  3060847922,
  1551124588,
  1463996600
}; // idb
_DWORD dword_D6A74[256] =
{
  4104605777,
  1097159550,
  396673818,
  660510266,
  2875968315,
  2638606623,
  4200115116,
  3808662347,
  821712160,
  1986918061,
  3430322568,
  38544885,
  3856137295,
  718002117,
  893681702,
  1654886325,
  2975484382,
  3122358053,
  3926825029,
  4274053469,
  796197571,
  1290801793,
  1184342925,
  3556361835,
  2405426947,
  2459735317,
  1836772287,
  1381620373,
  3196267988,
  1948373848,
  3764988233,
  3385345166,
  3263785589,
  2390325492,
  1480485785,
  3111247143,
  3780097726,
  2293045232,
  548169417,
  3459953789,
  3746175075,
  439452389,
  1362321559,
  1400849762,
  1685577905,
  1806599355,
  2174754046,
  137073913,
  1214797936,
  1174215055,
  3731654548,
  2079897426,
  1943217067,
  1258480242,
  529487843,
  1437280870,
  3945269170,
  3049390895,
  3313212038,
  923313619,
  679998000,
  3215307299,
  57326082,
  377642221,
  3474729866,
  2041877159,
  133361907,
  1776460110,
  3673476453,
  96392454,
  878845905,
  2801699524,
  777231668,
  4082475170,
  2330014213,
  4142626212,
  2213296395,
  1626319424,
  1906247262,
  1846563261,
  562755902,
  3708173718,
  1040559837,
  3871163981,
  1418573201,
  3294430577,
  114585348,
  1343618912,
  2566595609,
  3186202582,
  1078185097,
  3651041127,
  3896688048,
  2307622919,
  425408743,
  3371096953,
  2081048481,
  1108339068,
  2216610296,
  0,
  2156299017,
  736970802,
  292596766,
  1517440620,
  251657213,
  2235061775,
  2933202493,
  758720310,
  265905162,
  1554391400,
  1532285339,
  908999204,
  174567692,
  1474760595,
  4002861748,
  2610011675,
  3234156416,
  3693126241,
  2001430874,
  303699484,
  2478443234,
  2687165888,
  585122620,
  454499602,
  151849742,
  2345119218,
  3064510765,
  514443284,
  4044981591,
  1963412655,
  2581445614,
  2137062819,
  19308535,
  1928707164,
  1715193156,
  4219352155,
  1126790795,
  600235211,
  3992742070,
  3841024952,
  836553431,
  1669664834,
  2535604243,
  3323011204,
  1243905413,
  3141400786,
  4180808110,
  698445255,
  2653899549,
  2989552604,
  2253581325,
  3252932727,
  3004591147,
  1891211689,
  2487810577,
  3915653703,
  4237083816,
  4030667424,
  2100090966,
  865136418,
  1229899655,
  953270745,
  3399679628,
  3557504664,
  4118925222,
  2061379749,
  3079546586,
  2915017791,
  983426092,
  2022837584,
  1607244650,
  2118541908,
  2366882550,
  3635996816,
  972512814,
  3283088770,
  1568718495,
  3499326569,
  3576539503,
  621982671,
  2895723464,
  410887952,
  2623762152,
  1002142683,
  645401037,
  1494807662,
  2595684844,
  1335535747,
  2507040230,
  4293295786,
  3167684641,
  367585007,
  3885750714,
  1865862730,
  2668221674,
  2960971305,
  2763173681,
  1059270954,
  2777952454,
  2724642869,
  1320957812,
  2194319100,
  2429595872,
  2815956275,
  77089521,
  3973773121,
  3444575871,
  2448830231,
  1305906550,
  4021308739,
  2857194700,
  2516901860,
  3518358430,
  1787304780,
  740276417,
  1699839814,
  1592394909,
  2352307457,
  2272556026,
  188821243,
  1729977011,
  3687994002,
  274084841,
  3594982253,
  3613494426,
  2701949495,
  4162096729,
  322734571,
  2837966542,
  1640576439,
  484830689,
  1202797690,
  3537852828,
  4067639125,
  349075736,
  3342319475,
  4157467219,
  4255800159,
  1030690015,
  1155237496,
  2951971274,
  1757691577,
  607398968,
  2738905026,
  499347990,
  3794078908,
  1011452712,
  227885567,
  2818666809,
  213114376,
  3034881240,
  1455525988,
  3414450555,
  850817237,
  1817998408,
  3092726480
}; // idb
unsigned __int8 byte_D6E74[256] =
{
  82u,
  9u,
  106u,
  213u,
  48u,
  54u,
  165u,
  56u,
  191u,
  64u,
  163u,
  158u,
  129u,
  243u,
  215u,
  251u,
  124u,
  227u,
  57u,
  130u,
  155u,
  47u,
  255u,
  135u,
  52u,
  142u,
  67u,
  68u,
  196u,
  222u,
  233u,
  203u,
  84u,
  123u,
  148u,
  50u,
  166u,
  194u,
  35u,
  61u,
  238u,
  76u,
  149u,
  11u,
  66u,
  250u,
  195u,
  78u,
  8u,
  46u,
  161u,
  102u,
  40u,
  217u,
  36u,
  178u,
  118u,
  91u,
  162u,
  73u,
  109u,
  139u,
  209u,
  37u,
  114u,
  248u,
  246u,
  100u,
  134u,
  104u,
  152u,
  22u,
  212u,
  164u,
  92u,
  204u,
  93u,
  101u,
  182u,
  146u,
  108u,
  112u,
  72u,
  80u,
  253u,
  237u,
  185u,
  218u,
  94u,
  21u,
  70u,
  87u,
  167u,
  141u,
  157u,
  132u,
  144u,
  216u,
  171u,
  0u,
  140u,
  188u,
  211u,
  10u,
  247u,
  228u,
  88u,
  5u,
  184u,
  179u,
  69u,
  6u,
  208u,
  44u,
  30u,
  143u,
  202u,
  63u,
  15u,
  2u,
  193u,
  175u,
  189u,
  3u,
  1u,
  19u,
  138u,
  107u,
  58u,
  145u,
  17u,
  65u,
  79u,
  103u,
  220u,
  234u,
  151u,
  242u,
  207u,
  206u,
  240u,
  180u,
  230u,
  115u,
  150u,
  172u,
  116u,
  34u,
  231u,
  173u,
  53u,
  133u,
  226u,
  249u,
  55u,
  232u,
  28u,
  117u,
  223u,
  110u,
  71u,
  241u,
  26u,
  113u,
  29u,
  41u,
  197u,
  137u,
  111u,
  183u,
  98u,
  14u,
  170u,
  24u,
  190u,
  27u,
  252u,
  86u,
  62u,
  75u,
  198u,
  210u,
  121u,
  32u,
  154u,
  219u,
  192u,
  254u,
  120u,
  205u,
  90u,
  244u,
  31u,
  221u,
  168u,
  51u,
  136u,
  7u,
  199u,
  49u,
  177u,
  18u,
  16u,
  89u,
  39u,
  128u,
  236u,
  95u,
  96u,
  81u,
  127u,
  169u,
  25u,
  181u,
  74u,
  13u,
  45u,
  229u,
  122u,
  159u,
  147u,
  201u,
  156u,
  239u,
  160u,
  224u,
  59u,
  77u,
  174u,
  42u,
  245u,
  176u,
  200u,
  235u,
  187u,
  60u,
  131u,
  83u,
  153u,
  97u,
  23u,
  43u,
  4u,
  126u,
  186u,
  119u,
  214u,
  38u,
  225u,
  105u,
  20u,
  99u,
  85u,
  33u,
  12u,
  125u
}; // idb
_UNKNOWN unk_D7074; // weak
_UNKNOWN unk_D7081; // weak
_UNKNOWN unk_D70D8; // weak
_UNKNOWN unk_D7180; // weak
unsigned __int8 byte_D7220[256] =
{
  0u,
  1u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u
}; // idb
char a0123456789abcd[17] = "0123456789abcdef"; // weak
unsigned __int16 word_D73A8[2048] =
{
  2u,
  3u,
  5u,
  7u,
  11u,
  13u,
  17u,
  19u,
  23u,
  29u,
  31u,
  37u,
  41u,
  43u,
  47u,
  53u,
  59u,
  61u,
  67u,
  71u,
  73u,
  79u,
  83u,
  89u,
  97u,
  101u,
  103u,
  107u,
  109u,
  113u,
  127u,
  131u,
  137u,
  139u,
  149u,
  151u,
  157u,
  163u,
  167u,
  173u,
  179u,
  181u,
  191u,
  193u,
  197u,
  199u,
  211u,
  223u,
  227u,
  229u,
  233u,
  239u,
  241u,
  251u,
  257u,
  263u,
  269u,
  271u,
  277u,
  281u,
  283u,
  293u,
  307u,
  311u,
  313u,
  317u,
  331u,
  337u,
  347u,
  349u,
  353u,
  359u,
  367u,
  373u,
  379u,
  383u,
  389u,
  397u,
  401u,
  409u,
  419u,
  421u,
  431u,
  433u,
  439u,
  443u,
  449u,
  457u,
  461u,
  463u,
  467u,
  479u,
  487u,
  491u,
  499u,
  503u,
  509u,
  521u,
  523u,
  541u,
  547u,
  557u,
  563u,
  569u,
  571u,
  577u,
  587u,
  593u,
  599u,
  601u,
  607u,
  613u,
  617u,
  619u,
  631u,
  641u,
  643u,
  647u,
  653u,
  659u,
  661u,
  673u,
  677u,
  683u,
  691u,
  701u,
  709u,
  719u,
  727u,
  733u,
  739u,
  743u,
  751u,
  757u,
  761u,
  769u,
  773u,
  787u,
  797u,
  809u,
  811u,
  821u,
  823u,
  827u,
  829u,
  839u,
  853u,
  857u,
  859u,
  863u,
  877u,
  881u,
  883u,
  887u,
  907u,
  911u,
  919u,
  929u,
  937u,
  941u,
  947u,
  953u,
  967u,
  971u,
  977u,
  983u,
  991u,
  997u,
  1009u,
  1013u,
  1019u,
  1021u,
  1031u,
  1033u,
  1039u,
  1049u,
  1051u,
  1061u,
  1063u,
  1069u,
  1087u,
  1091u,
  1093u,
  1097u,
  1103u,
  1109u,
  1117u,
  1123u,
  1129u,
  1151u,
  1153u,
  1163u,
  1171u,
  1181u,
  1187u,
  1193u,
  1201u,
  1213u,
  1217u,
  1223u,
  1229u,
  1231u,
  1237u,
  1249u,
  1259u,
  1277u,
  1279u,
  1283u,
  1289u,
  1291u,
  1297u,
  1301u,
  1303u,
  1307u,
  1319u,
  1321u,
  1327u,
  1361u,
  1367u,
  1373u,
  1381u,
  1399u,
  1409u,
  1423u,
  1427u,
  1429u,
  1433u,
  1439u,
  1447u,
  1451u,
  1453u,
  1459u,
  1471u,
  1481u,
  1483u,
  1487u,
  1489u,
  1493u,
  1499u,
  1511u,
  1523u,
  1531u,
  1543u,
  1549u,
  1553u,
  1559u,
  1567u,
  1571u,
  1579u,
  1583u,
  1597u,
  1601u,
  1607u,
  1609u,
  1613u,
  1619u,
  1621u,
  1627u,
  1637u,
  1657u,
  1663u,
  1667u,
  1669u,
  1693u,
  1697u,
  1699u,
  1709u,
  1721u,
  1723u,
  1733u,
  1741u,
  1747u,
  1753u,
  1759u,
  1777u,
  1783u,
  1787u,
  1789u,
  1801u,
  1811u,
  1823u,
  1831u,
  1847u,
  1861u,
  1867u,
  1871u,
  1873u,
  1877u,
  1879u,
  1889u,
  1901u,
  1907u,
  1913u,
  1931u,
  1933u,
  1949u,
  1951u,
  1973u,
  1979u,
  1987u,
  1993u,
  1997u,
  1999u,
  2003u,
  2011u,
  2017u,
  2027u,
  2029u,
  2039u,
  2053u,
  2063u,
  2069u,
  2081u,
  2083u,
  2087u,
  2089u,
  2099u,
  2111u,
  2113u,
  2129u,
  2131u,
  2137u,
  2141u,
  2143u,
  2153u,
  2161u,
  2179u,
  2203u,
  2207u,
  2213u,
  2221u,
  2237u,
  2239u,
  2243u,
  2251u,
  2267u,
  2269u,
  2273u,
  2281u,
  2287u,
  2293u,
  2297u,
  2309u,
  2311u,
  2333u,
  2339u,
  2341u,
  2347u,
  2351u,
  2357u,
  2371u,
  2377u,
  2381u,
  2383u,
  2389u,
  2393u,
  2399u,
  2411u,
  2417u,
  2423u,
  2437u,
  2441u,
  2447u,
  2459u,
  2467u,
  2473u,
  2477u,
  2503u,
  2521u,
  2531u,
  2539u,
  2543u,
  2549u,
  2551u,
  2557u,
  2579u,
  2591u,
  2593u,
  2609u,
  2617u,
  2621u,
  2633u,
  2647u,
  2657u,
  2659u,
  2663u,
  2671u,
  2677u,
  2683u,
  2687u,
  2689u,
  2693u,
  2699u,
  2707u,
  2711u,
  2713u,
  2719u,
  2729u,
  2731u,
  2741u,
  2749u,
  2753u,
  2767u,
  2777u,
  2789u,
  2791u,
  2797u,
  2801u,
  2803u,
  2819u,
  2833u,
  2837u,
  2843u,
  2851u,
  2857u,
  2861u,
  2879u,
  2887u,
  2897u,
  2903u,
  2909u,
  2917u,
  2927u,
  2939u,
  2953u,
  2957u,
  2963u,
  2969u,
  2971u,
  2999u,
  3001u,
  3011u,
  3019u,
  3023u,
  3037u,
  3041u,
  3049u,
  3061u,
  3067u,
  3079u,
  3083u,
  3089u,
  3109u,
  3119u,
  3121u,
  3137u,
  3163u,
  3167u,
  3169u,
  3181u,
  3187u,
  3191u,
  3203u,
  3209u,
  3217u,
  3221u,
  3229u,
  3251u,
  3253u,
  3257u,
  3259u,
  3271u,
  3299u,
  3301u,
  3307u,
  3313u,
  3319u,
  3323u,
  3329u,
  3331u,
  3343u,
  3347u,
  3359u,
  3361u,
  3371u,
  3373u,
  3389u,
  3391u,
  3407u,
  3413u,
  3433u,
  3449u,
  3457u,
  3461u,
  3463u,
  3467u,
  3469u,
  3491u,
  3499u,
  3511u,
  3517u,
  3527u,
  3529u,
  3533u,
  3539u,
  3541u,
  3547u,
  3557u,
  3559u,
  3571u,
  3581u,
  3583u,
  3593u,
  3607u,
  3613u,
  3617u,
  3623u,
  3631u,
  3637u,
  3643u,
  3659u,
  3671u,
  3673u,
  3677u,
  3691u,
  3697u,
  3701u,
  3709u,
  3719u,
  3727u,
  3733u,
  3739u,
  3761u,
  3767u,
  3769u,
  3779u,
  3793u,
  3797u,
  3803u,
  3821u,
  3823u,
  3833u,
  3847u,
  3851u,
  3853u,
  3863u,
  3877u,
  3881u,
  3889u,
  3907u,
  3911u,
  3917u,
  3919u,
  3923u,
  3929u,
  3931u,
  3943u,
  3947u,
  3967u,
  3989u,
  4001u,
  4003u,
  4007u,
  4013u,
  4019u,
  4021u,
  4027u,
  4049u,
  4051u,
  4057u,
  4073u,
  4079u,
  4091u,
  4093u,
  4099u,
  4111u,
  4127u,
  4129u,
  4133u,
  4139u,
  4153u,
  4157u,
  4159u,
  4177u,
  4201u,
  4211u,
  4217u,
  4219u,
  4229u,
  4231u,
  4241u,
  4243u,
  4253u,
  4259u,
  4261u,
  4271u,
  4273u,
  4283u,
  4289u,
  4297u,
  4327u,
  4337u,
  4339u,
  4349u,
  4357u,
  4363u,
  4373u,
  4391u,
  4397u,
  4409u,
  4421u,
  4423u,
  4441u,
  4447u,
  4451u,
  4457u,
  4463u,
  4481u,
  4483u,
  4493u,
  4507u,
  4513u,
  4517u,
  4519u,
  4523u,
  4547u,
  4549u,
  4561u,
  4567u,
  4583u,
  4591u,
  4597u,
  4603u,
  4621u,
  4637u,
  4639u,
  4643u,
  4649u,
  4651u,
  4657u,
  4663u,
  4673u,
  4679u,
  4691u,
  4703u,
  4721u,
  4723u,
  4729u,
  4733u,
  4751u,
  4759u,
  4783u,
  4787u,
  4789u,
  4793u,
  4799u,
  4801u,
  4813u,
  4817u,
  4831u,
  4861u,
  4871u,
  4877u,
  4889u,
  4903u,
  4909u,
  4919u,
  4931u,
  4933u,
  4937u,
  4943u,
  4951u,
  4957u,
  4967u,
  4969u,
  4973u,
  4987u,
  4993u,
  4999u,
  5003u,
  5009u,
  5011u,
  5021u,
  5023u,
  5039u,
  5051u,
  5059u,
  5077u,
  5081u,
  5087u,
  5099u,
  5101u,
  5107u,
  5113u,
  5119u,
  5147u,
  5153u,
  5167u,
  5171u,
  5179u,
  5189u,
  5197u,
  5209u,
  5227u,
  5231u,
  5233u,
  5237u,
  5261u,
  5273u,
  5279u,
  5281u,
  5297u,
  5303u,
  5309u,
  5323u,
  5333u,
  5347u,
  5351u,
  5381u,
  5387u,
  5393u,
  5399u,
  5407u,
  5413u,
  5417u,
  5419u,
  5431u,
  5437u,
  5441u,
  5443u,
  5449u,
  5471u,
  5477u,
  5479u,
  5483u,
  5501u,
  5503u,
  5507u,
  5519u,
  5521u,
  5527u,
  5531u,
  5557u,
  5563u,
  5569u,
  5573u,
  5581u,
  5591u,
  5623u,
  5639u,
  5641u,
  5647u,
  5651u,
  5653u,
  5657u,
  5659u,
  5669u,
  5683u,
  5689u,
  5693u,
  5701u,
  5711u,
  5717u,
  5737u,
  5741u,
  5743u,
  5749u,
  5779u,
  5783u,
  5791u,
  5801u,
  5807u,
  5813u,
  5821u,
  5827u,
  5839u,
  5843u,
  5849u,
  5851u,
  5857u,
  5861u,
  5867u,
  5869u,
  5879u,
  5881u,
  5897u,
  5903u,
  5923u,
  5927u,
  5939u,
  5953u,
  5981u,
  5987u,
  6007u,
  6011u,
  6029u,
  6037u,
  6043u,
  6047u,
  6053u,
  6067u,
  6073u,
  6079u,
  6089u,
  6091u,
  6101u,
  6113u,
  6121u,
  6131u,
  6133u,
  6143u,
  6151u,
  6163u,
  6173u,
  6197u,
  6199u,
  6203u,
  6211u,
  6217u,
  6221u,
  6229u,
  6247u,
  6257u,
  6263u,
  6269u,
  6271u,
  6277u,
  6287u,
  6299u,
  6301u,
  6311u,
  6317u,
  6323u,
  6329u,
  6337u,
  6343u,
  6353u,
  6359u,
  6361u,
  6367u,
  6373u,
  6379u,
  6389u,
  6397u,
  6421u,
  6427u,
  6449u,
  6451u,
  6469u,
  6473u,
  6481u,
  6491u,
  6521u,
  6529u,
  6547u,
  6551u,
  6553u,
  6563u,
  6569u,
  6571u,
  6577u,
  6581u,
  6599u,
  6607u,
  6619u,
  6637u,
  6653u,
  6659u,
  6661u,
  6673u,
  6679u,
  6689u,
  6691u,
  6701u,
  6703u,
  6709u,
  6719u,
  6733u,
  6737u,
  6761u,
  6763u,
  6779u,
  6781u,
  6791u,
  6793u,
  6803u,
  6823u,
  6827u,
  6829u,
  6833u,
  6841u,
  6857u,
  6863u,
  6869u,
  6871u,
  6883u,
  6899u,
  6907u,
  6911u,
  6917u,
  6947u,
  6949u,
  6959u,
  6961u,
  6967u,
  6971u,
  6977u,
  6983u,
  6991u,
  6997u,
  7001u,
  7013u,
  7019u,
  7027u,
  7039u,
  7043u,
  7057u,
  7069u,
  7079u,
  7103u,
  7109u,
  7121u,
  7127u,
  7129u,
  7151u,
  7159u,
  7177u,
  7187u,
  7193u,
  7207u,
  7211u,
  7213u,
  7219u,
  7229u,
  7237u,
  7243u,
  7247u,
  7253u,
  7283u,
  7297u,
  7307u,
  7309u,
  7321u,
  7331u,
  7333u,
  7349u,
  7351u,
  7369u,
  7393u,
  7411u,
  7417u,
  7433u,
  7451u,
  7457u,
  7459u,
  7477u,
  7481u,
  7487u,
  7489u,
  7499u,
  7507u,
  7517u,
  7523u,
  7529u,
  7537u,
  7541u,
  7547u,
  7549u,
  7559u,
  7561u,
  7573u,
  7577u,
  7583u,
  7589u,
  7591u,
  7603u,
  7607u,
  7621u,
  7639u,
  7643u,
  7649u,
  7669u,
  7673u,
  7681u,
  7687u,
  7691u,
  7699u,
  7703u,
  7717u,
  7723u,
  7727u,
  7741u,
  7753u,
  7757u,
  7759u,
  7789u,
  7793u,
  7817u,
  7823u,
  7829u,
  7841u,
  7853u,
  7867u,
  7873u,
  7877u,
  7879u,
  7883u,
  7901u,
  7907u,
  7919u,
  7927u,
  7933u,
  7937u,
  7949u,
  7951u,
  7963u,
  7993u,
  8009u,
  8011u,
  8017u,
  8039u,
  8053u,
  8059u,
  8069u,
  8081u,
  8087u,
  8089u,
  8093u,
  8101u,
  8111u,
  8117u,
  8123u,
  8147u,
  8161u,
  8167u,
  8171u,
  8179u,
  8191u,
  8209u,
  8219u,
  8221u,
  8231u,
  8233u,
  8237u,
  8243u,
  8263u,
  8269u,
  8273u,
  8287u,
  8291u,
  8293u,
  8297u,
  8311u,
  8317u,
  8329u,
  8353u,
  8363u,
  8369u,
  8377u,
  8387u,
  8389u,
  8419u,
  8423u,
  8429u,
  8431u,
  8443u,
  8447u,
  8461u,
  8467u,
  8501u,
  8513u,
  8521u,
  8527u,
  8537u,
  8539u,
  8543u,
  8563u,
  8573u,
  8581u,
  8597u,
  8599u,
  8609u,
  8623u,
  8627u,
  8629u,
  8641u,
  8647u,
  8663u,
  8669u,
  8677u,
  8681u,
  8689u,
  8693u,
  8699u,
  8707u,
  8713u,
  8719u,
  8731u,
  8737u,
  8741u,
  8747u,
  8753u,
  8761u,
  8779u,
  8783u,
  8803u,
  8807u,
  8819u,
  8821u,
  8831u,
  8837u,
  8839u,
  8849u,
  8861u,
  8863u,
  8867u,
  8887u,
  8893u,
  8923u,
  8929u,
  8933u,
  8941u,
  8951u,
  8963u,
  8969u,
  8971u,
  8999u,
  9001u,
  9007u,
  9011u,
  9013u,
  9029u,
  9041u,
  9043u,
  9049u,
  9059u,
  9067u,
  9091u,
  9103u,
  9109u,
  9127u,
  9133u,
  9137u,
  9151u,
  9157u,
  9161u,
  9173u,
  9181u,
  9187u,
  9199u,
  9203u,
  9209u,
  9221u,
  9227u,
  9239u,
  9241u,
  9257u,
  9277u,
  9281u,
  9283u,
  9293u,
  9311u,
  9319u,
  9323u,
  9337u,
  9341u,
  9343u,
  9349u,
  9371u,
  9377u,
  9391u,
  9397u,
  9403u,
  9413u,
  9419u,
  9421u,
  9431u,
  9433u,
  9437u,
  9439u,
  9461u,
  9463u,
  9467u,
  9473u,
  9479u,
  9491u,
  9497u,
  9511u,
  9521u,
  9533u,
  9539u,
  9547u,
  9551u,
  9587u,
  9601u,
  9613u,
  9619u,
  9623u,
  9629u,
  9631u,
  9643u,
  9649u,
  9661u,
  9677u,
  9679u,
  9689u,
  9697u,
  9719u,
  9721u,
  9733u,
  9739u,
  9743u,
  9749u,
  9767u,
  9769u,
  9781u,
  9787u,
  9791u,
  9803u,
  9811u,
  9817u,
  9829u,
  9833u,
  9839u,
  9851u,
  9857u,
  9859u,
  9871u,
  9883u,
  9887u,
  9901u,
  9907u,
  9923u,
  9929u,
  9931u,
  9941u,
  9949u,
  9967u,
  9973u,
  10007u,
  10009u,
  10037u,
  10039u,
  10061u,
  10067u,
  10069u,
  10079u,
  10091u,
  10093u,
  10099u,
  10103u,
  10111u,
  10133u,
  10139u,
  10141u,
  10151u,
  10159u,
  10163u,
  10169u,
  10177u,
  10181u,
  10193u,
  10211u,
  10223u,
  10243u,
  10247u,
  10253u,
  10259u,
  10267u,
  10271u,
  10273u,
  10289u,
  10301u,
  10303u,
  10313u,
  10321u,
  10331u,
  10333u,
  10337u,
  10343u,
  10357u,
  10369u,
  10391u,
  10399u,
  10427u,
  10429u,
  10433u,
  10453u,
  10457u,
  10459u,
  10463u,
  10477u,
  10487u,
  10499u,
  10501u,
  10513u,
  10529u,
  10531u,
  10559u,
  10567u,
  10589u,
  10597u,
  10601u,
  10607u,
  10613u,
  10627u,
  10631u,
  10639u,
  10651u,
  10657u,
  10663u,
  10667u,
  10687u,
  10691u,
  10709u,
  10711u,
  10723u,
  10729u,
  10733u,
  10739u,
  10753u,
  10771u,
  10781u,
  10789u,
  10799u,
  10831u,
  10837u,
  10847u,
  10853u,
  10859u,
  10861u,
  10867u,
  10883u,
  10889u,
  10891u,
  10903u,
  10909u,
  10937u,
  10939u,
  10949u,
  10957u,
  10973u,
  10979u,
  10987u,
  10993u,
  11003u,
  11027u,
  11047u,
  11057u,
  11059u,
  11069u,
  11071u,
  11083u,
  11087u,
  11093u,
  11113u,
  11117u,
  11119u,
  11131u,
  11149u,
  11159u,
  11161u,
  11171u,
  11173u,
  11177u,
  11197u,
  11213u,
  11239u,
  11243u,
  11251u,
  11257u,
  11261u,
  11273u,
  11279u,
  11287u,
  11299u,
  11311u,
  11317u,
  11321u,
  11329u,
  11351u,
  11353u,
  11369u,
  11383u,
  11393u,
  11399u,
  11411u,
  11423u,
  11437u,
  11443u,
  11447u,
  11467u,
  11471u,
  11483u,
  11489u,
  11491u,
  11497u,
  11503u,
  11519u,
  11527u,
  11549u,
  11551u,
  11579u,
  11587u,
  11593u,
  11597u,
  11617u,
  11621u,
  11633u,
  11657u,
  11677u,
  11681u,
  11689u,
  11699u,
  11701u,
  11717u,
  11719u,
  11731u,
  11743u,
  11777u,
  11779u,
  11783u,
  11789u,
  11801u,
  11807u,
  11813u,
  11821u,
  11827u,
  11831u,
  11833u,
  11839u,
  11863u,
  11867u,
  11887u,
  11897u,
  11903u,
  11909u,
  11923u,
  11927u,
  11933u,
  11939u,
  11941u,
  11953u,
  11959u,
  11969u,
  11971u,
  11981u,
  11987u,
  12007u,
  12011u,
  12037u,
  12041u,
  12043u,
  12049u,
  12071u,
  12073u,
  12097u,
  12101u,
  12107u,
  12109u,
  12113u,
  12119u,
  12143u,
  12149u,
  12157u,
  12161u,
  12163u,
  12197u,
  12203u,
  12211u,
  12227u,
  12239u,
  12241u,
  12251u,
  12253u,
  12263u,
  12269u,
  12277u,
  12281u,
  12289u,
  12301u,
  12323u,
  12329u,
  12343u,
  12347u,
  12373u,
  12377u,
  12379u,
  12391u,
  12401u,
  12409u,
  12413u,
  12421u,
  12433u,
  12437u,
  12451u,
  12457u,
  12473u,
  12479u,
  12487u,
  12491u,
  12497u,
  12503u,
  12511u,
  12517u,
  12527u,
  12539u,
  12541u,
  12547u,
  12553u,
  12569u,
  12577u,
  12583u,
  12589u,
  12601u,
  12611u,
  12613u,
  12619u,
  12637u,
  12641u,
  12647u,
  12653u,
  12659u,
  12671u,
  12689u,
  12697u,
  12703u,
  12713u,
  12721u,
  12739u,
  12743u,
  12757u,
  12763u,
  12781u,
  12791u,
  12799u,
  12809u,
  12821u,
  12823u,
  12829u,
  12841u,
  12853u,
  12889u,
  12893u,
  12899u,
  12907u,
  12911u,
  12917u,
  12919u,
  12923u,
  12941u,
  12953u,
  12959u,
  12967u,
  12973u,
  12979u,
  12983u,
  13001u,
  13003u,
  13007u,
  13009u,
  13033u,
  13037u,
  13043u,
  13049u,
  13063u,
  13093u,
  13099u,
  13103u,
  13109u,
  13121u,
  13127u,
  13147u,
  13151u,
  13159u,
  13163u,
  13171u,
  13177u,
  13183u,
  13187u,
  13217u,
  13219u,
  13229u,
  13241u,
  13249u,
  13259u,
  13267u,
  13291u,
  13297u,
  13309u,
  13313u,
  13327u,
  13331u,
  13337u,
  13339u,
  13367u,
  13381u,
  13397u,
  13399u,
  13411u,
  13417u,
  13421u,
  13441u,
  13451u,
  13457u,
  13463u,
  13469u,
  13477u,
  13487u,
  13499u,
  13513u,
  13523u,
  13537u,
  13553u,
  13567u,
  13577u,
  13591u,
  13597u,
  13613u,
  13619u,
  13627u,
  13633u,
  13649u,
  13669u,
  13679u,
  13681u,
  13687u,
  13691u,
  13693u,
  13697u,
  13709u,
  13711u,
  13721u,
  13723u,
  13729u,
  13751u,
  13757u,
  13759u,
  13763u,
  13781u,
  13789u,
  13799u,
  13807u,
  13829u,
  13831u,
  13841u,
  13859u,
  13873u,
  13877u,
  13879u,
  13883u,
  13901u,
  13903u,
  13907u,
  13913u,
  13921u,
  13931u,
  13933u,
  13963u,
  13967u,
  13997u,
  13999u,
  14009u,
  14011u,
  14029u,
  14033u,
  14051u,
  14057u,
  14071u,
  14081u,
  14083u,
  14087u,
  14107u,
  14143u,
  14149u,
  14153u,
  14159u,
  14173u,
  14177u,
  14197u,
  14207u,
  14221u,
  14243u,
  14249u,
  14251u,
  14281u,
  14293u,
  14303u,
  14321u,
  14323u,
  14327u,
  14341u,
  14347u,
  14369u,
  14387u,
  14389u,
  14401u,
  14407u,
  14411u,
  14419u,
  14423u,
  14431u,
  14437u,
  14447u,
  14449u,
  14461u,
  14479u,
  14489u,
  14503u,
  14519u,
  14533u,
  14537u,
  14543u,
  14549u,
  14551u,
  14557u,
  14561u,
  14563u,
  14591u,
  14593u,
  14621u,
  14627u,
  14629u,
  14633u,
  14639u,
  14653u,
  14657u,
  14669u,
  14683u,
  14699u,
  14713u,
  14717u,
  14723u,
  14731u,
  14737u,
  14741u,
  14747u,
  14753u,
  14759u,
  14767u,
  14771u,
  14779u,
  14783u,
  14797u,
  14813u,
  14821u,
  14827u,
  14831u,
  14843u,
  14851u,
  14867u,
  14869u,
  14879u,
  14887u,
  14891u,
  14897u,
  14923u,
  14929u,
  14939u,
  14947u,
  14951u,
  14957u,
  14969u,
  14983u,
  15013u,
  15017u,
  15031u,
  15053u,
  15061u,
  15073u,
  15077u,
  15083u,
  15091u,
  15101u,
  15107u,
  15121u,
  15131u,
  15137u,
  15139u,
  15149u,
  15161u,
  15173u,
  15187u,
  15193u,
  15199u,
  15217u,
  15227u,
  15233u,
  15241u,
  15259u,
  15263u,
  15269u,
  15271u,
  15277u,
  15287u,
  15289u,
  15299u,
  15307u,
  15313u,
  15319u,
  15329u,
  15331u,
  15349u,
  15359u,
  15361u,
  15373u,
  15377u,
  15383u,
  15391u,
  15401u,
  15413u,
  15427u,
  15439u,
  15443u,
  15451u,
  15461u,
  15467u,
  15473u,
  15493u,
  15497u,
  15511u,
  15527u,
  15541u,
  15551u,
  15559u,
  15569u,
  15581u,
  15583u,
  15601u,
  15607u,
  15619u,
  15629u,
  15641u,
  15643u,
  15647u,
  15649u,
  15661u,
  15667u,
  15671u,
  15679u,
  15683u,
  15727u,
  15731u,
  15733u,
  15737u,
  15739u,
  15749u,
  15761u,
  15767u,
  15773u,
  15787u,
  15791u,
  15797u,
  15803u,
  15809u,
  15817u,
  15823u,
  15859u,
  15877u,
  15881u,
  15887u,
  15889u,
  15901u,
  15907u,
  15913u,
  15919u,
  15923u,
  15937u,
  15959u,
  15971u,
  15973u,
  15991u,
  16001u,
  16007u,
  16033u,
  16057u,
  16061u,
  16063u,
  16067u,
  16069u,
  16073u,
  16087u,
  16091u,
  16097u,
  16103u,
  16111u,
  16127u,
  16139u,
  16141u,
  16183u,
  16187u,
  16189u,
  16193u,
  16217u,
  16223u,
  16229u,
  16231u,
  16249u,
  16253u,
  16267u,
  16273u,
  16301u,
  16319u,
  16333u,
  16339u,
  16349u,
  16361u,
  16363u,
  16369u,
  16381u,
  16411u,
  16417u,
  16421u,
  16427u,
  16433u,
  16447u,
  16451u,
  16453u,
  16477u,
  16481u,
  16487u,
  16493u,
  16519u,
  16529u,
  16547u,
  16553u,
  16561u,
  16567u,
  16573u,
  16603u,
  16607u,
  16619u,
  16631u,
  16633u,
  16649u,
  16651u,
  16657u,
  16661u,
  16673u,
  16691u,
  16693u,
  16699u,
  16703u,
  16729u,
  16741u,
  16747u,
  16759u,
  16763u,
  16787u,
  16811u,
  16823u,
  16829u,
  16831u,
  16843u,
  16871u,
  16879u,
  16883u,
  16889u,
  16901u,
  16903u,
  16921u,
  16927u,
  16931u,
  16937u,
  16943u,
  16963u,
  16979u,
  16981u,
  16987u,
  16993u,
  17011u,
  17021u,
  17027u,
  17029u,
  17033u,
  17041u,
  17047u,
  17053u,
  17077u,
  17093u,
  17099u,
  17107u,
  17117u,
  17123u,
  17137u,
  17159u,
  17167u,
  17183u,
  17189u,
  17191u,
  17203u,
  17207u,
  17209u,
  17231u,
  17239u,
  17257u,
  17291u,
  17293u,
  17299u,
  17317u,
  17321u,
  17327u,
  17333u,
  17341u,
  17351u,
  17359u,
  17377u,
  17383u,
  17387u,
  17389u,
  17393u,
  17401u,
  17417u,
  17419u,
  17431u,
  17443u,
  17449u,
  17467u,
  17471u,
  17477u,
  17483u,
  17489u,
  17491u,
  17497u,
  17509u,
  17519u,
  17539u,
  17551u,
  17569u,
  17573u,
  17579u,
  17581u,
  17597u,
  17599u,
  17609u,
  17623u,
  17627u,
  17657u,
  17659u,
  17669u,
  17681u,
  17683u,
  17707u,
  17713u,
  17729u,
  17737u,
  17747u,
  17749u,
  17761u,
  17783u,
  17789u,
  17791u,
  17807u,
  17827u,
  17837u,
  17839u,
  17851u,
  17863u
}; // idb
_UNKNOWN unk_D83A8; // weak
_UNKNOWN unk_D8FB0; // weak
_UNKNOWN unk_D9D60; // weak
_UNKNOWN unk_DAC0C; // weak
_UNKNOWN unk_DD494; // weak
_DWORD dword_DD4DC[9] = { 0, 0, 1, 1, 0, 0, 0, 0, 0 }; // idb
_DWORD dword_DD500[10] = { 99, 99, 12, 31, 23, 59, 59, 12, 59, 0 }; // idb
_UNKNOWN unk_DD528; // weak
_QWORD qword_DD8D0[32] =
{
  0LL,
  0LL,
  0LL,
  1024LL,
  512LL,
  0LL,
  0LL,
  4096LL,
  4096LL,
  4096LL,
  4096LL,
  4096LL,
  8192LL,
  4096LL,
  4096LL,
  4096LL,
  65536LL,
  0LL,
  1LL,
  2LL,
  4LL,
  8LL,
  16LL,
  16384LL,
  32768LL,
  32LL,
  64LL,
  128LL,
  256LL,
  4096LL,
  2048LL,
  4096LL
}; // idb
_UNKNOWN unk_DDB5C; // weak
_UNKNOWN unk_DDB65; // weak
char byte_DDBB4[31] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\x01',
  '\x01',
  '\xFF',
  '\x01',
  '\x01',
  '\x01',
  '\xFF',
  '\x01',
  '\xFF',
  '\x04',
  '\xFF',
  '\x02'
}; // idb
_BYTE byte_DDBD3[129] =
{
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  120,
  0,
  1,
  40,
  0,
  0,
  0,
  16,
  16,
  16,
  0,
  25,
  25,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  9,
  9,
  16,
  9,
  16,
  0,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  0,
  1,
  0,
  0,
  0,
  0,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  0,
  0,
  0,
  0,
  2,
  0
}; // idb
_DWORD dword_DDD10[27] =
{
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1
}; // idb
_UNKNOWN unk_DDDB8; // weak
int dword_DDDC0 = 6; // weak
_UNKNOWN unk_DDFB8; // weak
_UNKNOWN unk_DDFC1; // weak
_UNKNOWN unk_DDFCA; // weak
unsigned __int8 _clz_tab[256] =
{
  0u,
  1u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u
}; // idb
_UNKNOWN unk_F6180; // weak
_UNKNOWN unk_F6190; // weak
_UNKNOWN unk_F61A8; // weak
__int64 (__fastcall *off_F61D8[2])() = { &sub_34A48, &sub_34BA4 }; // weak
__int64 (__fastcall *off_F6200[2])() = { &sub_34AB4, &sub_34C18 }; // weak
__int64 (__fastcall *off_F6250[2])() =
{
  &`virtual thunk to'std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream,
  &`virtual thunk to'std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream
}; // weak
__int64 (__fastcall *off_F6270[14])() =
{
  &sub_34C9C,
  &sub_34CEC,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf,
  &sub_34D48,
  &sub_34EA8,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::sync,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::showmanyc,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsgetn,
  &sub_34F8C,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::uflow,
  &sub_3502C,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsputn,
  &sub_35168
}; // weak
__int64 (__fastcall *off_F62F0[14])() =
{
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::~basic_streambuf,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::~basic_streambuf,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::seekpos,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::seekpos,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::sync,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::showmanyc,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsgetn,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::underflow,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::uflow,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::underflow,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsputn,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::underflow
}; // weak
char *off_F6360[6] =
{
  "com.sonymobile.security.appid.1",
  "Sony-Mobile-Device-Unique-1",
  "CORE_KEY_11",
  "com.sonymobile.security.appid.1",
  "Sony-Mobile-Device-Unique-2",
  "CORE_KEY_12"
}; // weak
void *off_F6390 = &unk_F63B8; // weak
long double byte_F63A0 = ?flt; // idb
_UNKNOWN unk_F64F0; // weak
_UNKNOWN unk_F6530; // weak
_UNKNOWN unk_F6570; // weak
_UNKNOWN unk_F65B0; // weak
_UNKNOWN unk_F65F0; // weak
_UNKNOWN unk_F6630; // weak
_UNKNOWN unk_F6670; // weak
_UNKNOWN unk_F66B0; // weak
_UNKNOWN unk_F66F0; // weak
_UNKNOWN unk_F6730; // weak
_UNKNOWN unk_F6770; // weak
_UNKNOWN unk_F67B0; // weak
_UNKNOWN unk_F67F0; // weak
_UNKNOWN unk_F6830; // weak
_UNKNOWN unk_F6870; // weak
_UNKNOWN unk_F68A8; // weak
_UNKNOWN unk_F68E0; // weak
_UNKNOWN unk_F6918; // weak
_UNKNOWN unk_F6950; // weak
_UNKNOWN unk_F6990; // weak
_UNKNOWN unk_F69D0; // weak
_UNKNOWN unk_F6A10; // weak
_UNKNOWN unk_F6A50; // weak
_UNKNOWN unk_F6A90; // weak
_UNKNOWN unk_F6AD0; // weak
_UNKNOWN unk_F6B10; // weak
_UNKNOWN unk_F6B50; // weak
_UNKNOWN unk_F6B80; // weak
_UNKNOWN unk_F6BB0; // weak
_UNKNOWN unk_F6BE0; // weak
_UNKNOWN unk_F6C10; // weak
_UNKNOWN unk_F6C40; // weak
_UNKNOWN unk_F6C70; // weak
_UNKNOWN unk_F6CA0; // weak
void *off_F6CD0 = (void *)0x101LL; // weak
_UNKNOWN unk_F6EF0; // weak
_UNKNOWN unk_F6F20; // weak
_UNKNOWN unk_F6F38; // weak
_UNKNOWN unk_F6F50; // weak
_UNKNOWN unk_F6F68; // weak
_UNKNOWN unk_F6F80; // weak
char *off_F6F98[38] =
{
  "invalid library (0)",
  "unknown library",
  "system library",
  "bignum routines",
  "RSA routines",
  "Diffie-Hellman routines",
  "public key routines",
  "memory buffer routines",
  "object identifier routines",
  "PEM routines",
  "DSA routines",
  "X.509 certificate routines",
  "ASN.1 encoding routines",
  "configuration file routines",
  "common libcrypto routines",
  "elliptic curve routines",
  "SSL routines",
  "BIO routines",
  "PKCS7 routines",
  "PKCS8 routines",
  "X509 V3 routines",
  "random number generator",
  "ENGINE routines",
  "OCSP routines",
  "UI routines",
  "COMP routines",
  "ECDSA routines",
  "ECDH routines",
  "HMAC routines",
  "Digest functions",
  "Cipher functions",
  "HKDF functions",
  "User defined functions",
  "malloc failure",
  "function should not have been called",
  "passed a null parameter",
  "internal error",
  "overflow"
}; // weak
char *off_F70A0[5] =
{
  "malloc failure",
  "function should not have been called",
  "passed a null parameter",
  "internal error",
  "overflow"
}; // weak
__int64 (__fastcall *off_F70C8[6])() =
{
  &RAND_seed,
  &RAND_pseudo_bytes,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf,
  &std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf,
  &RAND_pseudo_bytes,
  &X509V3_add_standard_extensions
}; // weak
int dword_F70F8 = 116; // weak
_UNKNOWN unk_F70FC; // weak
int dword_F7170 = 408; // weak
int dword_F71D0 = 408; // weak
_UNKNOWN unk_F71D4; // weak
int dword_F7248 = 6; // weak
int dword_F72A8 = 6; // weak
_UNKNOWN unk_F72AC; // weak
_UNKNOWN unk_F7348; // weak
_UNKNOWN unk_F73C0; // weak
_UNKNOWN unk_F7460; // weak
_UNKNOWN ASN1_OCTET_STRING_it; // weak
_UNKNOWN ASN1_INTEGER_it; // weak
_UNKNOWN ASN1_ENUMERATED_it; // weak
_UNKNOWN ASN1_BIT_STRING_it; // weak
_UNKNOWN ASN1_UTF8STRING_it; // weak
_UNKNOWN ASN1_PRINTABLESTRING_it; // weak
_UNKNOWN ASN1_T61STRING_it; // weak
_UNKNOWN ASN1_IA5STRING_it; // weak
_UNKNOWN ASN1_GENERALSTRING_it; // weak
_UNKNOWN ASN1_UTCTIME_it; // weak
_UNKNOWN ASN1_GENERALIZEDTIME_it; // weak
_UNKNOWN ASN1_VISIBLESTRING_it; // weak
_UNKNOWN ASN1_UNIVERSALSTRING_it; // weak
_UNKNOWN ASN1_BMPSTRING_it; // weak
_UNKNOWN ASN1_NULL_it; // weak
_UNKNOWN ASN1_ANY_it; // weak
_UNKNOWN ASN1_PRINTABLE_it; // weak
_UNKNOWN DISPLAYTEXT_it; // weak
_UNKNOWN DIRECTORYSTRING_it; // weak
_UNKNOWN ASN1_SEQUENCE_ANY_it; // weak
_UNKNOWN ASN1_SET_ANY_it; // weak
void *off_F7C50 = &unk_D7218; // weak
int dword_F7C68[] = { 716 }; // weak
char *off_F7C78 = &off_F7D08; // weak
_UNKNOWN unk_F7E5B; // weak
_UNKNOWN unk_F7F99; // weak
_UNKNOWN unk_F8079; // weak
_UNKNOWN unk_F8135; // weak
__int64 (__fastcall *off_F8158[18])() =
{
  &sub_754A4,
  &sub_754C8,
  &sub_754F4,
  &sub_75568,
  &sub_7579C,
  &sub_84090,
  &sub_75674,
  &sub_756C0,
  &sub_7570C,
  &sub_75754,
  &sub_82314,
  &sub_82358,
  &sub_82390,
  &sub_823FC,
  &sub_76334,
  &sub_76F60,
  &sub_84028,
  &sub_84040
}; // weak
char *off_F81F8[2] = { "UNDEF", "undefined" }; // weak
char *off_101640 = "default"; // weak
char *off_101680 = "pkcs7"; // weak
char *off_1016C0 = "smime_sign"; // weak
char *off_101700 = "ssl_client"; // weak
char *off_101740 = "ssl_server"; // weak
_UNKNOWN X509_ATTRIBUTE_it; // weak
_UNKNOWN X509_REVOKED_it; // weak
_UNKNOWN X509_CRL_INFO_it; // weak
_UNKNOWN X509_CRL_it; // weak
_UNKNOWN unk_101B80; // weak
_UNKNOWN X509_EXTENSION_it; // weak
_UNKNOWN X509_EXTENSIONS_it; // weak
_UNKNOWN X509_NAME_ENTRY_it; // weak
_UNKNOWN unk_101D68; // weak
_UNKNOWN unk_101DC8; // weak
_UNKNOWN X509_NAME_it; // weak
_UNKNOWN X509_PUBKEY_it; // weak
_UNKNOWN X509_REQ_INFO_it; // weak
_UNKNOWN X509_REQ_it; // weak
_UNKNOWN X509_SIG_it; // weak
_UNKNOWN NETSCAPE_SPKAC_it; // weak
_UNKNOWN NETSCAPE_SPKI_it; // weak
_UNKNOWN X509_CINF_it; // weak
_UNKNOWN X509_it; // weak
_UNKNOWN X509_CERT_AUX_it; // weak
_UNKNOWN X509_CERT_PAIR_it; // weak
_UNKNOWN AUTHORITY_KEYID_it; // weak
_UNKNOWN CERTIFICATEPOLICIES_it; // weak
_UNKNOWN POLICYINFO_it; // weak
_UNKNOWN POLICYQUALINFO_it; // weak
_UNKNOWN USERNOTICE_it; // weak
_UNKNOWN NOTICEREF_it; // weak
_UNKNOWN CRL_DIST_POINTS_it; // weak
_UNKNOWN DIST_POINT_NAME_it; // weak
_UNKNOWN DIST_POINT_it; // weak
_UNKNOWN ISSUING_DIST_POINT_it; // weak
int dword_102F10 = 0; // weak
char *off_102F18[2] = { "Unused", "unused" }; // weak
int dword_102F28 = 1; // weak
char *off_102F30[2] = { "Key Compromise", "keyCompromise" }; // weak
int dword_102F40 = 2; // weak
char *off_102F48[2] = { "CA Compromise", "CACompromise" }; // weak
int dword_102F58 = 3; // weak
char *off_102F60[2] = { "Affiliation Changed", "affiliationChanged" }; // weak
int dword_102F70 = 4; // weak
char *off_102F78[2] = { "Superseded", "superseded" }; // weak
int dword_102F88 = 5; // weak
char *off_102F90[2] = { "Cessation Of Operation", "cessationOfOperation" }; // weak
int dword_102FA0 = 6; // weak
char *off_102FA8[2] = { "Certificate Hold", "certificateHold" }; // weak
int dword_102FB8 = 7; // weak
char *off_102FC0[2] = { "Privilege Withdrawn", "privilegeWithdrawn" }; // weak
int dword_102FD0 = 8; // weak
char *off_102FD8[2] = { "AA Compromise", "AACompromise" }; // weak
_UNKNOWN OTHERNAME_it; // weak
_UNKNOWN EDIPARTYNAME_it; // weak
_UNKNOWN GENERAL_NAME_it; // weak
_UNKNOWN GENERAL_NAMES_it; // weak
void *off_103310 = &unk_1043C8; // weak
_UNKNOWN NAME_CONSTRAINTS_it; // weak
_UNKNOWN GENERAL_SUBTREE_it; // weak
_UNKNOWN PROXY_POLICY_it; // weak
_UNKNOWN PROXY_CERT_INFO_EXTENSION_it; // weak
_UNKNOWN POLICY_CONSTRAINTS_it; // weak
_UNKNOWN PKEY_USAGE_PERIOD_it; // weak
_UNKNOWN POLICY_MAPPING_it; // weak
_UNKNOWN SXNET_it; // weak
_UNKNOWN SXNETID_it; // weak
_UNKNOWN ASN1_TIME_it; // weak
_UNKNOWN unk_103C70; // weak
_UNKNOWN PKCS8_PRIV_KEY_INFO_it; // weak
_UNKNOWN RSA_PSS_PARAMS_it; // weak
char *off_103E90[12] =
{
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
}; // weak
_UNKNOWN X509_ALGOR_it; // weak
_UNKNOWN X509_ALGORS_it; // weak
_UNKNOWN X509_VAL_it; // weak
_UNKNOWN BASIC_CONSTRAINTS_it; // weak
__int64 (__fastcall *off_104588[2])() = { &sub_AF4DC, &sub_AF4E0 }; // weak
_UNKNOWN EXTENDED_KEY_USAGE_it; // weak
_UNKNOWN AUTHORITY_INFO_ACCESS_it; // weak
_UNKNOWN ACCESS_DESCRIPTION_it; // weak
char *off_104E10[31] =
{
  "EOC",
  "BOOLEAN",
  "INTEGER",
  "BIT STRING",
  "OCTET STRING",
  "NULL",
  "OBJECT",
  "OBJECT DESCRIPTOR",
  "EXTERNAL",
  "REAL",
  "ENUMERATED",
  "<ASN1 11>",
  "UTF8STRING",
  "<ASN1 13>",
  "<ASN1 14>",
  "<ASN1 15>",
  "SEQUENCE",
  "SET",
  "NUMERICSTRING",
  "PRINTABLESTRING",
  "T61STRING",
  "VIDEOTEXSTRING",
  "IA5STRING",
  "UTCTIME",
  "GENERALIZEDTIME",
  "GRAPHICSTRING",
  "VISIBLESTRING",
  "GENERALSTRING",
  "UNIVERSALSTRING",
  "<ASN1 29>",
  "BMPSTRING"
}; // weak
__int64 (__fastcall *off_104F08[2])() = { &EVP_PKEY_CTX_free, &EVP_PKEY_CTX_dup }; // weak
_UNKNOWN unk_104F18; // weak
_UNKNOWN unk_104F1C; // weak
_UNKNOWN unk_104F40; // weak
_UNKNOWN unk_104F44; // weak
_UNKNOWN unk_104F68; // weak
_UNKNOWN unk_104F6C; // weak
_UNKNOWN unk_104F90; // weak
_UNKNOWN unk_104F94; // weak
char *off_104FB8 = "BOOL"; // weak
char *off_104FC8 = "BOOLEAN"; // weak
_UNKNOWN unk_1052C8; // weak
_UNKNOWN unk_1052E0; // weak
_UNKNOWN unk_1052F8; // weak
_UNKNOWN unk_105310; // weak
_UNKNOWN unk_105328; // weak
int dword_106008[] = { 4294967295 }; // weak
char aDeviceSecurity_0[16] = "device_security"; // weak
char aUnknown_2[8] = "unknown"; // weak
char aCredentialMana_0[19] = "credential_manager"; // weak
char *off_1060A0[5] = { "MIRRORLINK_PRIV_KEY", "TEST_HUK", "CORE_KEY_11", "CORE_KEY_12", "GAT_CMD" }; // weak
char *off_1060A8[4] = { "TEST_HUK", "CORE_KEY_11", "CORE_KEY_12", "GAT_CMD" }; // weak
char *off_1060B0[3] = { "CORE_KEY_11", "CORE_KEY_12", "GAT_CMD" }; // weak
char *off_1060B8[2] = { "CORE_KEY_12", "GAT_CMD" }; // weak
char *off_1060C0 = "GAT_CMD"; // weak
char byte_1060C8 = '\x01'; // weak
int dword_1060CC[] = { 0 }; // weak
int dword_106110 = 1; // weak
int dword_106154 = 2; // weak
int dword_106198 = 3; // weak
int dword_1061DC = 4; // weak
int dword_106220 = 5; // weak
int dword_106264 = 9; // weak
int dword_1062A8 = 10; // weak
int dword_1062EC = 11; // weak
int dword_106330 = 12; // weak
int dword_106374 = 13; // weak
int dword_1063B8 = 14; // weak
int dword_1063FC = 15; // weak
int dword_106440 = 16; // weak
int dword_106484 = 33; // weak
int dword_106488 = 4294967294; // weak
int dword_10648C = 4294967294; // weak
char *off_106490[8] =
{
  "S1_Root",
  "S1_HWConf",
  "S1_SL",
  "S1_RLock",
  "S1_FOTA",
  "purpose",
  "config",
  "hwconfig"
}; // weak
char *off_106498[7] = { "S1_HWConf", "S1_SL", "S1_RLock", "S1_FOTA", "purpose", "config", "hwconfig" }; // weak
char *off_1064A0[6] = { "S1_SL", "S1_RLock", "S1_FOTA", "purpose", "config", "hwconfig" }; // weak
char *off_1064A8[5] = { "S1_RLock", "S1_FOTA", "purpose", "config", "hwconfig" }; // weak
char *off_1064B0[4] = { "S1_FOTA", "purpose", "config", "hwconfig" }; // weak
char *off_1064B8[3] = { "purpose", "config", "hwconfig" }; // weak
char *off_1064D8[3] = { "purpose", "config", "simlock" }; // weak
char *off_1064F8[3] = { "purpose", "boot", "service" }; // weak
char *off_106518[3] = { "purpose", "boot", "normal" }; // weak
char *off_106538[3] = { "purpose", "boot", "fota" }; // weak
char *off_106558[3] = { "purpose", "boot", "ramdumper" }; // weak
char *off_106578[2] = { "purpose", "flash" }; // weak
char *off_106590[3] = { "purpose", "config", "keystore" }; // weak
char *off_1065B0[3] = { "purpose", "config", "rlock" }; // weak
char *off_1065D0 = "deviceid"; // weak
char *off_1065E0 = "imei"; // weak
char *off_1065F0 = "sequence"; // weak
int dword_106600 = 949; // weak
_UNKNOWN unk_106608; // weak
void *off_106650 = &unk_101B80; // weak
_UNKNOWN unk_106658; // weak
__int64 qword_106808 = 8192LL; // weak
_UNKNOWN off_106810; // weak
__int64 (__fastcall *off_106818)(_QWORD, _QWORD, _QWORD) = &sub_AC634; // weak
_UNKNOWN unk_106820; // weak
int dword_106960 = 6; // weak
int dword_106980 = 116; // weak
void *off_106988 = &loc_B2220; // weak
void *off_106990 = &loc_B222C; // weak
void *off_106998 = &loc_B2238; // weak
int dword_1069A0 = 408; // weak
_UNKNOWN unk_1069C0; // weak
_UNKNOWN unk_106DE8; // weak
__int64 qword_106E10; // weak
char byte_106E18; // weak
int dword_106E1C; // weak
char byte_106E20; // weak
int dword_106E24; // weak
char byte_106E28; // weak
int dword_106E2C; // weak
_UNKNOWN unk_106E30; // weak
_UNKNOWN unk_106E68; // weak
_UNKNOWN unk_106F68; // weak
_UNKNOWN unk_106FA8; // weak
_UNKNOWN unk_106FB8; // weak
_UNKNOWN unk_106FF0; // weak
char byte_106FF4; // weak
int dword_106FF8; // weak
_UNKNOWN unk_106FFC; // weak
_UNKNOWN unk_107010; // weak
_UNKNOWN unk_10702C; // weak
_UNKNOWN unk_10704C; // weak
_UNKNOWN unk_10707C; // weak
_UNKNOWN unk_1070BC; // weak
int dword_1070C0; // weak
int dword_1070C4; // weak
_UNKNOWN unk_1070C8; // weak
_UNKNOWN unk_1070F0; // weak
_UNKNOWN unk_107100; // weak
_UNKNOWN unk_107110; // weak
_UNKNOWN unk_107148; // weak
__int64 qword_107190; // weak
_UNKNOWN unk_107198; // weak
_UNKNOWN unk_1071E0; // weak
__int64 qword_1071E8; // weak
_UNKNOWN unk_1071F0; // weak
_UNKNOWN unk_107238; // weak
__int64 qword_107270; // weak
__int64 qword_107278; // weak
__int64 qword_107280; // weak
__int64 qword_107288; // weak
_UNKNOWN unk_107290; // weak
__int64 qword_1072C8; // weak
_UNKNOWN unk_1072D0; // weak
_UNKNOWN unk_107308; // weak
_UNKNOWN unk_107340; // weak
_UNKNOWN unk_107388; // weak
__int64 qword_1073C0; // weak
__int64 qword_1073C8; // weak
__int64 qword_1073D0; // weak
_UNKNOWN unk_1073D8; // weak
__int64 qword_107420; // weak
__int64 qword_107428; // weak
// extern _UNKNOWN _stack_chk_guard; weak
// extern _UNKNOWN _sF; weak


//----- (0000000000032930) ----------------------------------------------------
__int64 __libc_init()
{
  return _libc_init();
}
// 107438: using guessed type __int64 _libc_init(void);

//----- (0000000000032940) ----------------------------------------------------
__int64 __cxa_atexit()
{
  return _cxa_atexit();
}
// 107448: using guessed type __int64 _cxa_atexit(void);

//----- (0000000000032950) ----------------------------------------------------
__int64 __register_atfork()
{
  return _register_atfork();
}
// 107440: using guessed type __int64 _register_atfork(void);

//----- (0000000000032960) ----------------------------------------------------
__int64 __strrchr_chk()
{
  return _strrchr_chk();
}
// 107470: using guessed type __int64 _strrchr_chk(void);

//----- (0000000000032970) ----------------------------------------------------
__int64 Suntory_FreeBlobStatusList()
{
  return Suntory_FreeBlobStatusList();
}
// 107458: using guessed type __int64 Suntory_FreeBlobStatusList(void);

//----- (0000000000032980) ----------------------------------------------------
__int64 Suntory_GetAllBlobStatus()
{
  return Suntory_GetAllBlobStatus();
}
// 107460: using guessed type __int64 Suntory_GetAllBlobStatus(void);

//----- (0000000000032990) ----------------------------------------------------
void *__fastcall malloc(size_t size)
{
  return malloc(size);
}

//----- (00000000000329A0) ----------------------------------------------------
void *__fastcall memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (00000000000329B0) ----------------------------------------------------
void *__fastcall memcpy(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (00000000000329D0) ----------------------------------------------------
__int64 __fastcall strncmp(const char *s1, const char *s2, size_t n)
{
  return strncmp(s1, s2, n);
}

//----- (00000000000329E0) ----------------------------------------------------
__int64 __fastcall std::__1::ios_base::init(std::__1::ios_base *this, void *a2)
{
  return std::__1::ios_base::init(this, a2);
}

//----- (00000000000329F0) ----------------------------------------------------
__int64 __fastcall std::__1::locale::locale(std::__1::locale *this)
{
  return std::__1::locale::locale(this);
}

//----- (0000000000032A00) ----------------------------------------------------
void __fastcall operator delete(void *a1)
{
  operator delete(a1);
}

//----- (0000000000032A10) ----------------------------------------------------
size_t __fastcall strlen(const char *s)
{
  return strlen(s);
}

//----- (0000000000032A20) ----------------------------------------------------
void __fastcall free(void *ptr)
{
  free(ptr);
}

//----- (0000000000032A30) ----------------------------------------------------
__int64 property_get()
{
  return property_get();
}
// 107530: using guessed type __int64 property_get(void);

//----- (0000000000032A40) ----------------------------------------------------
__int64 __fastcall strcmp(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}

//----- (0000000000032A50) ----------------------------------------------------
__int64 __memcpy_chk()
{
  return _memcpy_chk();
}
// 1074F8: using guessed type __int64 _memcpy_chk(void);

//----- (0000000000032A60) ----------------------------------------------------
__int64 libasb_get_startup_reason()
{
  return libasb_get_startup_reason();
}
// 107518: using guessed type __int64 libasb_get_startup_reason(void);

//----- (0000000000032A70) ----------------------------------------------------
DIR *__fastcall opendir(const char *name)
{
  return opendir(name);
}

//----- (0000000000032A80) ----------------------------------------------------
struct dirent *__fastcall readdir(DIR *dirp)
{
  return readdir(dirp);
}

//----- (0000000000032A90) ----------------------------------------------------
__int64 __fastcall closedir(DIR *dirp)
{
  return closedir(dirp);
}

//----- (0000000000032AA0) ----------------------------------------------------
__int64 __fastcall std::__1::locale::~locale(std::__1::locale *this)
{
  return std::__1::locale::~locale(this);
}

//----- (0000000000032AB0) ----------------------------------------------------
__int64 __fastcall std::__1::ios_base::~ios_base(std::__1::ios_base *this)
{
  return std::__1::ios_base::~ios_base(this);
}

//----- (0000000000032AC0) ----------------------------------------------------
__int64 __fastcall std::__1::ios_base::getloc(std::__1::ios_base *this)
{
  return std::__1::ios_base::getloc(this);
}

//----- (0000000000032AD0) ----------------------------------------------------
__int64 std::__1::locale::use_facet()
{
  return std::__1::locale::use_facet();
}
// 107498: using guessed type __int64 std::__1::locale::use_facet(void);

//----- (0000000000032AE0) ----------------------------------------------------
__int64 __fastcall std::__1::ios_base::clear(std::__1::ios_base *this, unsigned int a2)
{
  return std::__1::ios_base::clear(this, a2);
}

//----- (0000000000032AF0) ----------------------------------------------------
__int64 std::uncaught_exception(void)
{
  return std::uncaught_exception();
}

//----- (0000000000032B00) ----------------------------------------------------
__int64 __fastcall operator new(unsigned __int64 a1)
{
  return operator new(a1);
}

//----- (0000000000032B10) ----------------------------------------------------
void __noreturn abort()
{
  abort();
}

//----- (0000000000032B20) ----------------------------------------------------
void *__fastcall memmove(void *dest, const void *src, size_t n)
{
  return memmove(dest, src, n);
}

//----- (0000000000032B30) ----------------------------------------------------
__int64 __errno()
{
  return _errno();
}
// 107550: using guessed type __int64 _errno(void);

//----- (0000000000032B40) ----------------------------------------------------
char *__fastcall strerror(int errnum)
{
  return strerror(errnum);
}

//----- (0000000000032B50) ----------------------------------------------------
__int64 __fastcall pthread_mutex_lock(pthread_mutex_t *mutex)
{
  return pthread_mutex_lock(mutex);
}

//----- (0000000000032B60) ----------------------------------------------------
__int64 __fastcall pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (0000000000032B70) ----------------------------------------------------
__int64 idd_create()
{
  return idd_create();
}
// 107578: using guessed type __int64 idd_create(void);

//----- (0000000000032B80) ----------------------------------------------------
__int64 idd_add_event()
{
  return idd_add_event();
}
// 107570: using guessed type __int64 idd_add_event(void);

//----- (0000000000032B90) ----------------------------------------------------
__int64 idd_destroy()
{
  return idd_destroy();
}
// 107580: using guessed type __int64 idd_destroy(void);

//----- (0000000000032BA0) ----------------------------------------------------
__sighandler_t __fastcall signal(int sig, __sighandler_t handler)
{
  return signal(sig, handler);
}

//----- (0000000000032BB0) ----------------------------------------------------
__int64 __FD_SET_chk()
{
  return _FD_SET_chk();
}
// 107590: using guessed type __int64 _FD_SET_chk(void);

//----- (0000000000032BC0) ----------------------------------------------------
__int64 __fastcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
{
  return select(nfds, readfds, writefds, exceptfds, timeout);
}

//----- (0000000000032BD0) ----------------------------------------------------
__int64 __FD_ISSET_chk()
{
  return _FD_ISSET_chk();
}
// 107588: using guessed type __int64 _FD_ISSET_chk(void);

//----- (0000000000032BE0) ----------------------------------------------------
size_t __fastcall strnlen(const char *string, size_t maxlen)
{
  return strnlen(string, maxlen);
}

//----- (0000000000032BF0) ----------------------------------------------------
__int64 __vsnprintf_chk()
{
  return _vsnprintf_chk();
}
// 1075B8: using guessed type __int64 _vsnprintf_chk(void);

//----- (0000000000032C00) ----------------------------------------------------
__int64 __android_log_buf_print()
{
  return _android_log_buf_print();
}
// 1075B0: using guessed type __int64 _android_log_buf_print(void);

//----- (0000000000032C10) ----------------------------------------------------
void *__fastcall realloc(void *ptr, size_t size)
{
  return realloc(ptr, size);
}

//----- (0000000000032C20) ----------------------------------------------------
__int64 android_get_control_socket()
{
  return android_get_control_socket();
}
// 1075E8: using guessed type __int64 android_get_control_socket(void);

//----- (0000000000032C30) ----------------------------------------------------
__int64 __fastcall listen(int fd, int n)
{
  return listen(fd, n);
}

//----- (0000000000032C40) ----------------------------------------------------
__int64 __fastcall close(int fd)
{
  return close(fd);
}

//----- (0000000000032C50) ----------------------------------------------------
__int64 __fastcall accept(int fd, struct sockaddr *addr, socklen_t *addr_len)
{
  return accept(fd, addr, addr_len);
}

//----- (0000000000032C60) ----------------------------------------------------
ssize_t __fastcall recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)
{
  return recvfrom(fd, buf, n, flags, addr, addr_len);
}

//----- (0000000000032C70) ----------------------------------------------------
ssize_t __fastcall sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
{
  return sendto(fd, buf, n, flags, addr, addr_len);
}

//----- (0000000000032C80) ----------------------------------------------------
__int64 QSEECom_start_app()
{
  return QSEECom_start_app();
}
// 107630: using guessed type __int64 QSEECom_start_app(void);

//----- (0000000000032C90) ----------------------------------------------------
__int64 QSEECom_set_bandwidth()
{
  return QSEECom_set_bandwidth();
}
// 107620: using guessed type __int64 QSEECom_set_bandwidth(void);

//----- (0000000000032CA0) ----------------------------------------------------
__int64 QSEECom_send_cmd()
{
  return QSEECom_send_cmd();
}
// 107618: using guessed type __int64 QSEECom_send_cmd(void);

//----- (0000000000032CB0) ----------------------------------------------------
__int64 QSEECom_shutdown_app()
{
  return QSEECom_shutdown_app();
}
// 107628: using guessed type __int64 QSEECom_shutdown_app(void);

//----- (0000000000032CC0) ----------------------------------------------------
__int64 __strncpy_chk2()
{
  return _strncpy_chk2();
}
// 107638: using guessed type __int64 _strncpy_chk2(void);

//----- (0000000000032CD0) ----------------------------------------------------
__int64 __memset_chk()
{
  return _memset_chk();
}
// 107640: using guessed type __int64 _memset_chk(void);

//----- (0000000000032CE0) ----------------------------------------------------
__int64 property_set()
{
  return property_set();
}
// 107650: using guessed type __int64 property_set(void);

//----- (0000000000032CF0) ----------------------------------------------------
__int64 Suntory_ConvertAllBlobs()
{
  return Suntory_ConvertAllBlobs();
}
// 107648: using guessed type __int64 Suntory_ConvertAllBlobs(void);

//----- (0000000000032D00) ----------------------------------------------------
__int64 __fastcall sleep(unsigned int seconds)
{
  return sleep(seconds);
}

//----- (0000000000032D10) ----------------------------------------------------
__int64 SuntoryTee_LoadBlob()
{
  return SuntoryTee_LoadBlob();
}
// 107670: using guessed type __int64 SuntoryTee_LoadBlob(void);

//----- (0000000000032D20) ----------------------------------------------------
__int64 Suntory_GetBlobType()
{
  return Suntory_GetBlobType();
}
// 107690: using guessed type __int64 Suntory_GetBlobType(void);

//----- (0000000000032D30) ----------------------------------------------------
__int64 SuntoryTee_Sign()
{
  return SuntoryTee_Sign();
}
// 107680: using guessed type __int64 SuntoryTee_Sign(void);

//----- (0000000000032D40) ----------------------------------------------------
__int64 SuntoryTee_Verify()
{
  return SuntoryTee_Verify();
}
// 107688: using guessed type __int64 SuntoryTee_Verify(void);

//----- (0000000000032D50) ----------------------------------------------------
__int64 SuntoryTee_GetKey()
{
  return SuntoryTee_GetKey();
}
// 107668: using guessed type __int64 SuntoryTee_GetKey(void);

//----- (0000000000032D60) ----------------------------------------------------
__int64 SuntoryTee_GetCert()
{
  return SuntoryTee_GetCert();
}
// 107660: using guessed type __int64 SuntoryTee_GetCert(void);

//----- (0000000000032D70) ----------------------------------------------------
__int64 SuntoryTee_GetCredential()
{
  return SuntoryTee_GetCredential();
}
// 1076A8: using guessed type __int64 SuntoryTee_GetCredential(void);

//----- (0000000000032D80) ----------------------------------------------------
__int64 SuntoryTee_GetAllCredentialData()
{
  return SuntoryTee_GetAllCredentialData();
}
// 1076A0: using guessed type __int64 SuntoryTee_GetAllCredentialData(void);

//----- (0000000000032D90) ----------------------------------------------------
__int64 __android_log_write()
{
  return _android_log_write();
}
// 1076B0: using guessed type __int64 _android_log_write(void);

//----- (0000000000032DA0) ----------------------------------------------------
__int64 sqlite3_open_v2()
{
  return sqlite3_open_v2();
}
// 107700: using guessed type __int64 sqlite3_open_v2(void);

//----- (0000000000032DB0) ----------------------------------------------------
__int64 sqlite3_prepare_v2()
{
  return sqlite3_prepare_v2();
}
// 107708: using guessed type __int64 sqlite3_prepare_v2(void);

//----- (0000000000032DC0) ----------------------------------------------------
__int64 sqlite3_errmsg()
{
  return sqlite3_errmsg();
}
// 1076E8: using guessed type __int64 sqlite3_errmsg(void);

//----- (0000000000032DD0) ----------------------------------------------------
__int64 sqlite3_step()
{
  return sqlite3_step();
}
// 107710: using guessed type __int64 sqlite3_step(void);

//----- (0000000000032DE0) ----------------------------------------------------
__int64 __fastcall chmod(const char *file, __mode_t mode)
{
  return chmod(file, mode);
}

//----- (0000000000032DF0) ----------------------------------------------------
__int64 sqlite3_finalize()
{
  return sqlite3_finalize();
}
// 1076F8: using guessed type __int64 sqlite3_finalize(void);

//----- (0000000000032E00) ----------------------------------------------------
__int64 sqlite3_close()
{
  return sqlite3_close();
}
// 1076D0: using guessed type __int64 sqlite3_close(void);

//----- (0000000000032E10) ----------------------------------------------------
__int64 sqlite3_exec()
{
  return sqlite3_exec();
}
// 1076F0: using guessed type __int64 sqlite3_exec(void);

//----- (0000000000032E20) ----------------------------------------------------
__int64 __fastcall remove(const char *filename)
{
  return remove(filename);
}

//----- (0000000000032E30) ----------------------------------------------------
__int64 sqlite3_bind_blob()
{
  return sqlite3_bind_blob();
}
// 1076C8: using guessed type __int64 sqlite3_bind_blob(void);

//----- (0000000000032E40) ----------------------------------------------------
__int64 sqlite3_column_blob()
{
  return sqlite3_column_blob();
}
// 1076D8: using guessed type __int64 sqlite3_column_blob(void);

//----- (0000000000032E50) ----------------------------------------------------
__int64 sqlite3_column_bytes()
{
  return sqlite3_column_bytes();
}
// 1076E0: using guessed type __int64 sqlite3_column_bytes(void);

//----- (0000000000032E60) ----------------------------------------------------
FILE *__fastcall fopen(const char *filename, const char *modes)
{
  return fopen(filename, modes);
}

//----- (0000000000032E70) ----------------------------------------------------
__int64 __fastcall fseek(FILE *stream, __int64 off, int whence)
{
  return fseek(stream, off, whence);
}

//----- (0000000000032E80) ----------------------------------------------------
__int64 __fastcall fclose(FILE *stream)
{
  return fclose(stream);
}

//----- (0000000000032E90) ----------------------------------------------------
__int64 __fastcall ftell(FILE *stream)
{
  return ftell(stream);
}

//----- (0000000000032EA0) ----------------------------------------------------
size_t __fastcall fread(void *ptr, size_t size, size_t n, FILE *stream)
{
  return fread(ptr, size, n, stream);
}

//----- (0000000000032EB0) ----------------------------------------------------
__int64 miscta_write_unit_critical()
{
  return miscta_write_unit_critical();
}
// 1075D8: using guessed type __int64 miscta_write_unit_critical(void);

//----- (0000000000032EC0) ----------------------------------------------------
__int64 miscta_get_unit_size()
{
  return miscta_get_unit_size();
}
// 1075C8: using guessed type __int64 miscta_get_unit_size(void);

//----- (0000000000032ED0) ----------------------------------------------------
__int64 miscta_read_unit()
{
  return miscta_read_unit();
}
// 1075D0: using guessed type __int64 miscta_read_unit(void);

//----- (0000000000032EE0) ----------------------------------------------------
size_t __fastcall fwrite(const void *ptr, size_t size, size_t n, FILE *s)
{
  return fwrite(ptr, size, n, s);
}

//----- (0000000000032EF0) ----------------------------------------------------
__int64 protobuf_c_message_get_packed_size()
{
  return protobuf_c_message_get_packed_size();
}
// 107750: using guessed type __int64 protobuf_c_message_get_packed_size(void);

//----- (0000000000032F00) ----------------------------------------------------
__int64 protobuf_c_message_pack()
{
  return protobuf_c_message_pack();
}
// 107758: using guessed type __int64 protobuf_c_message_pack(void);

//----- (0000000000032F10) ----------------------------------------------------
__int64 __fastcall memcmp(const void *s1, const void *s2, size_t n)
{
  return memcmp(s1, s2, n);
}

//----- (0000000000032F20) ----------------------------------------------------
__int64 __snprintf_chk()
{
  return _snprintf_chk();
}
// 107770: using guessed type __int64 _snprintf_chk(void);

//----- (0000000000032F30) ----------------------------------------------------
__int64 __fastcall atoi(const char *nptr)
{
  return atoi(nptr);
}

//----- (0000000000032F40) ----------------------------------------------------
char *__fastcall strchr(const char *s, int c)
{
  return strchr(s, c);
}

//----- (0000000000032F50) ----------------------------------------------------
void *__fastcall bsearch(const void *key, const void *base, size_t nmemb, size_t size, __compar_fn_t compar)
{
  return bsearch(key, base, nmemb, size, compar);
}

//----- (0000000000032F60) ----------------------------------------------------
__int64 __strlen_chk()
{
  return _strlen_chk();
}
// 1077C0: using guessed type __int64 _strlen_chk(void);

//----- (0000000000032F70) ----------------------------------------------------
__int64 __fastcall fputs(const char *s, FILE *stream)
{
  return fputs(s, stream);
}

//----- (0000000000032F80) ----------------------------------------------------
char *__fastcall strdup(const char *s)
{
  return strdup(s);
}

//----- (0000000000032F90) ----------------------------------------------------
__int64 __fastcall strcasecmp(const char *s1, const char *s2)
{
  return strcasecmp(s1, s2);
}

//----- (0000000000032FA0) ----------------------------------------------------
__int64 __fastcall strncasecmp(const char *s1, const char *s2, size_t n)
{
  return strncasecmp(s1, s2, n);
}

//----- (0000000000032FB0) ----------------------------------------------------
__int64 __fastcall dup(int fd)
{
  return dup(fd);
}

//----- (0000000000032FC0) ----------------------------------------------------
__int64 __fastcall syscall(__int64 sysno)
{
  return syscall(sysno);
}

//----- (0000000000032FD0) ----------------------------------------------------
__int64 __open_2()
{
  return _open_2();
}
// 107808: using guessed type __int64 _open_2(void);

//----- (0000000000032FE0) ----------------------------------------------------
__int64 __fastcall fcntl(int fd, int cmd)
{
  return fcntl(fd, cmd);
}

//----- (0000000000032FF0) ----------------------------------------------------
ssize_t __fastcall read(int fd, void *buf, size_t nbytes)
{
  return read(fd, buf, nbytes);
}

//----- (0000000000033000) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)
{
  return pthread_rwlock_init(rwlock, attr);
}

//----- (0000000000033010) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_rdlock(rwlock);
}

//----- (0000000000033020) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_wrlock(rwlock);
}

//----- (0000000000033030) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_unlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_unlock(rwlock);
}

//----- (0000000000033040) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_destroy(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_destroy(rwlock);
}

//----- (0000000000033050) ----------------------------------------------------
__int64 __fastcall pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
{
  return pthread_once(once_control, init_routine);
}

//----- (0000000000033060) ----------------------------------------------------
void *__fastcall pthread_getspecific(pthread_key_t key)
{
  return pthread_getspecific(key);
}

//----- (0000000000033070) ----------------------------------------------------
__int64 __fastcall pthread_key_create(pthread_key_t *key, void (*destr_function)(void *))
{
  return pthread_key_create(key, destr_function);
}

//----- (0000000000033080) ----------------------------------------------------
__int64 __fastcall pthread_setspecific(pthread_key_t key, const void *pointer)
{
  return pthread_setspecific(key, pointer);
}

//----- (0000000000033090) ----------------------------------------------------
void *__fastcall memchr(const void *s, int c, size_t n)
{
  return memchr(s, c, n);
}

//----- (00000000000330A0) ----------------------------------------------------
unsigned __int64 __fastcall getauxval(unsigned __int64 type)
{
  return getauxval(type);
}

//----- (00000000000330B0) ----------------------------------------------------
void __fastcall qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar)
{
  qsort(base, nmemb, size, compar);
}

//----- (00000000000330C0) ----------------------------------------------------
__int64 __fastcall isxdigit(int a1)
{
  return isxdigit(a1);
}

//----- (00000000000330D0) ----------------------------------------------------
time_t __fastcall time(time_t *timer)
{
  return time(timer);
}

//----- (00000000000330E0) ----------------------------------------------------
__int64 __fastcall isspace(int a1)
{
  return isspace(a1);
}

//----- (00000000000330F0) ----------------------------------------------------
__int64 __fastcall tolower(int c)
{
  return tolower(c);
}

//----- (0000000000033100) ----------------------------------------------------
__int64 __fastcall isupper(int a1)
{
  return isupper(a1);
}

//----- (0000000000033110) ----------------------------------------------------
__int64 __fastcall sscanf(const char *s, const char *format)
{
  return sscanf(s, format);
}

//----- (0000000000033120) ----------------------------------------------------
unsigned __int64 __fastcall strtoul(const char *nptr, char **endptr, int base)
{
  return strtoul(nptr, endptr, base);
}

//----- (0000000000033130) ----------------------------------------------------
struct tm *__fastcall gmtime_r(const time_t *timer, struct tm *tp)
{
  return gmtime_r(timer, tp);
}

//----- (0000000000033140) ----------------------------------------------------
__int64 __fastcall ferror(FILE *stream)
{
  return ferror(stream);
}

//----- (0000000000033150) ----------------------------------------------------
char *__fastcall fgets(char *s, int n, FILE *stream)
{
  return fgets(s, n, stream);
}

//----- (0000000000033160) ----------------------------------------------------
__int64 __fastcall feof(FILE *stream)
{
  return feof(stream);
}

//----- (0000000000033170) ----------------------------------------------------
__int64 __fastcall fflush(FILE *stream)
{
  return fflush(stream);
}

//----- (0000000000033180) ----------------------------------------------------
__int64 __strcat_chk()
{
  return _strcat_chk();
}
// 107698: using guessed type __int64 _strcat_chk(void);

//----- (0000000000033190) ----------------------------------------------------
char *__fastcall strncpy(char *dest, const char *src, size_t n)
{
  return strncpy(dest, src, n);
}

//----- (00000000000331A0) ----------------------------------------------------
__int64 __strchr_chk()
{
  return _strchr_chk();
}
// 107450: using guessed type __int64 _strchr_chk(void);

//----- (0000000000033214) ----------------------------------------------------
void __fastcall start(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int64 *v9; // x29
  __int64 v10; // x30
  __int64 *v11; // [xsp+0h] [xbp-40h]
  __int64 v12; // [xsp+8h] [xbp-38h]
  __int64 *v13; // [xsp+18h] [xbp-28h]
  void *v14; // [xsp+28h] [xbp-18h]
  void *v15; // [xsp+30h] [xbp-10h]
  void *v16; // [xsp+38h] [xbp-8h]

  while ( 1 )
  {
    v11 = v9;
    v12 = v10;
    v9 = (__int64 *)&v11;
    v13 = &a9;
    v14 = &unk_F6180;
    v15 = &unk_F6190;
    v16 = &unk_F61A8;
    __libc_init();
  }
}

//----- (000000000003321C) ----------------------------------------------------
__int64 (*__fastcall sub_3321C(__int64 (*result)(void)))(void)
{
  if ( result )
    result = (__int64 (*)(void))result();
  return result;
}

//----- (00000000000332B0) ----------------------------------------------------
__int64 __fastcall sub_332B0(_QWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // x21
  _QWORD *v3; // x19
  const char *v4; // x20
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  const char *v13; // x4
  const char *v14; // x5
  __int64 v15; // x3
  unsigned int v16; // w19
  const char *v17; // x20
  char *v18; // x0
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  __int64 result; // x0
  unsigned int v28; // w20
  const char *v29; // x19
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  void *v38; // x0
  const char *v43; // x19
  double v44; // d0
  double v45; // d1
  double v46; // d2
  double v47; // d3
  double v48; // d4
  double v49; // d5
  double v50; // d6
  double v51; // d7
  __int64 v52; // [xsp+18h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v52 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_blob_status.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v13 = "param %s is NULL";
    v14 = "p_data";
    v15 = 29LL;
    goto LABEL_9;
  }
  if ( *a1 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_blob_status.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v13 = "param %s is not NULL";
    v14 = "*p_data";
    v15 = 30LL;
LABEL_9:
    v16 = 1;
    sub_379E4((__int64)"secd", 1, (__int64)v4, v15, (__int64)v13, v5, v6, v7, v8, v9, v10, v11, v12, v14);
    goto LABEL_10;
  }
  if ( !a2 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_blob_status.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v13 = "param %s is NULL";
    v14 = "p_data_len";
    v15 = 31LL;
    goto LABEL_9;
  }
  v28 = Suntory_GetAllBlobStatus();
  if ( v28 )
  {
    v29 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_blob_status.cpp";
    if ( __strrchr_chk() )
      v29 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v29,
      44LL,
      (__int64)"Suntory_GetAllBlobStatus failed %d",
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v28);
  }
  else
  {
    *v2 = 4;
    v38 = malloc(4uLL);
    *v3 = v38;
    if ( v38 )
    {
      memset(v38, 0, (unsigned int)*v2);
      *(_DWORD *)*v3 = 0;
      result = Suntory_FreeBlobStatusList();
      v16 = 0;
      goto LABEL_13;
    }
    v43 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_blob_status.cpp";
    if ( __strrchr_chk() )
      v43 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v43,
      58LL,
      (__int64)"failed to allocate memory",
      v44,
      v45,
      v46,
      v47,
      v48,
      v49,
      v50,
      v51);
  }
  v16 = 4;
LABEL_10:
  Suntory_FreeBlobStatusList();
  v17 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_blob_status.cpp";
  if ( __strrchr_chk() )
    v17 = (const char *)(__strrchr_chk() + 1);
  v18 = sub_38F2C(v16);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v17,
             118LL,
             (__int64)"%s() ended. result %d - %s",
             v19,
             v20,
             v21,
             v22,
             v23,
             v24,
             v25,
             v26,
             "devsec_get_blob_status",
             v16,
             v18);
LABEL_13:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v52 )
    result = v16;
  return result;
}

//----- (000000000003364C) ----------------------------------------------------
__int64 __fastcall sub_3364C(_DWORD *a1)
{
  _DWORD *v1; // x19
  unsigned int v2; // w20
  const char *v3; // x19
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  const char *v12; // x20
  double v13; // d0
  double v14; // d1
  double v15; // d2
  double v16; // d3
  double v17; // d4
  double v18; // d5
  double v19; // d6
  double v20; // d7
  unsigned int v21; // w19
  __int64 v22; // x22
  __int64 result; // x0
  const char *v24; // x20
  char *v25; // x0
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  __int64 v34; // [xsp+18h] [xbp-38h]

  v1 = a1;
  v34 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v2 = Suntory_GetAllBlobStatus();
    if ( v2 )
    {
      v3 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_ckb_status.cpp";
      if ( __strrchr_chk() )
        v3 = (const char *)(__strrchr_chk() + 1);
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v3,
        38LL,
        (__int64)"Suntory_GetAllBlobStatus failed %d",
        v4,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        v2);
    }
    else
    {
      v22 = 0LL;
      while ( v22 )
      {
        if ( !(unsigned int)strncmp(*(const char **)(24LL * (unsigned int)--v22), "CKB", 3uLL) )
        {
          *v1 = 0;
          *v1 = *(_DWORD *)&byte_8[24 * (unsigned int)v22] > 3u;
          result = Suntory_FreeBlobStatusList();
          v21 = 0;
          goto LABEL_17;
        }
      }
    }
    v21 = 4;
  }
  else
  {
    v12 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_ckb_status.cpp";
    if ( __strrchr_chk() )
      v12 = (const char *)(__strrchr_chk() + 1);
    v21 = 1;
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v12,
      25LL,
      (__int64)"param %s is NULL",
      v13,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      "p_ckb_status");
  }
  Suntory_FreeBlobStatusList();
  v24 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_ckb_status.cpp";
  if ( __strrchr_chk() )
    v24 = (const char *)(__strrchr_chk() + 1);
  v25 = sub_38F2C(v21);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v24,
             87LL,
             (__int64)"%s() ended. result %d - %s",
             v26,
             v27,
             v28,
             v29,
             v30,
             v31,
             v32,
             v33,
             "devsec_get_ckb_status",
             v21,
             v25);
LABEL_17:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v34 )
    result = v21;
  return result;
}

//----- (0000000000033870) ----------------------------------------------------
void __fastcall sub_33870(void **a1)
{
  void **v1; // x26
  const char *v2; // x19
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  const char *v11; // x4
  const char *v12; // x5
  __int64 v13; // x3
  __int128 v14; // q0
  unsigned int v15; // w25
  _QWORD *v16; // x0
  _QWORD *v17; // x0
  _QWORD *v18; // x0
  int v19; // w19
  const char *v20; // x1
  __int128 *v21; // x0
  __int64 v22; // x2
  const char *v23; // x1
  __int128 *v24; // x0
  __int64 v25; // x2
  __int64 v26; // x19
  __int64 v27; // x0
  int v28; // w19
  const char *v29; // x1
  __int64 v30; // x2
  int v31; // w19
  const char *v32; // x1
  __int64 v33; // x2
  int v34; // w19
  const char *v35; // x1
  __int128 *v36; // x0
  __int64 v37; // x2
  __int64 v38; // x19
  __int64 v39; // x0
  const char *v40; // x1
  __int64 v41; // x2
  int v42; // w19
  const char *v43; // x1
  __int64 v44; // x2
  unsigned __int64 v45; // x19
  char *v46; // x10
  __int64 v47; // x1
  const char *v48; // x1
  __int64 v49; // x2
  const char *v50; // x1
  __int64 v51; // x2
  const char *v52; // x1
  unsigned int v53; // w23
  unsigned int v54; // w20
  __int64 v55; // x19
  int v56; // w26
  __int64 v57; // x28
  signed __int64 v58; // x19
  _QWORD *v59; // x0
  _QWORD *v60; // x21
  __int64 v61; // x0
  _QWORD *v62; // x0
  _QWORD *v63; // x0
  _QWORD *v64; // x21
  const char *v65; // x22
  __int64 v66; // x0
  __int64 v67; // x2
  const char *v68; // x1
  int v69; // w19
  const char *v70; // x1
  __int128 *v71; // x0
  __int64 v72; // x2
  _QWORD *v73; // x0
  _QWORD *v74; // x19
  __int64 v75; // x0
  int v76; // w19
  const char *v77; // x1
  __int128 *v78; // x0
  __int64 v79; // x2
  _QWORD *v80; // x0
  _QWORD *v81; // x19
  __int64 v82; // x0
  int v83; // w19
  const char *v84; // x1
  __int64 v85; // x2
  const char *v86; // x1
  __int64 v87; // x2
  DIR *v88; // x0
  DIR *v89; // x19
  struct dirent *i; // x0
  const char *v91; // x22
  __int64 v92; // x0
  _QWORD *v93; // x0
  _QWORD *v94; // x0
  _QWORD *v95; // x21
  __int64 v96; // x0
  _QWORD *v97; // x0
  __int64 v98; // x0
  _QWORD *v99; // x0
  _QWORD *v100; // x0
  _QWORD *v101; // x0
  const char *v102; // x1
  __int64 v103; // x2
  const char *v104; // x19
  char *v105; // x0
  double v106; // d0
  double v107; // d1
  double v108; // d2
  double v109; // d3
  double v110; // d4
  double v111; // d5
  double v112; // d6
  double v113; // d7
  unsigned __int8 v114; // w20
  unsigned __int64 v115; // x8
  void *v116; // x19
  _BYTE *v117; // x20
  unsigned __int64 v118; // x8
  void **v119; // [xsp+8h] [xbp-278h]
  signed int v120; // [xsp+34h] [xbp-24Ch]
  unsigned __int8 v121; // [xsp+38h] [xbp-248h]
  unsigned __int64 v122; // [xsp+40h] [xbp-240h]
  void *v123; // [xsp+48h] [xbp-238h]
  char v124; // [xsp+50h] [xbp-230h]
  _BYTE v125[7]; // [xsp+51h] [xbp-22Fh]
  void *v126; // [xsp+60h] [xbp-220h]
  unsigned __int8 v127; // [xsp+68h] [xbp-218h]
  unsigned __int64 v128; // [xsp+70h] [xbp-210h]
  void *v129; // [xsp+78h] [xbp-208h]
  int v130; // [xsp+84h] [xbp-1FCh]
  unsigned int v131; // [xsp+88h] [xbp-1F8h]
  int v132; // [xsp+90h] [xbp-1F0h]
  int v133; // [xsp+94h] [xbp-1ECh]
  unsigned int *v134; // [xsp+98h] [xbp-1E8h]
  __int128 v135; // [xsp+A0h] [xbp-1E0h]
  __int64 v136; // [xsp+B0h] [xbp-1D0h]
  __int64 v137; // [xsp+B8h] [xbp-1C8h]
  __int64 v138; // [xsp+C0h] [xbp-1C0h]
  __int64 v139; // [xsp+C8h] [xbp-1B8h]
  __int64 v140; // [xsp+D0h] [xbp-1B0h]
  __int64 v141; // [xsp+D8h] [xbp-1A8h]
  __int64 v142; // [xsp+E0h] [xbp-1A0h]
  __int64 v143; // [xsp+E8h] [xbp-198h]
  __int64 v144; // [xsp+F0h] [xbp-190h]
  void *v145; // [xsp+F8h] [xbp-188h]
  __int64 v146; // [xsp+100h] [xbp-180h]
  int v147; // [xsp+108h] [xbp-178h]
  __int64 (__fastcall **v148)(); // [xsp+110h] [xbp-170h]
  __int64 v149; // [xsp+198h] [xbp-E8h]
  int v150; // [xsp+1A0h] [xbp-E0h]
  char *v151; // [xsp+1A8h] [xbp-D8h]
  __int64 v152; // [xsp+1B0h] [xbp-D0h]
  void *v153; // [xsp+1B8h] [xbp-C8h]
  __int64 v154; // [xsp+228h] [xbp-58h]

  v1 = a1;
  v154 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v134 = 0LL;
  v133 = 0;
  if ( !a1 )
  {
    v2 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_debugmenu_report.cpp";
    if ( __strrchr_chk() )
      v2 = (const char *)(__strrchr_chk() + 1);
    v11 = "param %s is NULL";
    v12 = "p_report";
    v13 = 64LL;
    goto LABEL_9;
  }
  if ( *a1 )
  {
    v2 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_debugmenu_report.cpp";
    if ( __strrchr_chk() )
      v2 = (const char *)(__strrchr_chk() + 1);
    v11 = "param %s is not NULL";
    v12 = "*p_report";
    v13 = 65LL;
LABEL_9:
    sub_379E4((__int64)"secd", 1, (__int64)v2, v13, (__int64)v11, v3, v4, v5, v6, v7, v8, v9, v10, v12);
    v120 = 0;
    goto LABEL_11;
  }
  v120 = 1;
LABEL_11:
  v148 = off_F6250;
  std::__1::ios_base::init((std::__1::ios_base *)&v148, (char *)&v135 + 8);
  *(_QWORD *)&v14 = off_F61D8;
  v150 = -1;
  *((_QWORD *)&v14 + 1) = off_F62F0;
  v149 = 0LL;
  v148 = off_F6200;
  v135 = v14;
  std::__1::locale::locale((std::__1::locale *)&v136);
  *((_QWORD *)&v135 + 1) = off_F6270;
  v141 = 0LL;
  v142 = 0LL;
  v139 = 0LL;
  v140 = 0LL;
  v137 = 0LL;
  v138 = 0LL;
  v152 = 0LL;
  v153 = 0LL;
  v145 = 0LL;
  v146 = 0LL;
  v143 = 0LL;
  v144 = 0LL;
  v147 = 16;
  v151 = 0LL;
  sub_3563C((_QWORD *)&v135 + 1, (unsigned __int8 *)&v151);
  if ( (unsigned __int8)v151 & 1 )
    operator delete(v153);
  v15 = v120 ^ 1;
  v132 = sub_3ACD4();
  sub_359A8(&v135, (__int64)"Device Security daemon, ver ", 28LL);
  *(_DWORD *)((char *)v16 + *(_QWORD *)(*v16 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v16 + *(_QWORD *)(*v16 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  std::__1::basic_ostream<char,std::__1::char_traits<char>>::operator<<((__int64)v16);
  sub_359A8(&v135, (__int64)".", 1LL);
  *(_DWORD *)((char *)v17 + *(_QWORD *)(*v17 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v17 + *(_QWORD *)(*v17 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  v18 = (_QWORD *)std::__1::basic_ostream<char,std::__1::char_traits<char>>::operator<<((__int64)v17);
  sub_359A8(v18, (__int64)"\n", 1LL);
  if ( !v120 )
  {
    sub_359A8(&v135, (__int64)"\nTEE\t\t\t\t\tlisteners\t\t\t[", 22LL);
    sub_359A8(&v135, (__int64)"\nSuntory\t\t\tblobs\t\t\t\t\t[", 22LL);
    sub_359A8(&v135, (__int64)"\nKey Provision daemon\n", 22LL);
    v23 = "\nSPC\t\t\t\t";
    v24 = &v135;
    v25 = 8LL;
LABEL_106:
    sub_359A8(v24, (__int64)v23, v25);
    goto LABEL_107;
  }
  v151 = 0LL;
  v19 = sub_39C10((void **)&v151);
  sub_359A8(&v135, (__int64)"  HW Config rev\t\t", 17LL);
  if ( v19 )
  {
    v20 = "error\n";
    v21 = &v135;
    v22 = 6LL;
  }
  else
  {
    v26 = (__int64)v151;
    v27 = strlen(v151);
    sub_359A8(&v135, v26, v27);
    v20 = "\n";
    v22 = 1LL;
  }
  sub_359A8(v21, (__int64)v20, v22);
  free(v151);
  LODWORD(v151) = 0;
  v28 = sub_3A734(&v151);
  sub_359A8(&v135, (__int64)"  Rooting status\t\t", 18LL);
  if ( v28 )
  {
    v29 = "error\n";
    v30 = 6LL;
LABEL_20:
    sub_359A8(&v135, (__int64)v29, v30);
  }
  else
  {
    switch ( (_DWORD)v151 )
    {
      case 0:
        v29 = "NOT_ALLOWED\n";
        v30 = 12LL;
        goto LABEL_20;
      case 1:
        v29 = "NOT_DONE\n";
        v30 = 9LL;
        goto LABEL_20;
      case 2:
        v29 = "DONE\n";
        v30 = 5LL;
        goto LABEL_20;
      case 3:
        v29 = "ALLOWED_WHEN_SL_IS_UNLOCKED\n";
        v30 = 28LL;
        goto LABEL_20;
      case 4:
        v29 = "ALLOWED_SINCE_SL_IS_UNLOCKED\n";
        v30 = 29LL;
        goto LABEL_20;
      case 5:
        v29 = "DONE_AND_SL_IS_UNLOCKED\n";
        v30 = 24LL;
        goto LABEL_20;
      default:
        break;
    }
  }
  LODWORD(v151) = 0;
  v31 = sub_3A99C(&v151);
  sub_359A8(&v135, (__int64)"  Security conf\t\t\t", 18LL);
  if ( v31 )
  {
    v32 = "error\n";
    v33 = 6LL;
  }
  else
  {
    if ( (_DWORD)v151 )
      v32 = "LIVE\n";
    else
      v32 = "TEST\n";
    v33 = 5LL;
  }
  sub_359A8(&v135, (__int64)v32, v33);
  v151 = 0LL;
  v131 = 0;
  v34 = sub_39E6C(1, (__int64 *)&v151, &v131);
  sub_359A8(&v135, (__int64)"  IMEI\t\t\t\t\t\t\t\t", 14LL);
  if ( v34 )
  {
    v35 = "error\n";
    v36 = &v135;
    v37 = 6LL;
  }
  else
  {
    v38 = (__int64)v151;
    v39 = strlen(v151);
    sub_359A8(&v135, v38, v39);
    v35 = "\n";
    v37 = 1LL;
  }
  sub_359A8(v36, (__int64)v35, v37);
  free(v151);
  LODWORD(v151) = 1;
  sub_3ABDC(&v151);
  sub_359A8(&v135, (__int64)"  TEE status\t\t\t\t", 16LL);
  if ( (_DWORD)v151 == 1 )
  {
    v40 = "STUBBED\n";
    v41 = 8LL;
  }
  else
  {
    v40 = "NORMAL\n";
    v41 = 7LL;
  }
  sub_359A8(&v135, (__int64)v40, v41);
  v151 = 0LL;
  v42 = sub_3A478((__int64 *)&v151, &v131);
  sub_359A8(&v135, (__int64)"  Keystore hash\n", 16LL);
  if ( v42 )
  {
    v43 = "error\n";
    v44 = 6LL;
  }
  else
  {
    if ( v131 )
    {
      v45 = 0LL;
      do
      {
        v46 = v151;
        *(_DWORD *)((char *)&v135 + *(_QWORD *)(v135 - 24) + 8) = *(_DWORD *)((_BYTE *)&v135 + *(_QWORD *)(v135 - 24)
                                                                                             + 8) & 0xFFFFFFB5 | 8;
        v47 = (unsigned __int8)v46[v45];
        std::__1::basic_ostream<char,std::__1::char_traits<char>>::operator<<((__int64)&v135);
        ++v45;
      }
      while ( v45 < v131 );
    }
    v43 = "\n";
    v44 = 1LL;
  }
  sub_359A8(&v135, (__int64)v43, v44);
  free(v151);
  sub_359A8(&v135, (__int64)"\nTEE\t\t\t\t\tlisteners\t\t\t[", 22LL);
  property_get();
  if ( (unsigned int)strcmp((const char *)&v151, "true") )
  {
    v48 = "ERROR]\n";
    v49 = 7LL;
  }
  else
  {
    v48 = "ACTIVE]\n";
    v49 = 8LL;
  }
  sub_359A8(&v135, (__int64)v48, v49);
  sub_359A8(&v135, (__int64)"  tzxflattest status\t\t\t\t", 24LL);
  v131 = 0;
  if ( (unsigned int)sub_38F4C((__int64)"tzxflattest", 7, &v131, 4u, &v151, 94) )
  {
    v50 = "ERROR\n";
    v51 = 6LL;
    goto LABEL_52;
  }
  sub_359A8(&v135, (__int64)"OK, ver. ", 9LL);
  if ( (_DWORD)v151 == 17825792 )
  {
    v50 = "2\n";
    goto LABEL_50;
  }
  if ( (_DWORD)v151 == 0x1000000 )
  {
    v50 = "1\n";
LABEL_50:
    v51 = 2LL;
    goto LABEL_52;
  }
  v50 = "unknown\n";
  v51 = 8LL;
LABEL_52:
  sub_359A8(&v135, (__int64)v50, v51);
  sub_359A8(&v135, (__int64)"\nSuntory\t\t\tblobs\t\t\t\t\t[", 22LL);
  property_get();
  v119 = v1;
  if ( (unsigned int)strcmp((const char *)&v151, "true") )
    v52 = "ERROR]\n";
  else
    v52 = "READY]\n";
  sub_359A8(&v135, (__int64)v52, 7LL);
  if ( !(unsigned int)sub_332B0(&v134, &v133) )
  {
    v53 = *v134;
    if ( *v134 )
    {
      v54 = 0;
      v55 = (__int64)(v134 + 1);
      do
      {
        v56 = *(_DWORD *)(v55 + 4);
        v57 = *(unsigned int *)(v55 + 8);
        v58 = v55 + 12;
        memset(&v151, 0, 0x80uLL);
        __memcpy_chk();
        sub_359A8(&v135, (__int64)"  ", 2LL);
        v60 = v59;
        v61 = strlen((const char *)&v151);
        sub_359A8(v60, (__int64)&v151, v61);
        sub_359A8(v62, (__int64)"\t\t\t\t", 4LL);
        v64 = v63;
        v65 = "OK";
        switch ( (unsigned int)"OK" )
        {
          case 0u:
            break;
          case 1u:
            v65 = "OK_NO_ROOT";
            break;
          case 2u:
            v65 = "WRONG_VERSION";
            break;
          case 3u:
            v65 = "WRONG_TYPE";
            break;
          case 4u:
            v65 = "MISSING_KEY";
            break;
          case 5u:
            v65 = "MISSING_SMK";
            break;
          case 6u:
            v65 = "INVALID_MAC";
            break;
          case 7u:
            v65 = "MISSING_KEY_ID";
            break;
          case 8u:
            v65 = "CERTIFICATE_ERROR";
            break;
          case 9u:
            v65 = "CERTIFICATE_EXPIRED";
            break;
          case 0xAu:
            v65 = "CERTIFICATE_NOT_VALID_YET";
            break;
          case 0xBu:
            v65 = "INVALID_KEY_PAIR";
            break;
          case 0xCu:
            v65 = "MISSING_GROUP_ID";
            break;
          case 0xDu:
            v65 = "CRYPTO_ERROR";
            break;
          default:
            if ( (unsigned int)"OK" == 255 )
              v65 = "GENERAL_ERROR";
            else
              v65 = "UNKNOWN SUNTORY STATUS";
            break;
        }
        v55 = v58 + v57;
        v66 = strlen(v65);
        sub_359A8(v64, (__int64)v65, v66);
        if ( v56 == 1 )
        {
          v67 = 11LL;
          v68 = "\t\t[ACTIVE]\n";
        }
        else
        {
          v67 = 15LL;
          v68 = "\t\t[NOT ACTIVE]\n";
        }
        sub_359A8(&v135, (__int64)v68, v67);
        ++v54;
      }
      while ( v54 < v53 );
    }
  }
  free(v134);
  sub_359A8(&v135, (__int64)"\nKey Provision daemon\n", 22LL);
  v131 = 1;
  v69 = sub_35FF8(1LL, &v131);
  sub_359A8(&v135, (__int64)"  SOMC FIDO Key", 15LL);
  v1 = v119;
  if ( !v69 )
  {
    if ( v131 )
    {
      v70 = "\t\t\tNOT PROVISIONED\n";
      v71 = &v135;
      v72 = 19LL;
    }
    else
    {
      property_get();
      sub_359A8(&v135, (__int64)"\t\t\tPROVISIONED, ver. ", 21LL);
      v74 = v73;
      v75 = strlen((const char *)&v151);
      sub_359A8(v74, (__int64)&v151, v75);
      v70 = "\n";
      v72 = 1LL;
    }
    sub_359A8(v71, (__int64)v70, v72);
  }
  v130 = 1;
  v76 = sub_35FF8(2LL, &v130);
  sub_359A8(&v135, (__int64)"  SOMC Attest Key", 17LL);
  if ( !v76 )
  {
    if ( v130 )
    {
      v77 = "\t\tNOT PROVISIONED\n";
      v78 = &v135;
      v79 = 18LL;
    }
    else
    {
      property_get();
      sub_359A8(&v135, (__int64)"\t\tPROVISIONED, ver. ", 20LL);
      v81 = v80;
      v82 = strlen((const char *)&v151);
      sub_359A8(v81, (__int64)&v151, v82);
      v77 = "\n";
      v79 = 1LL;
    }
    sub_359A8(v78, (__int64)v77, v79);
  }
  LODWORD(v151) = 1;
  v83 = sub_35FF8(3LL, &v151);
  sub_359A8(&v135, (__int64)"  Android Attest Key", 20LL);
  if ( !v83 )
  {
    if ( (_DWORD)v151 )
    {
      v84 = "\tNOT PROVISIONED\n";
      v85 = 17LL;
    }
    else
    {
      v84 = "\tPROVISIONED\n";
      v85 = 13LL;
    }
    sub_359A8(&v135, (__int64)v84, v85);
  }
  sub_359A8(&v135, (__int64)"\nSPC\t\t\t\t", 8LL);
  if ( v120 )
  {
    LODWORD(v151) = 0;
    sub_359A8(&v135, (__int64)"  startup reason\t\t[", 19LL);
    if ( (unsigned int)libasb_get_startup_reason() )
    {
      v86 = "ERROR\n";
    }
    else
    {
      if ( (_DWORD)v151 != 2 )
      {
        if ( (_DWORD)v151 == 1 )
        {
          v86 = "CRASH]\n";
          v87 = 7LL;
        }
        else if ( (_DWORD)v151 )
        {
          v86 = "UNKNOWN]\n";
          v87 = 9LL;
        }
        else
        {
          v86 = "NORMAL]\n";
          v87 = 8LL;
        }
        goto LABEL_98;
      }
      v86 = "FOTA]\n";
    }
    v87 = 6LL;
LABEL_98:
    sub_359A8(&v135, (__int64)v86, v87);
    sub_359A8(&v135, (__int64)"  Files\t\t\t\t", 11LL);
    v88 = opendir("/persist/pc");
    v89 = v88;
    if ( v88 )
    {
      for ( i = readdir(v88); i; i = readdir(v89) )
      {
        v91 = i->d_name;
        if ( (unsigned int)strcmp(i->d_name, ".") && (unsigned int)strcmp(v91, "..") )
        {
          v92 = strlen(v91);
          sub_359A8(&v135, (__int64)v91, v92);
          sub_359A8(v93, (__int64)", ", 2LL);
        }
      }
      closedir(v89);
      sub_359A8(&v135, (__int64)"\n", 1LL);
    }
    property_get();
    sub_359A8(&v135, (__int64)"  Args\t\t\t\t", 10LL);
    v95 = v94;
    v96 = strlen((const char *)&v151);
    sub_359A8(v95, (__int64)&v151, v96);
    sub_359A8(v97, (__int64)", ", 2LL);
    property_get();
    v98 = strlen((const char *)&v151);
    sub_359A8(&v135, (__int64)&v151, v98);
    v23 = "\n";
    v25 = 1LL;
    goto LABEL_106;
  }
LABEL_107:
  sub_3C170(&v132);
  sub_359A8(&v135, (__int64)"\nCredential Manager, ver ", 25LL);
  *(_DWORD *)((char *)v99 + *(_QWORD *)(*v99 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v99 + *(_QWORD *)(*v99 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  v100 = (_QWORD *)std::__1::basic_ostream<char,std::__1::char_traits<char>>::operator<<((__int64)v99);
  sub_359A8(v100, (__int64)".", 1LL);
  *(_DWORD *)((char *)&v135 + *(_QWORD *)(v135 - 24) + 8) = *(_DWORD *)((_BYTE *)&v135 + *(_QWORD *)(v135 - 24) + 8) & 0xFFFFFFB5 | 2;
  v101 = (_QWORD *)std::__1::basic_ostream<char,std::__1::char_traits<char>>::operator<<((__int64)&v135);
  sub_359A8(v101, (__int64)"\n", 1LL);
  if ( v120 )
  {
    v151 = 0LL;
    v131 = 0;
    sub_359A8(&v135, (__int64)"  Secondary\t\t", 13LL);
    if ( (unsigned int)sub_3C198(
                         (const char *)&unk_C11A8,
                         (const char *)&unk_C11A8,
                         0x10u,
                         "com.sonyericsson.sdo.appid.141",
                         30,
                         (void **)&v151,
                         &v131) )
    {
      v102 = "  [ERROR]\n";
      v103 = 10LL;
    }
    else
    {
      v102 = "  [ACTIVE]\n";
      v103 = 11LL;
    }
    sub_359A8(&v135, (__int64)v102, v103);
    free(v151);
    sub_35DCC((__int64)&v135 + 8, &v127);
    v114 = v127;
    v115 = v128;
    if ( !(v127 & 1) )
      v115 = (unsigned __int64)v127 >> 1;
    v116 = malloc(v115 + 1);
    *v1 = v116;
    if ( v114 & 1 )
    {
      operator delete(v129);
      v116 = *v1;
    }
    sub_35DCC((__int64)&v135 + 8, &v124);
    if ( v124 & 1 )
      v117 = v126;
    else
      v117 = v125;
    sub_35DCC((__int64)&v135 + 8, &v121);
    if ( v121 & 1 )
      v118 = v122;
    else
      v118 = (unsigned __int64)v121 >> 1;
    memcpy(v116, v117, v118 + 1);
    if ( v121 & 1 )
      operator delete(v123);
    if ( v124 & 1 )
      operator delete(v126);
  }
  else
  {
    v104 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_debugmenu_report.cpp";
    if ( __strrchr_chk() )
      v104 = (const char *)(__strrchr_chk() + 1);
    v105 = sub_38F2C(v15);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v104,
      434LL,
      (__int64)"%s() ended. result %d - %s",
      v106,
      v107,
      v108,
      v109,
      v110,
      v111,
      v112,
      v113,
      "devsec_get_debugmenu_report",
      v15,
      v105);
  }
  *(_QWORD *)&v135 = off_F61D8;
  *((_QWORD *)&v135 + 1) = off_F6270;
  v148 = off_F6200;
  if ( v143 & 1 )
    operator delete(v145);
  *((_QWORD *)&v135 + 1) = off_F62F0;
  std::__1::locale::~locale((std::__1::locale *)&v136);
  std::__1::ios_base::~ios_base((std::__1::ios_base *)&v148);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v154;
}
// F61D8: using guessed type __int64 (__fastcall *off_F61D8[2])();
// F6200: using guessed type __int64 (__fastcall *off_F6200[2])();
// F6250: using guessed type __int64 (__fastcall *[2])();
// F6270: using guessed type __int64 (__fastcall *off_F6270[14])();
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (0000000000034898) ----------------------------------------------------
__int64 __fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::operator<<(__int64 result)
{
  _QWORD *v1; // x19
  __int64 v2; // x8
  _QWORD *v3; // x0
  __int64 v4; // x21
  char *v5; // x22
  __int64 v6; // x23
  __int64 v7; // x0
  unsigned __int8 v8; // w24
  char *v9; // x8
  __int64 v10; // [xsp+0h] [xbp-40h]
  __int64 v11; // [xsp+8h] [xbp-38h]

  v1 = (_QWORD *)result;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *(_QWORD *)(*(_QWORD *)result - 24LL);
  if ( !*(_DWORD *)(result + v2 + 32) )
  {
    v3 = *(_QWORD **)(result + v2 + 136);
    if ( v3 )
    {
      std::__1::basic_ostream<char,std::__1::char_traits<char>>::flush(v3);
      v2 = *(_QWORD *)(*v1 - 24LL);
    }
    std::__1::ios_base::getloc((std::__1::ios_base *)((char *)v1 + v2));
    v4 = std::__1::locale::use_facet();
    std::__1::locale::~locale((std::__1::locale *)&v10);
    v5 = (char *)v1 + *(_QWORD *)(*v1 - 24LL);
    v6 = *((_QWORD *)v5 + 5);
    if ( *((_DWORD *)v5 + 36) == -1 )
    {
      std::__1::ios_base::getloc((std::__1::ios_base *)((char *)v1 + *(_QWORD *)(*v1 - 24LL)));
      v7 = std::__1::locale::use_facet();
      v8 = (*(__int64 (**)(void))(*(_QWORD *)v7 + 56LL))();
      std::__1::locale::~locale((std::__1::locale *)&v10);
      *((_DWORD *)v5 + 36) = v8;
    }
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v4 + 48LL))(v4, v6, v5);
    if ( !result )
      result = std::__1::ios_base::clear(
                 (std::__1::ios_base *)((char *)v1 + *(_QWORD *)(*v1 - 24LL)),
                 *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24LL) + 32) | 5u);
  }
  v9 = (char *)v1 + *(_QWORD *)(*v1 - 24LL);
  if ( *((_QWORD *)v9 + 5) )
  {
    if ( !*((_DWORD *)v9 + 8) )
    {
      if ( v9[9] & 0x20 )
      {
        result = std::uncaught_exception();
        if ( !(result & 1) )
        {
          result = (*(__int64 (**)(void))(**(_QWORD **)((char *)v1 + *(_QWORD *)(*v1 - 24LL) + 40) + 48LL))();
          if ( (_DWORD)result == -1 )
            result = std::__1::ios_base::clear(
                       (std::__1::ios_base *)((char *)v1 + *(_QWORD *)(*v1 - 24LL)),
                       *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24LL) + 32) | 1u);
        }
      }
    }
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v11 )
    result = (__int64)v1;
  return result;
}

//----- (0000000000034A48) ----------------------------------------------------
__int64 __fastcall sub_34A48(__int64 a1)
{
  _QWORD *v1; // x19
  char v2; // w10

  v1 = (_QWORD *)a1;
  v2 = *(_BYTE *)(a1 + 72);
  *(_QWORD *)(a1 + 112) = off_F6200;
  *(_QWORD *)a1 = off_F61D8;
  *(_QWORD *)(a1 + 8) = off_F6270;
  if ( v2 & 1 )
    operator delete(*(void **)(a1 + 88));
  v1[1] = off_F62F0;
  std::__1::locale::~locale((std::__1::locale *)(v1 + 2));
  return std::__1::ios_base::~ios_base((std::__1::ios_base *)(v1 + 14));
}
// F61D8: using guessed type __int64 (__fastcall *[2])();
// F6200: using guessed type __int64 (__fastcall *[2])();
// F6270: using guessed type __int64 (__fastcall *[14])();
// F62F0: using guessed type __int64 (__fastcall *[14])();

//----- (0000000000034AB4) ----------------------------------------------------
__int64 __fastcall sub_34AB4(_QWORD *a1)
{
  char *v1; // x20
  char v2; // w8

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  *(_QWORD *)v1 = off_F61D8;
  *((_QWORD *)v1 + 14) = off_F6200;
  v2 = v1[72];
  *((_QWORD *)v1 + 1) = off_F6270;
  if ( v2 & 1 )
    operator delete(*((void **)v1 + 11));
  *((_QWORD *)v1 + 1) = off_F62F0;
  std::__1::locale::~locale((std::__1::locale *)(v1 + 16));
  return std::__1::ios_base::~ios_base((std::__1::ios_base *)(v1 + 112));
}
// F61D8: using guessed type __int64 (__fastcall *off_F61D8[2])();
// F6200: using guessed type __int64 (__fastcall *off_F6200[2])();
// F6270: using guessed type __int64 (__fastcall *off_F6270[14])();
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (0000000000034B30) ----------------------------------------------------
__int64 __fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(__int64 a1)
{
  return std::__1::ios_base::~ios_base((std::__1::ios_base *)(a1 + 8));
}

//----- (0000000000034B38) ----------------------------------------------------
void __fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(__int64 a1)
{
  void *v1; // x19

  v1 = (void *)a1;
  std::__1::ios_base::~ios_base((std::__1::ios_base *)(a1 + 8));
  operator delete(v1);
}

//----- (0000000000034B60) ----------------------------------------------------
__int64 __fastcall `virtual thunk to'std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(_QWORD *a1)
{
  return std::__1::ios_base::~ios_base((std::__1::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 8));
}

//----- (0000000000034B74) ----------------------------------------------------
void __fastcall `virtual thunk to'std::__1::basic_ostream<char,std::__1::char_traits<char>>::~basic_ostream(_QWORD *a1)
{
  char *v1; // x19

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  std::__1::ios_base::~ios_base((std::__1::ios_base *)(v1 + 8));
  operator delete(v1);
}

//----- (0000000000034BA4) ----------------------------------------------------
void __fastcall sub_34BA4(__int64 a1)
{
  _QWORD *v1; // x19
  char v2; // w10

  v1 = (_QWORD *)a1;
  v2 = *(_BYTE *)(a1 + 72);
  *(_QWORD *)(a1 + 112) = off_F6200;
  *(_QWORD *)a1 = off_F61D8;
  *(_QWORD *)(a1 + 8) = off_F6270;
  if ( v2 & 1 )
    operator delete(*(void **)(a1 + 88));
  v1[1] = off_F62F0;
  std::__1::locale::~locale((std::__1::locale *)(v1 + 2));
  std::__1::ios_base::~ios_base((std::__1::ios_base *)(v1 + 14));
  operator delete(v1);
}
// F61D8: using guessed type __int64 (__fastcall *off_F61D8[2])();
// F6200: using guessed type __int64 (__fastcall *off_F6200[2])();
// F6270: using guessed type __int64 (__fastcall *off_F6270[14])();
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (0000000000034C18) ----------------------------------------------------
void __fastcall sub_34C18(_QWORD *a1)
{
  char *v1; // x19
  char v2; // w8

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  *(_QWORD *)v1 = off_F61D8;
  *((_QWORD *)v1 + 14) = off_F6200;
  v2 = v1[72];
  *((_QWORD *)v1 + 1) = off_F6270;
  if ( v2 & 1 )
    operator delete(*((void **)v1 + 11));
  *((_QWORD *)v1 + 1) = off_F62F0;
  std::__1::locale::~locale((std::__1::locale *)(v1 + 16));
  std::__1::ios_base::~ios_base((std::__1::ios_base *)(v1 + 112));
  operator delete(v1);
}
// F61D8: using guessed type __int64 (__fastcall *off_F61D8[2])();
// F6200: using guessed type __int64 (__fastcall *off_F6200[2])();
// F6270: using guessed type __int64 (__fastcall *off_F6270[14])();
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (0000000000034C9C) ----------------------------------------------------
__int64 __fastcall sub_34C9C(__int64 a1)
{
  _QWORD *v1; // x19
  char v2; // w8

  v1 = (_QWORD *)a1;
  v2 = *(_BYTE *)(a1 + 64);
  *(_QWORD *)a1 = off_F6270;
  if ( v2 & 1 )
    operator delete(*(void **)(a1 + 80));
  *v1 = off_F62F0;
  return std::__1::locale::~locale((std::__1::locale *)(v1 + 1));
}
// F6270: using guessed type __int64 (__fastcall *off_F6270[14])();
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (0000000000034CEC) ----------------------------------------------------
void __fastcall sub_34CEC(__int64 a1)
{
  _QWORD *v1; // x19
  char v2; // w8

  v1 = (_QWORD *)a1;
  v2 = *(_BYTE *)(a1 + 64);
  *(_QWORD *)a1 = off_F6270;
  if ( v2 & 1 )
    operator delete(*(void **)(a1 + 80));
  *v1 = off_F62F0;
  std::__1::locale::~locale((std::__1::locale *)(v1 + 1));
  operator delete(v1);
}
// F6270: using guessed type __int64 (__fastcall *off_F6270[14])();
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (0000000000034D48) ----------------------------------------------------
__int64 __fastcall sub_34D48(__int64 a1, signed __int64 a2, int a3, char a4)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x9
  signed __int64 v7; // x10
  signed __int64 v8; // x10

  v4 = *(_QWORD *)(a1 + 88);
  v5 = *(_QWORD *)(a1 + 48);
  if ( v4 < v5 )
  {
    v4 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 88) = v5;
  }
  if ( !(a4 & 0x18) )
    return 0LL;
  if ( a3 == 1 && (a4 & 0x18) == 24 )
    return 0LL;
  if ( a3 )
  {
    if ( a3 == 2 )
    {
      if ( *(_BYTE *)(a1 + 64) & 1 )
        v7 = *(_QWORD *)(a1 + 80);
      else
        v7 = a1 + 65;
      a2 += v4 - v7;
      if ( a2 & 0x8000000000000000LL )
        return 0LL;
    }
    else
    {
      if ( a3 != 1 )
        return 0LL;
      if ( a4 & 8 )
      {
        a2 += *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
        if ( a2 & 0x8000000000000000LL )
          return 0LL;
      }
      else
      {
        a2 += v5 - *(_QWORD *)(a1 + 40);
        if ( a2 & 0x8000000000000000LL )
          return 0LL;
      }
    }
  }
  else if ( a2 & 0x8000000000000000LL )
  {
    return 0LL;
  }
  if ( *(_BYTE *)(a1 + 64) & 1 )
    v8 = *(_QWORD *)(a1 + 80);
  else
    v8 = a1 + 65;
  if ( (signed __int64)(v4 - v8) < a2 )
    return 0LL;
  if ( a2 )
  {
    if ( a4 & 8 && !*(_QWORD *)(a1 + 24) )
      return 0LL;
    if ( a4 & 0x10 && !v5 )
      return 0LL;
  }
  if ( a4 & 8 )
  {
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + a2;
    *(_QWORD *)(a1 + 32) = v4;
  }
  if ( a4 & 0x10 )
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40) + (signed int)a2;
  return 0LL;
}

//----- (0000000000034EA8) ----------------------------------------------------
__int64 __fastcall sub_34EA8(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 32LL))();
}

//----- (0000000000034EBC) ----------------------------------------------------
__int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::sync()
{
  return 0LL;
}

//----- (0000000000034EC4) ----------------------------------------------------
__int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::showmanyc()
{
  return 0LL;
}

//----- (0000000000034ECC) ----------------------------------------------------
signed __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsgetn(_QWORD *a1, _BYTE *a2, signed __int64 a3)
{
  signed __int64 v3; // x19
  _BYTE *v4; // x20
  _QWORD *v5; // x22
  signed __int64 v6; // x21
  char *v7; // x1
  unsigned __int64 v8; // x8
  signed __int64 v9; // x8
  size_t v10; // x23
  int v11; // w0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 < 1 )
    return 0LL;
  v6 = 0LL;
  do
  {
    while ( 1 )
    {
      v7 = (char *)v5[3];
      v8 = v5[4];
      if ( (unsigned __int64)v7 < v8 )
        break;
      v11 = (*(__int64 (__fastcall **)(_QWORD *))(*v5 + 80LL))(v5);
      if ( v11 != -1 )
      {
        *v4++ = v11;
        if ( ++v6 < v3 )
          continue;
      }
      return v6;
    }
    v9 = v8 - (_QWORD)v7;
    if ( v3 - v6 >= v9 )
      v10 = v9;
    else
      v10 = v3 - v6;
    if ( v10 )
    {
      memcpy(v4, v7, v10);
      v7 = (char *)v5[3];
    }
    v4 += v10;
    v6 += v10;
    v5[3] = &v7[(signed int)v10];
  }
  while ( v6 < v3 );
  return v6;
}

//----- (0000000000034F8C) ----------------------------------------------------
signed __int64 __fastcall sub_34F8C(__int64 a1)
{
  unsigned __int64 v1; // x8
  unsigned __int64 v2; // x9
  signed __int64 result; // x0
  unsigned __int64 v4; // x9
  unsigned __int8 *v5; // x8

  v1 = *(_QWORD *)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 48);
  if ( v1 < v2 )
  {
    v1 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 88) = v2;
  }
  if ( !(*(_BYTE *)(a1 + 96) & 8) )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 32);
  if ( v4 < v1 )
  {
    v4 = v1;
    *(_QWORD *)(a1 + 32) = v1;
  }
  v5 = *(unsigned __int8 **)(a1 + 24);
  if ( (unsigned __int64)v5 >= v4 )
    result = 0xFFFFFFFFLL;
  else
    result = *v5;
  return result;
}

//----- (0000000000034FE4) ----------------------------------------------------
signed __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::uflow(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int8 *v2; // x8

  v1 = a1;
  if ( (*(unsigned int (**)(void))(*(_QWORD *)a1 + 72LL))() == -1 )
    return 0xFFFFFFFFLL;
  v2 = *(unsigned __int8 **)(v1 + 24);
  *(_QWORD *)(v1 + 24) = v2 + 1;
  return *v2;
}

//----- (000000000003502C) ----------------------------------------------------
signed __int64 __fastcall sub_3502C(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x9
  _BYTE *v5; // x9
  int v6; // t1
  signed __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 88);
  v3 = *(_QWORD *)(a1 + 48);
  if ( v2 < v3 )
  {
    v2 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 88) = v3;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if ( *(_QWORD *)(a1 + 16) >= v4 )
    return 0xFFFFFFFFLL;
  if ( a2 == -1 )
  {
    *(_QWORD *)(a1 + 24) = v4 - 1;
    *(_QWORD *)(a1 + 32) = v2;
    result = 0LL;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 96) & 0x10 )
    {
      v5 = (_BYTE *)(v4 - 1);
    }
    else
    {
      v6 = *(unsigned __int8 *)(v4 - 1);
      v5 = (_BYTE *)(v4 - 1);
      if ( (unsigned __int8)a2 != v6 )
        return 0xFFFFFFFFLL;
    }
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = v2;
    result = a2;
    *v5 = a2;
  }
  return result;
}

//----- (00000000000350A4) ----------------------------------------------------
signed __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::xsputn(_QWORD *a1, unsigned __int8 *a2, signed __int64 a3)
{
  signed __int64 v3; // x19
  unsigned __int8 *v4; // x20
  _QWORD *v5; // x22
  signed __int64 v6; // x21
  char *v7; // x0
  unsigned __int64 v8; // x8
  signed __int64 v9; // x8
  size_t v10; // x23

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 < 1 )
    return 0LL;
  v6 = 0LL;
  do
  {
    while ( 1 )
    {
      v7 = (char *)v5[6];
      v8 = v5[7];
      if ( (unsigned __int64)v7 < v8 )
        break;
      if ( (*(unsigned int (__fastcall **)(_QWORD *, _QWORD))(*v5 + 104LL))(v5, *v4) != -1 )
      {
        ++v4;
        if ( ++v6 < v3 )
          continue;
      }
      return v6;
    }
    v9 = v8 - (_QWORD)v7;
    if ( v3 - v6 >= v9 )
      v10 = v9;
    else
      v10 = v3 - v6;
    if ( v10 )
    {
      memcpy(v7, v4, v10);
      v7 = (char *)v5[6];
    }
    v4 += v10;
    v6 += v10;
    v5[6] = &v7[v10];
  }
  while ( v6 < v3 );
  return v6;
}

//----- (0000000000035168) ----------------------------------------------------
__int64 __fastcall sub_35168(__int64 a1, int a2)
{
  unsigned __int8 v2; // w19
  _QWORD *v3; // x20
  unsigned __int8 *v4; // x8
  unsigned __int8 *v5; // x26
  __int64 v6; // x22
  __int64 v7; // x23
  unsigned __int64 v8; // x10
  __int64 *v9; // x25
  _BYTE *v10; // x24
  __int64 result; // x0
  __int64 v12; // x28
  unsigned __int64 v13; // x9
  _BYTE *v14; // x21
  unsigned __int64 v15; // x27
  unsigned __int64 v16; // x1
  signed __int64 v17; // x8
  _BYTE *v18; // x8
  __int64 v19; // x9
  unsigned __int64 v20; // x8
  unsigned __int64 v21; // x10
  int v22; // w26
  unsigned __int64 v23; // x8
  __int64 v24; // x9
  signed __int64 v25; // x11
  unsigned __int64 v26; // x8
  bool v27; // cf
  __int64 *v28; // x10
  __int64 v29; // x10
  signed __int64 v30; // x12
  __int64 v31; // [xsp+8h] [xbp-68h]
  _BYTE *v32; // [xsp+10h] [xbp-60h]
  __int64 v33; // [xsp+18h] [xbp-58h]

  v2 = a2;
  v3 = (_QWORD *)a1;
  v33 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 == -1 )
  {
    result = 0LL;
    goto LABEL_41;
  }
  v5 = *(unsigned __int8 **)(a1 + 48);
  v4 = *(unsigned __int8 **)(a1 + 56);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  if ( v5 == v4 )
  {
    v10 = (_BYTE *)(a1 + 96);
    if ( !(*(_BYTE *)(a1 + 96) & 0x10) )
    {
      result = 0xFFFFFFFFLL;
      goto LABEL_41;
    }
    v9 = (__int64 *)(a1 + 88);
    v31 = *(_QWORD *)(a1 + 88);
    v12 = *(_QWORD *)(a1 + 40);
    v14 = (_BYTE *)(a1 + 64);
    v13 = *(unsigned __int8 *)(a1 + 64);
    if ( v13 & 1 )
    {
      v15 = *(_QWORD *)(a1 + 72);
      v16 = (*(_QWORD *)(a1 + 64) & 0xFFFFFFFFFFFFFFFELL) - 1;
      if ( v15 != v16 )
      {
LABEL_13:
        if ( v13 & 1 )
          goto LABEL_14;
        goto LABEL_15;
      }
    }
    else
    {
      v15 = v13 >> 1;
      v16 = 22LL;
      if ( v13 >> 1 != 22 )
        goto LABEL_13;
    }
    std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::__grow_by(
      (_QWORD *)(a1 + 64),
      v16,
      1uLL,
      v16,
      v16,
      0LL,
      0LL);
    if ( *v14 & 1 )
    {
LABEL_14:
      v17 = v3[10];
      v3[9] = v15 + 1;
      goto LABEL_16;
    }
LABEL_15:
    *v14 = 2 * v15 + 2;
    v17 = (signed __int64)v3 + 65;
LABEL_16:
    v18 = (_BYTE *)(v17 + v15);
    *v18 = 0;
    v18[1] = 0;
    LOBYTE(v19) = *v14;
    if ( *v14 & 1 )
    {
      v19 = *(_QWORD *)v14;
      v20 = (*(_QWORD *)v14 & 0xFFFFFFFFFFFFFFFELL) - 1;
      if ( *(_QWORD *)v14 & 1 )
      {
LABEL_21:
        v21 = v3[9];
        goto LABEL_22;
      }
    }
    else
    {
      v20 = 22LL;
      if ( *v14 & 1 )
        goto LABEL_21;
    }
    v21 = (unsigned __int64)((unsigned __int8)v19 & 0xFE) >> 1;
LABEL_22:
    v22 = (_DWORD)v5 - v12;
    if ( v20 <= v21 )
    {
      if ( v19 & 1 )
      {
        *(_BYTE *)(v3[10] + v20) = 0;
        v3[9] = v20;
      }
      else
      {
        v14[v20 + 1] = 0;
        *v14 = 2 * v20;
      }
    }
    else
    {
      std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::append(v3 + 8, v20 - v21, 0);
    }
    v23 = (unsigned __int8)*v14;
    v24 = v31 - v12;
    if ( v23 & 1 )
    {
      v26 = v3[9];
      v25 = v3[10];
    }
    else
    {
      v25 = (signed __int64)v3 + 65;
      v26 = v23 >> 1;
    }
    v4 = (unsigned __int8 *)(v25 + v26);
    v5 = (unsigned __int8 *)(v25 + v22);
    v8 = v25 + v24;
    v3[6] = v5;
    v3[7] = v4;
    v3[5] = v25;
    v3[11] = v25 + v24;
    goto LABEL_31;
  }
  v9 = (__int64 *)(a1 + 88);
  v8 = *(_QWORD *)(a1 + 88);
  v10 = (_BYTE *)(a1 + 96);
LABEL_31:
  v27 = (unsigned __int64)(v5 + 1) >= v8;
  v28 = (__int64 *)&v32;
  v32 = v5 + 1;
  if ( !v27 )
    v28 = v9;
  v29 = *v28;
  *v9 = v29;
  if ( *v10 & 8 )
  {
    if ( v3[8] & 1 )
      v30 = v3[10];
    else
      v30 = (signed __int64)v3 + 65;
    v3[2] = v30;
    v3[3] = v30 + v7 - v6;
    v3[4] = v29;
  }
  if ( v5 == v4 )
  {
    result = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v3 + 104LL))(v3, v2);
  }
  else
  {
    v3[6] = v5 + 1;
    *v5 = v2;
    result = v2;
  }
LABEL_41:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000353DC) ----------------------------------------------------
__int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::~basic_streambuf(_QWORD *a1)
{
  *a1 = off_F62F0;
  return std::__1::locale::~locale((std::__1::locale *)(a1 + 1));
}
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (00000000000353F0) ----------------------------------------------------
void __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::~basic_streambuf(_QWORD *a1)
{
  void *v1; // x19

  v1 = a1;
  *a1 = off_F62F0;
  std::__1::locale::~locale((std::__1::locale *)(a1 + 1));
  operator delete(v1);
}
// F62F0: using guessed type __int64 (__fastcall *off_F62F0[14])();

//----- (0000000000035424) ----------------------------------------------------
__int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::seekpos()
{
  return 0LL;
}

//----- (0000000000035430) ----------------------------------------------------
signed __int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::underflow()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000035438) ----------------------------------------------------
void __fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::__grow_by(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, size_t a5, __int64 a6, __int64 a7)
{
  unsigned __int64 v7; // x20
  __int64 v8; // x21
  __int64 v9; // x22
  size_t v10; // x23
  __int64 v11; // x25
  signed __int64 *v12; // x19
  char *v13; // x24
  unsigned __int64 v14; // x8
  signed __int64 v15; // x26
  char *v16; // x0
  char *v17; // x27

  v7 = a2;
  v8 = a7;
  v9 = a6;
  v10 = a5;
  v11 = a4;
  v12 = a1;
  if ( -17LL - a2 < a3 )
    std::__1::__basic_string_common<true>::__throw_length_error();
  if ( *(_BYTE *)a1 & 1 )
    v13 = (char *)a1[2];
  else
    v13 = (char *)a1 + 1;
  if ( a2 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v15 = -17LL;
  }
  else
  {
    v14 = a3 + a2;
    if ( a3 + a2 < 2 * a2 )
      v14 = 2 * a2;
    if ( v14 >= 0x17 )
      v15 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v15 = 23LL;
  }
  v16 = (char *)operator new(v15);
  v17 = v16;
  if ( v10 )
    memcpy(v16, v13, v10);
  if ( v11 - v9 != v10 )
    memcpy(&v17[v10 + v8], &v13[v10 + v9], v11 - v9 - v10);
  if ( v7 != 22 )
    operator delete(v13);
  v12[2] = (signed __int64)v17;
  *v12 = v15 | 1;
}

//----- (0000000000035550) ----------------------------------------------------
void __noreturn std::__1::__basic_string_common<true>::__throw_length_error()
{
  abort();
}

//----- (000000000003555C) ----------------------------------------------------
_QWORD *__fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::append(_QWORD *a1, size_t a2, int a3)
{
  int v3; // w21
  size_t v4; // x20
  _QWORD *v5; // x19
  __int64 v6; // x8
  unsigned __int64 v7; // x1
  unsigned __int64 v8; // x22
  signed __int64 v9; // x23
  unsigned __int64 v10; // x8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a2 )
    return v5;
  LOBYTE(v6) = *(_BYTE *)a1;
  if ( *(_BYTE *)a1 & 1 )
  {
    v6 = *a1;
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( *a1 & 1 )
    {
LABEL_7:
      v8 = a1[1];
      goto LABEL_8;
    }
  }
  else
  {
    v7 = 22LL;
    if ( *(_BYTE *)a1 & 1 )
      goto LABEL_7;
  }
  v8 = (unsigned __int64)((unsigned __int8)v6 & 0xFE) >> 1;
LABEL_8:
  if ( v7 - v8 < v4 )
  {
    std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::__grow_by(
      a1,
      v7,
      v4 - v7 + v8,
      v8,
      v8,
      0LL,
      0LL);
    LOBYTE(v6) = *(_BYTE *)v5;
  }
  if ( v6 & 1 )
    v9 = v5[2];
  else
    v9 = (signed __int64)v5 + 1;
  memset((void *)(v9 + v8), v3, v4);
  v10 = v8 + v4;
  if ( *(_BYTE *)v5 & 1 )
    v5[1] = v10;
  else
    *(_BYTE *)v5 = 2 * v10;
  *(_BYTE *)(v9 + v10) = 0;
  return v5;
}

//----- (000000000003563C) ----------------------------------------------------
_QWORD *__fastcall sub_3563C(_QWORD *result, unsigned __int8 *a2)
{
  _QWORD *v2; // x19
  _QWORD *v3; // x20
  unsigned __int64 v4; // x8
  size_t v5; // x10
  bool v6; // zf
  size_t v7; // x8
  const void *v8; // x1
  size_t v9; // x2
  int v10; // w8
  unsigned __int64 v11; // x10
  signed __int64 v12; // x9
  signed __int64 v13; // x10
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x21
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x10
  size_t v18; // x1
  unsigned __int64 v19; // x10
  unsigned __int64 v20; // x9
  signed __int64 v21; // x8
  unsigned __int64 v22; // x9
  char v23; // w10

  v2 = result;
  v3 = result + 8;
  if ( result + 8 != (_QWORD *)a2 )
  {
    v4 = *a2;
    v5 = *((_QWORD *)a2 + 1);
    v6 = (v4 & 1) == 0;
    v7 = v4 >> 1;
    if ( v6 )
      v8 = a2 + 1;
    else
      v8 = (const void *)*((_QWORD *)a2 + 2);
    if ( v6 )
      v9 = v7;
    else
      v9 = v5;
    result = std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::assign(
               result + 8,
               v8,
               v9);
  }
  v10 = *((_DWORD *)v2 + 24);
  v2[11] = 0LL;
  if ( v10 & 8 )
  {
    v11 = *(unsigned __int8 *)v3;
    if ( v11 & 1 )
    {
      v12 = v2[10];
      v13 = v12 + v2[9];
    }
    else
    {
      v12 = (signed __int64)v3 + 1;
      v13 = (signed __int64)v3 + (v11 >> 1) + 1;
    }
    v2[11] = v13;
    v2[2] = v12;
    v2[3] = v12;
    v2[4] = v13;
  }
  if ( v10 & 0x10 )
  {
    v14 = *(unsigned __int8 *)v3;
    if ( v14 & 1 )
    {
      v15 = v2[9];
      v14 = v2[8];
      v2[11] = v2[10] + v15;
      v16 = (v14 & 0xFFFFFFFFFFFFFFFELL) - 1;
      if ( v14 & 1 )
        goto LABEL_21;
    }
    else
    {
      v15 = v14 >> 1;
      v2[11] = (char *)v3 + (v14 >> 1) + 1;
      v16 = 22LL;
      if ( v14 & 1 )
      {
LABEL_21:
        v19 = v2[9];
        v18 = v16 - v19;
        if ( v16 > v19 )
        {
LABEL_22:
          result = std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::append(
                     v3,
                     v18,
                     0);
          v20 = *(unsigned __int8 *)v3;
          if ( v20 & 1 )
            goto LABEL_29;
          goto LABEL_28;
        }
LABEL_24:
        if ( v14 & 1 )
        {
          *(_BYTE *)(v2[10] + v16) = 0;
          v2[9] = v16;
          v20 = *(unsigned __int8 *)v3;
          if ( v20 & 1 )
          {
LABEL_29:
            v22 = v2[9];
            v21 = v2[10];
LABEL_30:
            v23 = *((_BYTE *)v2 + 96);
            v2[5] = v21;
            v2[6] = v21;
            v2[7] = v21 + v22;
            if ( v23 & 3 )
              v2[6] = v21 + (signed int)v15;
            return result;
          }
        }
        else
        {
          *((_BYTE *)v3 + v16 + 1) = 0;
          *(_BYTE *)v3 = 2 * v16;
          v20 = *(unsigned __int8 *)v3;
          if ( v20 & 1 )
            goto LABEL_29;
        }
LABEL_28:
        v21 = (signed __int64)v3 + 1;
        v22 = v20 >> 1;
        goto LABEL_30;
      }
    }
    v17 = (unsigned __int64)((unsigned __int8)v14 & 0xFE) >> 1;
    v18 = v16 - v17;
    if ( v16 > v17 )
      goto LABEL_22;
    goto LABEL_24;
  }
  return result;
}

//----- (00000000000357A0) ----------------------------------------------------
_QWORD *__fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::assign(_QWORD *a1, const void *a2, size_t a3)
{
  _QWORD *v3; // x19
  __int64 v4; // x9
  size_t v5; // x20
  const void *v6; // x8
  unsigned __int64 v7; // x1
  __int64 v8; // x3
  _BYTE *v9; // x21

  v3 = a1;
  LOBYTE(v4) = *(_BYTE *)a1;
  v5 = a3;
  v6 = a2;
  if ( *(_BYTE *)a1 & 1 )
  {
    v4 = *a1;
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  }
  else
  {
    v7 = 22LL;
  }
  if ( v7 >= a3 )
  {
    if ( v4 & 1 )
    {
      v9 = (_BYTE *)a1[2];
      if ( !a3 )
        goto LABEL_14;
    }
    else
    {
      v9 = (char *)a1 + 1;
      if ( !a3 )
      {
LABEL_14:
        v9[v5] = 0;
        if ( *(_BYTE *)v3 & 1 )
          v3[1] = v5;
        else
          *(_BYTE *)v3 = 2 * v5;
        return v3;
      }
    }
    memmove(v9, v6, a3);
    goto LABEL_14;
  }
  if ( v4 & 1 )
    v8 = a1[1];
  else
    v8 = (unsigned __int64)((unsigned __int8)v4 & 0xFE) >> 1;
  std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::__grow_by_and_replace(
    a1,
    v7,
    a3 - v7,
    v8,
    0LL,
    v8,
    a3,
    v6);
  return v3;
}

//----- (0000000000035870) ----------------------------------------------------
void __fastcall std::__1::basic_string<char,std::__1::char_traits<char>,std::__1::allocator<char>>::__grow_by_and_replace(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, size_t a5, __int64 a6, size_t a7, const void *a8)
{
  unsigned __int64 v8; // x21
  const void *v9; // x26
  size_t v10; // x19
  __int64 v11; // x22
  size_t v12; // x23
  __int64 v13; // x25
  signed __int64 *v14; // x20
  char *v15; // x24
  unsigned __int64 v16; // x8
  signed __int64 v17; // x27
  _BYTE *v18; // x0
  _BYTE *v19; // x28
  __int64 v20; // x25

  v8 = a2;
  v9 = a8;
  v10 = a7;
  v11 = a6;
  v12 = a5;
  v13 = a4;
  v14 = a1;
  if ( -18LL - a2 < a3 )
    std::__1::__basic_string_common<true>::__throw_length_error();
  if ( *(_BYTE *)a1 & 1 )
    v15 = (char *)a1[2];
  else
    v15 = (char *)a1 + 1;
  if ( a2 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v17 = -17LL;
  }
  else
  {
    v16 = a3 + a2;
    if ( a3 + a2 < 2 * a2 )
      v16 = 2 * a2;
    if ( v16 >= 0x17 )
      v17 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v17 = 23LL;
  }
  v18 = (_BYTE *)operator new(v17);
  v19 = v18;
  if ( v12 )
    memcpy(v18, v15, v12);
  if ( v10 )
    memcpy(&v19[v12], v9, v10);
  v20 = v13 - v11;
  if ( v20 != v12 )
    memcpy(&v19[v12 + v10], &v15[v12 + v11], v20 - v12);
  if ( v8 != 22 )
    operator delete(v15);
  *v14 = v17 | 1;
  v14[1] = v20 + v10;
  v14[2] = (signed __int64)v19;
  v19[v20 + v10] = 0;
}

//----- (00000000000359A8) ----------------------------------------------------
void __fastcall sub_359A8(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // x19
  __int64 v4; // x22
  __int64 v5; // x20
  __int64 v6; // x8
  _QWORD *v7; // x0
  std::__1::ios_base *v8; // x21
  __int64 v9; // x23
  int v10; // w5
  __int64 v11; // x22
  __int64 v12; // x24
  __int64 v13; // x0
  unsigned __int8 v14; // w25
  __int64 v15; // x0
  char *v16; // x8
  __int64 v17; // [xsp+0h] [xbp-50h]
  __int64 v18; // [xsp+8h] [xbp-48h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = *(_QWORD *)(*a1 - 24LL);
  if ( !*(_DWORD *)((char *)a1 + v6 + 32) )
  {
    v7 = *(_QWORD **)((char *)a1 + v6 + 136);
    if ( v7 )
    {
      std::__1::basic_ostream<char,std::__1::char_traits<char>>::flush(v7);
      v6 = *(_QWORD *)(*v3 - 24LL);
    }
    v8 = (std::__1::ios_base *)((char *)v3 + v6);
    v9 = *(_QWORD *)((char *)v3 + v6 + 40);
    v10 = *(_DWORD *)((char *)v3 + v6 + 144);
    v11 = v5 + v4;
    if ( (*(_DWORD *)((_BYTE *)v3 + v6 + 8) & 0xB0) == 32 )
      v12 = v11;
    else
      v12 = v5;
    if ( v10 == -1 )
    {
      std::__1::ios_base::getloc(v8);
      v13 = std::__1::locale::use_facet();
      v14 = (*(__int64 (**)(void))(*(_QWORD *)v13 + 56LL))();
      std::__1::locale::~locale((std::__1::locale *)&v17);
      v10 = v14;
      *((_DWORD *)v8 + 36) = v14;
    }
    sub_35B48(v9, v5, v12, v11, (__int64)v8, v10);
    if ( !v15 )
      std::__1::ios_base::clear(
        (std::__1::ios_base *)((char *)v3 + *(_QWORD *)(*v3 - 24LL)),
        *(_DWORD *)((char *)v3 + *(_QWORD *)(*v3 - 24LL) + 32) | 5);
  }
  v16 = (char *)v3 + *(_QWORD *)(*v3 - 24LL);
  if ( *((_QWORD *)v16 + 5)
    && !*((_DWORD *)v16 + 8)
    && v16[9] & 0x20
    && !(std::uncaught_exception() & 1)
    && (*(unsigned int (**)(void))(**(_QWORD **)((char *)v3 + *(_QWORD *)(*v3 - 24LL) + 40) + 48LL))() == -1 )
  {
    std::__1::ios_base::clear(
      (std::__1::ios_base *)((char *)v3 + *(_QWORD *)(*v3 - 24LL)),
      *(_DWORD *)((char *)v3 + *(_QWORD *)(*v3 - 24LL) + 32) | 1);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000035B48) ----------------------------------------------------
void __fastcall sub_35B48(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)
{
  int v6; // w24
  __int64 v7; // x20
  __int64 v8; // x22
  __int64 v9; // x21
  __int64 v10; // x19
  __int64 v11; // x8
  signed __int64 v12; // x25
  unsigned __int8 v13; // vf
  __int64 v14; // x8
  size_t v15; // x23
  char *v16; // x25
  char *v17; // x1
  __int64 v18; // x24
  signed __int64 v19; // x22
  unsigned __int64 v20; // [xsp+0h] [xbp-60h]
  size_t v21; // [xsp+8h] [xbp-58h]
  void *v22; // [xsp+10h] [xbp-50h]
  __int64 v23; // [xsp+18h] [xbp-48h]

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a1;
  v23 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v11 = *(_QWORD *)(a5 + 24);
    v12 = a3 - a2;
    v13 = __OFSUB__(v11, a4 - a2);
    v14 = v11 - (a4 - a2);
    v15 = (unsigned __int8)((v14 < 0) ^ v13) | (v14 == 0) ? 0LL : v14;
    if ( v12 < 1 || (*(__int64 (**)(void))(*(_QWORD *)a1 + 96LL))() == v12 )
    {
      if ( (signed __int64)v15 < 1 )
        goto LABEL_23;
      v21 = 0LL;
      v22 = 0LL;
      v20 = 0LL;
      if ( v15 >= 0x17 )
      {
        v16 = (char *)operator new((v15 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v21 = v15;
        v22 = v16;
        v20 = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v16 = (char *)&v20 + 1;
        LOBYTE(v20) = 2 * v15;
      }
      memset(v16, v6, v15);
      v16[v15] = 0;
      if ( v20 & 1 )
        v17 = (char *)v22;
      else
        v17 = (char *)&v20 + 1;
      v18 = (*(__int64 (__fastcall **)(__int64, char *, size_t))(*(_QWORD *)v10 + 96LL))(v10, v17, v15);
      if ( v20 & 1 )
        operator delete(v22);
      if ( v18 == v15 )
      {
LABEL_23:
        v19 = v8 - v9;
        if ( v19 < 1
          || (*(__int64 (__fastcall **)(__int64, __int64, signed __int64))(*(_QWORD *)v10 + 96LL))(v10, v9, v19) == v19 )
        {
          *(_QWORD *)(v7 + 24) = 0LL;
        }
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000035CDC) ----------------------------------------------------
_QWORD *__fastcall std::__1::basic_ostream<char,std::__1::char_traits<char>>::flush(_QWORD *a1)
{
  _QWORD *v1; // x19
  char *v2; // x8
  __int64 v3; // x0
  __int64 v4; // x8
  char *v5; // x8

  v1 = a1;
  v2 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  v3 = *((_QWORD *)v2 + 5);
  if ( v3 )
  {
    if ( !*((_DWORD *)v2 + 8) )
    {
      v4 = *((_QWORD *)v2 + 17);
      if ( v4 )
      {
        std::__1::basic_ostream<char,std::__1::char_traits<char>>::flush(v4);
        v3 = *(_QWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24LL) + 40);
      }
      if ( (*(unsigned int (**)(void))(*(_QWORD *)v3 + 48LL))() == -1 )
        std::__1::ios_base::clear(
          (std::__1::ios_base *)((char *)v1 + *(_QWORD *)(*v1 - 24LL)),
          *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24LL) + 32) | 1);
    }
    v5 = (char *)v1 + *(_QWORD *)(*v1 - 24LL);
    if ( *((_QWORD *)v5 + 5)
      && !*((_DWORD *)v5 + 8)
      && v5[9] & 0x20
      && !(std::uncaught_exception() & 1)
      && (*(unsigned int (**)(void))(**(_QWORD **)((char *)v1 + *(_QWORD *)(*v1 - 24LL) + 40) + 48LL))() == -1 )
    {
      std::__1::ios_base::clear(
        (std::__1::ios_base *)((char *)v1 + *(_QWORD *)(*v1 - 24LL)),
        *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24LL) + 32) | 1);
    }
  }
  return v1;
}

//----- (0000000000035DCC) ----------------------------------------------------
__int64 __usercall sub_35DCC@<X0>(__int64 result@<X0>, _QWORD *a2@<X8>)
{
  int v2; // w9
  unsigned __int64 *v3; // x19
  char *v4; // x21
  unsigned __int64 v5; // x8
  char *v6; // x23
  unsigned __int64 v7; // x22
  char *v8; // x19
  char *v9; // x23
  char *v10; // x21
  char *v11; // x8
  unsigned __int64 v12; // x9
  _OWORD *v13; // x11
  __int128 *v14; // x12
  unsigned __int64 v15; // x13
  __int128 v16; // q0
  __int128 v17; // q1
  char *v18; // x8
  unsigned __int64 v19; // x9
  _OWORD *v20; // x11
  __int128 *v21; // x12
  unsigned __int64 v22; // x13
  __int128 v23; // q0
  __int128 v24; // q1
  char v25; // t1
  char v26; // t1

  v2 = *(_DWORD *)(result + 96);
  v3 = a2;
  if ( v2 & 0x10 )
  {
    v4 = *(char **)(result + 88);
    v5 = *(_QWORD *)(result + 48);
    if ( (unsigned __int64)v4 < v5 )
    {
      v4 = *(char **)(result + 48);
      *(_QWORD *)(result + 88) = v5;
    }
    v6 = *(char **)(result + 40);
    v3[1] = 0LL;
    v3[2] = 0LL;
    *v3 = 0LL;
    v7 = v4 - v6;
    if ( (unsigned __int64)(v4 - v6) < 0xFFFFFFFFFFFFFFF0LL )
    {
      if ( v7 > 0x16 )
      {
        result = operator new((v7 + 16) & 0xFFFFFFFFFFFFFFF0LL);
        v3[1] = v7;
        v3[2] = result;
        *v3 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
        v8 = (char *)result;
        if ( v6 == v4 )
          goto LABEL_40;
      }
      else
      {
        *(_BYTE *)v3 = 2 * v7;
        v8 = (char *)v3 + 1;
        if ( v6 == v4 )
          goto LABEL_40;
      }
      if ( v7 >= 0x20 )
      {
        v12 = v7 & 0xFFFFFFFFFFFFFFE0LL;
        if ( v7 & 0xFFFFFFFFFFFFFFE0LL )
        {
          if ( v8 >= v4 || (v11 = v8, v6 >= &v8[v7]) )
          {
            v11 = &v8[v12];
            v13 = v8 + 16;
            v14 = (__int128 *)(v6 + 16);
            v15 = v7 & 0xFFFFFFFFFFFFFFE0LL;
            do
            {
              v16 = *(v14 - 1);
              v17 = *v14;
              v14 += 2;
              v15 -= 32LL;
              *(v13 - 1) = v16;
              *v13 = v17;
              v13 += 2;
            }
            while ( v15 );
            v6 += v12;
            if ( v7 == v12 )
              goto LABEL_39;
          }
        }
        else
        {
          v11 = v8;
        }
      }
      else
      {
        v11 = v8;
      }
      do
      {
        v25 = *v6++;
        *v11++ = v25;
      }
      while ( v4 != v6 );
      goto LABEL_39;
    }
LABEL_42:
    std::__1::__basic_string_common<true>::__throw_length_error();
  }
  if ( !(v2 & 8) )
  {
    a2[1] = 0LL;
    a2[2] = 0LL;
    *a2 = 0LL;
    return result;
  }
  v9 = *(char **)(result + 16);
  v10 = *(char **)(result + 32);
  a2[1] = 0LL;
  a2[2] = 0LL;
  *a2 = 0LL;
  v7 = v10 - v9;
  if ( (unsigned __int64)(v10 - v9) >= 0xFFFFFFFFFFFFFFF0LL )
    goto LABEL_42;
  if ( v7 <= 0x16 )
  {
    *(_BYTE *)a2 = 2 * v7;
    v8 = (char *)a2 + 1;
    if ( v9 == v10 )
      goto LABEL_40;
    goto LABEL_25;
  }
  result = operator new((v7 + 16) & 0xFFFFFFFFFFFFFFF0LL);
  v3[1] = v7;
  v3[2] = result;
  *v3 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  v8 = (char *)result;
  if ( v9 != v10 )
  {
LABEL_25:
    if ( v7 >= 0x20 )
    {
      v19 = v7 & 0xFFFFFFFFFFFFFFE0LL;
      if ( v7 & 0xFFFFFFFFFFFFFFE0LL )
      {
        if ( v8 >= v10 || (v18 = v8, v9 >= &v8[v7]) )
        {
          v18 = &v8[v19];
          v20 = v8 + 16;
          v21 = (__int128 *)(v9 + 16);
          v22 = v7 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v23 = *(v21 - 1);
            v24 = *v21;
            v21 += 2;
            v22 -= 32LL;
            *(v20 - 1) = v23;
            *v20 = v24;
            v20 += 2;
          }
          while ( v22 );
          v9 += v19;
          if ( v7 == v19 )
            goto LABEL_39;
        }
      }
      else
      {
        v18 = v8;
      }
    }
    else
    {
      v18 = v8;
    }
    do
    {
      v26 = *v9++;
      *v18++ = v26;
    }
    while ( v10 != v9 );
LABEL_39:
    v8 += v7;
  }
LABEL_40:
  *v8 = 0;
  return result;
}

//----- (0000000000035FF8) ----------------------------------------------------
__int64 __fastcall sub_35FF8(__int64 result, _DWORD *a2)
{
  _DWORD *v2; // x19
  const char *v3; // x19
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  const char *v12; // x19
  unsigned int v13; // w20
  char *v14; // x0
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  DIR *v23; // x20
  unsigned int v24; // w24
  struct dirent *v25; // x0
  const char *v26; // x23
  const char *v27; // x19
  int *v28; // x0
  char *v29; // x0
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  char v38; // [xsp+Ch] [xbp-94h]
  __int64 v39; // [xsp+68h] [xbp-38h]

  v2 = a2;
  v39 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 )
  {
    *a2 = 1;
    if ( (_DWORD)result == 3 )
    {
      v23 = opendir("/persist/data/keymaster64");
      if ( v23 )
      {
        v24 = 0;
        while ( 1 )
        {
          v25 = readdir(v23);
          if ( !v25 )
            break;
          v26 = v25->d_name;
          if ( (unsigned int)strcmp(v25->d_name, ".") && (unsigned int)strcmp(v26, "..") )
            ++v24;
        }
        result = closedir(v23);
        if ( v24 >= 5 )
          goto LABEL_21;
      }
      else
      {
        v27 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_key_prov_status.cpp";
        if ( __strrchr_chk() )
          v27 = (const char *)(__strrchr_chk() + 1);
        v28 = (int *)__errno();
        v29 = strerror(*v28);
        result = sub_379E4(
                   (__int64)"secd",
                   1,
                   (__int64)v27,
                   79LL,
                   (__int64)"failed to open %s dir, error %s",
                   v30,
                   v31,
                   v32,
                   v33,
                   v34,
                   v35,
                   v36,
                   v37,
                   "/persist/data/keymaster64",
                   v29);
      }
    }
    else if ( (_DWORD)result == 2 || (_DWORD)result == 1 )
    {
      property_get();
      result = strcmp(&v38, "true");
      if ( !(_DWORD)result )
      {
LABEL_21:
        v13 = 0;
        *v2 = 0;
        goto LABEL_26;
      }
    }
    v13 = 0;
  }
  else
  {
    v3 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_key_prov_status.cpp";
    if ( __strrchr_chk() )
      v3 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v3,
      96LL,
      (__int64)"param %s is NULL",
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      "p_status");
    v12 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_key_prov_status.cpp";
    if ( __strrchr_chk() )
      v12 = (const char *)(__strrchr_chk() + 1);
    v13 = 1;
    v14 = sub_38F2C(1u);
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v12,
               129LL,
               (__int64)"%s() ended. result %d - %s",
               v15,
               v16,
               v17,
               v18,
               v19,
               v20,
               v21,
               v22,
               "devsec_get_key_prov_status",
               1LL,
               v14);
  }
LABEL_26:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v39 )
    result = v13;
  return result;
}

//----- (0000000000036278) ----------------------------------------------------
__int64 __fastcall sub_36278(_DWORD *a1)
{
  *a1 = sub_3ACD4();
  return 0LL;
}

//----- (00000000000362A0) ----------------------------------------------------
__int64 __fastcall sub_362A0(int a1, __int64 *a2, _DWORD *a3)
{
  int v3; // w21
  _DWORD *v4; // x19
  __int64 *v5; // x20
  unsigned int v6; // w19
  const char *v7; // x20
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7

  v3 = a1;
  v4 = a3;
  v5 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v6 = sub_39E6C(v3, v5, v4);
  if ( v6 )
  {
    v7 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v7 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v7,
      45LL,
      (__int64)"devsec_get_imei failed with error %d",
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v6);
    v6 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v6;
}

//----- (000000000003635C) ----------------------------------------------------
__int64 __fastcall sub_3635C(void **a1)
{
  void **v1; // x19
  unsigned int v2; // w19
  const char *v3; // x20
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7

  v1 = a1;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v2 = sub_39C10(v1);
  if ( v2 )
  {
    v3 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v3 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v3,
      69LL,
      (__int64)"devsec_get_hwconf_revision failed with error %d",
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v2);
    v2 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v2;
}

//----- (0000000000036400) ----------------------------------------------------
__int64 __fastcall sub_36400(_DWORD *a1)
{
  _DWORD *v1; // x19
  unsigned int v2; // w19
  const char *v3; // x20
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7

  v1 = a1;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v2 = sub_3A99C(v1);
  if ( v2 )
  {
    v3 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v3 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v3,
      93LL,
      (__int64)"devsec_get_security_config failed with error %d",
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v2);
    v2 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v2;
}

//----- (00000000000364A4) ----------------------------------------------------
__int64 __fastcall sub_364A4(_DWORD *a1)
{
  _DWORD *v1; // x19
  unsigned int v2; // w19
  const char *v3; // x20
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7

  v1 = a1;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v2 = sub_3A734(v1);
  if ( v2 )
  {
    v3 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v3 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v3,
      117LL,
      (__int64)"devsec_get_rooting_status failed with error %d",
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v2);
    v2 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v2;
}

//----- (0000000000036548) ----------------------------------------------------
__int64 __fastcall sub_36548(unsigned int a1, unsigned int a2, char *a3, unsigned int a4, _BYTE *a5)
{
  unsigned int v5; // w23
  _BYTE *v6; // x19
  unsigned int v7; // w20
  char *v8; // x21
  unsigned int v9; // w22
  unsigned int v10; // w19
  const char *v11; // x20
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v10 = sub_3ACDC(v5, v9, v8, v7, v6);
  if ( v10 )
  {
    v11 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v11 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v11,
      146LL,
      (__int64)"devsec_verify_s1sin_signature_hashes failed with error %d",
      v12,
      v13,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v10);
    v10 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v10;
}

//----- (000000000003661C) ----------------------------------------------------
__int64 __fastcall sub_3661C(unsigned int a1, unsigned int a2, __int64 a3, unsigned int a4, _BYTE *a5)
{
  unsigned int v5; // w23
  _BYTE *v6; // x19
  unsigned int v7; // w20
  __int64 v8; // x21
  unsigned int v9; // w22
  unsigned int v10; // w19
  const char *v11; // x20
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v10 = sub_3B14C(v5, v9, v8, v7, v6);
  if ( v10 )
  {
    v11 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v11 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v11,
      175LL,
      (__int64)"devsec_verify_s1sin_signature failed with error %d",
      v12,
      v13,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v10);
    v10 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v10;
}

//----- (00000000000366F0) ----------------------------------------------------
__int64 __fastcall sub_366F0(unsigned int a1, __int64 a2)
{
  unsigned int v2; // w20
  __int64 v3; // x19
  unsigned int v4; // w19
  const char *v5; // x20
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7

  v2 = a1;
  v3 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v4 = sub_3B4DC(v2, v3);
  if ( v4 )
  {
    v5 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v5 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v5,
      201LL,
      (__int64)"devsec_verify_s1sin_header failed with error %d",
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v4);
    v4 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v4;
}

//----- (000000000003679C) ----------------------------------------------------
signed __int64 __fastcall sub_3679C(_DWORD *a1)
{
  unsigned int v1; // w19
  const char *v2; // x20
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7

  v1 = sub_3ABDC(a1);
  if ( !v1 )
    return 0LL;
  v2 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
  if ( __strrchr_chk() )
    v2 = (const char *)(__strrchr_chk() + 1);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v2,
    223LL,
    (__int64)"devsec_get_tee_status failed with error %d",
    v3,
    v4,
    v5,
    v6,
    v7,
    v8,
    v9,
    v10,
    v1);
  return 7LL;
}

//----- (0000000000036824) ----------------------------------------------------
__int64 __fastcall sub_36824(_DWORD *a1)
{
  _DWORD *v1; // x19
  unsigned int v2; // w19
  const char *v3; // x20
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7

  v1 = a1;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v2 = sub_3364C(v1);
  if ( v2 )
  {
    v3 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v3 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v3,
      243LL,
      (__int64)"devsec_get_ckb_status failed with error %d",
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v2);
    v2 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v2;
}

//----- (00000000000368C8) ----------------------------------------------------
__int64 __fastcall sub_368C8(_QWORD *a1, _DWORD *a2)
{
  _QWORD *v2; // x20
  _DWORD *v3; // x19
  unsigned int v4; // w19
  const char *v5; // x20
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7

  v2 = a1;
  v3 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v4 = sub_332B0(v2, v3);
  if ( v4 )
  {
    v5 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v5 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v5,
      268LL,
      (__int64)"devsec_get_blob_status failed with error %d",
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v4);
    v4 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v4;
}

//----- (0000000000036974) ----------------------------------------------------
__int64 __fastcall sub_36974(size_t a1, unsigned int a2, _QWORD *a3, _DWORD *a4)
{
  size_t v4; // x22
  _DWORD *v5; // x19
  _QWORD *v6; // x20
  unsigned int v7; // w21
  unsigned int v8; // w19
  const char *v9; // x20
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v8 = sub_39240(v4, v7, v6, v5);
  if ( v8 )
  {
    v9 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v9 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v9,
      296LL,
      (__int64)"devsec_get_attest_data failed with error %d",
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v16,
      v17,
      v8);
    v8 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v8;
}

//----- (0000000000036A38) ----------------------------------------------------
__int64 __fastcall sub_36A38(__int64 *a1, _DWORD *a2)
{
  __int64 *v2; // x20
  _DWORD *v3; // x19
  unsigned int v4; // w19
  const char *v5; // x20
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7

  v2 = a1;
  v3 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v4 = sub_3A478(v2, v3);
  if ( v4 )
  {
    v5 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v5 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v5,
      322LL,
      (__int64)"devsec_get_keystore_hash failed with error %d",
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v4);
    v4 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v4;
}

//----- (0000000000036AE4) ----------------------------------------------------
__int64 __fastcall sub_36AE4(void **a1)
{
  void **v1; // x19
  unsigned int v2; // w0
  unsigned int v3; // w19
  const char *v4; // x20
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7

  v1 = a1;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  sub_33870(v1);
  v3 = v2;
  if ( v2 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v4,
      346LL,
      (__int64)"devsec_get_debugmenu_report failed with error %d",
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v3);
    v3 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v3;
}

//----- (0000000000036B88) ----------------------------------------------------
__int64 __fastcall sub_36B88(unsigned int a1, _DWORD *a2)
{
  unsigned int v2; // w20
  _DWORD *v3; // x19
  unsigned int v4; // w19
  const char *v5; // x20
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7

  v2 = a1;
  v3 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_1069C0);
  v4 = sub_35FF8(v2, v3);
  if ( v4 )
  {
    v5 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_device_security.cpp";
    if ( __strrchr_chk() )
      v5 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v5,
      371LL,
      (__int64)"devsec_get_key_prov_status failed with error %d",
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v4);
    v4 = 7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_1069C0);
  return v4;
}

//----- (0000000000036C34) ----------------------------------------------------
__int64 __fastcall sub_36C34(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // x19
  unsigned int v5; // w20
  unsigned int v6; // w21
  __int64 v7; // x22
  const char *v8; // x23
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  const char *v17; // x23
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  size_t v26; // x0
  void *v27; // x19
  const char *v28; // x19
  double v29; // d0
  double v30; // d1
  double v31; // d2
  double v32; // d3
  double v33; // d4
  double v34; // d5
  double v35; // d6
  double v36; // d7
  const char *v37; // x19
  double v38; // d0
  double v39; // d1
  double v40; // d2
  double v41; // d3
  double v42; // d4
  double v43; // d5
  double v44; // d6
  double v45; // d7
  const char *v46; // x20
  double v47; // d0
  double v48; // d1
  double v49; // d2
  double v50; // d3
  double v51; // d4
  double v52; // d5
  double v53; // d6
  double v54; // d7
  __int64 result; // x0
  _DWORD *v56; // [xsp+8h] [xbp-68h]
  unsigned int v57; // [xsp+20h] [xbp-50h]
  unsigned int v58; // [xsp+24h] [xbp-4Ch]
  __int64 v59; // [xsp+28h] [xbp-48h]
  __int64 v60; // [xsp+30h] [xbp-40h]
  __int64 v61; // [xsp+38h] [xbp-38h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v61 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 )
  {
    v8 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_idd.cpp";
    if ( __strrchr_chk() )
      v8 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v8,
      26LL,
      (__int64)"message %d failed, error code %d",
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v16,
      v6,
      v5);
    v17 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_idd.cpp";
    if ( __strrchr_chk() )
      v17 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v17,
      27LL,
      (__int64)"routine %s, caller %s",
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      v7,
      v4);
  }
  sub_4057C((__int64)&v56);
  v57 = v6;
  v58 = v5;
  v59 = v4;
  v60 = idd_create();
  if ( *v56 != 682290937 )
  {
    v28 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_idd.cpp";
    if ( __strrchr_chk() )
      v28 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v28,
      51LL,
      (__int64)"Message of type Sws__SecdProbe not correct!",
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36);
    goto LABEL_15;
  }
  v26 = j__protobuf_c_message_get_packed_size(&v56);
  if ( !v26 )
  {
LABEL_15:
    v37 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_idd.cpp";
    if ( __strrchr_chk() )
      v37 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v37,
      60LL,
      (__int64)"Could not serialize message data",
      v38,
      v39,
      v40,
      v41,
      v42,
      v43,
      v44,
      v45);
    v27 = 0LL;
    goto LABEL_18;
  }
  v27 = malloc(v26);
  if ( v27 && v60 )
  {
    j__protobuf_c_message_pack(&v56, v27);
    idd_add_event();
    goto LABEL_21;
  }
LABEL_18:
  v46 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_idd.cpp";
  if ( __strrchr_chk() )
    v46 = (const char *)(__strrchr_chk() + 1);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v46,
    71LL,
    (__int64)"Not enough memory, serialized data or idd component are null",
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54);
LABEL_21:
  free(v27);
  result = idd_destroy();
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 40598: using guessed type __int64 __fastcall j__protobuf_c_message_get_packed_size(_QWORD);
// 4059C: using guessed type __int64 __fastcall j__protobuf_c_message_pack(_QWORD, _QWORD);

//----- (0000000000036EE8) ----------------------------------------------------
void __fastcall sub_36EE8(int a1)
{
  int v1; // w20
  unsigned int v2; // w19
  const char *v3; // x20
  char *v4; // x0
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  __int64 v13; // [xsp+0h] [xbp-50h]
  int v14; // [xsp+24h] [xbp-2Ch]
  __int64 v15; // [xsp+28h] [xbp-28h]

  v1 = a1;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v14 = -1;
  v2 = sub_37AF8((__int64)&v13, 0);
  if ( !v2 )
  {
    v2 = sub_38398((unsigned __int8 *)&v13, v1, &v14);
    if ( !v2 )
    {
      sub_3717C((__int64)&v13);
      v2 = sub_38710((char *)&v13, v14);
    }
  }
  sub_388B0(v14);
  v14 = -1;
  sub_3825C((__int64)&v13);
  if ( v2 )
  {
    v3 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_main.cpp";
    if ( __strrchr_chk() )
      v3 = (const char *)(__strrchr_chk() + 1);
    v4 = sub_379C4(v2);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v3,
      86LL,
      (__int64)"%s() ended. result %d - %s",
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      "main_loop",
      v2,
      v4);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000037008) ----------------------------------------------------
__int64 sub_37008()
{
  __int64 v0; // x20
  int v1; // w19
  signed int v2; // w21
  int *v3; // x24
  __int64 result; // x0
  int v5; // w19
  __int64 v6; // x23
  int *v7; // x24
  __int64 v8; // x0
  __int64 v9; // [xsp+8h] [xbp-158h]
  __int64 v10; // [xsp+10h] [xbp-150h]
  char v11; // [xsp+18h] [xbp-148h]
  char v12; // [xsp+98h] [xbp-C8h]
  __int64 v13; // [xsp+118h] [xbp-48h]

  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  signal(13, (__sighandler_t)((char *)&dword_0 + 1));
  memset(&v12, 0, 0x80uLL);
  LODWORD(v0) = 0;
  v1 = 0;
  if ( !(dword_106008[0] & 0x80000000) )
    goto LABEL_8;
  LODWORD(v0) = 0;
  v2 = -1;
  v3 = dword_106008;
  while ( 1 )
  {
    result = sub_3828C();
    v5 = result;
    if ( (_DWORD)result == -1 )
      break;
    __FD_SET_chk();
    LODWORD(v0) = v0 + 1;
    *v3 = v5;
    v3 = &dword_106008[9 * (unsigned int)v0];
    if ( v2 < v5 )
      v2 = v5;
    if ( !(*v3 & 0x80000000) )
    {
      v1 = v2 + 1;
LABEL_8:
      sub_3BB6C();
      v0 = (unsigned int)v0;
      while ( 1 )
      {
        do
        {
          do
          {
            memcpy(&v11, &v12, 0x80uLL);
            v9 = 10LL;
            v10 = 0LL;
          }
          while ( (signed int)select(v1, (fd_set *)&v11, 0LL, 0LL, (struct timeval *)&v9) < 1 );
        }
        while ( !(_DWORD)v0 );
        v6 = v0;
        v7 = dword_106008;
        do
        {
          v8 = (unsigned int)*v7;
          if ( (unsigned int)__FD_ISSET_chk() )
            sub_36EE8(*v7);
          v7 += 9;
          --v6;
        }
        while ( v6 );
      }
    }
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v13 )
    result = 0xFFFFFFFFLL;
  return result;
}
// 0: using guessed type int dword_0;
// 106008: using guessed type int dword_106008[];

//----- (000000000003717C) ----------------------------------------------------
void __fastcall sub_3717C(__int64 a1)
{
  __int64 v1; // x19
  size_t v2; // x21
  char *v3; // x0
  char *v4; // x20
  const char *v5; // x20
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  unsigned int v14; // w8
  char *v15; // x0
  const char *v16; // x21
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  int v25; // w8
  unsigned int v26; // [xsp+Ch] [xbp-34h]
  const void *v27; // [xsp+10h] [xbp-30h]
  __int64 v28; // [xsp+18h] [xbp-28h]

  v1 = a1;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v27 = 0LL;
  v26 = 0;
  sub_37F74(a1, 0, &v26, (signed __int64 *)&v27);
  v2 = v26;
  v3 = (char *)malloc(v26 + 1);
  v4 = v3;
  if ( v3 )
  {
    memcpy(v3, v27, v2);
    v4[v26] = 0;
  }
  else
  {
    v5 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_process.cpp";
    if ( __strrchr_chk() )
      v5 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v5,
      61LL,
      (__int64)"Could not allocate memory for p_caller_buf",
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13);
    v4 = aUnknown_2;
  }
  v14 = *(_DWORD *)(v1 + 1) / 0x64u;
  if ( v14 == 2 )
  {
    sub_3B69C(v1);
    v15 = aCredentialMana_0;
  }
  else if ( v14 == 1 || v14 )
  {
    v16 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_process.cpp";
    if ( __strrchr_chk() )
      v16 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v16,
      30LL,
      (__int64)"unknown command = %d",
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      *(unsigned int *)(v1 + 1));
    v15 = aUnknown_2;
    v25 = *(_DWORD *)(v1 + 1) + 1;
    *(_DWORD *)(v1 + 5) = 0;
    *(_DWORD *)(v1 + 9) = 9;
    *(_DWORD *)(v1 + 1) = v25;
  }
  else
  {
    sub_37364(v1);
    v15 = aDeviceSecurity_0;
  }
  sub_36C34((__int64)v15, *(_DWORD *)(v1 + 1) - 1, *(_DWORD *)(v1 + 9), (__int64)v4);
  if ( v4 != aUnknown_2 )
    free(v4);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000037364) ----------------------------------------------------
void __fastcall sub_37364(__int64 a1)
{
  __int64 v1; // x19
  int v2; // w0
  const char *v3; // x20
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  int v12; // w8
  int v13; // w20
  signed int v14; // w8
  int v15; // w0
  unsigned int v16; // w2
  const char *v17; // x3
  int v18; // w1
  int v19; // w0
  int v20; // w0
  char *v21; // x0
  int v22; // w0
  int v23; // w0
  int v24; // w0
  signed int v25; // w8
  const char *v26; // x20
  int v27; // w0
  const char *v28; // x20
  int v29; // w0
  int v30; // w0
  _BYTE *v31; // [xsp+8h] [xbp-48h]
  unsigned int v32; // [xsp+14h] [xbp-3Ch]
  unsigned int v33; // [xsp+18h] [xbp-38h]
  unsigned int v34; // [xsp+1Ch] [xbp-34h]
  char *v35; // [xsp+20h] [xbp-30h]
  unsigned int v36; // [xsp+2Ch] [xbp-24h]
  const char *v37; // [xsp+30h] [xbp-20h]
  __int64 v38; // [xsp+38h] [xbp-18h]

  v1 = a1;
  v38 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  switch ( *(_DWORD *)(a1 + 1) )
  {
    case 0:
      LODWORD(v37) = 0;
      v2 = sub_36278(&v37);
      *(_QWORD *)(v1 + 1) = 1LL;
      if ( !v2 )
        v2 = sub_37BB0(v1, 6, 4u, &v37);
      *(_DWORD *)(v1 + 9) = v2;
      break;
    case 2:
      LODWORD(v37) = 1;
      v20 = sub_36824(&v37);
      *(_QWORD *)(v1 + 1) = 3LL;
      if ( !v20 )
        v20 = sub_37BB0(v1, 6, 4u, &v37);
      *(_DWORD *)(v1 + 9) = v20;
      break;
    case 6:
      v37 = 0LL;
      v13 = sub_3635C((void **)&v37);
      if ( v13 )
      {
        v14 = 7;
        goto LABEL_21;
      }
      v26 = v37;
      v27 = strnlen(v37, 0xFFuLL);
      v26[v27] = 0;
      *(_QWORD *)(v1 + 1) = 7LL;
      v17 = v37;
      v16 = v27 + 1;
      v18 = 2;
      goto LABEL_54;
    case 8:
      LODWORD(v31) = 0;
      v37 = 0LL;
      v36 = 0;
      v35 = 0LL;
      v34 = 0;
      v13 = sub_37F74(a1, 6, &v36, (signed __int64 *)&v37);
      if ( v13 )
      {
        *(_QWORD *)(v1 + 1) = 9LL;
        v21 = v35;
      }
      else
      {
        __memcpy_chk();
        v13 = sub_362A0((int)v31, (__int64 *)&v35, &v34);
        *(_QWORD *)(v1 + 1) = 9LL;
        if ( !v13 )
          v13 = sub_37BB0(v1, 1, v34, v35);
        v21 = v35;
      }
      goto LABEL_56;
    case 0xA:
      LODWORD(v37) = 0;
      v22 = sub_364A4(&v37);
      *(_QWORD *)(v1 + 1) = 11LL;
      if ( !v22 )
        v22 = sub_37BB0(v1, 6, 4u, &v37);
      *(_DWORD *)(v1 + 9) = v22;
      break;
    case 0xE:
      LODWORD(v37) = 1;
      v15 = sub_36400(&v37);
      *(_QWORD *)(v1 + 1) = 15LL;
      if ( !v15 )
        v15 = sub_37BB0(v1, 6, 4u, &v37);
      *(_DWORD *)(v1 + 9) = v15;
      break;
    case 0x10:
      LODWORD(v37) = 1;
      v23 = sub_3679C(&v37);
      *(_QWORD *)(v1 + 1) = 17LL;
      if ( !v23 )
        v23 = sub_37BB0(v1, 6, 4u, &v37);
      *(_DWORD *)(v1 + 9) = v23;
      break;
    case 0x16:
      LODWORD(v35) = 0;
      v37 = 0LL;
      v24 = sub_37F74(a1, 5, &v35, (signed __int64 *)&v37);
      if ( !v24 )
        v24 = sub_366F0((unsigned int)v35, (__int64)v37);
      *(_DWORD *)(v1 + 5) = 0;
      v25 = 23;
      goto LABEL_46;
    case 0x18:
      v36 = 0;
      v34 = 0;
      v37 = 0LL;
      v32 = 0;
      v33 = 0;
      v35 = 0LL;
      v31 = 0LL;
      v24 = sub_37F74(a1, 6, &v34, (signed __int64 *)&v37);
      if ( !v24 )
      {
        __memcpy_chk();
        v24 = sub_37F74(v1, 4, &v33, (signed __int64 *)&v35);
        if ( !v24 )
        {
          v24 = sub_37F74(v1, 5, &v32, (signed __int64 *)&v31);
          if ( !v24 )
            v24 = sub_3661C(v36, v33, (__int64)v35, v32, v31);
        }
      }
      *(_DWORD *)(v1 + 5) = 0;
      v25 = 25;
      goto LABEL_46;
    case 0x1A:
      v36 = 0;
      v34 = 0;
      v37 = 0LL;
      v32 = 0;
      v33 = 0;
      v35 = 0LL;
      v31 = 0LL;
      v24 = sub_37F74(a1, 6, &v34, (signed __int64 *)&v37);
      if ( !v24 )
      {
        __memcpy_chk();
        v24 = sub_37F74(v1, 2, &v33, (signed __int64 *)&v35);
        if ( !v24 )
        {
          v24 = sub_37F74(v1, 5, &v32, (signed __int64 *)&v31);
          if ( !v24 )
            v24 = sub_36548(v36, v33, v35, v32, v31);
        }
      }
      *(_DWORD *)(v1 + 5) = 0;
      v25 = 27;
LABEL_46:
      *(_DWORD *)(v1 + 1) = v25;
      *(_DWORD *)(v1 + 9) = v24;
      break;
    case 0x1C:
      v37 = 0LL;
      LODWORD(v35) = 0;
      v13 = sub_368C8(&v37, &v35);
      *(_QWORD *)(v1 + 1) = 29LL;
      if ( v13 )
        goto LABEL_55;
      v16 = (unsigned int)v35;
      v17 = v37;
      v18 = 4;
      goto LABEL_54;
    case 0x1E:
      v37 = 0LL;
      LODWORD(v31) = 0;
      v35 = 0LL;
      v36 = 0;
      v19 = sub_37F74(a1, 1, &v31, (signed __int64 *)&v37);
      if ( v19 )
      {
        *(_QWORD *)(v1 + 1) = 31LL;
      }
      else
      {
        v19 = sub_36974((size_t)v37, (unsigned int)v31, &v35, &v36);
        *(_QWORD *)(v1 + 1) = 31LL;
        if ( !v19 )
          v19 = sub_37BB0(v1, 4, v36, v35);
      }
      *(_DWORD *)(v1 + 9) = v19;
      free(v35);
      break;
    case 0x20:
      v37 = 0LL;
      LODWORD(v35) = 0;
      v13 = sub_36A38((__int64 *)&v37, &v35);
      *(_QWORD *)(v1 + 1) = 33LL;
      if ( v13 )
        goto LABEL_55;
      v16 = (unsigned int)v35;
      v17 = v37;
      v18 = 1;
      goto LABEL_54;
    case 0x22:
      v37 = 0LL;
      v13 = sub_36AE4((void **)&v37);
      if ( v13 )
      {
        v14 = 35;
LABEL_21:
        *(_DWORD *)(v1 + 5) = 0;
        *(_DWORD *)(v1 + 1) = v14;
      }
      else
      {
        v28 = v37;
        v29 = strnlen(v37, 0x1F3FFuLL);
        v28[v29] = 0;
        *(_QWORD *)(v1 + 1) = 35LL;
        v17 = v37;
        v16 = v29 + 1;
        v18 = 5;
LABEL_54:
        v13 = sub_37BB0(v1, v18, v16, v17);
      }
LABEL_55:
      v21 = (char *)v37;
LABEL_56:
      free(v21);
      *(_DWORD *)(v1 + 9) = v13;
      break;
    case 0x24:
      LODWORD(v31) = 0;
      v37 = 0LL;
      LODWORD(v35) = 1;
      v36 = 1;
      if ( (unsigned int)sub_37F74(a1, 6, &v31, (signed __int64 *)&v37) )
      {
        *(_QWORD *)(v1 + 1) = 37LL;
      }
      else
      {
        __memcpy_chk();
        v30 = sub_36B88((unsigned int)v35, &v36);
        *(_QWORD *)(v1 + 1) = 37LL;
        if ( !v30 )
          sub_37BB0(v1, 6, 4u, &v36);
      }
      break;
    default:
      v3 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_process_device_security.cpp";
      if ( __strrchr_chk() )
        v3 = (const char *)(__strrchr_chk() + 1);
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v3,
        490LL,
        (__int64)"unknown devsec command = %d",
        v4,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        *(unsigned int *)(v1 + 1));
      v12 = *(_DWORD *)(v1 + 1);
      *(_DWORD *)(v1 + 5) = 0;
      *(_DWORD *)(v1 + 9) = 9;
      *(_DWORD *)(v1 + 1) = v12 + 1;
      break;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v38;
}

//----- (00000000000379C4) ----------------------------------------------------
char *__fastcall sub_379C4(unsigned int a1)
{
  char *result; // x0

  if ( a1 >= 0xA )
    result = 0LL;
  else
    result = (char *)&unk_C124C + 68 * a1 + 4;
  return result;
}

//----- (00000000000379E4) ----------------------------------------------------
__int64 sub_379E4(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, ...)
{
  __int64 v13; // x22
  __int64 result; // x0
  gcc_va_list va; // [xsp+A0h] [xbp-80h]
  gcc_va_list va1; // [xsp+C0h] [xbp-60h]
  __int64 v17; // [xsp+E8h] [xbp-38h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a2 - 1) <= 3 )
    v13 = dword_C14F4[a2 - 1];
  va[0].__vr_offs = -128;
  va_start(va, a13);
  va_copy(va1, va);
  __vsnprintf_chk();
  result = __android_log_buf_print();
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000037AF8) ----------------------------------------------------
signed __int64 __fastcall sub_37AF8(__int64 a1, int a2)
{
  __int64 v2; // x19
  int v3; // w20
  void *v4; // x0
  signed __int64 result; // x0
  const char *v6; // x19
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7

  v2 = a1;
  v3 = a2;
  *(_DWORD *)(a1 + 24) = 0;
  v4 = malloc(0x16CuLL);
  *(_QWORD *)(v2 + 16) = v4;
  if ( v4 )
  {
    result = 0LL;
    *(_DWORD *)(v2 + 24) = 364;
    *(_DWORD *)(v2 + 1) = v3;
    *(_DWORD *)(v2 + 5) = 0;
    *(_BYTE *)v2 = 1;
    *(_DWORD *)(v2 + 9) = 0;
  }
  else
  {
    v6 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
    if ( __strrchr_chk() )
      v6 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v6,
      38LL,
      (__int64)"init_message failed to allocate memory block",
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v14);
    result = 4LL;
  }
  return result;
}

//----- (0000000000037BB0) ----------------------------------------------------
signed __int64 __fastcall sub_37BB0(__int64 a1, int a2, unsigned int a3, const void *a4)
{
  __int64 v4; // x19
  const void *v5; // x20
  char *v6; // x0
  const char *v7; // x19
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  const char *v16; // x5
  __int64 v17; // x3
  signed __int64 v18; // x6
  signed __int64 result; // x0
  int v20; // w8
  unsigned int v21; // w10
  unsigned int v22; // w9
  size_t v23; // x21
  char *v24; // x8
  const char *v25; // x19
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  unsigned int v34; // [xsp+0h] [xbp-30h]
  int v35; // [xsp+4h] [xbp-2Ch]
  __int64 v36; // [xsp+8h] [xbp-28h]

  v4 = a1;
  v5 = a4;
  v36 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v34 = a3;
  v35 = a2;
  v6 = *(char **)(a1 + 16);
  switch ( a2 )
  {
    case 0:
      if ( a3 < 0x81 )
        goto def_37BFC;
      v7 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v7 = (const char *)(__strrchr_chk() + 1);
      v16 = "FIELD_CALLER_NAME";
      v17 = 74LL;
      v18 = 128LL;
      goto LABEL_26;
    case 1:
      if ( a3 < 0x21 )
        goto def_37BFC;
      v7 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v7 = (const char *)(__strrchr_chk() + 1);
      v16 = "FIELD_BUFFER_32";
      v17 = 78LL;
      v18 = 32LL;
      goto LABEL_26;
    case 2:
      if ( a3 < 0x101 )
        goto def_37BFC;
      v7 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v7 = (const char *)(__strrchr_chk() + 1);
      v16 = "FIELD_BUFFER_256";
      v17 = 82LL;
      v18 = 256LL;
      goto LABEL_26;
    case 4:
      if ( a3 < 0x2801 )
        goto def_37BFC;
      v7 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v7 = (const char *)(__strrchr_chk() + 1);
      v16 = "FIELD_BUFFER_10240";
      v17 = 86LL;
      v18 = 10240LL;
      goto LABEL_26;
    case 5:
      if ( a3 < 0x1F401 )
        goto def_37BFC;
      v7 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v7 = (const char *)(__strrchr_chk() + 1);
      v16 = "FIELD_BUFFER_128000";
      v17 = 90LL;
      v18 = 128000LL;
      goto LABEL_26;
    case 6:
    case 7:
      if ( a3 < 5 )
        goto def_37BFC;
      v7 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v7 = (const char *)(__strrchr_chk() + 1);
      v16 = "FIELD_DATA_INT32";
      v17 = 94LL;
      v18 = 4LL;
LABEL_26:
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v7,
        v17,
        (__int64)"Size of the field %s should be in range [0..%ld]",
        v8,
        v9,
        v10,
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        v18);
      result = 2LL;
      goto LABEL_34;
    default:
def_37BFC:
      v20 = *(_DWORD *)(v4 + 5);
      v21 = *(_DWORD *)(v4 + 24);
      v22 = a3 + 8 + v20;
      if ( v22 <= v21 )
        goto LABEL_33;
      if ( 2 * v21 <= v22 )
        v23 = v22;
      else
        v23 = 2 * v21;
      v6 = (char *)realloc(v6, v23);
      *(_QWORD *)(v4 + 16) = v6;
      if ( v6 )
      {
        v20 = *(_DWORD *)(v4 + 5);
        *(_DWORD *)(v4 + 24) = v23;
LABEL_33:
        v24 = &v6[v20];
        *(_DWORD *)v24 = v35;
        *((_DWORD *)v24 + 1) = v34;
        memcpy(v24 + 8, v5, v34);
        result = 0LL;
        *(_DWORD *)(v4 + 5) += v34 + 8;
      }
      else
      {
        v25 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
        if ( __strrchr_chk() )
          v25 = (const char *)(__strrchr_chk() + 1);
        sub_379E4(
          (__int64)"secd",
          1,
          (__int64)v25,
          112LL,
          (__int64)"failed to allocate memory block",
          v26,
          v27,
          v28,
          v29,
          v30,
          v31,
          v32,
          v33);
        result = 4LL;
      }
LABEL_34:
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v36;
      return result;
  }
}

//----- (0000000000037F74) ----------------------------------------------------
signed __int64 __fastcall sub_37F74(__int64 a1, int a2, _DWORD *a3, signed __int64 *a4)
{
  int v4; // w10
  int *v5; // x9
  __int64 v6; // x8
  signed __int64 v7; // x9
  int v8; // w11
  signed __int64 result; // x0
  const char *v10; // x19
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  const char *v19; // x5
  __int64 v20; // x3
  signed __int64 v21; // x6

  v4 = *(_DWORD *)(a1 + 5);
  if ( !v4 )
    return 6LL;
  v5 = *(int **)(a1 + 16);
  while ( 1 )
  {
    v8 = *v5;
    v6 = (unsigned int)v5[1];
    v7 = (signed __int64)(v5 + 2);
    if ( v8 == a2 )
      break;
    v4 = v4 - 8 - v6;
    v5 = (int *)(v7 + v6);
    if ( !v4 )
      return 6LL;
  }
  switch ( a2 )
  {
    case 0:
      if ( (unsigned int)v6 < 0x81 )
        goto def_37FCC;
      v10 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v10 = (const char *)(__strrchr_chk() + 1);
      v19 = "FIELD_CALLER_NAME";
      v20 = 179LL;
      v21 = 128LL;
      goto LABEL_31;
    case 1:
      if ( (unsigned int)v6 < 0x21 )
        goto def_37FCC;
      v10 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v10 = (const char *)(__strrchr_chk() + 1);
      v19 = "FIELD_BUFFER_32";
      v20 = 183LL;
      v21 = 32LL;
      goto LABEL_31;
    case 2:
      if ( (unsigned int)v6 < 0x101 )
        goto def_37FCC;
      v10 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v10 = (const char *)(__strrchr_chk() + 1);
      v19 = "FIELD_BUFFER_256";
      v20 = 187LL;
      v21 = 256LL;
      goto LABEL_31;
    case 4:
      if ( (unsigned int)v6 < 0x2801 )
        goto def_37FCC;
      v10 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v10 = (const char *)(__strrchr_chk() + 1);
      v19 = "FIELD_BUFFER_10240";
      v20 = 191LL;
      v21 = 10240LL;
      goto LABEL_31;
    case 5:
      if ( (unsigned int)v6 < 0x1F401 )
        goto def_37FCC;
      v10 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v10 = (const char *)(__strrchr_chk() + 1);
      v19 = "FIELD_BUFFER_128000";
      v20 = 195LL;
      v21 = 128000LL;
      goto LABEL_31;
    case 6:
    case 7:
      if ( (unsigned int)v6 < 5 )
        goto def_37FCC;
      v10 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_message.cpp";
      if ( __strrchr_chk() )
        v10 = (const char *)(__strrchr_chk() + 1);
      v19 = "FIELD_DATA_INT32";
      v20 = 200LL;
      v21 = 4LL;
LABEL_31:
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v10,
        v20,
        (__int64)"Size of the field %s should be in range [0..%ld]",
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        v21);
      result = 2LL;
      break;
    default:
def_37FCC:
      result = 0LL;
      *a3 = v6;
      *a4 = v7;
      break;
  }
  return result;
}

//----- (000000000003825C) ----------------------------------------------------
void __fastcall sub_3825C(__int64 a1)
{
  __int64 v1; // x19
  void *v2; // x0

  v1 = a1;
  v2 = *(void **)(a1 + 16);
  *(_DWORD *)(v1 + 24) = 0;
  free(v2);
  *(_QWORD *)(v1 + 16) = 0LL;
  *(_DWORD *)(v1 + 5) = 0;
}

//----- (000000000003828C) ----------------------------------------------------
__int64 sub_3828C()
{
  unsigned int v0; // w19
  const char *v1; // x20
  int *v2; // x0
  char *v3; // x5
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  const char *v12; // x4
  __int64 v13; // x3
  int *v14; // x0

  v0 = android_get_control_socket();
  if ( v0 == -1 )
  {
    v1 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
    if ( __strrchr_chk() )
      v1 = (const char *)(__strrchr_chk() + 1);
    v14 = (int *)__errno();
    v3 = strerror(*v14);
    v12 = "android_get_control_socket failed: %s";
    v13 = 132LL;
    goto LABEL_9;
  }
  if ( (unsigned int)listen(v0, 5) == -1 )
  {
    close(v0);
    v1 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
    if ( __strrchr_chk() )
      v1 = (const char *)(__strrchr_chk() + 1);
    v2 = (int *)__errno();
    v3 = strerror(*v2);
    v12 = "listen failed: %s";
    v13 = 141LL;
LABEL_9:
    sub_379E4((__int64)"secd", 1, (__int64)v1, v13, (__int64)v12, v4, v5, v6, v7, v8, v9, v10, v11, v3);
  }
  return v0;
}

//----- (0000000000038398) ----------------------------------------------------
__int64 __fastcall sub_38398(unsigned __int8 *a1, int a2, int *a3)
{
  int *v3; // x19
  unsigned __int8 *v4; // x20
  int v5; // w0
  unsigned int v6; // w21
  unsigned int v7; // w2
  void *v8; // x0
  const char *v9; // x20
  int *v10; // x0
  char *v11; // x0
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  const char *v20; // x19
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  const char *v29; // x19
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  const char *v38; // x19
  char *v39; // x0
  double v40; // d0
  double v41; // d1
  double v42; // d2
  double v43; // d3
  double v44; // d4
  double v45; // d5
  double v46; // d6
  double v47; // d7
  const char *v49; // x19
  double v50; // d0
  double v51; // d1
  double v52; // d2
  double v53; // d3
  double v54; // d4
  double v55; // d5
  double v56; // d6
  double v57; // d7

  v3 = a3;
  v4 = a1;
  v5 = accept(a2, 0LL, 0LL);
  if ( v5 == -1 )
  {
    v9 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
    if ( __strrchr_chk() )
      v9 = (const char *)(__strrchr_chk() + 1);
    v10 = (int *)__errno();
    v11 = strerror(*v10);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v9,
      101LL,
      (__int64)"accept failed: %s",
      v12,
      v13,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v11);
    *v3 = -1;
    v20 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
    if ( __strrchr_chk() )
      v20 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v20,
      162LL,
      (__int64)"accept_socket failed",
      v21,
      v22,
      v23,
      v24,
      v25,
      v26,
      v27,
      v28);
    v6 = 5;
    goto LABEL_18;
  }
  *v3 = v5;
  v6 = sub_38640(v5, (char *)v4, 0xDu);
  if ( !v6 )
  {
    if ( *v4 != 1 )
    {
      v29 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
      if ( __strrchr_chk() )
        v29 = (const char *)(__strrchr_chk() + 1);
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v29,
        181LL,
        (__int64)"incorrect message version. current %d, but received %d",
        v30,
        v31,
        v32,
        v33,
        v34,
        v35,
        v36,
        v37,
        1LL,
        *v4);
      v6 = 6;
      goto LABEL_18;
    }
    v7 = *(_DWORD *)(v4 + 5);
    if ( v7 > *((_DWORD *)v4 + 6) )
    {
      v8 = realloc(*((void **)v4 + 2), *(unsigned int *)(v4 + 5));
      *((_QWORD *)v4 + 2) = v8;
      if ( !v8 )
      {
        v49 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
        if ( __strrchr_chk() )
          v49 = (const char *)(__strrchr_chk() + 1);
        sub_379E4(
          (__int64)"secd",
          1,
          (__int64)v49,
          195LL,
          (__int64)"failed to allocate memory block",
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57);
        v6 = 4;
        goto LABEL_18;
      }
      v7 = *(_DWORD *)(v4 + 5);
      *((_DWORD *)v4 + 6) = v7;
    }
    if ( !v7 )
      return 0;
    v6 = sub_38640(*v3, *((char **)v4 + 2), v7);
    if ( !v6 )
      return v6;
  }
LABEL_18:
  v38 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
  if ( __strrchr_chk() )
    v38 = (const char *)(__strrchr_chk() + 1);
  v39 = sub_379C4(v6);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v38,
    213LL,
    (__int64)"%s() ended. result %d - %s",
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    "server_accept_and_receive",
    v6,
    v39);
  return v6;
}

//----- (0000000000038640) ----------------------------------------------------
signed __int64 __fastcall sub_38640(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // w19
  char *v4; // x20
  int v5; // w21
  unsigned int v6; // w22
  int v7; // w0
  const char *v9; // x19
  int *v10; // x0
  char *v11; // x0
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  while ( 1 )
  {
    v7 = recvfrom(v5, v4, v3 - v6, 0, 0LL, 0LL);
    if ( v7 & 0x80000000 )
      break;
    v6 += v7;
    v4 += v7;
    if ( v6 >= v3 )
      return 0LL;
  }
  v9 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
  if ( __strrchr_chk() )
    v9 = (const char *)(__strrchr_chk() + 1);
  v10 = (int *)__errno();
  v11 = strerror(*v10);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v9,
    56LL,
    (__int64)"recv failed: %s",
    v12,
    v13,
    v14,
    v15,
    v16,
    v17,
    v18,
    v19,
    v11);
  return 5LL;
}

//----- (0000000000038710) ----------------------------------------------------
__int64 __fastcall sub_38710(char *a1, int a2)
{
  int v2; // w20
  char *v3; // x21
  unsigned int v4; // w19
  const char *v5; // x20
  char *v6; // x0
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  unsigned int v16; // w2

  v2 = a2;
  v3 = a1;
  v4 = sub_387E8(a2, a1, 0xDu);
  if ( !v4 )
  {
    v16 = *(_DWORD *)(v3 + 5);
    if ( !v16 )
      return 0;
    v4 = sub_387E8(v2, *((char **)v3 + 2), v16);
    if ( !v4 )
      return v4;
  }
  v5 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
  if ( __strrchr_chk() )
    v5 = (const char *)(__strrchr_chk() + 1);
  v6 = sub_379C4(v4);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v5,
    236LL,
    (__int64)"%s() ended. result %d - %s",
    v7,
    v8,
    v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    "server_send",
    v4,
    v6);
  return v4;
}

//----- (00000000000387E8) ----------------------------------------------------
signed __int64 __fastcall sub_387E8(int a1, char *a2, unsigned int a3)
{
  char *v3; // x19
  int v4; // w20
  unsigned int v5; // w21
  int v6; // w0
  const char *v8; // x19
  int *v9; // x0
  char *v10; // x0
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7

  v3 = a2;
  v4 = a1;
  while ( 1 )
  {
    v5 = a3;
    v6 = sendto(v4, v3, a3, 0, 0LL, 0);
    if ( v6 & 0x80000000 )
      break;
    a3 = v5 - v6;
    v3 += v6;
    if ( v5 == v6 )
      return 0LL;
  }
  v8 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_socket.cpp";
  if ( __strrchr_chk() )
    v8 = (const char *)(__strrchr_chk() + 1);
  v9 = (int *)__errno();
  v10 = strerror(*v9);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v8,
    27LL,
    (__int64)"send failed: %s",
    v11,
    v12,
    v13,
    v14,
    v15,
    v16,
    v17,
    v18,
    v10);
  return 5LL;
}

//----- (00000000000388B0) ----------------------------------------------------
__int64 __fastcall sub_388B0(int a1)
{
  if ( !(a1 & 0x80000000) )
    close(a1);
  return 0LL;
}

//----- (00000000000388CC) ----------------------------------------------------
signed __int64 __fastcall sub_388CC(__int64 a1, unsigned int a2, _BYTE *a3)
{
  _BYTE *v3; // x19
  unsigned int v4; // w20
  signed __int64 result; // x0
  const char *v6; // x22
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  const char *v15; // x19
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  const char *v24; // x4
  const char *v25; // x5
  __int64 v26; // x3
  int v27; // w22
  signed int v28; // w27
  signed int v29; // w23
  unsigned int v30; // w28
  __int64 v31; // x26
  __int64 v32; // x8
  int *v33; // x9
  int v34; // w13
  unsigned int v35; // w10
  int v36; // w9
  __int64 v37; // x8
  int *v38; // x10
  int v39; // w11
  unsigned int v40; // w12
  unsigned __int64 v41; // t2
  int v42; // w12
  __int64 v43; // x8
  int *v44; // x10
  int v45; // w14
  unsigned int v46; // w11
  int v47; // w10
  __int64 v48; // x8
  int *v49; // x11
  int v50; // w12
  unsigned int v51; // w13
  unsigned __int64 v52; // t2
  int v53; // w13
  int v54; // w8
  int v55; // w8
  int v56; // w8
  int v57; // w8
  int v58; // w8
  int v59; // w8
  int v60; // w8
  int v61; // w8
  int v62[15]; // [xsp+20h] [xbp-180h]
  int v63[15]; // [xsp+44h] [xbp-15Ch]
  char v64; // [xsp+5Ch] [xbp-144h]
  char v65; // [xsp+5Dh] [xbp-143h]
  char v66; // [xsp+5Eh] [xbp-142h]
  char v67; // [xsp+5Fh] [xbp-141h]
  __int128 v68; // [xsp+120h] [xbp-80h]
  __int128 v69; // [xsp+130h] [xbp-70h]
  __int64 v70; // [xsp+148h] [xbp-58h]

  v3 = a3;
  v4 = a2;
  v70 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v68 = unk_C1544;
  v69 = unk_C1554;
  if ( !a1 )
  {
    v6 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_sha256.cpp";
    if ( __strrchr_chk() )
      v6 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v6,
      100LL,
      (__int64)"param %s is NULL",
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      "pSrc");
    result = 2LL;
    if ( !(v4 | 2) )
      goto LABEL_12;
LABEL_7:
    if ( !v3 && !(_DWORD)result )
    {
      v15 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_sha256.cpp";
      if ( __strrchr_chk() )
        v15 = (const char *)(__strrchr_chk() + 1);
      v24 = "param %s is NULL";
      v25 = "pRes";
      v26 = 102LL;
      goto LABEL_15;
    }
    if ( (_DWORD)result )
      goto LABEL_42;
    if ( v4 )
    {
      v27 = 0;
      v28 = 0;
      v29 = 0;
      do
      {
        v30 = v27 + 64;
        if ( v27 + 64 <= v4 )
        {
          LODWORD(v31) = 64;
        }
        else
        {
          v31 = v4 - v27;
          memset((char *)v62 + v31, 0, 256 - v31);
        }
        __memcpy_chk();
        if ( (unsigned int)v31 <= 0x3F )
        {
          *((_BYTE *)v62 + (unsigned int)v31) = -128;
          if ( (unsigned int)(v31 + 1) > 0x38 )
          {
            v29 = 1;
          }
          else
          {
            v29 = 1;
            v28 = 1;
            v64 = v4 >> 21;
            v65 = v4 >> 13;
            v66 = v4 >> 5;
            v67 = 8 * v4;
          }
        }
        v32 = 0LL;
        do
        {
          v33 = &v62[v32];
          v34 = HIBYTE(v62[v32]);
          v35 = ((LOBYTE(v62[v32]) << 24) & 0xFF00FFFF | (BYTE1(v62[v32]) << 16)) & 0xFFFF00FF | (BYTE2(v62[v32]) << 8);
          ++v32;
          *v33 = v35 | v34;
        }
        while ( v32 != 16 );
        v36 = v62[0];
        v37 = 0LL;
        do
        {
          v38 = &v63[v37];
          v39 = v63[v37];
          v40 = v63[v37 + 5];
          ++v37;
          HIDWORD(v41) = v40;
          LODWORD(v41) = v40;
          v42 = (v41 >> 19) ^ (v40 >> 10) ^ __ROR4__(v40, 17);
          HIDWORD(v41) = *(v38 - 8);
          LODWORD(v41) = *(v38 - 8);
          v38[7] = v39 + v36 + ((v41 >> 18) ^ (HIDWORD(v41) >> 3) ^ __ROR4__(HIDWORD(v41), 7)) + v42;
          v36 = HIDWORD(v41);
        }
        while ( v37 != 48 );
        sub_38DF0((__int64)v62, (unsigned __int128 *)&v68);
        v27 += 64;
      }
      while ( v30 < v4 );
      if ( v28 )
        goto LABEL_41;
      memset(v62, 0, 0xFCuLL);
      if ( v29 )
      {
LABEL_36:
        v43 = 0LL;
        v67 = 8 * v4;
        v64 = v4 >> 21;
        v65 = v4 >> 13;
        v66 = v4 >> 5;
        do
        {
          v44 = &v62[v43];
          v45 = HIBYTE(v62[v43]);
          v46 = ((LOBYTE(v62[v43]) << 24) & 0xFF00FFFF | (BYTE1(v62[v43]) << 16)) & 0xFFFF00FF | (BYTE2(v62[v43]) << 8);
          ++v43;
          *v44 = v46 | v45;
        }
        while ( v43 != 16 );
        v47 = v62[0];
        v48 = 0LL;
        do
        {
          v49 = &v63[v48];
          v50 = v63[v48];
          v51 = v63[v48 + 5];
          ++v48;
          HIDWORD(v52) = v51;
          LODWORD(v52) = v51;
          v53 = (v52 >> 19) ^ (v51 >> 10) ^ __ROR4__(v51, 17);
          HIDWORD(v52) = *(v49 - 8);
          LODWORD(v52) = *(v49 - 8);
          v49[7] = v50 + v47 + ((v52 >> 18) ^ (HIDWORD(v52) >> 3) ^ __ROR4__(HIDWORD(v52), 7)) + v53;
          v47 = HIDWORD(v52);
        }
        while ( v48 != 48 );
        sub_38DF0((__int64)v62, (unsigned __int128 *)&v68);
LABEL_41:
        v54 = v68;
        result = 0LL;
        *v3 = BYTE3(v68);
        v3[3] = v54;
        v3[1] = BYTE2(v54);
        v3[2] = BYTE1(v54);
        v55 = DWORD1(v68);
        v3[4] = BYTE7(v68);
        v3[7] = v55;
        v3[5] = BYTE2(v55);
        v3[6] = BYTE1(v55);
        v56 = DWORD2(v68);
        v3[8] = BYTE11(v68);
        v3[11] = v56;
        v3[9] = BYTE2(v56);
        v3[10] = BYTE1(v56);
        v57 = HIDWORD(v68);
        v3[12] = HIBYTE(v68);
        v3[15] = v57;
        v3[13] = BYTE2(v57);
        v3[14] = BYTE1(v57);
        v58 = v69;
        v3[16] = BYTE3(v69);
        v3[19] = v58;
        v3[17] = BYTE2(v58);
        v3[18] = BYTE1(v58);
        v59 = DWORD1(v69);
        v3[20] = BYTE7(v69);
        v3[23] = v59;
        v3[21] = BYTE2(v59);
        v3[22] = BYTE1(v59);
        v60 = DWORD2(v69);
        v3[24] = BYTE11(v69);
        v3[27] = v60;
        v3[25] = BYTE2(v60);
        v3[26] = BYTE1(v60);
        v61 = HIDWORD(v69);
        v3[28] = HIBYTE(v69);
        v3[29] = BYTE2(v61);
        v3[30] = BYTE1(v61);
        v3[31] = v61;
        goto LABEL_42;
      }
    }
    else
    {
      memset(v62, 0, 0xFCuLL);
    }
    LOBYTE(v62[0]) = -128;
    goto LABEL_36;
  }
  result = 0LL;
  if ( a2 )
    goto LABEL_7;
LABEL_12:
  v15 = "vendor/semc/system/core/libasb/security_daemon/shared/native/secd_sha256.cpp";
  if ( __strrchr_chk() )
    v15 = (const char *)(__strrchr_chk() + 1);
  v24 = "param %s = 0";
  v25 = "srcLen";
  v26 = 101LL;
LABEL_15:
  sub_379E4((__int64)"secd", 1, (__int64)v15, v26, (__int64)v24, v16, v17, v18, v19, v20, v21, v22, v23, v25);
  result = 2LL;
LABEL_42:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 388CC: using guessed type int var_180[15];

//----- (0000000000038DF0) ----------------------------------------------------
__int64 __fastcall sub_38DF0(__int64 a1, unsigned __int128 *a2)
{
  __int64 v2; // x8
  __int64 v3; // ST28_8
  int v4; // w5
  unsigned int v5; // w16
  int v6; // w6
  int v7; // w14
  unsigned __int128 v8; // ST00_16
  int v9; // w2
  int v10; // w3
  int v11; // w4
  int v12; // w17
  int v13; // w12
  int v14; // w13
  unsigned int v15; // w9
  int v16; // w10
  int v17; // w11
  int v18; // w18
  int v19; // w5
  int v20; // w6
  int v21; // w2
  int v22; // w3
  unsigned __int64 v23; // t2
  int v24; // w14
  int v25; // w14
  __int64 result; // x0
  int v27; // w12
  int v28; // w13
  int v29; // w16
  int v30; // w10
  int v31; // w11

  v2 = 0LL;
  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (unsigned __int64)a2[1] >> 32;
  v5 = a2[1];
  v6 = a2[1] >> 64;
  v7 = a2[1] >> 96;
  v8 = *a2;
  v9 = *a2;
  v10 = DWORD1(v8);
  v11 = *a2 >> 64;
  v12 = *a2 >> 96;
  do
  {
    v13 = v10;
    v14 = v11;
    v15 = v5;
    v16 = v4;
    v17 = v6;
    v18 = v9;
    v19 = v6 & ~v5 ^ v4 & v5;
    v20 = *(_DWORD *)((char *)&unk_C15C4 + v2);
    v21 = (v11 ^ v10) & v9 ^ v11 & v10;
    v22 = *(_DWORD *)(a1 + v2);
    HIDWORD(v23) = v18;
    LODWORD(v23) = v18;
    v2 += 4LL;
    v24 = ((v5 >> 6) ^ __ROR4__(v5, 11) ^ __ROR4__(v5, 25)) + v7 + v19 + v20 + v22;
    v5 = v12 + v24;
    v9 = v21 + ((v23 >> 2) ^ __ROR4__(v18, 13) ^ __ROR4__(v18, 22)) + v24;
    v12 = v11;
    v7 = v17;
    v6 = v16;
    v4 = v15;
    v11 = v13;
    v10 = v18;
  }
  while ( v2 != 256 );
  v25 = v18 + *((_DWORD *)a2 + 1);
  result = *((unsigned int *)a2 + 5);
  v27 = v13 + *((_DWORD *)a2 + 2);
  v28 = v14 + *((_DWORD *)a2 + 3);
  v29 = v5 + *((_DWORD *)a2 + 4);
  v30 = v16 + *((_DWORD *)a2 + 6);
  v31 = v17 + *((_DWORD *)a2 + 7);
  *(_DWORD *)a2 += v9;
  *((_DWORD *)a2 + 1) = v25;
  *((_DWORD *)a2 + 2) = v27;
  *((_DWORD *)a2 + 3) = v28;
  *((_DWORD *)a2 + 4) = v29;
  *((_DWORD *)a2 + 5) = v15 + result;
  *((_DWORD *)a2 + 6) = v30;
  *((_DWORD *)a2 + 7) = v31;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000038F2C) ----------------------------------------------------
char *__fastcall sub_38F2C(unsigned int a1)
{
  char *result; // x0

  if ( a1 >= 5 )
    result = 0LL;
  else
    result = (char *)&unk_C16C4 + 68 * a1 + 4;
  return result;
}

//----- (0000000000038F4C) ----------------------------------------------------
__int64 __fastcall sub_38F4C(__int64 a1, int a2, const void *a3, unsigned int a4, void *a5, int a6)
{
  unsigned int v6; // w25
  size_t v7; // x22
  void *v8; // x19
  const void *v9; // x24
  int v10; // w26
  __int64 v11; // x9
  unsigned int v12; // w23
  unsigned int v13; // w20
  const char *v14; // x19
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  const char *v23; // x4
  __int64 v24; // x3
  __int64 v25; // x2
  __int64 v26; // x5
  unsigned int *v27; // x20
  unsigned int v28; // w21
  const char *v29; // x19
  const char *v30; // x19
  const char *v31; // x19
  unsigned int v32; // w20
  char *v33; // x0
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  __int64 result; // x0
  __int64 v43; // [xsp+8h] [xbp-58h]

  v6 = a4;
  LODWORD(v7) = a6;
  v8 = a5;
  v9 = a3;
  v10 = a2;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (a4 + 8) & 0x3F )
    v12 = (a4 + 71) & 0xFFFFFFC0;
  else
    v12 = a4 + 8;
  v43 = v11;
  v13 = QSEECom_start_app();
  if ( v13 )
  {
    v14 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/devsec_tee.cpp";
    if ( __strrchr_chk() )
      v14 = (const char *)(__strrchr_chk() + 1);
    v23 = "QSEECom_start_app failed %d";
    v24 = 55LL;
    v25 = (__int64)v14;
    v26 = v13;
  }
  else
  {
    v27 = (unsigned int *)(*(_QWORD *)&dword_0 + v12);
    **(_DWORD **)&dword_0 = v10;
    *(_DWORD *)(*(_QWORD *)&dword_0 + 4LL) = v6;
    memcpy((void *)(*(_QWORD *)&dword_0 + 8LL), v9, v6);
    *v27 = 0;
    v27[1] = v7;
    v7 = (unsigned int)v7;
    memset(v27 + 2, 0, (unsigned int)v7);
    QSEECom_set_bandwidth();
    v28 = QSEECom_send_cmd();
    QSEECom_set_bandwidth();
    if ( v28 )
    {
      v29 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/devsec_tee.cpp";
      if ( __strrchr_chk() )
        v29 = (const char *)(__strrchr_chk() + 1);
      v23 = "QSEECom_send_cmd failed %d";
      v24 = 82LL;
      v25 = (__int64)v29;
      v26 = v28;
    }
    else
    {
      if ( !*v27 )
      {
        memcpy(v8, (const void *)(*(_QWORD *)&dword_0 + v12 + 8LL), v7);
        result = QSEECom_shutdown_app();
        v32 = 0;
        goto LABEL_19;
      }
      v30 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/devsec_tee.cpp";
      if ( __strrchr_chk() )
        v30 = (const char *)(__strrchr_chk() + 1);
      v26 = *v27;
      v23 = "tz processing failed %d";
      v24 = 87LL;
      v25 = (__int64)v30;
    }
  }
  sub_379E4((__int64)"secd", 1, v25, v24, (__int64)v23, v15, v16, v17, v18, v19, v20, v21, v22, v26);
  QSEECom_shutdown_app();
  v31 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/devsec_tee.cpp";
  if ( __strrchr_chk() )
    v31 = (const char *)(__strrchr_chk() + 1);
  v32 = 4;
  v33 = sub_38F2C(4u);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v31,
             103LL,
             (__int64)"%s() ended. result %d - %s",
             v34,
             v35,
             v36,
             v37,
             v38,
             v39,
             v40,
             v41,
             "devsec_tee_send",
             4LL,
             v33,
             0LL);
LABEL_19:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v43 )
    result = v32;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000039240) ----------------------------------------------------
size_t __fastcall sub_39240(size_t result, unsigned int a2, _QWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // x19
  _QWORD *v5; // x20
  unsigned int v6; // w22
  const void *v7; // x21
  signed int v8; // w8
  const char *v9; // x23
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  const char *v18; // x19
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  const char *v27; // x4
  __int64 v28; // x3
  signed __int64 v29; // x6
  const char *v30; // x19
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  const char *v39; // x4
  const char *v40; // x5
  __int64 v41; // x3
  unsigned int v42; // w23
  const char *v43; // x19
  char *v44; // x0
  double v45; // d0
  double v46; // d1
  double v47; // d2
  double v48; // d3
  double v49; // d4
  double v50; // d5
  double v51; // d6
  double v52; // d7
  unsigned int v53; // w23
  const char *v54; // x19
  double v55; // d0
  double v56; // d1
  double v57; // d2
  double v58; // d3
  double v59; // d4
  double v60; // d5
  double v61; // d6
  double v62; // d7
  __int64 v63; // x3
  unsigned int v64; // w23
  const char *v65; // x24
  double v66; // d0
  double v67; // d1
  double v68; // d2
  double v69; // d3
  double v70; // d4
  double v71; // d5
  double v72; // d6
  double v73; // d7
  unsigned int *v74; // x23
  unsigned int v75; // w26
  const char *v76; // x19
  double v77; // d0
  double v78; // d1
  double v79; // d2
  double v80; // d3
  double v81; // d4
  double v82; // d5
  double v83; // d6
  double v84; // d7
  const char *v85; // x26
  double v86; // d0
  double v87; // d1
  double v88; // d2
  double v89; // d3
  double v90; // d4
  double v91; // d5
  double v92; // d6
  double v93; // d7
  const char *v94; // x19
  double v95; // d0
  double v96; // d1
  double v97; // d2
  double v98; // d3
  double v99; // d4
  double v100; // d5
  double v101; // d6
  double v102; // d7
  const char *v103; // x4
  __int64 v104; // x3
  unsigned int v105; // w27
  unsigned int *v106; // x23
  unsigned int *v107; // x22
  unsigned int v108; // w21
  const char *v109; // x19
  double v110; // d0
  double v111; // d1
  double v112; // d2
  double v113; // d3
  double v114; // d4
  double v115; // d5
  double v116; // d6
  double v117; // d7
  const char *v118; // x21
  double v119; // d0
  double v120; // d1
  double v121; // d2
  double v122; // d3
  double v123; // d4
  double v124; // d5
  double v125; // d6
  double v126; // d7
  void *v127; // x0
  const void *v128; // [xsp+0h] [xbp-70h]
  __int64 v129; // [xsp+18h] [xbp-58h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (const void *)result;
  v129 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( result )
  {
    v8 = 0;
    if ( !a2 )
    {
LABEL_12:
      v30 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
      if ( __strrchr_chk() )
        v30 = (const char *)(__strrchr_chk() + 1);
      v39 = "param %s = 0";
      v40 = "nonce_len";
      v41 = 66LL;
LABEL_15:
      v42 = 1;
      result = sub_379E4(
                 (__int64)"secd",
                 1,
                 (__int64)v30,
                 v41,
                 (__int64)v39,
                 v31,
                 v32,
                 v33,
                 v34,
                 v35,
                 v36,
                 v37,
                 v38,
                 v40);
      goto LABEL_27;
    }
  }
  else
  {
    v9 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v9 = (const char *)(__strrchr_chk() + 1);
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v9,
               65LL,
               (__int64)"param %s is NULL",
               v10,
               v11,
               v12,
               v13,
               v14,
               v15,
               v16,
               v17,
               "p_nonce");
    v8 = 2;
    if ( !(v6 | 2) )
      goto LABEL_12;
  }
  if ( v6 <= 7 && !v8 )
  {
    v18 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v18 = (const char *)(__strrchr_chk() + 1);
    v27 = "param %s < %d";
    v28 = 67LL;
    v29 = 8LL;
LABEL_22:
    v42 = 1;
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v18,
               v28,
               (__int64)v27,
               v19,
               v20,
               v21,
               v22,
               v23,
               v24,
               v25,
               v26,
               "nonce_len",
               v29);
    goto LABEL_27;
  }
  if ( v6 >= 0x21 && !v8 )
  {
    v18 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v18 = (const char *)(__strrchr_chk() + 1);
    v27 = "param %s > %d";
    v28 = 68LL;
    v29 = 32LL;
    goto LABEL_22;
  }
  if ( !v5 && !v8 )
  {
    v30 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v30 = (const char *)(__strrchr_chk() + 1);
    v39 = "param %s is NULL";
    v40 = "p_data";
    v41 = 69LL;
    goto LABEL_15;
  }
  if ( v8 )
  {
    v42 = 1;
    goto LABEL_27;
  }
  if ( *v5 )
  {
    v30 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v30 = (const char *)(__strrchr_chk() + 1);
    v39 = "param %s is not NULL";
    v40 = "*p_data";
    v41 = 70LL;
    goto LABEL_15;
  }
  if ( !v4 )
  {
    v30 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v30 = (const char *)(__strrchr_chk() + 1);
    v39 = "param %s is NULL";
    v40 = "p_data_len";
    v41 = 71LL;
    goto LABEL_15;
  }
  v53 = QSEECom_start_app();
  if ( v53 )
  {
    v54 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v54 = (const char *)(__strrchr_chk() + 1);
    v63 = 84LL;
LABEL_50:
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v54,
               v63,
               (__int64)"Open TZ app failed %d",
               v55,
               v56,
               v57,
               v58,
               v59,
               v60,
               v61,
               v62,
               v53);
LABEL_51:
    v42 = 4;
    goto LABEL_27;
  }
  v64 = QSEECom_start_app();
  if ( v64 )
  {
    v65 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v65 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v65,
      93LL,
      (__int64)"Open vendor TZ app failed %d",
      v66,
      v67,
      v68,
      v69,
      v70,
      v71,
      v72,
      v73,
      v64);
    v53 = QSEECom_start_app();
    if ( v53 )
    {
      v54 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
      if ( __strrchr_chk() )
        v54 = (const char *)(__strrchr_chk() + 1);
      v63 = 100LL;
      goto LABEL_50;
    }
  }
  **(_DWORD **)&dword_0 = 1;
  *(_DWORD *)(*(_QWORD *)&dword_0 + 4LL) = 68;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 24LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 32LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 16LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 8LL) = 0LL;
  v74 = (unsigned int *)(*(_QWORD *)&dword_0 + 76LL);
  __strncpy_chk2();
  *(_DWORD *)(*(_QWORD *)&dword_0 + 72LL) = v6;
  memcpy((void *)(*(_QWORD *)&dword_0 + 40LL), v7, v6);
  *(_DWORD *)(*(_QWORD *)&dword_0 + 80LL) = 512;
  QSEECom_set_bandwidth();
  v75 = QSEECom_send_cmd();
  if ( v75 )
  {
    v76 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v76 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v76,
      138LL,
      (__int64)"Send command failed %d",
      v77,
      v78,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v75);
LABEL_67:
    result = QSEECom_set_bandwidth();
    goto LABEL_51;
  }
  result = QSEECom_set_bandwidth();
  if ( *v74 )
  {
    v85 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v85 = (const char *)(__strrchr_chk() + 1);
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v85,
               147LL,
               (__int64)"TZ operation failed %d",
               v86,
               v87,
               v88,
               v89,
               v90,
               v91,
               v92,
               v93,
               *v74);
    v42 = 4;
  }
  else
  {
    v42 = 0;
  }
  if ( (unsigned int)(*(_DWORD *)(*(_QWORD *)&dword_0 + 80LL) - 1) >= 0x200 )
  {
    v94 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v94 = (const char *)(__strrchr_chk() + 1);
    v103 = "TZ operation returned wrong buffer";
    v104 = 153LL;
LABEL_77:
    result = sub_379E4((__int64)"secd", 1, (__int64)v94, v104, (__int64)v103, v95, v96, v97, v98, v99, v100, v101, v102);
    goto LABEL_51;
  }
  if ( v42 )
    goto LABEL_27;
  v128 = (const void *)(*(_QWORD *)&dword_0 + 84LL);
  **(_DWORD **)&dword_0 = 0;
  *(_DWORD *)(*(_QWORD *)&dword_0 + 4LL) = 585;
  *(_DWORD *)(*(_QWORD *)&dword_0 + 8LL) = 0x1000000;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 69LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 61LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 53LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)&dword_0 + 45LL) = 0LL;
  if ( (v6 + 303) & 0x3F )
    v105 = (v6 + 366) & 0xFFFFFFC0;
  else
    v105 = v6 + 303;
  v106 = (unsigned int *)(*(_QWORD *)&dword_0 + 593LL);
  __strncpy_chk2();
  *(_BYTE *)(*(_QWORD *)&dword_0 + 12LL) = v6;
  memcpy((void *)(*(_QWORD *)&dword_0 + 13LL), v7, v6);
  *(_DWORD *)(*(_QWORD *)&dword_0 + 77LL) = *(_DWORD *)(*(_QWORD *)&dword_0 + 80LL);
  memcpy((void *)(*(_QWORD *)&dword_0 + 81LL), v128, *(unsigned int *)(*(_QWORD *)&dword_0 + 80LL));
  v107 = (unsigned int *)(*(_QWORD *)&dword_0 + 597LL);
  *(_DWORD *)(*(_QWORD *)&dword_0 + 597LL) = v105;
  QSEECom_set_bandwidth();
  v108 = QSEECom_send_cmd();
  if ( v108 )
  {
    v109 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v109 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v109,
      195LL,
      (__int64)"Send command failed %d",
      v110,
      v111,
      v112,
      v113,
      v114,
      v115,
      v116,
      v117,
      v108);
    goto LABEL_67;
  }
  QSEECom_set_bandwidth();
  if ( *v106 )
  {
    v118 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v118 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v118,
      204LL,
      (__int64)"TZ operation failed %d",
      v119,
      v120,
      v121,
      v122,
      v123,
      v124,
      v125,
      v126,
      *v106);
    v42 = 4;
    result = *v107;
    if ( !(_DWORD)result )
      goto LABEL_96;
  }
  else
  {
    v42 = 0;
    result = *v107;
    if ( !(_DWORD)result )
    {
LABEL_96:
      v94 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
      if ( __strrchr_chk() )
        v94 = (const char *)(__strrchr_chk() + 1);
      v103 = "TZ operation returned wrong buffer";
      v104 = 209LL;
      goto LABEL_77;
    }
  }
  if ( v42 )
    goto LABEL_27;
  *v4 = result;
  v127 = malloc(result);
  *v5 = v127;
  if ( !v127 )
  {
    v94 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v94 = (const char *)(__strrchr_chk() + 1);
    v103 = "failed to allocate memory";
    v104 = 224LL;
    goto LABEL_77;
  }
  result = (size_t)memcpy(v127, (const void *)(*(_QWORD *)&dword_0 + 601LL), (unsigned int)*v4);
  v42 = 0;
LABEL_27:
  if ( v42 )
  {
    v43 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_attest_data.cpp";
    if ( __strrchr_chk() )
      v43 = (const char *)(__strrchr_chk() + 1);
    v44 = sub_38F2C(v42);
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v43,
               245LL,
               (__int64)"%s() ended. result %d - %s",
               v45,
               v46,
               v47,
               v48,
               v49,
               v50,
               v51,
               v52,
               "devsec_get_attest_data",
               v42,
               v44,
               v128);
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v129 )
    result = v42;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000039C10) ----------------------------------------------------
__int64 __fastcall sub_39C10(void **a1)
{
  void **v1; // x20
  const char *v2; // x19
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  const char *v11; // x4
  const char *v12; // x5
  __int64 v13; // x3
  unsigned int v14; // w19
  const char *v15; // x20
  char *v16; // x0
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  __int64 result; // x0
  size_t v26; // x19
  void *v27; // x0
  const char *v28; // x19
  double v29; // d0
  double v30; // d1
  double v31; // d2
  double v32; // d3
  double v33; // d4
  double v34; // d5
  double v35; // d6
  double v36; // d7
  int v37; // [xsp+0h] [xbp-80h]
  unsigned int v38; // [xsp+8h] [xbp-78h]
  _BYTE v39[7]; // [xsp+31h] [xbp-4Fh]
  unsigned __int8 v40; // [xsp+51h] [xbp-2Fh]
  __int64 v41; // [xsp+68h] [xbp-18h]

  v1 = a1;
  v41 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
  {
    v2 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_hwconf_revision.cpp";
    if ( __strrchr_chk() )
      v2 = (const char *)(__strrchr_chk() + 1);
    v11 = "param %s is NULL";
    v12 = "p_revision";
    v13 = 25LL;
    goto LABEL_9;
  }
  if ( *a1 )
  {
    v2 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_hwconf_revision.cpp";
    if ( __strrchr_chk() )
      v2 = (const char *)(__strrchr_chk() + 1);
    v11 = "param %s is not NULL";
    v12 = "*p_revision";
    v13 = 26LL;
LABEL_9:
    sub_379E4((__int64)"secd", 1, (__int64)v2, v13, (__int64)v11, v3, v4, v5, v6, v7, v8, v9, v10, v12);
    v37 = 0;
    v14 = 1;
    goto LABEL_10;
  }
  v37 = 0;
  v14 = sub_38F4C((__int64)"tzxflattest", 7, &v37, 4u, &v38, 94);
  if ( !v14 )
  {
    if ( (v38 | 0x100000) == 17825792 )
    {
      v26 = v40 + 1LL;
      v27 = malloc(v26);
      *v1 = v27;
      memset(v27, 0, v26);
      result = (__int64)memcpy(*v1, v39, v40);
      v14 = 0;
      goto LABEL_13;
    }
    v28 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_hwconf_revision.cpp";
    if ( __strrchr_chk() )
      v28 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v28,
      49LL,
      (__int64)"tz protocol_version is bad %d",
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v38);
    v14 = 4;
  }
LABEL_10:
  v15 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_hwconf_revision.cpp";
  if ( __strrchr_chk() )
    v15 = (const char *)(__strrchr_chk() + 1);
  v16 = sub_38F2C(v14);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v15,
             68LL,
             (__int64)"%s() ended. result %d - %s",
             v17,
             v18,
             v19,
             v20,
             v21,
             v22,
             v23,
             v24,
             "devsec_get_hwconf_revision",
             v14,
             v16);
LABEL_13:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v41 )
    result = v14;
  return result;
}

//----- (0000000000039E6C) ----------------------------------------------------
__int64 __fastcall sub_39E6C(int a1, __int64 *a2, _DWORD *a3)
{
  _DWORD *v3; // x20
  __int64 *v4; // x19
  int v5; // w22
  const char *v6; // x19
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  const char *v15; // x4
  const char *v16; // x5
  __int64 v17; // x3
  unsigned int v18; // w21
  const char *v19; // x19
  char *v20; // x0
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  __int64 result; // x0
  const char *v30; // x19
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  const char *v39; // x19
  char *v40; // x0
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  const char *v49; // x19
  double v50; // d0
  double v51; // d1
  double v52; // d2
  double v53; // d3
  double v54; // d4
  double v55; // d5
  double v56; // d6
  double v57; // d7
  unsigned int v58; // w18
  unsigned int v59; // w12
  unsigned int v60; // w1
  unsigned int v61; // w2
  signed int v62; // w9
  int v63; // w9
  int v64; // w8
  void *v65; // x0
  __int64 v66; // x2
  unsigned int v67; // w8
  __int64 v68; // x9
  unsigned int v69; // w12
  signed __int64 v70; // x13
  const char *v71; // x19
  double v72; // d0
  double v73; // d1
  double v74; // d2
  double v75; // d3
  double v76; // d4
  double v77; // d5
  double v78; // d6
  double v79; // d7
  __int64 v80; // x3
  int v81; // [xsp+0h] [xbp-A0h]
  unsigned int v82; // [xsp+8h] [xbp-98h]
  __int64 v83; // [xsp+18h] [xbp-88h]
  __int64 v84; // [xsp+68h] [xbp-38h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v84 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    v6 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v6 = (const char *)(__strrchr_chk() + 1);
    v15 = "param %s is NULL";
    v16 = "p_imei";
    v17 = 151LL;
    goto LABEL_9;
  }
  if ( *a2 )
  {
    v6 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v6 = (const char *)(__strrchr_chk() + 1);
    v15 = "param %s is not NULL";
    v16 = "*p_imei";
    v17 = 152LL;
LABEL_9:
    sub_379E4((__int64)"secd", 1, (__int64)v6, v17, (__int64)v15, v7, v8, v9, v10, v11, v12, v13, v14, v16);
    v81 = 0;
    v18 = 1;
LABEL_10:
    v19 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v19 = (const char *)(__strrchr_chk() + 1);
    v20 = sub_38F2C(v18);
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v19,
               203LL,
               (__int64)"%s() ended. result %d - %s",
               v21,
               v22,
               v23,
               v24,
               v25,
               v26,
               v27,
               v28,
               "devsec_get_imei",
               v18,
               v20);
    goto LABEL_13;
  }
  if ( !a3 )
  {
    v6 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v6 = (const char *)(__strrchr_chk() + 1);
    v15 = "param %s is NULL";
    v16 = "p_imei_size";
    v17 = 153LL;
    goto LABEL_9;
  }
  v81 = 0;
  v18 = sub_38F4C((__int64)"tzxflattest", 7, &v81, 4u, &v82, 94);
  if ( v18 )
    goto LABEL_10;
  if ( (v82 | 0x100000) != 17825792 )
  {
    v49 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v49 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v49,
      176LL,
      (__int64)"tz protocol_version is bad %d",
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56,
      v57,
      v82);
    v18 = 4;
    goto LABEL_10;
  }
  if ( *v4 )
  {
    v30 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v30 = (const char *)(__strrchr_chk() + 1);
    v18 = 1;
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v30,
      80LL,
      (__int64)"param %s is not NULL",
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      "*p_imei");
    goto LABEL_22;
  }
  v58 = 2 * (v83 & 0xF);
  v59 = 2 * (BYTE1(v83) & 0xF);
  v60 = 2 * (BYTE2(v83) & 0xF);
  v61 = 2 * (BYTE3(v83) & 0xF);
  v62 = ((unsigned int)BYTE1(v83) >> 4)
      + ((unsigned int)(unsigned __int8)v83 >> 4)
      + v58 / 0xA
      + v58 % 0xA
      + ((unsigned int)BYTE2(v83) >> 4)
      + v59 / 0xA
      + v59 % 0xA
      + ((unsigned int)BYTE3(v83) >> 4)
      + v60 / 0xA
      + v60 % 0xA
      + ((unsigned int)BYTE4(v83) >> 4)
      + v61 / 0xA
      + v61 % 0xA
      + ((unsigned int)BYTE5(v83) >> 4)
      + 2 * (BYTE4(v83) & 0xFu) / 0xA
      + 2 * (BYTE4(v83) & 0xFu) % 0xA
      + ((unsigned int)BYTE6(v83) >> 4)
      + 2 * (BYTE5(v83) & 0xFu) / 0xA
      + 2 * (BYTE5(v83) & 0xFu) % 0xA
      + 2 * (BYTE6(v83) & 0xFu) / 0xA
      + 2 * (BYTE6(v83) & 0xFu) % 0xA;
  v63 = v62 - 10 * ((1717986919LL * v62 >> 34) + ((unsigned __int64)(1717986919LL * v62) >> 63));
  v64 = 16 * (10 - v63);
  if ( !v63 )
    LOBYTE(v64) = 0;
  HIBYTE(v83) = v64;
  if ( v5 != 1 )
  {
    *v3 = 8;
    result = (__int64)malloc(8uLL);
    *v4 = result;
    if ( result )
    {
      v18 = 0;
      *(_QWORD *)result = v83;
      goto LABEL_13;
    }
    v71 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v71 = (const char *)(__strrchr_chk() + 1);
    v80 = 109LL;
    goto LABEL_49;
  }
  *v3 = 16;
  v65 = malloc(0x10uLL);
  *v4 = (__int64)v65;
  if ( !v65 )
  {
    v71 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v71 = (const char *)(__strrchr_chk() + 1);
    v80 = 126LL;
LABEL_49:
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v71,
      v80,
      (__int64)"failed to allocate memory",
      v72,
      v73,
      v74,
      v75,
      v76,
      v77,
      v78,
      v79);
    v18 = 4;
LABEL_22:
    v39 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_imei.cpp";
    if ( __strrchr_chk() )
      v39 = (const char *)(__strrchr_chk() + 1);
    v40 = sub_38F2C(v18);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v39,
      133LL,
      (__int64)"%s() ended. result %d - %s",
      v41,
      v42,
      v43,
      v44,
      v45,
      v46,
      v47,
      v48,
      "imei_post_processing",
      v18,
      v40);
    goto LABEL_10;
  }
  v66 = (unsigned int)*v3;
  result = __memset_chk();
  v67 = *v3 - 1;
  if ( *v3 == 1 )
  {
    v18 = 0;
  }
  else
  {
    v68 = *v4;
    v69 = 0;
    v18 = 0;
    do
    {
      v70 = v69 + 1LL;
      *(_BYTE *)(v68 + v69) = a0123456789abcd_0[(unsigned __int64)*((unsigned __int8 *)&v82 + (v69 >> 1) + 16) >> 4];
      if ( (unsigned int)v70 < v67 )
      {
        *(_BYTE *)(v68 + v70) = a0123456789abcd_0[*((_BYTE *)&v82 + ((unsigned int)v70 >> 1) + 16) & 0xF];
        LODWORD(v70) = v69 + 2;
      }
      v69 = v70;
    }
    while ( (unsigned int)v70 < v67 );
  }
LABEL_13:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v84 )
    result = v18;
  return result;
}

//----- (000000000003A478) ----------------------------------------------------
__int64 __fastcall sub_3A478(__int64 *a1, _DWORD *a2)
{
  _DWORD *v2; // x21
  __int64 *v3; // x20
  const char *v4; // x19
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  const char *v13; // x4
  const char *v14; // x5
  __int64 v15; // x3
  unsigned int v16; // w19
  const char *v17; // x20
  char *v18; // x0
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  __int64 result; // x0
  __int64 v28; // x8
  const char *v29; // x19
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  int v38; // [xsp+0h] [xbp-90h]
  int v39; // [xsp+8h] [xbp-88h]
  __int128 v40; // [xsp+52h] [xbp-3Eh]
  int v41; // [xsp+62h] [xbp-2Eh]
  __int64 v42; // [xsp+68h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v42 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_keystore_hash.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v13 = "param %s is NULL";
    v14 = "p_keystore_hash";
    v15 = 26LL;
    goto LABEL_9;
  }
  if ( *a1 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_keystore_hash.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v13 = "param %s is not NULL";
    v14 = "*p_keystore_hash";
    v15 = 27LL;
LABEL_9:
    sub_379E4((__int64)"secd", 1, (__int64)v4, v15, (__int64)v13, v5, v6, v7, v8, v9, v10, v11, v12, v14);
    v38 = 0;
    v16 = 1;
    goto LABEL_10;
  }
  if ( !a2 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_keystore_hash.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v13 = "param %s is NULL";
    v14 = "p_keystore_hash_len";
    v15 = 28LL;
    goto LABEL_9;
  }
  v38 = 0;
  v16 = sub_38F4C((__int64)"tzxflattest", 7, &v38, 4u, &v39, 94);
  if ( !v16 )
  {
    if ( v39 == 17825792 )
    {
      result = (__int64)malloc(0x14uLL);
      *v3 = result;
      *(_DWORD *)(result + 16) = 0;
      *(_QWORD *)result = 0LL;
      *(_QWORD *)(result + 8) = 0LL;
      *v2 = 20;
      v28 = *v3;
      v16 = 0;
      *(_DWORD *)(v28 + 16) = v41;
      *(_OWORD *)v28 = v40;
      goto LABEL_13;
    }
    v29 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_keystore_hash.cpp";
    if ( __strrchr_chk() )
      v29 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v29,
      50LL,
      (__int64)"tz protocol_version v%d is bad (needs v2)",
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      HIBYTE(v39));
    v16 = 4;
  }
LABEL_10:
  v17 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_keystore_hash.cpp";
  if ( __strrchr_chk() )
    v17 = (const char *)(__strrchr_chk() + 1);
  v18 = sub_38F2C(v16);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v17,
             70LL,
             (__int64)"%s() ended. result %d - %s",
             v19,
             v20,
             v21,
             v22,
             v23,
             v24,
             v25,
             v26,
             "devsec_get_keystore_hash",
             v16,
             v18);
LABEL_13:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v42 )
    result = v16;
  return result;
}

//----- (000000000003A734) ----------------------------------------------------
__int64 __fastcall sub_3A734(_DWORD *a1)
{
  _DWORD *v1; // x20
  __int64 result; // x0
  unsigned int v3; // w19
  const char *v4; // x20
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  const char *v13; // x19
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  __int64 v22; // x5
  const char *v23; // x4
  __int64 v24; // x3
  const char *v25; // x20
  char *v26; // x0
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  int v35; // [xsp+0h] [xbp-80h]
  unsigned int v36; // [xsp+8h] [xbp-78h]
  unsigned __int8 v37; // [xsp+30h] [xbp-50h]
  __int64 v38; // [xsp+68h] [xbp-18h]

  v1 = a1;
  v38 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_rooting_status.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v3 = 1;
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v4,
      31LL,
      (__int64)"param %s is NULL",
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      "p_rooting_status");
    v35 = 0;
    goto LABEL_16;
  }
  v35 = 0;
  result = sub_38F4C((__int64)"tzxflattest", 7, &v35, 4u, &v36, 94);
  v3 = result;
  if ( (_DWORD)result )
  {
LABEL_16:
    v25 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_rooting_status.cpp";
    if ( __strrchr_chk() )
      v25 = (const char *)(__strrchr_chk() + 1);
    v26 = sub_38F2C(v3);
    result = sub_379E4(
               (__int64)"secd",
               1,
               (__int64)v25,
               92LL,
               (__int64)"%s() ended. result %d - %s",
               v27,
               v28,
               v29,
               v30,
               v31,
               v32,
               v33,
               v34,
               "devsec_get_rooting_status",
               v3,
               v26);
    goto LABEL_19;
  }
  if ( (v36 | 0x100000) != 17825792 )
  {
    v13 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_rooting_status.cpp";
    if ( __strrchr_chk() )
      v13 = (const char *)(__strrchr_chk() + 1);
    v22 = v36;
    v23 = "tz protocol_version is bad %d";
    v24 = 54LL;
LABEL_15:
    sub_379E4((__int64)"secd", 1, (__int64)v13, v24, (__int64)v23, v14, v15, v16, v17, v18, v19, v20, v21, v22);
    v3 = 4;
    goto LABEL_16;
  }
  switch ( v37 )
  {
    case 0u:
      v3 = 0;
      *v1 = 0;
      break;
    case 1u:
    case 2u:
    case 3u:
    case 4u:
      v3 = 0;
      *v1 = 0;
      break;
    default:
      v13 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_rooting_status.cpp";
      if ( __strrchr_chk() )
        v13 = (const char *)(__strrchr_chk() + 1);
      v22 = v37;
      v23 = "unsupported rooting status value %d";
      v24 = 80LL;
      goto LABEL_15;
  }
LABEL_19:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v38 )
    result = v3;
  return result;
}

//----- (000000000003A99C) ----------------------------------------------------
__int64 __fastcall sub_3A99C(_DWORD *a1)
{
  _DWORD *v1; // x20
  __int64 result; // x0
  unsigned int v3; // w19
  const char *v4; // x20
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  const char *v13; // x19
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  __int64 v22; // x5
  const char *v23; // x4
  __int64 v24; // x3
  const char *v25; // x20
  char *v26; // x0
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  int v35; // [xsp+0h] [xbp-80h]
  unsigned int v36; // [xsp+8h] [xbp-78h]
  unsigned int v37; // [xsp+14h] [xbp-6Ch]
  __int64 v38; // [xsp+68h] [xbp-18h]

  v1 = a1;
  v38 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v35 = 0;
    result = sub_38F4C((__int64)"tzxflattest", 7, &v35, 4u, &v36, 94);
    v3 = result;
    if ( !(_DWORD)result )
    {
      if ( (v36 | 0x100000) == 17825792 )
      {
        if ( v37 == 0x2000 )
        {
          v3 = 0;
          *v1 = 0;
          goto LABEL_21;
        }
        if ( !v37 )
        {
          v3 = 0;
          *v1 = 1;
          goto LABEL_21;
        }
        v13 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_security_config.cpp";
        if ( __strrchr_chk() )
          v13 = (const char *)(__strrchr_chk() + 1);
        v22 = v37;
        v23 = "unsupported security config value %d";
        v24 = 68LL;
      }
      else
      {
        v13 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_security_config.cpp";
        if ( __strrchr_chk() )
          v13 = (const char *)(__strrchr_chk() + 1);
        v22 = v36;
        v23 = "tz protocol_version is bad %d";
        v24 = 51LL;
      }
      sub_379E4((__int64)"secd", 1, (__int64)v13, v24, (__int64)v23, v14, v15, v16, v17, v18, v19, v20, v21, v22);
      v3 = 4;
    }
  }
  else
  {
    v4 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_security_config.cpp";
    if ( __strrchr_chk() )
      v4 = (const char *)(__strrchr_chk() + 1);
    v3 = 1;
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v4,
      28LL,
      (__int64)"param %s is NULL",
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      "p_security_config");
    v35 = 0;
  }
  v25 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_security_config.cpp";
  if ( __strrchr_chk() )
    v25 = (const char *)(__strrchr_chk() + 1);
  v26 = sub_38F2C(v3);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v25,
             80LL,
             (__int64)"%s() ended. result %d - %s",
             v27,
             v28,
             v29,
             v30,
             v31,
             v32,
             v33,
             v34,
             "devsec_get_security_config",
             v3,
             v26);
LABEL_21:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v38 )
    result = v3;
  return result;
}

//----- (000000000003ABDC) ----------------------------------------------------
__int64 __fastcall sub_3ABDC(_DWORD *a1)
{
  unsigned int v1; // w20
  const char *v2; // x19
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  const char *v11; // x19
  char *v12; // x0
  double v13; // d0
  double v14; // d1
  double v15; // d2
  double v16; // d3
  double v17; // d4
  double v18; // d5
  double v19; // d6
  double v20; // d7

  if ( a1 )
  {
    v1 = 0;
    *a1 = 0;
  }
  else
  {
    v2 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_tee_status.cpp";
    if ( __strrchr_chk() )
      v2 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v2,
      21LL,
      (__int64)"param %s is NULL",
      v3,
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      "p_tee_status");
    v11 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/get_tee_status.cpp";
    if ( __strrchr_chk() )
      v11 = (const char *)(__strrchr_chk() + 1);
    v1 = 1;
    v12 = sub_38F2C(1u);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v11,
      56LL,
      (__int64)"%s() ended. result %d - %s",
      v13,
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      "devsec_get_tee_status",
      1LL,
      v12);
  }
  return v1;
}

//----- (000000000003ACD4) ----------------------------------------------------
signed __int64 sub_3ACD4()
{
  return 116LL;
}

//----- (000000000003ACDC) ----------------------------------------------------
__int64 __fastcall sub_3ACDC(__int64 a1, unsigned int a2, char *a3, unsigned int a4, _BYTE *a5)
{
  _BYTE *v5; // x21
  unsigned int v6; // w22
  char *v7; // x20
  unsigned int v8; // w19
  const char *v9; // x23
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  const char *v18; // x23
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  const char *v27; // x4
  const char *v28; // x5
  __int64 v29; // x3
  signed int v30; // w8
  const char *v31; // x23
  double v32; // d0
  double v33; // d1
  double v34; // d2
  double v35; // d3
  double v36; // d4
  double v37; // d5
  double v38; // d6
  double v39; // d7
  const char *v40; // x23
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  const char *v49; // x4
  const char *v50; // x5
  __int64 v51; // x3
  const char *v52; // x20
  double v53; // d0
  double v54; // d1
  double v55; // d2
  double v56; // d3
  double v57; // d4
  double v58; // d5
  double v59; // d6
  double v60; // d7
  unsigned int v61; // w23
  void *v62; // x0
  signed __int64 v63; // x1
  __int64 result; // x0
  unsigned int v65; // w19
  const char *v66; // x20
  double v67; // d0
  double v68; // d1
  double v69; // d2
  double v70; // d3
  double v71; // d4
  double v72; // d5
  double v73; // d6
  double v74; // d7
  const char *v75; // x19
  char *v76; // x0
  double v77; // d0
  double v78; // d1
  double v79; // d2
  double v80; // d3
  double v81; // d4
  double v82; // d5
  double v83; // d6
  double v84; // d7
  int v85; // [xsp+4h] [xbp-3Ch]
  __int64 v86; // [xsp+8h] [xbp-38h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v86 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    v18 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v18 = (const char *)(__strrchr_chk() + 1);
    v27 = "param %s = 0";
    v28 = "hash_len";
    v29 = 56LL;
    goto LABEL_15;
  }
  if ( a2 >= 0x401 )
  {
    v9 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v9 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v9,
      57LL,
      (__int64)"param %s > %d",
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v16,
      v17,
      "hash_len",
      1024LL);
LABEL_16:
    v30 = 2;
    if ( v6 | 2 )
      goto LABEL_17;
LABEL_22:
    v40 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v40 = (const char *)(__strrchr_chk() + 1);
    v49 = "param %s = 0";
    v50 = "sin_header_size";
    v51 = 59LL;
    goto LABEL_30;
  }
  if ( !a3 )
  {
    v18 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v18 = (const char *)(__strrchr_chk() + 1);
    v27 = "param %s is NULL";
    v28 = "p_hash_data";
    v29 = 58LL;
LABEL_15:
    sub_379E4((__int64)"secd", 1, (__int64)v18, v29, (__int64)v27, v19, v20, v21, v22, v23, v24, v25, v26, v28);
    goto LABEL_16;
  }
  v30 = 0;
  if ( !a4 )
    goto LABEL_22;
LABEL_17:
  if ( v6 > 0x19000 && !v30 )
  {
    v31 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v31 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v31,
      60LL,
      (__int64)"param %s > %d",
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      "sin_header_size",
      102400LL);
    goto LABEL_31;
  }
  if ( !v5 && !v30 )
  {
    v40 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v40 = (const char *)(__strrchr_chk() + 1);
    v49 = "param %s is NULL";
    v50 = "p_sin_header_data";
    v51 = 61LL;
LABEL_30:
    sub_379E4((__int64)"secd", 1, (__int64)v40, v51, (__int64)v49, v41, v42, v43, v44, v45, v46, v47, v48, v50);
LABEL_31:
    v30 = 2;
  }
  if ( v8 & 0x1F )
  {
    v52 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v52 = (const char *)(__strrchr_chk() + 1);
    v61 = 1;
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v52,
      65LL,
      (__int64)"param hash_len=%d is not alligned to 32",
      v53,
      v54,
      v55,
      v56,
      v57,
      v58,
      v59,
      v60,
      v8);
  }
  else
  {
    v61 = 1;
    if ( !v30 )
    {
      v85 = 1;
      sub_3A99C(&v85);
      if ( v85 )
        v62 = &unk_C182C;
      else
        v62 = &unk_C1AD7;
      if ( v85 )
        v63 = 683LL;
      else
        v63 = 693LL;
      result = sub_53DD4((__int64)v62, v63, v5, v6, v7, v8 >> 5);
      v65 = result;
      if ( !(_DWORD)result )
      {
        v61 = 0;
        goto LABEL_50;
      }
      v66 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
      if ( __strrchr_chk() )
        v66 = (const char *)(__strrchr_chk() + 1);
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v66,
        93LL,
        (__int64)"sinfota_verify failed, error %d",
        v67,
        v68,
        v69,
        v70,
        v71,
        v72,
        v73,
        v74,
        v65);
      v61 = 4;
    }
  }
  v75 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
  if ( __strrchr_chk() )
    v75 = (const char *)(__strrchr_chk() + 1);
  v76 = sub_38F2C(v61);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v75,
             105LL,
             (__int64)"%s() ended. result %d - %s",
             v77,
             v78,
             v79,
             v80,
             v81,
             v82,
             v83,
             v84,
             "devsec_verify_s1sin_signature_hashes",
             v61,
             v76);
LABEL_50:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v86 )
    result = v61;
  return result;
}

//----- (000000000003B14C) ----------------------------------------------------
__int64 __fastcall sub_3B14C(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4, _BYTE *a5)
{
  _BYTE *v5; // x19
  unsigned int v6; // w20
  __int64 v7; // x21
  unsigned int v8; // w22
  signed int v9; // w8
  const char *v10; // x23
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  const char *v19; // x4
  const char *v20; // x5
  __int64 v21; // x3
  const char *v22; // x20
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  unsigned int v31; // w19
  const char *v32; // x20
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  const char *v41; // x4
  const char *v42; // x5
  __int64 v43; // x3
  const char *v44; // x20
  char *v45; // x0
  double v46; // d0
  double v47; // d1
  double v48; // d2
  double v49; // d3
  double v50; // d4
  double v51; // d5
  double v52; // d6
  double v53; // d7
  __int64 result; // x0
  __int64 v55; // x0
  unsigned int v56; // w21
  const char *v57; // x19
  double v58; // d0
  double v59; // d1
  double v60; // d2
  double v61; // d3
  double v62; // d4
  double v63; // d5
  double v64; // d6
  double v65; // d7
  __int64 v66; // [xsp+8h] [xbp-58h]
  __int64 v67; // [xsp+10h] [xbp-50h]
  __int64 v68; // [xsp+18h] [xbp-48h]
  __int64 v69; // [xsp+20h] [xbp-40h]
  __int64 v70; // [xsp+28h] [xbp-38h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v70 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v68 = 0LL;
  v69 = 0LL;
  v66 = 0LL;
  v67 = 0LL;
  if ( a2 )
  {
    if ( a3 )
    {
      v9 = 0;
      if ( !a4 )
        goto LABEL_17;
      goto LABEL_12;
    }
    v10 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v10 = (const char *)(__strrchr_chk() + 1);
    v19 = "param %s is NULL";
    v20 = "p_package_data";
    v21 = 125LL;
  }
  else
  {
    v10 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v10 = (const char *)(__strrchr_chk() + 1);
    v19 = "param %s = 0";
    v20 = "package_size";
    v21 = 124LL;
  }
  sub_379E4((__int64)"secd", 1, (__int64)v10, v21, (__int64)v19, v11, v12, v13, v14, v15, v16, v17, v18, v20);
  v9 = 2;
  if ( !(v6 | 2) )
  {
LABEL_17:
    v32 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v32 = (const char *)(__strrchr_chk() + 1);
    v41 = "param %s = 0";
    v42 = "sin_header_size";
    v43 = 126LL;
LABEL_25:
    v31 = 1;
    sub_379E4((__int64)"secd", 1, (__int64)v32, v43, (__int64)v41, v33, v34, v35, v36, v37, v38, v39, v40, v42);
    goto LABEL_26;
  }
LABEL_12:
  if ( v6 > 0x19000 && !v9 )
  {
    v22 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v22 = (const char *)(__strrchr_chk() + 1);
    v31 = 1;
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v22,
      127LL,
      (__int64)"param %s > %d",
      v23,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      "sin_header_size",
      102400LL);
    goto LABEL_26;
  }
  if ( !v5 && !v9 )
  {
    v32 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v32 = (const char *)(__strrchr_chk() + 1);
    v41 = "param %s is NULL";
    v42 = "p_sin_header_data";
    v43 = 128LL;
    goto LABEL_25;
  }
  if ( v9 )
  {
    v31 = 1;
  }
  else
  {
    v55 = sub_388CC(v7, v8, &v66);
    v56 = v55;
    if ( (_DWORD)v55 )
    {
      v57 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
      if ( __strrchr_chk() )
        v57 = (const char *)(__strrchr_chk() + 1);
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v57,
        143LL,
        (__int64)"secd_sha256 failed %d",
        v58,
        v59,
        v60,
        v61,
        v62,
        v63,
        v64,
        v65,
        v56);
      v31 = 4;
    }
    else
    {
      result = sub_3ACDC(v55, 0x20u, (char *)&v66, v6, v5);
      v31 = result;
      if ( !(_DWORD)result )
        goto LABEL_29;
    }
  }
LABEL_26:
  v44 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
  if ( __strrchr_chk() )
    v44 = (const char *)(__strrchr_chk() + 1);
  v45 = sub_38F2C(v31);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v44,
             161LL,
             (__int64)"%s() ended. result %d - %s",
             v46,
             v47,
             v48,
             v49,
             v50,
             v51,
             v52,
             v53,
             "devsec_verify_s1sin_signature",
             v31,
             v45);
LABEL_29:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v70 )
    result = v31;
  return result;
}

//----- (000000000003B4DC) ----------------------------------------------------
__int64 __fastcall sub_3B4DC(unsigned int a1, __int64 a2)
{
  const char *v2; // x19
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  const char *v11; // x19
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  const char *v20; // x4
  const char *v21; // x5
  __int64 v22; // x3
  unsigned int v23; // w20
  const char *v24; // x19
  char *v25; // x0
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7

  if ( a1 )
  {
    if ( a1 > 0x19000 )
    {
      v2 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
      if ( __strrchr_chk() )
        v2 = (const char *)(__strrchr_chk() + 1);
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v2,
        177LL,
        (__int64)"param %s > %d",
        v3,
        v4,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        "sin_header_size",
        102400LL);
      goto LABEL_15;
    }
    if ( a2 )
      return 0;
    v11 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v11 = (const char *)(__strrchr_chk() + 1);
    v20 = "param %s is NULL";
    v21 = "p_sin_header_data";
    v22 = 178LL;
  }
  else
  {
    v11 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
    if ( __strrchr_chk() )
      v11 = (const char *)(__strrchr_chk() + 1);
    v20 = "param %s = 0";
    v21 = "sin_header_size";
    v22 = 176LL;
  }
  sub_379E4((__int64)"secd", 1, (__int64)v11, v22, (__int64)v20, v12, v13, v14, v15, v16, v17, v18, v19, v21);
LABEL_15:
  v24 = "vendor/semc/system/core/libasb/security_daemon/backend/device_security/verify_s1sin_signature.cpp";
  if ( __strrchr_chk() )
    v24 = (const char *)(__strrchr_chk() + 1);
  v23 = 1;
  v25 = sub_38F2C(1u);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v24,
    192LL,
    (__int64)"%s() ended. result %d - %s",
    v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    "devsec_verify_s1sin_header",
    1LL,
    v25);
  return v23;
}

//----- (000000000003B69C) ----------------------------------------------------
void __fastcall sub_3B69C(__int64 a1)
{
  __int64 v1; // x19
  int v2; // w0
  const char *v3; // x20
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  int v12; // w8
  signed int v13; // w0
  int v14; // w0
  signed int v15; // w8
  char *v16; // x0
  int v17; // w0
  signed int v18; // w8
  int v19; // w0
  unsigned int v20; // w2
  const char *v21; // x3
  int v22; // w1
  const char *v23; // x20
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  unsigned int v32; // [xsp+Ch] [xbp-54h]
  void *v33; // [xsp+10h] [xbp-50h]
  unsigned int v34; // [xsp+1Ch] [xbp-44h]
  const char *v35; // [xsp+20h] [xbp-40h]
  unsigned int v36; // [xsp+2Ch] [xbp-34h]
  const char *v37; // [xsp+30h] [xbp-30h]
  unsigned int v38; // [xsp+3Ch] [xbp-24h]
  const char *v39; // [xsp+40h] [xbp-20h]
  __int64 v40; // [xsp+48h] [xbp-18h]

  v1 = a1;
  v40 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  switch ( *(_DWORD *)(a1 + 1) )
  {
    case 0xC8:
      LODWORD(v39) = 0;
      v2 = sub_3C170(&v39);
      *(_QWORD *)(v1 + 1) = 201LL;
      if ( !v2 )
        v2 = sub_37BB0(v1, 6, 4u, &v39);
      *(_DWORD *)(v1 + 9) = v2;
      goto LABEL_47;
    case 0xCA:
      v39 = 0LL;
      v38 = 0;
      v37 = 0LL;
      v36 = 0;
      v35 = 0LL;
      v34 = 0;
      v33 = 0LL;
      v32 = 0;
      v13 = sub_37F74(a1, 2, &v38, (signed __int64 *)&v39);
      if ( v13 )
        goto LABEL_44;
      v13 = sub_37F74(v1, 3, &v36, (signed __int64 *)&v37);
      if ( v13 )
        goto LABEL_44;
      if ( v38 == v36 )
      {
        v13 = sub_37F74(v1, 1, &v34, (signed __int64 *)&v35);
        if ( !v13 )
        {
          v13 = sub_3C198(v39, v37, v38, v35, v34, &v33, &v32);
          *(_QWORD *)(v1 + 1) = 203LL;
          if ( !v13 )
            v13 = sub_37BB0(v1, 5, v32, v33);
          goto LABEL_45;
        }
      }
      else
      {
        v23 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_process_credential_manager.cpp";
        if ( __strrchr_chk() )
          v23 = (const char *)(__strrchr_chk() + 1);
        sub_379E4(
          (__int64)"secd",
          1,
          (__int64)v23,
          74LL,
          (__int64)"length of test and live keyIDs should be identical",
          v24,
          v25,
          v26,
          v27,
          v28,
          v29,
          v30,
          v31);
        v13 = 2;
      }
LABEL_44:
      *(_QWORD *)(v1 + 1) = 203LL;
LABEL_45:
      *(_DWORD *)(v1 + 9) = v13;
      v16 = (char *)v33;
      goto LABEL_46;
    case 0xCC:
      LODWORD(v33) = 0;
      v39 = 0LL;
      v38 = 0;
      v37 = 0LL;
      v36 = 0;
      v35 = 0LL;
      v34 = 0;
      v14 = sub_37F74(a1, 6, &v38, (signed __int64 *)&v39);
      if ( v14 || (__memcpy_chk(), (v14 = sub_37F74(v1, 2, &v36, (signed __int64 *)&v37)) != 0) )
      {
        v15 = 205;
        goto LABEL_20;
      }
      v14 = sub_3C30C((unsigned int)v33, v37, v36, &v35, (__int64)&v34);
      *(_QWORD *)(v1 + 1) = 205LL;
      if ( v14 )
        goto LABEL_21;
      v20 = v34;
      v21 = v35;
      v22 = 5;
      goto LABEL_40;
    case 0xCE:
      v39 = 0LL;
      LODWORD(v37) = 0;
      v17 = sub_37F74(a1, 5, &v37, (signed __int64 *)&v39);
      if ( !v17 )
        v17 = sub_3C534((__int64)v39, (int)v37);
      *(_DWORD *)(v1 + 5) = 0;
      v18 = 207;
      goto LABEL_32;
    case 0xD0:
      v39 = 0LL;
      LODWORD(v37) = 0;
      LODWORD(v35) = 1;
      v17 = sub_37F74(a1, 5, &v37, (signed __int64 *)&v39);
      if ( v17 )
      {
        v18 = 209;
        *(_DWORD *)(v1 + 5) = 0;
LABEL_32:
        *(_DWORD *)(v1 + 1) = v18;
        *(_DWORD *)(v1 + 9) = v17;
      }
      else
      {
        v19 = sub_3C660((__int64)v39, (int)v37, (__int64)&v35);
        *(_QWORD *)(v1 + 1) = 209LL;
        if ( !v19 )
          v19 = sub_37BB0(v1, 6, 4u, &v35);
        *(_DWORD *)(v1 + 9) = v19;
      }
      goto LABEL_47;
    case 0xD2:
      v39 = 0LL;
      LODWORD(v33) = 0;
      v37 = 0LL;
      v38 = 0;
      v35 = 0LL;
      v36 = 0;
      v14 = sub_37F74(a1, 2, &v33, (signed __int64 *)&v39);
      if ( v14 || (v14 = sub_37F74(v1, 5, &v38, (signed __int64 *)&v37)) != 0 )
      {
        v15 = 211;
LABEL_20:
        *(_DWORD *)(v1 + 5) = 0;
        *(_DWORD *)(v1 + 1) = v15;
      }
      else
      {
        v14 = sub_3C79C((__int64)v39, (int)v33, (__int64)v37, v38, &v35, (int *)&v36);
        *(_QWORD *)(v1 + 1) = 211LL;
        if ( !v14 )
        {
          v20 = v36;
          v21 = v35;
          v22 = 2;
LABEL_40:
          v14 = sub_37BB0(v1, v22, v20, v21);
        }
      }
LABEL_21:
      *(_DWORD *)(v1 + 9) = v14;
      v16 = (char *)v35;
LABEL_46:
      free(v16);
LABEL_47:
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
      return;
    case 0xD4:
      v39 = 0LL;
      LODWORD(v33) = 0;
      v37 = 0LL;
      v38 = 0;
      v35 = 0LL;
      v36 = 0;
      v17 = sub_37F74(a1, 2, &v33, (signed __int64 *)&v39);
      if ( !v17 )
      {
        v17 = sub_37F74(v1, 5, &v38, (signed __int64 *)&v37);
        if ( !v17 )
        {
          v17 = sub_37F74(v1, 3, &v36, (signed __int64 *)&v35);
          if ( !v17 )
            v17 = sub_3C910((__int64)v39, (int)v33, (__int64)v37, v38, (__int64)v35, v36);
        }
      }
      *(_DWORD *)(v1 + 5) = 0;
      v18 = 213;
      goto LABEL_32;
    default:
      v3 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_process_credential_manager.cpp";
      if ( __strrchr_chk() )
        v3 = (const char *)(__strrchr_chk() + 1);
      sub_379E4(
        (__int64)"secd",
        1,
        (__int64)v3,
        298LL,
        (__int64)"unknown cremgr command = %d",
        v4,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        *(unsigned int *)(v1 + 1));
      v12 = *(_DWORD *)(v1 + 1);
      *(_DWORD *)(v1 + 5) = 0;
      *(_DWORD *)(v1 + 9) = 9;
      *(_DWORD *)(v1 + 1) = v12 + 1;
      goto LABEL_47;
  }
}

//----- (000000000003BB6C) ----------------------------------------------------
__int64 sub_3BB6C()
{
  unsigned int v0; // w19
  const char *v1; // x20
  double v2; // d0
  double v3; // d1
  double v4; // d2
  double v5; // d3
  double v6; // d4
  double v7; // d5
  double v8; // d6
  double v9; // d7
  const char *v10; // x19
  char *v11; // x0
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  __int64 result; // x0
  const char *v21; // x19
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d3
  double v26; // d4
  double v27; // d5
  double v28; // d6
  double v29; // d7
  unsigned int v30; // w19
  const char *v31; // x20
  double v32; // d0
  double v33; // d1
  double v34; // d2
  double v35; // d3
  double v36; // d4
  double v37; // d5
  double v38; // d6
  double v39; // d7
  unsigned int v40; // w19
  const char *v41; // x20
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  unsigned int v50; // w19
  const char *v51; // x20
  double v52; // d0
  double v53; // d1
  double v54; // d2
  double v55; // d3
  double v56; // d4
  double v57; // d5
  double v58; // d6
  double v59; // d7
  unsigned int v60; // w19
  const char *v61; // x20
  double v62; // d0
  double v63; // d1
  double v64; // d2
  double v65; // d3
  double v66; // d4
  double v67; // d5
  double v68; // d6
  double v69; // d7
  const char *v70; // x19
  double v71; // d0
  double v72; // d1
  double v73; // d2
  double v74; // d3
  double v75; // d4
  double v76; // d5
  double v77; // d6
  double v78; // d7
  const char *v79; // x4
  __int64 v80; // x3
  unsigned int v81; // w0
  unsigned int v82; // w19
  const char *v83; // x20
  double v84; // d0
  double v85; // d1
  double v86; // d2
  double v87; // d3
  double v88; // d4
  double v89; // d5
  double v90; // d6
  double v91; // d7
  unsigned int v92; // w0
  unsigned int v93; // w19
  const char *v94; // x20
  double v95; // d0
  double v96; // d1
  double v97; // d2
  double v98; // d3
  double v99; // d4
  double v100; // d5
  double v101; // d6
  double v102; // d7
  unsigned int v103; // w0
  unsigned int v104; // w19
  const char *v105; // x20
  double v106; // d0
  double v107; // d1
  double v108; // d2
  double v109; // d3
  double v110; // d4
  double v111; // d5
  double v112; // d6
  double v113; // d7
  unsigned int v114; // w0
  unsigned int v115; // w19
  const char *v116; // x20
  double v117; // d0
  double v118; // d1
  double v119; // d2
  double v120; // d3
  double v121; // d4
  double v122; // d5
  double v123; // d6
  double v124; // d7
  int v125; // [xsp+4h] [xbp-1Ch]
  __int64 v126; // [xsp+8h] [xbp-18h]

  v126 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  pthread_mutex_lock((pthread_mutex_t *)&unk_106DE8);
  property_set();
  v125 = 2;
  v0 = sub_364A4(&v125);
  if ( v0 )
  {
    v1 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v1 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v1,
      70LL,
      (__int64)"do_backend_devsec_get_rooting_status failed, result %d",
      v2,
      v3,
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v0);
    goto LABEL_5;
  }
  if ( v125 == 5 || v125 == 2 )
  {
    v21 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v21 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v21,
      77LL,
      (__int64)"the bootloader is unlocked, use limited functionality",
      v22,
      v23,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29);
    goto LABEL_29;
  }
  v30 = Suntory_ConvertAllBlobs();
  if ( !v30 )
    goto LABEL_49;
  v31 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v31 = (const char *)(__strrchr_chk() + 1);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v31,
    99LL,
    (__int64)"Suntory_ConvertAllBlobs failed (%d) with error %d",
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    1LL,
    v30);
  sleep(1u);
  v40 = Suntory_ConvertAllBlobs();
  if ( !v40 )
    goto LABEL_49;
  v41 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v41 = (const char *)(__strrchr_chk() + 1);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v41,
    99LL,
    (__int64)"Suntory_ConvertAllBlobs failed (%d) with error %d",
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    2LL,
    v40);
  sleep(1u);
  v50 = Suntory_ConvertAllBlobs();
  if ( !v50 )
    goto LABEL_49;
  v51 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v51 = (const char *)(__strrchr_chk() + 1);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v51,
    99LL,
    (__int64)"Suntory_ConvertAllBlobs failed (%d) with error %d",
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    v59,
    3LL,
    v50);
  sleep(1u);
  v60 = Suntory_ConvertAllBlobs();
  if ( !v60 )
  {
LABEL_49:
    property_set();
LABEL_29:
    sub_3CA6C();
    v82 = v81;
    if ( !v81 )
      goto LABEL_50;
    v83 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v83 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v83,
      133LL,
      (__int64)"InitializeAndOpenSession failed (%d) with error %d",
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      1LL,
      v82);
    sleep(1u);
    sub_3CA6C();
    v93 = v92;
    if ( !v92 )
      goto LABEL_50;
    v94 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v94 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v94,
      133LL,
      (__int64)"InitializeAndOpenSession failed (%d) with error %d",
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102,
      2LL,
      v93);
    sleep(1u);
    sub_3CA6C();
    v104 = v103;
    if ( !v103 )
      goto LABEL_50;
    v105 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v105 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v105,
      133LL,
      (__int64)"InitializeAndOpenSession failed (%d) with error %d",
      v106,
      v107,
      v108,
      v109,
      v110,
      v111,
      v112,
      v113,
      3LL,
      v104);
    sleep(1u);
    sub_3CA6C();
    v115 = v114;
    if ( !v114 )
    {
LABEL_50:
      result = pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
      goto LABEL_46;
    }
    v116 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v116 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v116,
      133LL,
      (__int64)"InitializeAndOpenSession failed (%d) with error %d",
      v117,
      v118,
      v119,
      v120,
      v121,
      v122,
      v123,
      v124,
      4LL,
      v115);
    sleep(1u);
    v70 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v70 = (const char *)(__strrchr_chk() + 1);
    v79 = "No more tries for InitializeAndOpenSession";
    v80 = 140LL;
    goto LABEL_44;
  }
  v61 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v61 = (const char *)(__strrchr_chk() + 1);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v61,
    99LL,
    (__int64)"Suntory_ConvertAllBlobs failed (%d) with error %d",
    v62,
    v63,
    v64,
    v65,
    v66,
    v67,
    v68,
    v69,
    4LL,
    v60);
  sleep(1u);
  v70 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v70 = (const char *)(__strrchr_chk() + 1);
  v79 = "No more tries for Suntory_ConvertAllBlobs";
  v80 = 106LL;
LABEL_44:
  sub_379E4((__int64)"secd", 1, (__int64)v70, v80, (__int64)v79, v71, v72, v73, v74, v75, v76, v77, v78);
LABEL_5:
  pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
  v10 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v10 = (const char *)(__strrchr_chk() + 1);
  v11 = sub_379C4(7u);
  result = sub_379E4(
             (__int64)"secd",
             1,
             (__int64)v10,
             149LL,
             (__int64)"%s() ended. result %d - %s",
             v12,
             v13,
             v14,
             v15,
             v16,
             v17,
             v18,
             v19,
             "do_backend_credmgr_init",
             7LL,
             v11);
LABEL_46:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000003C170) ----------------------------------------------------
__int64 __fastcall sub_3C170(_DWORD *a1)
{
  *a1 = sub_3D558();
  return 0LL;
}

//----- (000000000003C198) ----------------------------------------------------
__int64 __fastcall sub_3C198(const char *a1, const char *a2, unsigned int a3, const char *a4, int a5, void **a6, unsigned int *a7)
{
  const char *v7; // x25
  unsigned int *v8; // x19
  void **v9; // x20
  int v10; // w21
  const char *v11; // x22
  unsigned int v12; // w23
  const char *v13; // x24
  unsigned int v14; // w0
  unsigned int v15; // w19
  const char *v16; // x20
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  const char *v25; // x20
  char *v26; // x0
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7

  v7 = a1;
  v8 = a7;
  v9 = a6;
  v10 = a5;
  v11 = a4;
  v12 = a3;
  v13 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_106DE8);
  sub_3CBCC(v11, v10, v7, v13, v12, v9, v8);
  v15 = v14;
  if ( v14 )
  {
    v16 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v16 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v16,
      190LL,
      (__int64)"GetCredential failed with error %d",
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v15);
    if ( v15 == 13 )
      v15 = 3;
    else
      v15 = 7;
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v25 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v25 = (const char *)(__strrchr_chk() + 1);
    v26 = sub_379C4(v15);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v25,
      204LL,
      (__int64)"%s() ended. result %d - %s",
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      "do_backend_credmgr_get_credential",
      v15,
      v26);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
  }
  return v15;
}

//----- (000000000003C30C) ----------------------------------------------------
__int64 __fastcall sub_3C30C(unsigned int a1, const char *a2, int a3, _QWORD *a4, __int64 a5)
{
  unsigned int v5; // w19
  __int64 v6; // x21
  _QWORD *v7; // x20
  int v8; // w22
  const char *v9; // x23
  unsigned int v10; // w19
  const char *v11; // x20
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  const char *v20; // x4
  __int64 v21; // x3
  unsigned int v22; // w19
  const char *v23; // x20
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  const char *v32; // x20
  char *v33; // x0
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_106DE8);
  if ( v5 == 1 )
  {
    v10 = sub_3D1FC(v9, v8, v6, v7);
    if ( v10 )
    {
      v11 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
      if ( __strrchr_chk() )
        v11 = (const char *)(__strrchr_chk() + 1);
      v20 = "GetKey failed with error %d";
      v21 = 244LL;
      goto LABEL_11;
    }
LABEL_18:
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    return 0;
  }
  if ( v5 )
  {
    v23 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v23 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v23,
      251LL,
      (__int64)"unsupported data type %d",
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v5);
    v22 = 9;
    goto LABEL_15;
  }
  v10 = sub_3D420((__int64)v9, v8, v6, v7);
  if ( !v10 )
    goto LABEL_18;
  v11 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v11 = (const char *)(__strrchr_chk() + 1);
  v20 = "GetCert failed with error %d";
  v21 = 231LL;
LABEL_11:
  sub_379E4((__int64)"secd", 1, (__int64)v11, v21, (__int64)v20, v12, v13, v14, v15, v16, v17, v18, v19, v10);
  v22 = 7;
LABEL_15:
  pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
  v32 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
  if ( __strrchr_chk() )
    v32 = (const char *)(__strrchr_chk() + 1);
  v33 = sub_379C4(v22);
  sub_379E4(
    (__int64)"secd",
    1,
    (__int64)v32,
    260LL,
    (__int64)"%s() ended. result %d - %s",
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    "do_backend_credmgr_get_data",
    v22,
    v33);
  return v22;
}

//----- (000000000003C534) ----------------------------------------------------
__int64 __fastcall sub_3C534(__int64 a1, int a2)
{
  __int64 v2; // x20
  int v3; // w19
  unsigned int v4; // w19
  const char *v5; // x20
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  const char *v14; // x19
  unsigned int v15; // w20
  char *v16; // x0
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7

  v2 = a1;
  v3 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_106DE8);
  v4 = sub_3CD30(v2, v3);
  if ( v4 )
  {
    v5 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v5 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v5,
      277LL,
      (__int64)"LoadBlob failed with error %d",
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v4);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v14 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v14 = (const char *)(__strrchr_chk() + 1);
    v15 = 7;
    v16 = sub_379C4(7u);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v14,
      284LL,
      (__int64)"%s() ended. result %d - %s",
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      "do_backend_credmgr_load_blob",
      7LL,
      v16);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v15 = 0;
  }
  return v15;
}

//----- (000000000003C660) ----------------------------------------------------
__int64 __fastcall sub_3C660(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // x21
  __int64 v4; // x19
  int v5; // w20
  unsigned int v6; // w19
  const char *v7; // x20
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  const char *v16; // x19
  unsigned int v17; // w20
  char *v18; // x0
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7

  v3 = a1;
  v4 = a3;
  v5 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_106DE8);
  v6 = sub_3CE50(v3, v5, v4);
  if ( v6 )
  {
    v7 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v7 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v7,
      302LL,
      (__int64)"GetBlobType failed with error %d",
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v6);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v16 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v16 = (const char *)(__strrchr_chk() + 1);
    v17 = 7;
    v18 = sub_379C4(7u);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v16,
      309LL,
      (__int64)"%s() ended. result %d - %s",
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      v26,
      "do_backend_credmgr_get_blob_type",
      7LL,
      v18);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v17 = 0;
  }
  return v17;
}

//----- (000000000003C79C) ----------------------------------------------------
__int64 __fastcall sub_3C79C(__int64 a1, int a2, __int64 a3, int a4, _QWORD *a5, int *a6)
{
  __int64 v6; // x24
  int *v7; // x19
  _QWORD *v8; // x20
  int v9; // w21
  __int64 v10; // x22
  int v11; // w23
  void *v12; // x0
  unsigned int v13; // w19
  const char *v14; // x20
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  const char *v23; // x19
  unsigned int v24; // w20
  char *v25; // x0
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_106DE8);
  *v7 = 256;
  v12 = malloc(0x100uLL);
  *v8 = v12;
  v13 = sub_3CF74(v6, v11, v10, v9, (__int64)v12, *v7);
  if ( v13 )
  {
    v14 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v14 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v14,
      334LL,
      (__int64)"Sign failed with error %d",
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      v13);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v23 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v23 = (const char *)(__strrchr_chk() + 1);
    v24 = 7;
    v25 = sub_379C4(7u);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v23,
      341LL,
      (__int64)"%s() ended. result %d - %s",
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      "do_backend_credmgr_get_sign_signature",
      7LL,
      v25);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v24 = 0;
  }
  return v24;
}

//----- (000000000003C910) ----------------------------------------------------
__int64 __fastcall sub_3C910(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6)
{
  __int64 v6; // x24
  int v7; // w19
  __int64 v8; // x20
  int v9; // w21
  __int64 v10; // x22
  int v11; // w23
  unsigned int v12; // w19
  const char *v13; // x20
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  const char *v22; // x19
  unsigned int v23; // w20
  char *v24; // x0
  double v25; // d0
  double v26; // d1
  double v27; // d2
  double v28; // d3
  double v29; // d4
  double v30; // d5
  double v31; // d6
  double v32; // d7

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  pthread_mutex_lock((pthread_mutex_t *)&unk_106DE8);
  v12 = sub_3D0B8(v6, v11, v10, v9, v8, v7);
  if ( v12 )
  {
    v13 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v13 = (const char *)(__strrchr_chk() + 1);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v13,
      363LL,
      (__int64)"Verify failed with error %d",
      v14,
      v15,
      v16,
      v17,
      v18,
      v19,
      v20,
      v21,
      v12);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v22 = "vendor/semc/system/core/libasb/security_daemon/daemon/secd_backend_credential_manager.cpp";
    if ( __strrchr_chk() )
      v22 = (const char *)(__strrchr_chk() + 1);
    v23 = 7;
    v24 = sub_379C4(7u);
    sub_379E4(
      (__int64)"secd",
      1,
      (__int64)v22,
      370LL,
      (__int64)"%s() ended. result %d - %s",
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      "do_backend_credmgr_verify_signature",
      7LL,
      v24);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_106DE8);
    v23 = 0;
  }
  return v23;
}

//----- (000000000003CA6C) ----------------------------------------------------
void sub_3CA6C()
{
  unsigned int v0; // w0
  unsigned int v1; // w19
  unsigned int v2; // w0
  int *v3; // x0
  __int64 v4; // x2
  __int64 v5; // x7
  __int64 v6; // [xsp+0h] [xbp-120h]
  char v7; // [xsp+8h] [xbp-118h]
  __int64 v8; // [xsp+108h] [xbp-18h]

  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  sub_405A0();
  v1 = v0;
  if ( v0 || (sub_410C8(&qword_106E10), (v1 = v2) != 0) )
  {
    memset(&v7, 0, 0xFFuLL);
    v3 = sub_3E02C(v1);
    sub_3CB24(
      (__int64)&v7,
      (__int64)v3,
      v4,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"InitializeAndOpenSession",
      v1,
      (__int64)v3,
      v5,
      v6);
    sub_3E16C();
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 106E10: using guessed type __int64 qword_106E10;

//----- (000000000003CB24) ----------------------------------------------------
__int64 __fastcall sub_3CB24(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  unsigned __int64 v9; // x19
  __int64 v10; // ST08_8
  __int64 result; // x0
  __int64 v12; // [xsp+90h] [xbp-80h]
  __int64 v13; // [xsp+98h] [xbp-78h]
  __int64 v14; // [xsp+A0h] [xbp-70h]
  __int64 v15; // [xsp+A8h] [xbp-68h]
  __int128 v16; // [xsp+B0h] [xbp-60h]
  __int128 v17; // [xsp+C0h] [xbp-50h]
  __int64 *v18; // [xsp+D8h] [xbp-38h]
  __int128 *v19; // [xsp+E0h] [xbp-30h]
  __int64 *v20; // [xsp+E8h] [xbp-28h]
  int v21; // [xsp+F0h] [xbp-20h]
  int v22; // [xsp+F4h] [xbp-1Ch]

  v14 = a7;
  v15 = a8;
  v12 = a5;
  v13 = a6;
  v9 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = *(_QWORD *)(v9 + 40);
  v21 = -32;
  v22 = -128;
  v19 = &v16;
  v20 = &v12;
  v18 = &a9;
  v16 = *(_OWORD *)&v18;
  v17 = *(_OWORD *)&v20;
  result = __vsnprintf_chk();
  *(_QWORD *)(v9 + 40);
  return result;
}

//----- (000000000003CBCC) ----------------------------------------------------
void __fastcall sub_3CBCC(const char *a1, int a2, const char *a3, const char *a4, unsigned int a5, void **a6, unsigned int *a7)
{
  unsigned int *v7; // x23
  void **v8; // x24
  unsigned int v9; // w20
  const char *v10; // x25
  const char *v11; // x26
  int v12; // w21
  const char *v13; // x22
  unsigned int v14; // w19
  __int64 v15; // ST18_8
  const char *v16; // x5
  unsigned int v17; // w0
  int *v18; // x0
  __int64 v19; // x2
  __int64 v20; // x7
  __int64 v21; // [xsp+0h] [xbp-180h]
  int v22; // [xsp+24h] [xbp-15Ch]
  char v23; // [xsp+28h] [xbp-158h]

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  v14 = 3;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v22 = 0;
  if ( !a1
    || !a2
    || !a3
    || !a4
    || !a5
    || !a6
    || (v14 = 3, !a7)
    || *a6
    || (v14 = sub_3D70C((__int64)&v22)) != 0
    || (v22 != 1 ? (v16 = v11) : (v16 = v10),
        LODWORD(v21) = 5,
        sub_4117C(qword_106E10, v13, v12, (__int64)"1000", 4, v16, v9, (__int64)"dummy", v21, v8, v7),
        (v14 = v17) != 0) )
  {
    memset(&v23, 0, 0xFFuLL);
    v18 = sub_3E02C(v14);
    sub_3CB24(
      (__int64)&v23,
      (__int64)v18,
      v19,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"GetCredential",
      v14,
      (__int64)v18,
      v20,
      v21);
    sub_3E16C();
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 106E10: using guessed type __int64 qword_106E10;

//----- (000000000003CD30) ----------------------------------------------------
__int64 __fastcall sub_3CD30(__int64 a1, int a2)
{
  __int64 result; // x0
  unsigned int v3; // w19
  __int64 v4; // x1
  __int64 v5; // x2
  __int64 v6; // x5
  __int64 v7; // x6
  __int64 v8; // x7
  int *v9; // x0
  __int64 v10; // x2
  __int64 v11; // x7
  __int64 v12; // [xsp+0h] [xbp-120h]
  char v13; // [xsp+8h] [xbp-118h]
  __int64 v14; // [xsp+108h] [xbp-18h]

  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 || (unsigned int)(a2 - 1) >> 4 >= 0xC35 )
  {
    memset(&v13, 0, 0xFFuLL);
    sub_3CB24((__int64)&v13, v4, v5, (__int64)"%s", (__int64)"LoadBlob: invalid input", v6, v7, v8, v12);
    sub_3E16C();
    v3 = 3;
    goto LABEL_8;
  }
  result = SuntoryTee_LoadBlob();
  if ( (_DWORD)result != 0 && (unsigned int)result < 0xFFFFFFFA )
  {
    v3 = 1;
    goto LABEL_8;
  }
  if ( (_DWORD)result )
  {
    v3 = dword_C1DC0[(signed int)result + 6];
LABEL_8:
    memset(&v13, 0, 0xFFuLL);
    v9 = sub_3E02C(v3);
    sub_3CB24(
      (__int64)&v13,
      (__int64)v9,
      v10,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"LoadBlob",
      v3,
      (__int64)v9,
      v11,
      v12);
    result = sub_3E16C();
    goto LABEL_9;
  }
  v3 = 0;
LABEL_9:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v14 )
    result = v3;
  return result;
}

//----- (000000000003CE50) ----------------------------------------------------
__int64 __fastcall sub_3CE50(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // x0
  unsigned int v4; // w19
  __int64 v5; // x1
  __int64 v6; // x2
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  int *v10; // x0
  __int64 v11; // x2
  __int64 v12; // x7
  __int64 v13; // [xsp+0h] [xbp-120h]
  char v14; // [xsp+8h] [xbp-118h]
  __int64 v15; // [xsp+108h] [xbp-18h]

  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a2 - 1) >> 4 > 0xC34 || !a1 || !a3 )
  {
    memset(&v14, 0, 0xFFuLL);
    sub_3CB24((__int64)&v14, v5, v6, (__int64)"%s", (__int64)"GetBlobType: invalid input", v7, v8, v9, v13);
    sub_3E16C();
    v4 = 3;
    goto LABEL_9;
  }
  result = Suntory_GetBlobType();
  if ( (_DWORD)result != 0 && (unsigned int)result < 0xFFFFFFFA )
  {
    v4 = 1;
    goto LABEL_9;
  }
  if ( (_DWORD)result )
  {
    v4 = dword_C1DC0[(signed int)result + 6];
LABEL_9:
    memset(&v14, 0, 0xFFuLL);
    v10 = sub_3E02C(v4);
    sub_3CB24(
      (__int64)&v14,
      (__int64)v10,
      v11,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"GetBlobType",
      v4,
      (__int64)v10,
      v12,
      v13);
    result = sub_3E16C();
    goto LABEL_10;
  }
  v4 = 0;
LABEL_10:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v15 )
    result = v4;
  return result;
}

//----- (000000000003CF74) ----------------------------------------------------
__int64 __fastcall sub_3CF74(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6)
{
  __int64 result; // x0
  unsigned int v7; // w19
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x5
  __int64 v11; // x6
  __int64 v12; // x7
  int *v13; // x0
  __int64 v14; // x2
  __int64 v15; // x7
  __int64 v16; // [xsp+0h] [xbp-120h]
  char v17; // [xsp+8h] [xbp-118h]
  __int64 v18; // [xsp+108h] [xbp-18h]

  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a6 - 1) >> 4 > 0x270
    || !a5
    || (unsigned int)(a4 - 1) >> 4 > 0x270
    || !a3
    || !a1
    || (unsigned int)(a2 - 1) >= 0x20 )
  {
    memset(&v17, 0, 0xFFuLL);
    sub_3CB24((__int64)&v17, v8, v9, (__int64)"%s", (__int64)"SignInit: invalid input", v10, v11, v12, v16);
    sub_3E16C();
    v7 = 3;
    goto LABEL_12;
  }
  result = SuntoryTee_Sign();
  if ( (_DWORD)result != 0 && (unsigned int)result < 0xFFFFFFFA )
  {
    v7 = 1;
    goto LABEL_12;
  }
  if ( (_DWORD)result )
  {
    v7 = dword_C1DC0[(signed int)result + 6];
LABEL_12:
    memset(&v17, 0, 0xFFuLL);
    v13 = sub_3E02C(v7);
    sub_3CB24(
      (__int64)&v17,
      (__int64)v13,
      v14,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"Sign",
      v7,
      (__int64)v13,
      v15,
      v16);
    result = sub_3E16C();
    goto LABEL_13;
  }
  v7 = 0;
LABEL_13:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v18 )
    result = v7;
  return result;
}

//----- (000000000003D0B8) ----------------------------------------------------
__int64 __fastcall sub_3D0B8(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6)
{
  __int64 result; // x0
  unsigned int v7; // w19
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x5
  __int64 v11; // x6
  __int64 v12; // x7
  int *v13; // x0
  __int64 v14; // x2
  __int64 v15; // x7
  __int64 v16; // [xsp+0h] [xbp-120h]
  char v17; // [xsp+8h] [xbp-118h]
  __int64 v18; // [xsp+108h] [xbp-18h]

  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a6 - 1) >> 4 > 0x270
    || !a5
    || (unsigned int)(a4 - 1) >> 4 > 0x270
    || !a3
    || !a1
    || (unsigned int)(a2 - 1) >= 0x20 )
  {
    memset(&v17, 0, 0xFFuLL);
    sub_3CB24((__int64)&v17, v8, v9, (__int64)"%s", (__int64)"VerifyInit: invalid input", v10, v11, v12, v16);
    sub_3E16C();
    v7 = 3;
    goto LABEL_12;
  }
  result = SuntoryTee_Verify();
  if ( (_DWORD)result != 0 && (unsigned int)result < 0xFFFFFFFA )
  {
    v7 = 1;
    goto LABEL_12;
  }
  if ( (_DWORD)result )
  {
    v7 = dword_C1DC0[(signed int)result + 6];
LABEL_12:
    memset(&v17, 0, 0xFFuLL);
    v13 = sub_3E02C(v7);
    sub_3CB24(
      (__int64)&v17,
      (__int64)v13,
      v14,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"Verify",
      v7,
      (__int64)v13,
      v15,
      v16);
    result = sub_3E16C();
    goto LABEL_13;
  }
  v7 = 0;
LABEL_13:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v18 )
    result = v7;
  return result;
}

//----- (000000000003D1FC) ----------------------------------------------------
__int64 __fastcall sub_3D1FC(const char *a1, int a2, __int64 a3, _QWORD *a4)
{
  const char *v4; // x22
  __int64 v5; // x1
  __int64 v6; // x2
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  unsigned int v10; // w19
  int *v11; // x0
  __int64 v12; // x2
  __int64 v13; // x7
  __int64 result; // x0
  const char *v15; // x23
  size_t v16; // x0
  const char *v17; // x23
  size_t v18; // x0
  const char *v19; // x23
  size_t v20; // x0
  const char *v21; // x23
  size_t v22; // x0
  const char *v23; // x23
  size_t v24; // x0
  __int64 v25; // [xsp+0h] [xbp-150h]
  char v26; // [xsp+8h] [xbp-148h]
  __int64 v27; // [xsp+108h] [xbp-48h]

  v4 = a1;
  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a4 )
    goto LABEL_22;
  if ( !a3 )
    goto LABEL_22;
  if ( !a1 )
    goto LABEL_22;
  if ( (unsigned int)(a2 - 1) > 0x1F )
    goto LABEL_22;
  if ( *a4 )
    goto LABEL_22;
  v15 = off_1060A0[0];
  v16 = strnlen(off_1060A0[0], 0x20uLL);
  if ( (unsigned int)strncmp(v15, v4, v16) )
  {
    v17 = off_1060A8[0];
    v18 = strnlen(off_1060A8[0], 0x20uLL);
    if ( (unsigned int)strncmp(v17, v4, v18) )
    {
      v19 = off_1060B0[0];
      v20 = strnlen(off_1060B0[0], 0x20uLL);
      if ( (unsigned int)strncmp(v19, v4, v20) )
      {
        v21 = off_1060B8[0];
        v22 = strnlen(off_1060B8[0], 0x20uLL);
        if ( (unsigned int)strncmp(v21, v4, v22) )
        {
          v23 = off_1060C0;
          v24 = strnlen(off_1060C0, 0x20uLL);
          if ( (unsigned int)strncmp(v23, v4, v24) )
          {
LABEL_22:
            memset(&v26, 0, 0xFFuLL);
            sub_3CB24((__int64)&v26, v5, v6, (__int64)"%s", (__int64)"GetKey: invalid input", v7, v8, v9, v25);
            sub_3E16C();
            v10 = 3;
LABEL_7:
            memset(&v26, 0, 0xFFuLL);
            v11 = sub_3E02C(v10);
            sub_3CB24(
              (__int64)&v26,
              (__int64)v11,
              v12,
              (__int64)"%s() ended. result %d - %s",
              (__int64)"GetKey",
              v10,
              (__int64)v11,
              v13,
              v25);
            result = sub_3E16C();
            goto LABEL_8;
          }
        }
      }
    }
  }
  result = SuntoryTee_GetKey();
  if ( (_DWORD)result != 0 && (unsigned int)result < 0xFFFFFFFA )
  {
    v10 = 1;
    goto LABEL_7;
  }
  if ( (_DWORD)result )
  {
    v10 = dword_C1DC0[(signed int)result + 6];
    goto LABEL_7;
  }
  v10 = 0;
LABEL_8:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v27 )
    result = v10;
  return result;
}
// 1060A0: using guessed type char *off_1060A0[5];
// 1060A8: using guessed type char *off_1060A8[4];
// 1060B0: using guessed type char *off_1060B0[3];
// 1060B8: using guessed type char *off_1060B8[2];
// 1060C0: using guessed type char *off_1060C0;

//----- (000000000003D420) ----------------------------------------------------
__int64 __fastcall sub_3D420(__int64 a1, int a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // x1
  __int64 v5; // x2
  __int64 v6; // x5
  __int64 v7; // x6
  __int64 v8; // x7
  unsigned int v9; // w19
  int *v10; // x0
  __int64 v11; // x2
  __int64 v12; // x7
  __int64 result; // x0
  __int64 v14; // [xsp+0h] [xbp-120h]
  char v15; // [xsp+8h] [xbp-118h]
  __int64 v16; // [xsp+108h] [xbp-18h]

  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a4 || !a3 || !a1 || (unsigned int)(a2 - 1) > 0x1F || *a4 )
  {
    memset(&v15, 0, 0xFFuLL);
    sub_3CB24((__int64)&v15, v4, v5, (__int64)"%s", (__int64)"GetCert: invalid input", v6, v7, v8, v14);
    sub_3E16C();
    v9 = 3;
LABEL_7:
    memset(&v15, 0, 0xFFuLL);
    v10 = sub_3E02C(v9);
    sub_3CB24(
      (__int64)&v15,
      (__int64)v10,
      v11,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"GetCert",
      v9,
      (__int64)v10,
      v12,
      v14);
    result = sub_3E16C();
    goto LABEL_8;
  }
  result = SuntoryTee_GetCert();
  if ( (_DWORD)result != 0 && (unsigned int)result < 0xFFFFFFFA )
  {
    v9 = 1;
    goto LABEL_7;
  }
  if ( (_DWORD)result )
  {
    v9 = dword_C1DC0[(signed int)result + 6];
    goto LABEL_7;
  }
  v9 = 0;
LABEL_8:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v16 )
    result = v9;
  return result;
}

//----- (000000000003D558) ----------------------------------------------------
signed __int64 sub_3D558()
{
  return 222LL;
}

//----- (000000000003D560) ----------------------------------------------------
__int64 __fastcall sub_3D560(__int64 result)
{
  _DWORD *v1; // x20
  unsigned int v2; // w19
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  unsigned int v8; // w19
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x5
  __int64 v12; // x6
  __int64 v13; // x7
  int *v14; // x0
  __int64 v15; // x2
  __int64 v16; // x7
  signed int v17; // w8
  __int64 v18; // [xsp+0h] [xbp-150h]
  __int64 v19; // [xsp+0h] [xbp-150h]
  __int64 v20; // [xsp+8h] [xbp-148h]
  int v21; // [xsp+14h] [xbp-13Ch]
  char v22; // [xsp+18h] [xbp-138h]

  v1 = (_DWORD *)result;
  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !result )
  {
    memset(&v22, 0, 0xFFuLL);
    sub_3CB24((__int64)&v22, v3, v4, (__int64)"param %s is NULL", (__int64)"pStatus", v5, v6, v7, v18);
    sub_3E16C();
    v2 = 3;
LABEL_7:
    memset(&v22, 0, 0xFFuLL);
    v14 = sub_3E02C(v2);
    sub_3CB24(
      (__int64)&v22,
      (__int64)v14,
      v15,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_GetRootingStatus",
      v2,
      (__int64)v14,
      v16,
      v19);
    result = sub_3E16C();
    goto LABEL_8;
  }
  if ( byte_106E18 == 1 )
  {
    v2 = 0;
    *(_DWORD *)result = dword_106E1C;
    goto LABEL_8;
  }
  v21 = 2;
  result = sub_364A4(&v21);
  v8 = result;
  if ( (_DWORD)result )
  {
    memset(&v22, 0, 0xFFuLL);
    sub_3CB24(
      (__int64)&v22,
      v9,
      v10,
      (__int64)"do_backend_devsec_get_rooting_status failed, result %d",
      v8,
      v11,
      v12,
      v13,
      v18);
    sub_3E16C();
    v2 = 5;
    goto LABEL_7;
  }
  *v1 = 0;
  v17 = 0;
  if ( v21 != 2 && v21 != 5 )
  {
    v17 = 1;
    *v1 = 1;
  }
  v2 = 0;
  byte_106E18 = 1;
  dword_106E1C = v17;
LABEL_8:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v20 )
    result = v2;
  return result;
}
// 106E18: using guessed type char byte_106E18;
// 106E1C: using guessed type int dword_106E1C;

//----- (000000000003D70C) ----------------------------------------------------
__int64 __fastcall sub_3D70C(__int64 result)
{
  _DWORD *v1; // x20
  unsigned int v2; // w19
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  unsigned int v8; // w19
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x5
  __int64 v12; // x6
  __int64 v13; // x7
  const char *v14; // x3
  int *v15; // x0
  __int64 v16; // x2
  __int64 v17; // x7
  signed int v18; // w8
  __int64 v19; // [xsp+0h] [xbp-150h]
  __int64 v20; // [xsp+0h] [xbp-150h]
  __int64 v21; // [xsp+8h] [xbp-148h]
  unsigned int v22; // [xsp+14h] [xbp-13Ch]
  char v23; // [xsp+18h] [xbp-138h]

  v1 = (_DWORD *)result;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !result )
  {
    memset(&v23, 0, 0xFFuLL);
    sub_3CB24((__int64)&v23, v3, v4, (__int64)"param %s is NULL", (__int64)"pMode", v5, v6, v7, v19);
    sub_3E16C();
    v2 = 3;
LABEL_8:
    memset(&v23, 0, 0xFFuLL);
    v15 = sub_3E02C(v2);
    sub_3CB24(
      (__int64)&v23,
      (__int64)v15,
      v16,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_GetSecureMode",
      v2,
      (__int64)v15,
      v17,
      v20);
    result = sub_3E16C();
    goto LABEL_9;
  }
  if ( byte_106E20 == 1 )
  {
    v2 = 0;
    *(_DWORD *)result = dword_106E24;
    goto LABEL_9;
  }
  v22 = 0;
  result = sub_36400(&v22);
  v8 = result;
  if ( (_DWORD)result )
  {
    memset(&v23, 0, 0xFFuLL);
    v14 = "do_backend_devsec_get_security_config failed, result %d";
LABEL_7:
    sub_3CB24((__int64)&v23, v9, v10, (__int64)v14, v8, v11, v12, v13, v19);
    sub_3E16C();
    v2 = 5;
    goto LABEL_8;
  }
  v8 = v22;
  if ( v22 == 1 )
  {
    v18 = 0;
  }
  else
  {
    if ( v22 )
    {
      memset(&v23, 0, 0xFFuLL);
      v14 = "unknown mode from devsec_get_security_config: %d";
      goto LABEL_7;
    }
    v18 = 1;
  }
  v2 = 0;
  *v1 = v18;
  byte_106E20 = 1;
  dword_106E24 = v18;
LABEL_9:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v21 )
    result = v2;
  return result;
}
// 106E20: using guessed type char byte_106E20;
// 106E24: using guessed type int dword_106E24;

//----- (000000000003D8CC) ----------------------------------------------------
__int64 __fastcall sub_3D8CC(__int64 a1, __int64 a2, int a3)
{
  int v3; // w21
  signed int v4; // w8
  __int64 v5; // x1
  __int64 v6; // x2
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  const char *v10; // x4
  bool v11; // zf
  unsigned int v12; // w21
  __int64 result; // x0
  __int64 v14; // x1
  __int64 v15; // x2
  __int64 v16; // x5
  __int64 v17; // x6
  __int64 v18; // x7
  int *v19; // x0
  __int64 v20; // x2
  __int64 v21; // x7
  __int64 v22; // [xsp+0h] [xbp-130h]
  char v23; // [xsp+8h] [xbp-128h]
  __int64 v24; // [xsp+108h] [xbp-28h]

  v3 = a3;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    if ( a2 )
    {
      v4 = 0;
      goto LABEL_7;
    }
    memset(&v23, 0, 0xFFuLL);
    v10 = "keyLength";
  }
  else
  {
    memset(&v23, 0, 0xFFuLL);
    v10 = "pKey";
  }
  sub_3CB24((__int64)&v23, v5, v6, (__int64)"param %s is NULL", (__int64)v10, v7, v8, v9, v22);
  sub_3E16C();
  v4 = 3;
LABEL_7:
  if ( v4 )
    v11 = 1;
  else
    v11 = v3 == 1;
  if ( v11 )
    v12 = v4;
  else
    v12 = 3;
  if ( v12 )
    goto LABEL_16;
  strnlen("CREDENTIAL_DB", 0x20uLL);
  result = SuntoryTee_GetKey();
  if ( (_DWORD)result )
  {
    memset(&v23, 0, 0xFFuLL);
    sub_3CB24((__int64)&v23, v14, v15, (__int64)"%s", (__int64)"SuntoryTee_GetKey failed", v16, v17, v18, v22);
    sub_3E16C();
    v12 = 5;
LABEL_16:
    memset(&v23, 0, 0xFFuLL);
    v19 = sub_3E02C(v12);
    sub_3CB24(
      (__int64)&v23,
      (__int64)v19,
      v20,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_GetEncKey",
      v12,
      (__int64)v19,
      v21,
      v22);
    result = sub_3E16C();
    goto LABEL_17;
  }
  v12 = 0;
LABEL_17:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v24 )
    result = v12;
  return result;
}

//----- (000000000003DA74) ----------------------------------------------------
__int64 __fastcall sub_3DA74(__int64 *a1)
{
  __int64 *v1; // x20
  __int64 result; // x0
  unsigned int v3; // w19
  _DWORD *v4; // x8
  __int64 v5; // x13
  __int128 v6; // q0
  int *v7; // x0
  __int64 v8; // x2
  __int64 v9; // x7
  __int64 v10; // [xsp+0h] [xbp-140h]
  __int64 v11; // [xsp+8h] [xbp-138h]
  char v12; // [xsp+14h] [xbp-12Ch]
  char v13; // [xsp+18h] [xbp-128h]

  v1 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v12 = 1;
  if ( !a1 || !*a1 )
  {
    v3 = 3;
    goto LABEL_9;
  }
  result = sub_3DB88((__int64)&v12);
  v3 = result;
  if ( (_DWORD)result )
  {
LABEL_9:
    memset(&v13, 0, 0xFFuLL);
    v7 = sub_3E02C(v3);
    sub_3CB24(
      (__int64)&v13,
      (__int64)v7,
      v8,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_GetBlobSignature",
      v3,
      (__int64)v7,
      v9,
      v10);
    result = sub_3E16C();
    goto LABEL_10;
  }
  if ( v12 == 1 )
    v4 = &unk_CFCC7;
  else
    v4 = &unk_C8D4A;
  v5 = *v1;
  v6 = *(_OWORD *)v4;
  *(_DWORD *)(v5 + 16) = v4[4];
  *(_OWORD *)v5 = v6;
LABEL_10:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v11 )
    result = v3;
  return result;
}

//----- (000000000003DB88) ----------------------------------------------------
__int64 __fastcall sub_3DB88(__int64 result)
{
  char *v1; // x20
  unsigned int v2; // w19
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x5
  __int64 v11; // x6
  __int64 v12; // x7
  int *v13; // x0
  __int64 v14; // x2
  __int64 v15; // x7
  __int64 v16; // [xsp+0h] [xbp-150h]
  __int64 v17; // [xsp+0h] [xbp-150h]
  __int64 v18; // [xsp+8h] [xbp-148h]
  int v19; // [xsp+14h] [xbp-13Ch]
  char v20; // [xsp+18h] [xbp-138h]

  v1 = (char *)result;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !result )
  {
    memset(&v20, 0, 0xFFuLL);
    sub_3CB24((__int64)&v20, v3, v4, (__int64)"param %s is NULL", (__int64)"pCommercial", v5, v6, v7, v16);
    sub_3E16C();
    v2 = 3;
LABEL_7:
    memset(&v20, 0, 0xFFuLL);
    v13 = sub_3E02C(v2);
    sub_3CB24(
      (__int64)&v20,
      (__int64)v13,
      v14,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_GetCommercialStatus",
      v2,
      (__int64)v13,
      v15,
      v17);
    result = sub_3E16C();
    goto LABEL_8;
  }
  if ( byte_106E28 == 1 )
  {
    v2 = 0;
    *(_BYTE *)result = byte_1060C8;
    goto LABEL_8;
  }
  v19 = 0;
  result = sub_36824(&v19);
  v2 = result;
  if ( (_DWORD)result )
  {
    memset(&v20, 0, 0xFFuLL);
    sub_3CB24(
      (__int64)&v20,
      v8,
      v9,
      (__int64)"do_backend_devsec_get_ckb_status failed, result %d",
      v2,
      v10,
      v11,
      v12,
      v16);
    sub_3E16C();
    v2 = 5;
    goto LABEL_7;
  }
  *v1 = v19 != 1;
  byte_106E28 = 1;
  byte_1060C8 = *v1;
LABEL_8:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v18 )
    result = v2;
  return result;
}
// 1060C8: using guessed type char byte_1060C8;
// 106E28: using guessed type char byte_106E28;

//----- (000000000003DD1C) ----------------------------------------------------
__int64 sub_3DD1C()
{
  unsigned int v0; // w19
  int *v1; // x0
  __int64 v2; // x2
  __int64 v3; // x7
  __int64 result; // x0
  int *v5; // x0
  __int64 v6; // x2
  __int64 v7; // x7
  __int64 v8; // [xsp+0h] [xbp-150h]
  __int64 v9; // [xsp+8h] [xbp-148h]
  char v10; // [xsp+14h] [xbp-13Ch]
  int v11; // [xsp+18h] [xbp-138h]

  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = 1;
  v0 = sub_3DB88((__int64)&v10);
  if ( v0 )
  {
    memset(&v11, 0, 0xFFuLL);
    v1 = sub_3E02C(v0);
    sub_3CB24(
      (__int64)&v11,
      (__int64)v1,
      v2,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_GetBlob",
      v0,
      (__int64)v1,
      v3,
      v8);
    sub_3E16C();
LABEL_5:
    memset(&v11, 0, 0xFFuLL);
    v5 = sub_3E02C(v0);
    sub_3CB24(
      (__int64)&v11,
      (__int64)v5,
      v6,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DAL_GetCredential",
      v0,
      (__int64)v5,
      v7,
      v8);
    result = sub_3E16C();
    goto LABEL_6;
  }
  v11 = 0;
  result = SuntoryTee_GetCredential();
  if ( (_DWORD)result )
  {
    v0 = 5;
    goto LABEL_5;
  }
  v0 = 0;
LABEL_6:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v9 )
    result = v0;
  return result;
}

//----- (000000000003DE88) ----------------------------------------------------
__int64 __fastcall sub_3DE88(void **a1, _DWORD *a2)
{
  void **v2; // x21
  _DWORD *v3; // x20
  unsigned int v4; // w19
  int *v5; // x0
  __int64 v6; // x2
  __int64 v7; // x7
  int *v8; // x0
  __int64 v9; // x2
  __int64 v10; // x7
  __int64 result; // x0
  __int64 v12; // [xsp+0h] [xbp-150h]
  __int64 v13; // [xsp+8h] [xbp-148h]
  char v14; // [xsp+14h] [xbp-13Ch]
  char v15; // [xsp+18h] [xbp-138h]

  v2 = a1;
  v3 = a2;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v14 = 1;
  v4 = sub_3DB88((__int64)&v14);
  if ( v4 )
  {
    memset(&v15, 0, 0xFFuLL);
    v5 = sub_3E02C(v4);
    sub_3CB24(
      (__int64)&v15,
      (__int64)v5,
      v6,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_GetBlob",
      v4,
      (__int64)v5,
      v7,
      v12);
    sub_3E16C();
LABEL_5:
    memset(&v15, 0, 0xFFuLL);
    v8 = sub_3E02C(v4);
    sub_3CB24(
      (__int64)&v15,
      (__int64)v8,
      v9,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DAL_GetAllCredentialData",
      v4,
      (__int64)v8,
      v10,
      v12);
    result = sub_3E16C();
    goto LABEL_6;
  }
  *v3 = 0;
  if ( (unsigned int)SuntoryTee_GetAllCredentialData() )
    goto LABEL_14;
  *v2 = malloc((unsigned int)*v3);
  if ( !v2 )
  {
    v4 = 2;
    goto LABEL_5;
  }
  result = SuntoryTee_GetAllCredentialData();
  if ( (_DWORD)result )
  {
LABEL_14:
    v4 = 5;
    goto LABEL_5;
  }
  v4 = 0;
LABEL_6:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v13 )
    result = v4;
  return result;
}

//----- (000000000003E02C) ----------------------------------------------------
int *__fastcall sub_3E02C(int a1)
{
  signed __int64 v1; // x8

  if ( dword_1060CC[0] == a1 )
  {
    v1 = 0LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106110 == a1 )
  {
    v1 = 1LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106154 == a1 )
  {
    v1 = 2LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106198 == a1 )
  {
    v1 = 3LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_1061DC == a1 )
  {
    v1 = 4LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106220 == a1 )
  {
    v1 = 5LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106264 == a1 )
  {
    v1 = 6LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_1062A8 == a1 )
  {
    v1 = 7LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_1062EC == a1 )
  {
    v1 = 8LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106330 == a1 )
  {
    v1 = 9LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106374 == a1 )
  {
    v1 = 10LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_1063B8 == a1 )
  {
    v1 = 11LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_1063FC == a1 )
  {
    v1 = 12LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  if ( dword_106440 == a1 )
  {
    v1 = 13LL;
    return &dword_1060CC[17 * v1 + 1];
  }
  return 0LL;
}
// C8: using guessed type __int64;
// 150: using guessed type __int64;
// 1D8: using guessed type __int64;
// 258: using guessed type __int64[6];
// 2A0: using guessed type Elf64_Sym stru_2A0;
// 2E8: using guessed type Elf64_Sym stru_2E8;
// 360: using guessed type Elf64_Sym;
// 1060CC: using guessed type int dword_1060CC[];
// 106110: using guessed type int dword_106110;
// 106154: using guessed type int dword_106154;
// 106198: using guessed type int dword_106198;
// 1061DC: using guessed type int dword_1061DC;
// 106220: using guessed type int dword_106220;
// 106264: using guessed type int dword_106264;
// 1062A8: using guessed type int dword_1062A8;
// 1062EC: using guessed type int dword_1062EC;
// 106330: using guessed type int dword_106330;
// 106374: using guessed type int dword_106374;
// 1063B8: using guessed type int dword_1063B8;
// 1063FC: using guessed type int dword_1063FC;
// 106440: using guessed type int dword_106440;

//----- (000000000003E16C) ----------------------------------------------------
__int64 sub_3E16C()
{
  return __android_log_write();
}

//----- (000000000003E18C) ----------------------------------------------------
__int64 sub_3E18C()
{
  unsigned int v0; // w19
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x5
  __int64 v4; // x6
  __int64 v5; // x7
  unsigned int v6; // w19
  unsigned int v7; // w19
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x6
  __int64 v11; // x7
  const char *v12; // x3
  unsigned int v13; // w0
  bool v14; // zf
  int *v15; // x0
  __int64 v16; // x2
  __int64 v17; // x7
  __int64 result; // x0
  int *v19; // x0
  char *v20; // x0
  __int64 v21; // x2
  __int64 v22; // x5
  __int64 v23; // x6
  __int64 v24; // x7
  __int64 v25; // [xsp+0h] [xbp-130h]
  char v26; // [xsp+18h] [xbp-118h]
  __int64 v27; // [xsp+118h] [xbp-18h]

  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v0 = sqlite3_open_v2();
  if ( v0 )
  {
    memset(&v26, 0, 0xFFuLL);
    sub_3CB24((__int64)&v26, v1, v2, (__int64)"sqlite3_open_v2 failed: %i", v0, v3, v4, v5, v25);
    sub_3E16C();
    v6 = 14;
    goto LABEL_9;
  }
  v7 = sqlite3_prepare_v2();
  if ( v7 )
  {
    memset(&v26, 0, 0xFFuLL);
    v8 = sqlite3_errmsg();
    v12 = "sqlite3_prepare_v2 failed: %i, %s";
  }
  else
  {
    v7 = sqlite3_step();
    if ( v7 == 101 )
    {
      v6 = 0;
      goto LABEL_9;
    }
    memset(&v26, 0, 0xFFuLL);
    v8 = sqlite3_errmsg();
    v12 = "sqlite3_step failed: %i, %s";
  }
  sub_3CB24((__int64)&v26, v8, v9, (__int64)v12, v7, v8, v10, v11, v25);
  v6 = 1;
  sub_3E16C();
LABEL_9:
  v13 = sub_3E3C8(0LL, 0LL, v6);
  if ( v13 )
    v14 = v6 == 0;
  else
    v14 = 0;
  if ( v14 )
    v6 = v13;
  if ( v6 )
    goto LABEL_15;
  result = chmod("/data/credmgr/credmgr.db", 0x1B0u);
  if ( result & 0x80000000 )
  {
    memset(&v26, 0, 0xFFuLL);
    v19 = (int *)__errno();
    v20 = strerror(*v19);
    sub_3CB24((__int64)&v26, (__int64)v20, v21, (__int64)"chmod failed: %s", (__int64)v20, v22, v23, v24, v25);
    sub_3E16C();
    v6 = 14;
LABEL_15:
    memset(&v26, 0, 0xFFuLL);
    v15 = sub_3E02C(v6);
    sub_3CB24(
      (__int64)&v26,
      (__int64)v15,
      v16,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DbCreate",
      v6,
      (__int64)v15,
      v17,
      v25);
    result = sub_3E16C();
    goto LABEL_18;
  }
  v6 = 0;
LABEL_18:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v27 )
    result = v6;
  return result;
}

//----- (000000000003E3C8) ----------------------------------------------------
__int64 __fastcall sub_3E3C8(__int64 result, __int64 a2, unsigned int a3)
{
  unsigned int v3; // w19
  __int64 v4; // x20
  unsigned int v5; // w21
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x5
  __int64 v9; // x6
  __int64 v10; // x7
  unsigned int v11; // w20
  __int64 v12; // x1
  __int64 v13; // x2
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  int *v17; // x0
  __int64 v18; // x2
  __int64 v19; // x7
  __int64 v20; // [xsp+0h] [xbp-130h]
  char v21; // [xsp+8h] [xbp-128h]
  __int64 v22; // [xsp+108h] [xbp-28h]

  v3 = a3;
  v4 = result;
  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 )
  {
    result = sqlite3_finalize();
    v5 = result;
    if ( !v3 )
    {
      if ( (_DWORD)result )
      {
        memset(&v21, 0, 0xFFuLL);
        sub_3CB24((__int64)&v21, v6, v7, (__int64)"sqlite3_finalize failed: %i", v5, v8, v9, v10, v20);
        v3 = 1;
        result = sub_3E16C();
      }
    }
  }
  if ( v4 && (result = sqlite3_close(), v11 = result, !v3) && (_DWORD)result )
  {
    memset(&v21, 0, 0xFFuLL);
    sub_3CB24((__int64)&v21, v12, v13, (__int64)"sqlite3_close failed: %i", v11, v14, v15, v16, v20);
    v3 = 1;
    sub_3E16C();
  }
  else if ( !v3 )
  {
    goto LABEL_11;
  }
  memset(&v21, 0, 0xFFuLL);
  v17 = sub_3E02C(v3);
  sub_3CB24(
    (__int64)&v21,
    (__int64)v17,
    v18,
    (__int64)"%s() ended. result %d - %s",
    (__int64)"CredMgr_DbFinalizeAndClose",
    v3,
    (__int64)v17,
    v19,
    v20);
  result = sub_3E16C();
LABEL_11:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v22 )
    result = v3;
  return result;
}

//----- (000000000003E520) ----------------------------------------------------
__int64 __fastcall sub_3E520(_QWORD *a1)
{
  _QWORD *v1; // x20
  unsigned int v2; // w19
  __int64 v3; // x0
  __int64 v4; // x2
  __int64 v5; // x6
  __int64 v6; // x7
  __int64 v7; // x1
  __int64 v8; // x2
  __int64 v9; // x5
  __int64 v10; // x6
  __int64 v11; // x7
  unsigned int v12; // w19
  __int64 result; // x0
  __int64 v14; // x0
  __int64 v15; // x2
  __int64 v16; // x6
  __int64 v17; // x7
  int *v18; // x0
  __int64 v19; // x2
  __int64 v20; // x7
  __int64 v21; // [xsp+0h] [xbp-140h]
  __int64 v22; // [xsp+0h] [xbp-140h]
  char v23; // [xsp+18h] [xbp-128h]
  __int64 v24; // [xsp+118h] [xbp-28h]

  v1 = a1;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v2 = sqlite3_open_v2();
    if ( v2 )
    {
      memset(&v23, 0, 0xFFuLL);
      v3 = sqlite3_errmsg();
      sub_3CB24((__int64)&v23, v3, v4, (__int64)"sqlite3_open_v2 failed: %i, %s", v2, v3, v5, v6, v21);
      sub_3E16C();
    }
    else
    {
      *v1 = 0LL;
      result = sqlite3_exec();
      v12 = result;
      if ( !(_DWORD)result )
        goto LABEL_9;
      memset(&v23, 0, 0xFFuLL);
      v14 = sqlite3_errmsg();
      sub_3CB24((__int64)&v23, v14, v15, (__int64)"sqlite3_exec failed: %i, %s", v12, v14, v16, v17, v21);
      sub_3E16C();
      free(0LL);
    }
    v12 = 14;
  }
  else
  {
    memset(&v23, 0, 0xFFuLL);
    sub_3CB24((__int64)&v23, v7, v8, (__int64)"param %s is NULL", (__int64)"pDataBase", v9, v10, v11, v21);
    sub_3E16C();
    v12 = 3;
  }
  memset(&v23, 0, 0xFFuLL);
  v18 = sub_3E02C(v12);
  sub_3CB24(
    (__int64)&v23,
    (__int64)v18,
    v19,
    (__int64)"%s() ended. result %d - %s",
    (__int64)"CredMgr_DbOpen",
    v12,
    (__int64)v18,
    v20,
    v22);
  result = sub_3E16C();
LABEL_9:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v24 )
    result = v12;
  return result;
}

//----- (000000000003E6FC) ----------------------------------------------------
__int64 __fastcall sub_3E6FC(__int64 a1)
{
  unsigned int v1; // w20
  __int64 v2; // x0
  __int64 v3; // x2
  __int64 v4; // x6
  __int64 v5; // x7
  unsigned int v6; // w19
  __int64 v7; // x1
  __int64 v8; // x2
  __int64 v9; // x5
  __int64 v10; // x6
  __int64 v11; // x7
  __int64 result; // x0
  unsigned int v13; // w20
  __int64 v14; // x0
  __int64 v15; // x2
  __int64 v16; // x6
  __int64 v17; // x7
  int *v18; // x0
  __int64 v19; // x2
  __int64 v20; // x7
  __int64 v21; // [xsp+0h] [xbp-130h]
  void *v22; // [xsp+0h] [xbp-130h]
  char v23; // [xsp+8h] [xbp-128h]
  __int64 v24; // [xsp+108h] [xbp-28h]

  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
  {
    memset(&v23, 0, 0xFFuLL);
    sub_3CB24((__int64)&v23, v7, v8, (__int64)"param %s is NULL", (__int64)"pDataBase", v9, v10, v11, v21);
    sub_3E16C();
    v6 = 3;
    goto LABEL_7;
  }
  v1 = sqlite3_exec();
  if ( v1 )
  {
    memset(&v23, 0, 0xFFuLL);
    v2 = sqlite3_errmsg();
    sub_3CB24((__int64)&v23, v2, v3, (__int64)"sqlite3_exec failed: %i, %s", v1, v2, v4, v5, 0LL);
    v6 = 1;
    sub_3E16C();
    free(v22);
LABEL_7:
    memset(&v23, 0, 0xFFuLL);
    v18 = sub_3E02C(v6);
    sub_3CB24(
      (__int64)&v23,
      (__int64)v18,
      v19,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DbClose",
      v6,
      (__int64)v18,
      v20,
      (__int64)v22);
    result = sub_3E16C();
    goto LABEL_8;
  }
  result = sqlite3_close();
  v13 = result;
  if ( (_DWORD)result )
  {
    memset(&v23, 0, 0xFFuLL);
    v14 = sqlite3_errmsg();
    sub_3CB24((__int64)&v23, v14, v15, (__int64)"sqlite3_close failed: %i, %s", v13, v14, v16, v17, 0LL);
    v6 = 1;
    sub_3E16C();
    goto LABEL_7;
  }
  v6 = 0;
LABEL_8:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v24 )
    result = v6;
  return result;
}

//----- (000000000003E8CC) ----------------------------------------------------
__int64 sub_3E8CC()
{
  __int64 result; // x0
  unsigned int v1; // w19
  int *v2; // x0
  __int64 v3; // x2
  __int64 v4; // x7
  __int64 v5; // [xsp+0h] [xbp-120h]
  char v6; // [xsp+8h] [xbp-118h]
  __int64 v7; // [xsp+108h] [xbp-18h]

  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = remove("/data/credmgr/credmgr.db");
  v1 = result != 0;
  if ( (_DWORD)result )
  {
    memset(&v6, 0, 0xFFuLL);
    v2 = sub_3E02C(v1);
    sub_3CB24(
      (__int64)&v6,
      (__int64)v2,
      v3,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DbRemove",
      v1,
      (__int64)v2,
      v4,
      v5);
    result = sub_3E16C();
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v7 )
    result = v1;
  return result;
}

//----- (000000000003E97C) ----------------------------------------------------
__int64 __fastcall sub_3E97C(__int64 a1, __int64 a2, int a3, __int64 a4, int a5, __int64 a6, int a7, __int64 a8, __int64 a9, __int64 a10, int a11)
{
  int v11; // w21
  __int64 v12; // x22
  int v13; // w23
  __int64 v14; // x24
  int v15; // w25
  __int64 v16; // x26
  unsigned int v17; // w20
  __int64 v18; // x1
  __int64 v19; // x2
  __int64 v20; // x5
  __int64 v21; // x6
  __int64 v22; // x7
  const char *v23; // x4
  __int64 v24; // x1
  __int64 v25; // x2
  __int64 v26; // x5
  __int64 v27; // x6
  __int64 v28; // x7
  const char *v29; // x3
  const char *v30; // x4
  unsigned int v31; // w20
  __int64 v32; // x0
  __int64 v33; // x2
  __int64 v34; // x6
  __int64 v35; // x7
  __int64 result; // x0
  __int64 v37; // x1
  __int64 v38; // x2
  __int64 v39; // x5
  __int64 v40; // x6
  __int64 v41; // x7
  const char *v42; // x3
  const char *v43; // x4
  unsigned int v51; // w20
  __int64 v52; // x0
  __int64 v53; // x2
  __int64 v54; // x6
  __int64 v55; // x7
  int *v56; // x0
  __int64 v57; // x2
  __int64 v58; // x7
  __int64 v59; // [xsp+0h] [xbp-1B0h]
  __int64 v60; // [xsp+10h] [xbp-1A0h]
  __int128 v61; // [xsp+20h] [xbp-190h]
  char v62; // [xsp+58h] [xbp-158h]
  __int64 v63; // [xsp+158h] [xbp-58h]

  v60 = a8;
  v11 = a7;
  v12 = a6;
  v13 = a5;
  v14 = a4;
  v15 = a3;
  v16 = a2;
  v63 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a4 )
      {
        if ( a6 )
        {
          v17 = 0;
          goto LABEL_11;
        }
        memset(&v62, 0, 0xFFuLL);
        v23 = "pKeyId";
      }
      else
      {
        memset(&v62, 0, 0xFFuLL);
        v23 = "pDbUserId";
      }
    }
    else
    {
      memset(&v62, 0, 0xFFuLL);
      v23 = "pDbAppId";
    }
  }
  else
  {
    memset(&v62, 0, 0xFFuLL);
    v23 = "pDataBase";
  }
  sub_3CB24((__int64)&v62, v18, v19, (__int64)"param %s is NULL", (__int64)v23, v20, v21, v22, v59);
  sub_3E16C();
  v17 = 3;
LABEL_11:
  if ( !(v17 | v11) )
  {
    memset(&v62, 0, 0xFFuLL);
    v29 = "param %s = 0";
    v30 = "keyIdLength";
    goto LABEL_16;
  }
  if ( !a10 && !v17 )
  {
    memset(&v62, 0, 0xFFuLL);
    v29 = "param %s is NULL";
    v30 = "pData";
LABEL_16:
    sub_3CB24((__int64)&v62, v24, v25, (__int64)v29, (__int64)v30, v26, v27, v28, v59);
    sub_3E16C();
    v17 = 3;
  }
  if ( !(v17 | a11) )
  {
    memset(&v62, 0, 0xFFuLL);
    v42 = "param %s = 0";
    v43 = "dataLength";
LABEL_25:
    sub_3CB24((__int64)&v62, v37, v38, (__int64)v42, (__int64)v43, v39, v40, v41, v59);
    sub_3E16C();
    v17 = 3;
    goto LABEL_26;
  }
  if ( !(v13 | v15 | v17) )
  {
    memset(&v62, 0, 0xFFuLL);
    v42 = "%s";
    v43 = "Parameters userId and appId cannot both be empty.";
    goto LABEL_25;
  }
  if ( v17 )
    goto LABEL_26;
  strcpy(&v61, "INSERT INTO keytable VALUES ( ?, ?, ?, ?, ? )");
  v31 = sqlite3_prepare_v2();
  if ( v31 )
  {
    memset(&v62, 0, 0xFFuLL);
    v32 = sqlite3_errmsg();
    sub_3CB24((__int64)&v62, v32, v33, (__int64)"sqlite3_prepare_v2 failed: %i, %s", v31, v32, v34, v35, v59);
    v17 = 1;
    sub_3E16C();
    result = 0LL;
    goto LABEL_39;
  }
  v17 = sub_3EE18(0LL, 1LL, v16);
  if ( v17
    || (v17 = sub_3EE18(0LL, 2LL, v14)) != 0
    || (v17 = sub_3EE18(0LL, 3LL, v12)) != 0
    || (v17 = sub_3EE18(0LL, 4LL, v60)) != 0
    || (v17 = sub_3EE18(0LL, 5LL, a10)) != 0 )
  {
LABEL_26:
    result = 0LL;
    goto LABEL_39;
  }
  v51 = sqlite3_step();
  if ( v51 == 101 )
  {
    v17 = 0;
    result = 0LL;
  }
  else
  {
    memset(&v62, 0, 0xFFuLL);
    v52 = sqlite3_errmsg();
    sub_3CB24((__int64)&v62, v52, v53, (__int64)"sqlite3_step failed: %i, %s", v51, v52, v54, v55, v59);
    sub_3E16C();
    v17 = 15;
    result = 0LL;
  }
LABEL_39:
  if ( v17 )
  {
    memset(&v62, 0, 0xFFuLL);
    v56 = sub_3E02C(v17);
    sub_3CB24(
      (__int64)&v62,
      (__int64)v56,
      v57,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DbInsertTrans",
      v17,
      (__int64)v56,
      v58,
      v59);
    result = sub_3E16C();
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v63 )
    result = v17;
  return result;
}

//----- (000000000003EE18) ----------------------------------------------------
__int64 __fastcall sub_3EE18(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // x0
  unsigned int v4; // w19
  __int64 v5; // x1
  __int64 v6; // x2
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x5
  __int64 v13; // x6
  __int64 v14; // x7
  const char *v15; // x4
  int *v16; // x0
  __int64 v17; // x2
  __int64 v18; // x7
  __int64 v19; // [xsp+0h] [xbp-120h]
  __int64 v20; // [xsp+0h] [xbp-120h]
  char v21; // [xsp+8h] [xbp-118h]
  __int64 v22; // [xsp+108h] [xbp-18h]

  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
  {
    memset(&v21, 0, 0xFFuLL);
    v15 = "p_stmt";
LABEL_7:
    sub_3CB24((__int64)&v21, v10, v11, (__int64)"param %s is NULL", (__int64)v15, v12, v13, v14, v19);
    sub_3E16C();
    v4 = 3;
    goto LABEL_8;
  }
  if ( !a3 )
  {
    memset(&v21, 0, 0xFFuLL);
    v15 = "p_data";
    goto LABEL_7;
  }
  result = sqlite3_bind_blob();
  v4 = result;
  if ( !(_DWORD)result )
    goto LABEL_9;
  memset(&v21, 0, 0xFFuLL);
  sub_3CB24((__int64)&v21, v5, v6, (__int64)"sqlite3_bind_blob failed: %i", v4, v7, v8, v9, v19);
  v4 = 1;
  sub_3E16C();
LABEL_8:
  memset(&v21, 0, 0xFFuLL);
  v16 = sub_3E02C(v4);
  sub_3CB24(
    (__int64)&v21,
    (__int64)v16,
    v17,
    (__int64)"%s() ended. result %d - %s",
    (__int64)"CredMgr_DbBindBlob",
    v4,
    (__int64)v16,
    v18,
    v20);
  result = sub_3E16C();
LABEL_9:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v22 )
    result = v4;
  return result;
}

//----- (000000000003EF6C) ----------------------------------------------------
__int64 __fastcall sub_3EF6C(__int64 a1, int a2, __int64 a3, int a4, __int64 a5, int a6, _QWORD *a7, unsigned int *a8, _QWORD *a9, unsigned int *a10)
{
  unsigned int *v10; // x19
  _QWORD *v11; // x21
  int v12; // w22
  __int64 v13; // x23
  int v14; // w25
  __int64 v15; // x26
  __int64 result; // x0
  unsigned int v17; // w20
  __int64 v18; // x1
  __int64 v19; // x2
  __int64 v20; // x5
  __int64 v21; // x6
  __int64 v22; // x7
  int *v23; // x0
  __int64 v24; // x2
  __int64 v25; // x7
  const char *v26; // [xsp+0h] [xbp-160h]
  char v27; // [xsp+8h] [xbp-158h]
  __int64 v28; // [xsp+108h] [xbp-58h]

  v10 = a8;
  v11 = a7;
  v12 = a6;
  v13 = a5;
  v14 = a4;
  v15 = a3;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1
    || !a2
    || (v26 = "SELECT dbData, dbEncKeyType FROM keytable WHERE dbKeyId=? AND dbAppId=?",
        result = sub_3F110(a1, a2, a5, a6, a7, a8, a9, a10),
        v17 = result,
        (_DWORD)result == 4) )
  {
    if ( !v15 || !v14 )
    {
      memset(&v27, 0, 0xFFuLL);
      sub_3CB24(
        (__int64)&v27,
        v18,
        v19,
        (__int64)"%s",
        (__int64)"Invalid search parameters",
        v20,
        v21,
        v22,
        (__int64)v26);
      sub_3E16C();
      v17 = 3;
      goto LABEL_10;
    }
    memcpy(&v27, "SELECT dbData, dbEncKeyType FROM keytable WHERE dbKeyId=? AND dbUserId=?", 0x49uLL);
    v26 = &v27;
    result = sub_3F110(v15, v14, v13, v12, v11, v10, a9, a10);
    v17 = result;
  }
  if ( v17 )
  {
LABEL_10:
    memset(&v27, 0, 0xFFuLL);
    v23 = sub_3E02C(v17);
    sub_3CB24(
      (__int64)&v27,
      (__int64)v23,
      v24,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DbSelect",
      v17,
      (__int64)v23,
      v25,
      (__int64)v26);
    result = sub_3E16C();
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v28 )
    result = v17;
  return result;
}

//----- (000000000003F110) ----------------------------------------------------
__int64 __fastcall sub_3F110(__int64 a1, int a2, __int64 a3, int a4, _QWORD *a5, unsigned int *a6, _QWORD *a7, unsigned int *a8)
{
  unsigned int *v8; // x21
  _QWORD *v9; // x22
  unsigned int *v10; // x19
  _QWORD *v11; // x20
  int v12; // w25
  __int64 v13; // x26
  int v14; // w23
  __int64 v15; // x24
  unsigned int v16; // w27
  __int64 v17; // x1
  __int64 v18; // x2
  __int64 v19; // x5
  __int64 v20; // x6
  __int64 v21; // x7
  __int64 v22; // x1
  __int64 v23; // x2
  __int64 v24; // x5
  __int64 v25; // x6
  __int64 v26; // x7
  const char *v27; // x3
  const char *v28; // x4
  __int64 v29; // x1
  __int64 v30; // x2
  __int64 v31; // x5
  __int64 v32; // x6
  __int64 v33; // x7
  const char *v34; // x3
  const char *v35; // x4
  __int64 result; // x0
  unsigned int v37; // w19
  int *v38; // x0
  __int64 v39; // x2
  __int64 v40; // x7
  unsigned int v41; // w27
  __int64 v42; // x1
  __int64 v43; // x2
  __int64 v44; // x5
  __int64 v45; // x6
  __int64 v46; // x7
  unsigned int v47; // w27
  __int64 v48; // x1
  __int64 v49; // x2
  __int64 v50; // x6
  __int64 v51; // x7
  const char *v52; // x3
  __int64 v53; // x4
  unsigned int v54; // w23
  const void *v55; // x23
  unsigned int v56; // w0
  void *v57; // x0
  const void *v58; // x21
  unsigned int v59; // w0
  void *v60; // x0
  __int64 v61; // x1
  __int64 v62; // x2
  __int64 v63; // x5
  __int64 v64; // x6
  __int64 v65; // x7
  const char *v66; // x4
  __int64 v67; // x1
  __int64 v68; // x2
  __int64 v69; // x5
  __int64 v70; // x6
  __int64 v71; // x7
  const char *v72; // x4
  __int64 v73; // [xsp+0h] [xbp-170h]
  char v74; // [xsp+18h] [xbp-158h]
  __int64 v75; // [xsp+118h] [xbp-58h]

  v8 = a8;
  v9 = a7;
  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  v15 = a1;
  v75 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v16 = 0;
    if ( !a2 )
      goto LABEL_8;
  }
  else
  {
    memset(&v74, 0, 0xFFuLL);
    sub_3CB24((__int64)&v74, v17, v18, (__int64)"param %s is NULL", (__int64)"pId", v19, v20, v21, v73);
    sub_3E16C();
    v16 = 3;
    if ( !(v14 | 3) )
    {
LABEL_8:
      memset(&v74, 0, 0xFFuLL);
      v27 = "param %s = 0";
      v28 = "dbIdLength";
      goto LABEL_9;
    }
  }
  if ( v13 || v16 )
    goto LABEL_10;
  memset(&v74, 0, 0xFFuLL);
  v27 = "param %s is NULL";
  v28 = "pKeyId";
LABEL_9:
  sub_3CB24((__int64)&v74, v22, v23, (__int64)v27, (__int64)v28, v24, v25, v26, v73);
  sub_3E16C();
  v16 = 3;
LABEL_10:
  if ( !(v16 | v12) )
  {
    memset(&v74, 0, 0xFFuLL);
    v34 = "param %s = 0";
    v35 = "keyIdLength";
    goto LABEL_24;
  }
  if ( !v11 && !v16 )
  {
    memset(&v74, 0, 0xFFuLL);
    v34 = "param %s is NULL";
    v35 = "ppEncKeyType";
LABEL_24:
    sub_3CB24((__int64)&v74, v29, v30, (__int64)v34, (__int64)v35, v31, v32, v33, v73);
    sub_3E16C();
    v16 = 3;
    goto LABEL_25;
  }
  if ( !v10 && !v16 )
  {
    memset(&v74, 0, 0xFFuLL);
    v34 = "param %s is NULL";
    v35 = "pEncKeyTypeLength";
    goto LABEL_24;
  }
  if ( !v9 && !v16 )
  {
    memset(&v74, 0, 0xFFuLL);
    v34 = "param %s is NULL";
    v35 = "ppData";
    goto LABEL_24;
  }
  if ( !v8 && !v16 )
  {
    memset(&v74, 0, 0xFFuLL);
    v34 = "param %s = 0";
    v35 = "pDataLength";
    goto LABEL_24;
  }
  if ( !v16 )
  {
    v41 = sqlite3_open_v2();
    if ( v41 )
    {
      memset(&v74, 0, 0xFFuLL);
      sub_3CB24((__int64)&v74, v42, v43, (__int64)"sqlite3_open_v2 failed: %i", v41, v44, v45, v46, v73);
      sub_3E16C();
      v16 = 14;
      goto LABEL_25;
    }
    v47 = sqlite3_prepare_v2();
    if ( v47 )
    {
      memset(&v74, 0, 0xFFuLL);
      v48 = sqlite3_errmsg();
      v52 = "sqlite3_prepare_v2 failed: %i, %s";
      v53 = v47;
LABEL_34:
      sub_3CB24((__int64)&v74, v48, v49, (__int64)v52, v53, v48, v50, v51, v73);
      v16 = 1;
      sub_3E16C();
      goto LABEL_25;
    }
    v16 = sub_3EE18(0LL, 1LL, v13);
    if ( !v16 )
    {
      v16 = sub_3EE18(0LL, 2LL, v15);
      if ( !v16 )
      {
        v54 = sqlite3_step();
        if ( v54 - 100 >= 2 && v54 )
        {
          memset(&v74, 0, 0xFFuLL);
          v48 = sqlite3_errmsg();
          v52 = "sqlite3_step failed: %i, %s";
          v53 = v54;
          goto LABEL_34;
        }
        v55 = (const void *)sqlite3_column_blob();
        if ( v55 )
        {
          v56 = sqlite3_column_bytes();
          *v8 = v56;
          v57 = malloc(v56);
          *v9 = v57;
          if ( !v57 )
          {
            memset(&v74, 0, 0xFFuLL);
            v72 = "failed to allocate memory for credential info/data";
LABEL_50:
            sub_3CB24((__int64)&v74, v67, v68, (__int64)"%s", (__int64)v72, v69, v70, v71, v73);
            sub_3E16C();
            v16 = 2;
            goto LABEL_25;
          }
          memcpy(v57, v55, *v8);
          v58 = (const void *)sqlite3_column_blob();
          if ( v58 )
          {
            v59 = sqlite3_column_bytes();
            *v10 = v59;
            v60 = malloc(v59);
            *v11 = v60;
            if ( v60 )
            {
              memcpy(v60, v58, *v10);
              v16 = 0;
              goto LABEL_25;
            }
            memset(&v74, 0, 0xFFuLL);
            v72 = "failed to allocate memory for credential encr. type";
            goto LABEL_50;
          }
          memset(&v74, 0, 0xFFuLL);
          v66 = "sqlite3_column_blob did not find any credential encr. type";
        }
        else
        {
          memset(&v74, 0, 0xFFuLL);
          v66 = "sqlite3_column_blob did not find any credential info/data";
        }
        sub_3CB24((__int64)&v74, v61, v62, (__int64)"%s", (__int64)v66, v63, v64, v65, v73);
        sub_3E16C();
        v16 = 4;
        goto LABEL_25;
      }
    }
  }
LABEL_25:
  result = sub_3E3C8(0LL, 0LL, v16);
  v37 = result;
  if ( (_DWORD)result )
  {
    memset(&v74, 0, 0xFFuLL);
    v38 = sub_3E02C(v37);
    sub_3CB24(
      (__int64)&v74,
      (__int64)v38,
      v39,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_DbSelectEx",
      v37,
      (__int64)v38,
      v40,
      v73);
    result = sub_3E16C();
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v75 )
    result = v37;
  return result;
}

//----- (000000000003F674) ----------------------------------------------------
size_t __fastcall sub_3F674(const char *a1, int a2, const char *a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // x19
  size_t v6; // x22
  const char *v7; // x20
  size_t v8; // x23
  const char *v9; // x21
  unsigned int v10; // w24
  __int64 v11; // x1
  __int64 v12; // x2
  __int64 v13; // x5
  __int64 v14; // x6
  __int64 v15; // x7
  __int64 v16; // x1
  __int64 v17; // x2
  __int64 v18; // x5
  __int64 v19; // x6
  __int64 v20; // x7
  const char *v21; // x3
  const char *v22; // x4
  __int64 v23; // x1
  __int64 v24; // x2
  __int64 v25; // x5
  __int64 v26; // x6
  __int64 v27; // x7
  const char *v28; // x3
  const char *v29; // x4
  int *v30; // x0
  __int64 v31; // x2
  __int64 v32; // x7
  size_t result; // x0
  __int64 v34; // [xsp+0h] [xbp-150h]
  char v35; // [xsp+8h] [xbp-148h]
  __int64 v36; // [xsp+108h] [xbp-48h]

  v5 = a5;
  LODWORD(v6) = a4;
  v7 = a3;
  LODWORD(v8) = a2;
  v9 = a1;
  v36 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v10 = 0;
    if ( !a2 )
      goto LABEL_8;
  }
  else
  {
    memset(&v35, 0, 0xFFuLL);
    sub_3CB24((__int64)&v35, v11, v12, (__int64)"param %s is NULL", (__int64)"pAppId", v13, v14, v15, v34);
    sub_3E16C();
    v10 = 3;
    if ( !((unsigned int)v8 | 3) )
    {
LABEL_8:
      memset(&v35, 0, 0xFFuLL);
      v21 = "param %s = 0";
      v22 = "appIdLength";
      goto LABEL_9;
    }
  }
  if ( !v7 && !v10 )
  {
    memset(&v35, 0, 0xFFuLL);
    v21 = "param %s is NULL";
    v22 = "pKeyId";
LABEL_9:
    sub_3CB24((__int64)&v35, v16, v17, (__int64)v21, (__int64)v22, v18, v19, v20, v34);
    sub_3E16C();
    v10 = 3;
  }
  if ( !(v10 | (unsigned int)v6) )
  {
    memset(&v35, 0, 0xFFuLL);
    v28 = "param %s = 0";
    v29 = "keyIdLength";
    goto LABEL_15;
  }
  if ( !v5 && !v10 )
  {
    memset(&v35, 0, 0xFFuLL);
    v28 = "param %s is NULL";
    v29 = "pIsSupported";
LABEL_15:
    sub_3CB24((__int64)&v35, v23, v24, (__int64)v28, (__int64)v29, v25, v26, v27, v34);
    sub_3E16C();
    v10 = 3;
LABEL_17:
    memset(&v35, 0, 0xFFuLL);
    v30 = sub_3E02C(v10);
    sub_3CB24(
      (__int64)&v35,
      (__int64)v30,
      v31,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_ExtDbIsSupported",
      v10,
      (__int64)v30,
      v32,
      v34);
    result = sub_3E16C();
    goto LABEL_18;
  }
  if ( v10 )
    goto LABEL_17;
  *v5 = 0;
  v8 = (unsigned int)v8;
  result = strnlen("com.sonymobile.security.appid.1", 0x20uLL);
  if ( (unsigned int)v8 == result )
  {
    v6 = (unsigned int)v6;
    if ( !(unsigned int)strncmp(v9, "com.sonymobile.security.appid.1", v8)
      && v6 == strnlen("Sony-Mobile-Device-Unique-1", 0x20uLL) )
    {
      result = strncmp(v7, "Sony-Mobile-Device-Unique-1", v6);
      if ( !(_DWORD)result )
        goto LABEL_32;
    }
    result = strncmp(v9, "com.sonymobile.security.appid.1", v8);
    if ( (_DWORD)result )
    {
      v10 = 0;
      goto LABEL_18;
    }
    result = strnlen("Sony-Mobile-Device-Unique-2", 0x20uLL);
    if ( v6 != result || (result = strncmp(v7, "Sony-Mobile-Device-Unique-2", v6), (_DWORD)result) )
    {
      v10 = 0;
    }
    else
    {
LABEL_32:
      v10 = 0;
      *v5 = 1;
    }
  }
LABEL_18:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v36 )
    result = v10;
  return result;
}

//----- (000000000003F950) ----------------------------------------------------
__int64 __fastcall sub_3F950(const char *a1, int a2, const char *a3, unsigned int a4, __int64 a5, __int64 a6)
{
  __int64 v6; // x19
  __int64 v7; // x20
  unsigned int v8; // w24
  const char *v9; // x21
  size_t v10; // x25
  const char *v11; // x22
  unsigned int v12; // w23
  __int64 v13; // x1
  __int64 v14; // x2
  __int64 v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  __int64 v18; // x1
  __int64 v19; // x2
  __int64 v20; // x5
  __int64 v21; // x6
  __int64 v22; // x7
  const char *v23; // x3
  const char *v24; // x4
  __int64 v25; // x1
  __int64 v26; // x2
  __int64 v27; // x5
  __int64 v28; // x6
  __int64 v29; // x7
  const char *v30; // x3
  const char *v31; // x4
  int *v32; // x0
  __int64 v33; // x2
  __int64 v34; // x7
  __int64 result; // x0
  signed __int64 v36; // x8
  __int64 v37; // x1
  __int64 v38; // x2
  __int64 v39; // x5
  __int64 v40; // x6
  __int64 v41; // x7
  const char *v42; // x3
  const char *v43; // x4
  int *v44; // x0
  __int64 v45; // x2
  __int64 v46; // x7
  __int64 v47; // [xsp+0h] [xbp-150h]
  char v48; // [xsp+8h] [xbp-148h]
  __int64 v49; // [xsp+108h] [xbp-48h]

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  LODWORD(v10) = a2;
  v11 = a1;
  v49 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v12 = 0;
    if ( !a2 )
      goto LABEL_8;
  }
  else
  {
    memset(&v48, 0, 0xFFuLL);
    sub_3CB24((__int64)&v48, v13, v14, (__int64)"param %s is NULL", (__int64)"pAppId", v15, v16, v17, v47);
    sub_3E16C();
    v12 = 3;
    if ( !((unsigned int)v10 | 3) )
    {
LABEL_8:
      memset(&v48, 0, 0xFFuLL);
      v23 = "param %s = 0";
      v24 = "appIdLength";
      goto LABEL_9;
    }
  }
  if ( !v9 && !v12 )
  {
    memset(&v48, 0, 0xFFuLL);
    v23 = "param %s is NULL";
    v24 = "pKeyId";
LABEL_9:
    sub_3CB24((__int64)&v48, v18, v19, (__int64)v23, (__int64)v24, v20, v21, v22, v47);
    sub_3E16C();
    v12 = 3;
  }
  if ( !(v12 | v8) )
  {
    memset(&v48, 0, 0xFFuLL);
    v30 = "param %s = 0";
    v31 = "keyIdLength";
    goto LABEL_27;
  }
  if ( !v7 && !v12 )
  {
    memset(&v48, 0, 0xFFuLL);
    v30 = "param %s is NULL";
    v31 = "ppCredential";
LABEL_27:
    sub_3CB24((__int64)&v48, v25, v26, (__int64)v30, (__int64)v31, v27, v28, v29, v47);
    sub_3E16C();
    v12 = 3;
    goto LABEL_28;
  }
  if ( !v6 && !v12 )
  {
    memset(&v48, 0, 0xFFuLL);
    v30 = "param %s is NULL";
    v31 = "pCredentialLength";
    goto LABEL_27;
  }
  if ( v12 )
  {
LABEL_28:
    memset(&v48, 0, 0xFFuLL);
    v32 = sub_3E02C(v12);
    sub_3CB24(
      (__int64)&v48,
      (__int64)v32,
      v33,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"CredMgr_ExtDbSelect",
      v12,
      (__int64)v32,
      v34,
      v47);
    result = sub_3E16C();
    goto LABEL_29;
  }
  v10 = (unsigned int)v10;
  if ( (unsigned int)v10 != strnlen("com.sonymobile.security.appid.1", 0x20uLL) )
  {
LABEL_26:
    memset(&v48, 0, 0xFFuLL);
    v30 = "%s";
    v31 = "Invalid AppId and/or KeyId";
    goto LABEL_27;
  }
  if ( (unsigned int)strncmp(v11, "com.sonymobile.security.appid.1", v10)
    || v8 != strnlen("Sony-Mobile-Device-Unique-1", 0x20uLL)
    || (unsigned int)strncmp(v9, "Sony-Mobile-Device-Unique-1", v8) )
  {
    if ( (unsigned int)strncmp(v11, "com.sonymobile.security.appid.1", v10)
      || v8 != strnlen("Sony-Mobile-Device-Unique-2", 0x20uLL)
      || (unsigned int)strncmp(v9, "Sony-Mobile-Device-Unique-2", v8) )
    {
      goto LABEL_26;
    }
    v36 = 1LL;
  }
  else
  {
    v36 = 0LL;
  }
  if ( !(unsigned int)strnlen(off_F6360[3 * v36 + 2], 0x20uLL) )
  {
    memset(&v48, 0, 0xFFuLL);
    v42 = "param %s = 0";
    v43 = "duKeyIdLength";
LABEL_41:
    sub_3CB24((__int64)&v48, v37, v38, (__int64)v42, (__int64)v43, v39, v40, v41, v47);
    sub_3E16C();
    v12 = 3;
    goto LABEL_42;
  }
  if ( !v7 )
  {
    memset(&v48, 0, 0xFFuLL);
    v42 = "param %s is NULL";
    v43 = "ppKey";
    goto LABEL_41;
  }
  if ( !v6 )
  {
    memset(&v48, 0, 0xFFuLL);
    v42 = "param %s is NULL";
    v43 = "pKeyLength";
    goto LABEL_41;
  }
  result = SuntoryTee_GetKey();
  if ( (_DWORD)result )
  {
    v12 = 5;
LABEL_42:
    memset(&v48, 0, 0xFFuLL);
    v44 = sub_3E02C(v12);
    sub_3CB24(
      (__int64)&v48,
      (__int64)v44,
      v45,
      (__int64)"%s() ended. result %d - %s",
      (__int64)"GetDeviceUniqueKey",
      v12,
      (__int64)v44,
      v46,
      v47);
    sub_3E16C();
    goto LABEL_28;
  }
  v12 = 0;
LABEL_29:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v49 )
    result = v12;
  return result;
}
// F6360: using guessed type char *off_F6360[6];

//----- (000000000003FD98) ----------------------------------------------------
void sub_3FD98()
{
  FILE *v0; // x0
  FILE *v1; // x19
  int *v2; // x0
  char *v3; // x1
  __int64 v4; // x2
  __int64 v5; // x6
  __int64 v6; // x7
  const char *v7; // x3
  void *v8; // x20
  unsigned int v9; // w21
  int *v10; // x0
  char *v11; // x0
  __int64 v12; // x2
  __int64 v13; // x6
  __int64 v14; // x7
  int *v15; // x0
  __int64 v16; // x2
  __int64 v17; // x7
  unsigned int v18; // w21
  int *v19; // x0
  int *v20; // x0
  void *v21; // x0
  unsigned int v22; // w0
  unsigned int v23; // w22
  __int64 v24; // x1
  __int64 v25; // x2
  __int64 v26; // x5
  __int64 v27; // x6
  __int64 v28; // x7
  __int64 v29; // x1
  __int64 v30; // x2
  __int64 v31; // x5
  __int64 v32; // x6
  __int64 v33; // x7
  int *v34; // x0
  char *v35; // x0
  __int64 v36; // x2
  __int64 v37; // x6
  __int64 v38; // x7
  __int64 v39; // x1
  __int64 v40; // x2
  __int64 v41; // x6
  __int64 v42; // x7
  __int64 v43; // [xsp+0h] [xbp-140h]
  char v44; // [xsp+8h] [xbp-138h]
  __int64 v45; // [xsp+108h] [xbp-38h]

  v45 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v0 = fopen("/data/credmgr/credmgr.db", "rb");
  v1 = v0;
  if ( v0 )
  {
    if ( (unsigned int)fseek(v0, 0LL, 2) )
    {
      memset(&v44, 0, 0xFFuLL);
      v2 = (int *)__errno();
      v3 = strerror(*v2);
      v7 = "first fseek failed on %s, error: %s";
LABEL_4:
      sub_3CB24(
        (__int64)&v44,
        (__int64)v3,
        v4,
        (__int64)v7,
        (__int64)"/data/credmgr/credmgr.db",
        (__int64)v3,
        v5,
        v6,
        v43);
      sub_3E16C();
      v8 = 0LL;
      v9 = 14;
      goto LABEL_5;
    }
    v18 = ftell(v1);
    if ( v18 == -1 )
    {
      memset(&v44, 0, 0xFFuLL);
      v20 = (int *)__errno();
      v3 = strerror(*v20);
      v7 = "ftell failed on %s, error: %s";
      goto LABEL_4;
    }
    if ( (unsigned int)fseek(v1, 0LL, 0) )
    {
      memset(&v44, 0, 0xFFuLL);
      v19 = (int *)__errno();
      v3 = strerror(*v19);
      v7 = "second fseek failed on %s, error: %s";
      goto LABEL_4;
    }
    v21 = malloc((signed int)v18);
    v8 = v21;
    if ( !v21 )
    {
      memset(&v44, 0, 0xFFuLL);
      sub_3CB24((__int64)&v44, v29, v30, (__int64)"%s", (__int64)"failed to allocate memory", v31, v32, v33, v43);
      sub_3E16C();
      v9 = 2;
      goto LABEL_5;
    }
    v22 = fread(v21, 1uLL, (signed int)v18, v1);
    v23 = v22;
    if ( v22 & 0x80000000 )
    {
      memset(&v44, 0, 0xFFuLL);
      v34 = (int *)__errno();
      v35 = strerror(*v34);
      sub_3CB24(
        (__int64)&v44,
        (__int64)v35,
        v36,
        (__int64)"fread failed on %s, error: %s",
        (__int64)"/data/credmgr/credmgr.db",
        (__int64)v35,
        v37,
        v38,
        v43);
    }
    else
    {
      if ( v22 == v18 )
      {
        v9 = miscta_write_unit_critical();
        if ( v9 )
        {
          memset(&v44, 0, 0xFFuLL);
          sub_3CB24(
            (__int64)&v44,
            v24,
            v25,
            (__int64)"miscta_get_unit_size failed, miscta_status %d",
            v9,
            v26,
            v27,
            v28,
            v43);
          sub_3E16C();
          v9 = 5;
        }
LABEL_5:
        fclose(v1);
        free(v8);
        if ( !v9 )
          goto LABEL_9;
        goto LABEL_8;
      }
      memset(&v44, 0, 0xFFuLL);
      sub_3CB24((__int64)&v44, v39, v40, (__int64)"read %i != expect %i", v23, v18, v41, v42, v43);
    }
    v9 = 1;
    sub_3E16C();
    goto LABEL_5;
  }
  memset(&v44, 0, 0xFFuLL);
  v10 = (int *)__errno();
  v11 = strerror(*v10);
  sub_3CB24(
    (__int64)&v44,
    (__int64)v11,
    v12,
    (__int64)"fopen failed on %s, error: %s",
    (__int64)"/data/credmgr/credmgr.db",
    (__int64)v11,
    v13,
    v14,
    v43);
  sub_3E16C();
  v9 = 14;
LABEL_8:
  memset(&v44, 0, 0xFFuLL);
  v15 = sub_3E02C(v9);
  sub_3CB24(
    (__int64)&v44,
    (__int64)v15,
    v16,
    (__int64)"%s() ended. result %d - %s",
    (__int64)"CredMgr_BackupDataBase",
    v9,
    (__int64)v15,
    v17,
    v43);
  sub_3E16C();
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v45;
}

//----- (000000000004010C) ----------------------------------------------------
__int64 sub_4010C()
{
  unsigned int v0; // w19
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x5
  __int64 v4; // x6
  __int64 v5; // x7
  void *v6; // x19
  unsigned int v7; // w20
  int *v8; // x0
  __int64 v9; // x2
  __int64 v10; // x7
  __int64 result; // x0
  __int64 v20; // x1
  __int64 v21; // x2
  __int64 v22; // x5
  __int64 v23; // x6
  __int64 v24; // x7
  __int64 v52; // [xsp+0h] [xbp-150h]
  __int64 v53; // [xsp+0h] [xbp-150h]
  __int64 v54; // [xsp+8h] [xbp-148h]
  char v55; // [xsp+18h] [xbp-138h]

  v54 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v0 = miscta_get_unit_size();
  if ( v0 )
  {
    memset(&v55, 0, 0xFFuLL);
    sub_3CB24((__int64)&v55, v1, v2, (__int64)"miscta_get_unit_size failed, ta_res %d", v0, v3, v4, v5, v52);
    sub_3E16C();
    v6 = 0LL;
    v7 = 5;
  }
  else
  {
    memset(&v55, 0, 0xFFuLL);
    sub_3CB24((__int64)&v55, v20, v21, (__int64)"miscta unit has bad size, ta_unit_size %d", 0LL, v22, v23, v24, v52);
    v7 = 1;
    sub_3E16C();
    v6 = 0LL;
  }
  free(v6);
  memset(&v55, 0, 0xFFuLL);
  v8 = sub_3E02C(v7);
  sub_3CB24(
    (__int64)&v55,
    (__int64)v8,
    v9,
    (__int64)"%s() ended. result %d - %s",
    (__int64)"CredMgr_RestoreDataBase",
    v7,
    (__int64)v8,
    v10,
    v53);
  result = sub_3E16C();
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v54 )
    result = v7;
  return result;
}

//----- (0000000000040450) ----------------------------------------------------
void sub_40450()
{
  __int64 v0; // ST08_8
  unsigned int v1; // w19
  __int64 v2; // x1
  __int64 v3; // x2
  __int64 v4; // x5
  __int64 v5; // x6
  __int64 v6; // x7
  const char *v7; // x3
  __int64 v8; // x4
  int *v9; // x0
  __int64 v10; // x2
  __int64 v11; // x7
  __int64 v12; // ST00_8
  __int64 v13; // [xsp+0h] [xbp-140h]
  char v14; // [xsp+18h] [xbp-128h]

  v0 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v1 = miscta_get_unit_size();
  if ( v1 )
  {
    memset(&v14, 0, 0xFFuLL);
    v7 = "miscta_get_unit_size failed, ta_res %d";
    v8 = v1;
  }
  else
  {
    memset(&v14, 0, 0xFFuLL);
    v7 = "miscta unit has bad size, ta_unit_size %d";
    v8 = 0LL;
  }
  sub_3CB24((__int64)&v14, v2, v3, (__int64)v7, v8, v4, v5, v6, v13);
  sub_3E16C();
  memset(&v14, 0, 0xFFuLL);
  v9 = sub_3E02C(5);
  sub_3CB24(
    (__int64)&v14,
    (__int64)v9,
    v10,
    (__int64)"%s() ended. result %d - %s",
    (__int64)"CredMgr_BackupDataBaseExist",
    5LL,
    (__int64)v9,
    v11,
    v12);
  sub_3E16C();
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000004057C) ----------------------------------------------------
long double __fastcall sub_4057C(__int64 a1)
{
  long double result; // q0

  result = byte_F63A0;
  *(_QWORD *)(a1 + 32) = &dword_0;
  *(_OWORD *)a1 = *(_OWORD *)&off_F6390;
  *(long double *)(a1 + 16) = byte_F63A0;
  return result;
}
// 0: using guessed type int dword_0;
// F6390: using guessed type void *off_F6390;

//----- (00000000000405A0) ----------------------------------------------------
void sub_405A0()
{
  int v0; // w19
  int v1; // w19
  int v2; // w0
  void *v3; // x22
  char v4; // w20
  char v5; // w20
  int v6; // w0
  __int64 v7; // x23
  unsigned int v8; // w27
  int v9; // w0
  int v10; // w0
  int v11; // w0
  _QWORD *v12; // x23
  void *v13; // x0
  int v14; // w0
  _QWORD *v15; // x23
  void *v16; // x0
  _QWORD *v17; // x23
  void *v18; // x0
  unsigned __int8 *v19; // x28
  bool v20; // w8
  unsigned int v21; // kr00_4
  signed int v22; // w27
  unsigned int v23; // w20
  __int64 v24; // x23
  int v25; // w0
  int v26; // w21
  __int64 v27; // x24
  char *v28; // x0
  char *v29; // x23
  int v30; // w0
  int v31; // w21
  __int64 v32; // x23
  int v33; // w19
  int v34; // w0
  int v35; // w0
  __int64 v36; // [xsp+0h] [xbp-1D0h]
  __int64 v37; // [xsp+38h] [xbp-198h]
  __int64 v38; // [xsp+40h] [xbp-190h]
  int v39; // [xsp+4Ch] [xbp-184h]
  __int64 v40; // [xsp+50h] [xbp-180h]
  void *v41; // [xsp+58h] [xbp-178h]
  void *v42; // [xsp+60h] [xbp-170h]
  int v43; // [xsp+68h] [xbp-168h]
  int v44; // [xsp+6Ch] [xbp-164h]
  void *v45; // [xsp+70h] [xbp-160h]
  void *v46; // [xsp+78h] [xbp-158h]

  v39 = 0;
  v38 = 0LL;
  v0 = sub_3D560((__int64)&v39);
  if ( v0 )
    goto LABEL_37;
  v45 = 0LL;
  v46 = 0LL;
  LODWORD(v41) = 0;
  v42 = 0LL;
  LODWORD(v40) = 0;
  v1 = strnlen(".appid.copy_complete", 0x14uLL);
  v2 = strnlen(".keyid.copy_complete", 0x14uLL);
  if ( (unsigned int)sub_3EF6C(
                       (__int64)".appid.copy_complete",
                       v1,
                       (__int64)&unk_B8A4C,
                       0,
                       (__int64)".keyid.copy_complete",
                       v2,
                       &v42,
                       (unsigned int *)&v40,
                       &v45,
                       (unsigned int *)&v41)
    || (_DWORD)v41 != 20
    || (v46 = malloc(0x14uLL)) == 0LL
    || (unsigned int)sub_3DA74((__int64 *)&v46)
    || (v3 = v45, (unsigned int)memcmp(v46, v45, 0x14uLL)) )
  {
    v3 = v45;
    v4 = 0;
  }
  else
  {
    v4 = 1;
  }
  free(v3);
  v45 = 0LL;
  free(v46);
  v46 = 0LL;
  free(v42);
  if ( v4 & 1 )
  {
    v5 = 0;
  }
  else
  {
    sub_3E8CC();
    v0 = sub_3E18C();
    if ( v0 )
      goto LABEL_37;
    v5 = 1;
  }
  sub_40D9C(&v38);
  v0 = v6;
  if ( v6 )
    goto LABEL_37;
  if ( !(v5 & 1) )
  {
    sub_40450();
    if ( !v9 )
      goto LABEL_32;
    sub_3FD98();
    if ( !v10 )
      goto LABEL_32;
    goto LABEL_36;
  }
  if ( v39 == 1 )
  {
    v7 = v38;
    v43 = 0;
    v41 = 0LL;
    v42 = 0LL;
    if ( !v38 )
    {
      memset(&v46, 0, 0xFFuLL);
      __snprintf_chk();
      sub_3E16C();
      v0 = 3;
      goto LABEL_28;
    }
    v0 = sub_3DE88(&v42, &v43);
    if ( v0 )
      goto LABEL_28;
    v8 = v43-- - 1;
    if ( !v43 )
    {
      v0 = 0;
      goto LABEL_28;
    }
    v19 = (unsigned __int8 *)v42;
    v40 = 0LL;
    v0 = sub_3E520(&v40);
    v20 = v0 == 0;
    if ( v8 < 0x6B || v0 )
    {
LABEL_61:
      if ( v20 )
      {
        v41 = malloc(0x14uLL);
        if ( v41 )
        {
          v0 = sub_3DA74((__int64 *)&v41);
          if ( !v0 )
          {
            v32 = v40;
            v33 = strnlen(".appid.copy_complete", 0x14uLL);
            v34 = strnlen(".keyid.copy_complete", 0x14uLL);
            LODWORD(v36) = 1;
            v0 = sub_3E97C(
                   v32,
                   (__int64)".appid.copy_complete",
                   v33,
                   (__int64)&unk_B8A4C,
                   0,
                   (__int64)".keyid.copy_complete",
                   v34,
                   (__int64)"0",
                   v36,
                   (__int64)v41,
                   20);
            if ( v0 == 15 )
              v0 = 0;
          }
        }
        else
        {
          v0 = 2;
        }
      }
      goto LABEL_70;
    }
    v21 = v8;
    v22 = 1;
    v37 = v7 + 40;
    v23 = 1;
    while ( 1 )
    {
      if ( v19[42] == 1 )
      {
        v24 = v40;
        v45 = 0LL;
        v44 = 0;
        if ( v40 )
        {
          sub_42060(v19 + 1, 0x14u, &unk_B8A4C, 0, v19 + 21, 0x14u, v19 + 43, v19[107], v37, v19[41], 0, &v45, &v44);
          v26 = v25;
          if ( !v25 )
          {
            LODWORD(v36) = 1;
            v26 = sub_3E97C(
                    v24,
                    (__int64)(v19 + 1),
                    20,
                    (__int64)&unk_B8A4C,
                    0,
                    (__int64)(v19 + 21),
                    20,
                    (__int64)(v19 + 42),
                    v36,
                    (__int64)v45,
                    v44);
          }
          free(v45);
          v0 = 0;
          if ( !v26 || v26 == 15 )
            goto LABEL_59;
        }
        else
        {
          memset(&v46, 0, 0xFFuLL);
          __snprintf_chk();
          sub_3E16C();
          free(v45);
          v26 = 3;
        }
        memset(&v46, 0, 0xFFuLL);
        sub_3E02C(v26);
        __snprintf_chk();
        sub_3E16C();
        v0 = v26;
      }
      else
      {
        v27 = v40;
        if ( !v40 )
        {
          memset(&v46, 0, 0xFFuLL);
          __snprintf_chk();
          sub_3E16C();
          v31 = 3;
          goto LABEL_69;
        }
        v28 = (char *)malloc(0xBuLL);
        v29 = v28;
        if ( !v28 )
        {
          v31 = 2;
LABEL_69:
          memset(&v46, 0, 0xFFuLL);
          sub_3E02C(v31);
          __snprintf_chk();
          sub_3E16C();
          v0 = v31;
LABEL_70:
          if ( v40 )
          {
            v35 = sub_3E6FC(v40);
            if ( !v0 )
            {
              if ( v35 )
                v0 = v35;
            }
          }
LABEL_28:
          free(v41);
          v41 = 0LL;
          free(v42);
          v42 = 0LL;
          if ( v0 )
          {
            memset(&v46, 0, 0xFFuLL);
            sub_3E02C(v0);
            __snprintf_chk();
            sub_3E16C();
            goto LABEL_37;
          }
          sub_3FD98();
          if ( !v14 || v14 == 5 )
          {
LABEL_32:
            v15 = (_QWORD *)v38;
            if ( v38 )
            {
              free(*(void **)(v38 + 40));
              v16 = (void *)v15[7];
              v15[5] = 0LL;
              free(v16);
            }
            free(v15);
            goto LABEL_35;
          }
LABEL_36:
          v0 = 1;
LABEL_37:
          v17 = (_QWORD *)v38;
          if ( v38 )
          {
            free(*(void **)(v38 + 40));
            v18 = (void *)v17[7];
            v17[5] = 0LL;
            free(v18);
          }
          free(v17);
LABEL_40:
          v38 = 0LL;
          memset(&v46, 0, 0xFFuLL);
          sub_3E02C(v0);
          __snprintf_chk();
          sub_3E16C();
          return;
        }
        v28[10] = 0;
        *((_WORD *)v28 + 4) = 0;
        *(_QWORD *)v28 = 0LL;
        __snprintf_chk();
        v30 = strnlen(v29, 0xBuLL);
        LODWORD(v36) = 1;
        v31 = sub_3E97C(
                v27,
                (__int64)(v19 + 1),
                20,
                (__int64)&unk_B8A4C,
                0,
                (__int64)(v19 + 21),
                20,
                (__int64)(v19 + 42),
                v36,
                (__int64)v29,
                v30);
        free(v29);
        v0 = 0;
        if ( v31 && v31 != 15 )
          goto LABEL_69;
      }
LABEL_59:
      v20 = v0 == 0;
      if ( v23 < v21 / 0x6B )
      {
        ++v23;
        v22 += 107;
        v19 += 107;
        if ( !v0 )
          continue;
      }
      goto LABEL_61;
    }
  }
  v11 = sub_4010C();
  v12 = (_QWORD *)v38;
  v0 = v11;
  if ( v38 )
  {
    free(*(void **)(v38 + 40));
    v13 = (void *)v12[7];
    v12[5] = 0LL;
    free(v13);
  }
  free(v12);
  if ( v0 )
    goto LABEL_40;
LABEL_35:
  v38 = 0LL;
}

//----- (0000000000040D9C) ----------------------------------------------------
void __fastcall sub_40D9C(_QWORD *a1)
{
  _QWORD *v1; // x19
  int v2; // w19
  _QWORD *v3; // x0
  __int64 v4; // x8
  __int64 v5; // x22
  void *v6; // x19
  void *v7; // x0
  _DWORD *v8; // x20
  int v9; // [xsp+0h] [xbp-140h]
  unsigned int v10; // [xsp+4h] [xbp-13Ch]
  void *v11; // [xsp+8h] [xbp-138h]

  v1 = a1;
  if ( !a1 )
  {
    memset(&v11, 0, 0xFFuLL);
    goto LABEL_5;
  }
  if ( *a1 )
  {
    memset(&v11, 0, 0xFFuLL);
LABEL_5:
    __snprintf_chk();
    sub_3E16C();
    v2 = 3;
LABEL_6:
    memset(&v11, 0, 0xFFuLL);
    sub_3E02C(v2);
    __snprintf_chk();
    sub_3E16C();
    return;
  }
  v3 = malloc(0x50uLL);
  *v1 = v3;
  if ( !v3 )
  {
    v2 = 2;
    goto LABEL_6;
  }
  v4 = *v1;
  *(_BYTE *)v3 = 0;
  v3[5] = 0LL;
  *((_DWORD *)v3 + 12) = 0;
  *(_QWORD *)(v4 + 56) = 0LL;
  *(_DWORD *)(*v1 + 64LL) = 0;
  *(_DWORD *)(*v1 + 68LL) = 3;
  v5 = *v1;
  if ( !*v1 )
  {
    memset(&v11, 0, 0xFFuLL);
    __snprintf_chk();
    sub_3E16C();
    v2 = 3;
    goto LABEL_25;
  }
  v2 = sub_3D70C((__int64)&v10);
  if ( v2 )
  {
LABEL_25:
    memset(&v11, 0, 0xFFuLL);
    sub_3E02C(v2);
    __snprintf_chk();
    sub_3E16C();
    goto LABEL_6;
  }
  if ( v10 > 1 )
  {
    v2 = 5;
    goto LABEL_25;
  }
  *(_DWORD *)(v5 + 72) = v10;
  v9 = 0;
  v11 = 0LL;
  v2 = sub_3D8CC((__int64)&v11, (__int64)&v9, 1);
  if ( !v2 )
  {
    v6 = malloc(0x14uLL);
    *(_QWORD *)(v5 + 40) = v6;
    if ( v6 )
    {
      v7 = malloc(0x14uLL);
      *(_QWORD *)(v5 + 56) = v7;
      if ( v7 )
      {
        v8 = (_DWORD *)(v5 + 48);
        v2 = sub_42848((__int64)"CREDENTIAL_ENC", 0xEu, (__int64)v11, v9, (__int64)v6, (_DWORD *)(v5 + 48), 0x14u);
        if ( !v2 )
        {
          if ( *v8 >= 0x11u )
            *v8 = 16;
          v2 = sub_42848(
                 (__int64)"CREDENTIAL_MAC",
                 0xEu,
                 (__int64)v11,
                 v9,
                 *(_QWORD *)(v5 + 56),
                 (_DWORD *)(v5 + 64),
                 0x14u);
        }
      }
      else
      {
        v2 = 2;
      }
    }
    else
    {
      v2 = 2;
    }
  }
  free(v11);
  if ( v2 )
    goto LABEL_25;
  *(_BYTE *)v5 = 1;
}

//----- (00000000000410C8) ----------------------------------------------------
void __fastcall sub_410C8(_QWORD *a1)
{
  int v1; // w0
  int v2; // w19
  char v3; // [xsp+9h] [xbp-127h]

  sub_40D9C(a1);
  v2 = v1;
  if ( v1 )
  {
    memset(&v3, 0, 0xFFuLL);
    sub_3E02C(v2);
    __snprintf_chk();
    sub_3E16C();
  }
}

//----- (000000000004117C) ----------------------------------------------------
void __fastcall sub_4117C(__int64 a1, const char *a2, int a3, __int64 a4, int a5, const char *a6, unsigned int a7, __int64 a8, __int64 a9, void **a10, unsigned int *a11)
{
  unsigned int v11; // w28
  const char *v12; // x20
  __int64 v13; // x22
  int v14; // w21
  const char *v15; // x19
  __int64 v16; // x23
  int v17; // w25
  int v18; // w25
  __int64 v19; // x4
  bool v20; // w22
  _BOOL4 v21; // ST6C_4
  void *v22; // x26
  void *v23; // x28
  void *v24; // x27
  bool v25; // w22
  int v26; // w19
  int v27; // w20
  int v28; // w21
  const void *v29; // x19
  void *v30; // x21
  size_t v31; // x27
  char *v32; // x0
  char *v33; // x20
  int v34; // w9
  int v35; // w0
  int v36; // w8
  size_t v37; // x0
  void *v38; // x0
  bool v39; // [xsp+44h] [xbp-80Ch]
  __int64 v40; // [xsp+58h] [xbp-7F8h]
  void *v41; // [xsp+60h] [xbp-7F0h]
  void *v42; // [xsp+70h] [xbp-7E0h]
  int v43; // [xsp+7Ch] [xbp-7D4h]
  int v44; // [xsp+8Ch] [xbp-7C4h]
  unsigned int v45; // [xsp+90h] [xbp-7C0h]
  int v46; // [xsp+94h] [xbp-7BCh]
  int v47; // [xsp+98h] [xbp-7B8h]
  int v48; // [xsp+9Ch] [xbp-7B4h]
  _BYTE *v49; // [xsp+A0h] [xbp-7B0h]
  _DWORD *v50; // [xsp+A8h] [xbp-7A8h]
  int v51; // [xsp+B4h] [xbp-79Ch]
  int v52; // [xsp+B8h] [xbp-798h]
  int v53; // [xsp+1B8h] [xbp-698h]
  unsigned __int8 v54; // [xsp+1E0h] [xbp-670h]
  _BYTE v55[6]; // [xsp+1E2h] [xbp-66Eh]
  unsigned __int8 v56; // [xsp+222h] [xbp-62Eh]
  int v57; // [xsp+2B8h] [xbp-598h]
  int v58; // [xsp+3B8h] [xbp-498h]
  void *v59[32]; // [xsp+4B8h] [xbp-398h]
  void *v60[32]; // [xsp+5B8h] [xbp-298h]
  void *v61[32]; // [xsp+6B8h] [xbp-198h]
  __int128 v62; // [xsp+7B8h] [xbp-98h]
  __int128 v63; // [xsp+7C8h] [xbp-88h]
  __int128 v64; // [xsp+7D8h] [xbp-78h]
  __int128 v65; // [xsp+7E8h] [xbp-68h]

  v43 = a5;
  v11 = a7;
  v12 = a6;
  v13 = a4;
  v14 = a3;
  v15 = a2;
  v16 = a1;
  v51 = 0;
  if ( !a1 )
  {
    memset(v61, 0, 0xFFuLL);
    goto LABEL_17;
  }
  if ( !a2 )
  {
    memset(v61, 0, 0xFFuLL);
    goto LABEL_17;
  }
  if ( !a3 )
  {
    memset(v61, 0, 0xFFuLL);
    goto LABEL_17;
  }
  if ( !a4 )
  {
    memset(v61, 0, 0xFFuLL);
    goto LABEL_17;
  }
  if ( !a5 )
  {
    memset(v61, 0, 0xFFuLL);
    goto LABEL_17;
  }
  if ( !a6 )
  {
    memset(v61, 0, 0xFFuLL);
    goto LABEL_17;
  }
  if ( !a7 )
  {
    memset(v61, 0, 0xFFuLL);
    goto LABEL_17;
  }
  if ( !a11 )
  {
    memset(v61, 0, 0xFFuLL);
LABEL_17:
    __snprintf_chk();
    sub_3E16C();
  }
  v17 = sub_3F674(v15, v14, v12, v11, &v51);
  if ( !v17 && v51 )
  {
    v18 = sub_3F950(v15, v14, v12, v11, (__int64)a10, (__int64)a11);
    if ( !v18 )
      return;
    memset(v61, 0, 0xFFuLL);
    sub_3E02C(v18);
    goto LABEL_69;
  }
  if ( !v17 )
  {
    v17 = 0;
    v49 = 0LL;
    v50 = 0LL;
    v47 = 0;
    v48 = 0;
    v45 = 0;
    v46 = 0;
    v44 = 0;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    if ( !v16 )
    {
      memset(v61, 0, 0xFFuLL);
      __snprintf_chk();
      sub_3E16C();
      v17 = 3;
    }
    v19 = v13;
    v20 = v13 != 0;
    v21 = v15 != 0LL && v14 != 0 && v17 == 0;
    if ( v21 == 1 )
    {
      v40 = v19;
      v42 = malloc(0x14uLL);
      if ( !v42 )
      {
        v22 = 0LL;
        v23 = 0LL;
        v24 = 0LL;
        v17 = 3;
        goto LABEL_46;
      }
    }
    else
    {
      v40 = v19;
      v42 = 0LL;
    }
    if ( (v12 != 0LL && v11 != 0 && v17 == 0) == 1 )
    {
      v24 = malloc(0x14uLL);
      if ( !v24 )
      {
        v23 = 0LL;
        v24 = 0LL;
LABEL_36:
        v17 = 3;
        v22 = v42;
        goto LABEL_46;
      }
    }
    else
    {
      v24 = 0LL;
    }
    v25 = v20 && v43 != 0;
    if ( (v25 && v17 == 0) == 1 )
    {
      v39 = v12 != 0LL && v11 != 0;
      v41 = malloc(0x14uLL);
      if ( !v41 )
      {
        v23 = 0LL;
        goto LABEL_36;
      }
    }
    else
    {
      v39 = v12 != 0LL && v11 != 0;
      v41 = 0LL;
      if ( v17 )
      {
        v22 = v42;
        v23 = 0LL;
        goto LABEL_46;
      }
    }
    LODWORD(v62) = -1742122413;
    WORD2(v62) = 15967;
    *(_QWORD *)((char *)&v62 + 6) = -7568457221430098699LL;
    HIWORD(v62) = 7181;
    LODWORD(v63) = 1213792899;
    v22 = v42;
    WORD2(v63) = -4465;
    BYTE6(v63) = 37;
    *(_QWORD *)((char *)&v63 + 7) = 4415259504977517556LL;
    HIBYTE(v63) = -52;
    LOWORD(v64) = -19789;
    BYTE2(v64) = -119;
    *(_QWORD *)((char *)&v64 + 3) = -6842573514652860424LL;
    *(_WORD *)((char *)&v64 + 11) = 22480;
    BYTE13(v64) = -10;
    HIWORD(v64) = 31853;
    LODWORD(v65) = -1464245533;
    *(_QWORD *)((char *)&v65 + 4) = -9164338727860482321LL;
    HIDWORD(v65) = 748529287;
    if ( v15 != 0LL && v14 != 0 && v17 == 0 )
      v17 = sub_42848((__int64)&v62, 0x40u, (__int64)v15, v14, (__int64)v42, &v48, 0x14u);
    if ( (v39 && v17 == 0) == 1 )
      v17 = sub_42848((__int64)&v62, 0x40u, (__int64)v12, v11, (__int64)v24, &v46, 0x14u);
    v23 = v41;
    if ( (v25 && v17 == 0) == 1 )
      v17 = sub_42848((__int64)&v62, 0x40u, v40, v43, (__int64)v41, &v47, 0x14u);
    if ( !v17 )
    {
      v17 = 0;
LABEL_47:
      if ( v17 )
        goto LABEL_67;
      if ( v16 )
      {
        if ( v22 )
        {
          if ( v23 )
          {
            if ( v24 )
            {
              v27 = v47;
              v26 = v48;
              v28 = v46;
              free(v50);
              v50 = 0LL;
              v17 = sub_3EF6C(
                      (__int64)v22,
                      v26,
                      (__int64)v23,
                      v27,
                      (__int64)v24,
                      v28,
                      &v49,
                      (unsigned int *)&v44,
                      &v50,
                      &v45);
              if ( !v17 )
              {
                v29 = v50;
                v30 = v24;
                v31 = v45;
                if ( *v49 )
                {
                  LODWORD(v62) = 1;
                  if ( !v50 )
                  {
                    memset(v60, 0, 0xFFuLL);
                    __snprintf_chk();
                    goto LABEL_82;
                  }
                  if ( !v45 )
                  {
                    memset(v59, 0, 0xFFuLL);
                    __snprintf_chk();
                    goto LABEL_82;
                  }
                  if ( !a10 )
                  {
                    memset(&v58, 0, 0xFFuLL);
                    __snprintf_chk();
                    sub_3E16C();
                    v17 = 3;
                    v24 = v30;
LABEL_88:
                    memset(&v52, 0, 0xFFuLL);
                    sub_3E02C(v17);
                    goto LABEL_66;
                  }
                  if ( *a10 )
                  {
                    memset(&v57, 0, 0xFFuLL);
                    __snprintf_chk();
LABEL_82:
                    sub_3E16C();
                    v17 = 3;
                    v24 = v30;
                    goto LABEL_83;
                  }
                  if ( !a11 )
                  {
                    memset(&v53, 0, 0xFFuLL);
                    __snprintf_chk();
                    goto LABEL_82;
                  }
                  v58 = 0;
                  v57 = 0;
                  v53 = 0;
                  v61[0] = 0LL;
                  v60[0] = 0LL;
                  v59[0] = 0LL;
                  v52 = 2;
                  sub_4238C(
                    v50,
                    v45,
                    v16 + 40,
                    v61,
                    (unsigned int *)&v58,
                    v59,
                    (unsigned int *)&v53,
                    v60,
                    (unsigned int *)&v57,
                    a10,
                    a11,
                    &v62,
                    &v52);
                  v17 = v35;
                  free(v61[0]);
                  v61[0] = 0LL;
                  free(v60[0]);
                  v60[0] = 0LL;
                  free(v59[0]);
                  v24 = v30;
                  if ( v17 )
                  {
LABEL_83:
                    if ( a10 )
                    {
                      if ( v17 )
                      {
                        free(*a10);
                        *a10 = 0LL;
                      }
                    }
                    goto LABEL_88;
                  }
                  v17 = 0;
                  v36 = *(_DWORD *)(v16 + 72);
                  if ( (_DWORD)v62 != v36 && v36 == 1 )
                  {
                    v17 = 13;
                    goto LABEL_83;
                  }
LABEL_67:
                  free(v22);
                  free(v23);
                  free(v24);
                  free(v50);
                  if ( !v17 )
                    return;
                  goto LABEL_68;
                }
                memset(&v53, 0, 0x6BuLL);
                if ( v29 )
                {
                  if ( (_DWORD)v31 )
                  {
                    if ( a10 )
                    {
                      if ( a11 )
                      {
                        v32 = (char *)malloc((unsigned int)(v31 + 1));
                        v33 = v32;
                        if ( v32 )
                        {
                          memcpy(v32, v29, v31);
                          v33[v31] = 0;
                          atoi(v33);
                          free(v33);
                          v17 = sub_3DD1C();
                          if ( v17 )
                          {
LABEL_98:
                            memset(&v57, 0, 0xFFuLL);
                            sub_3E02C(v17);
                            __snprintf_chk();
                            sub_3E16C();
                            v24 = v30;
                            goto LABEL_67;
                          }
                          v34 = *(_DWORD *)(v16 + 72);
                          if ( v54 != v34 && v34 == 1 )
                          {
                            v17 = 13;
                            goto LABEL_98;
                          }
                          v37 = v56;
                          *a11 = v56;
                          v38 = malloc(v37);
                          *a10 = v38;
                          if ( v38 )
                          {
                            memcpy(v38, v55, *a11);
                            v17 = 0;
                            v24 = v30;
                            goto LABEL_67;
                          }
                        }
                        v17 = 2;
                        goto LABEL_98;
                      }
                      memset(&v58, 0, 0xFFuLL);
                      __snprintf_chk();
                    }
                    else
                    {
                      memset(v59, 0, 0xFFuLL);
                      __snprintf_chk();
                    }
                  }
                  else
                  {
                    memset(v60, 0, 0xFFuLL);
                    __snprintf_chk();
                  }
                }
                else
                {
                  memset(v61, 0, 0xFFuLL);
                  __snprintf_chk();
                }
                sub_3E16C();
                v17 = 3;
                goto LABEL_98;
              }
LABEL_65:
              memset(&v52, 0, 0xFFuLL);
              sub_3E02C(v17);
LABEL_66:
              __snprintf_chk();
              sub_3E16C();
              goto LABEL_67;
            }
            memset(&v58, 0, 0xFFuLL);
            __snprintf_chk();
          }
          else
          {
            memset(v59, 0, 0xFFuLL);
            __snprintf_chk();
          }
        }
        else
        {
          memset(v60, 0, 0xFFuLL);
          __snprintf_chk();
        }
      }
      else
      {
        memset(v61, 0, 0xFFuLL);
        __snprintf_chk();
      }
      sub_3E16C();
      v17 = 3;
      goto LABEL_65;
    }
LABEL_46:
    memset(v61, 0, 0xFFuLL);
    sub_3E02C(v17);
    __snprintf_chk();
    sub_3E16C();
    goto LABEL_47;
  }
LABEL_68:
  memset(v61, 0, 0xFFuLL);
  sub_3E02C(v17);
LABEL_69:
  __snprintf_chk();
  sub_3E16C();
}

//----- (0000000000042060) ----------------------------------------------------
void __fastcall sub_42060(const void *a1, unsigned int a2, const void *a3, unsigned int a4, const void *a5, unsigned int a6, const void *a7, unsigned int a8, __int64 a9, int a10, unsigned int a11, _QWORD *a12, _DWORD *a13)
{
  unsigned int v13; // w24
  unsigned int v14; // w26
  unsigned int v15; // w27
  unsigned int v16; // w23
  const void *v17; // x28
  const void *v18; // x20
  char *v19; // x19
  int v20; // w21
  void *v21; // x12
  void *v22; // x22
  unsigned int v23; // w21
  void *v24; // x0
  const void *v25; // x23
  char *v26; // x20
  char *v27; // x22
  int v28; // w0
  size_t v29; // x20
  _DWORD *v30; // x0
  int v31; // w13
  __int64 v32; // x0
  unsigned int v33; // w1
  void *v34; // x27
  size_t v35; // [xsp+20h] [xbp-1A0h]
  size_t v36; // [xsp+28h] [xbp-198h]
  size_t v37; // [xsp+30h] [xbp-190h]
  size_t v38; // [xsp+38h] [xbp-188h]
  const void *v39; // [xsp+40h] [xbp-180h]
  const void *v40; // [xsp+48h] [xbp-178h]
  unsigned int v41; // [xsp+64h] [xbp-15Ch]
  int v42; // [xsp+68h] [xbp-158h]

  v13 = a8;
  v14 = a6;
  v15 = a4;
  v16 = a2;
  v17 = a3;
  v18 = a1;
  v19 = 0LL;
  v41 = 0;
  v20 = 3;
  if ( !a1 || !a2 || !a3 || !a5 || !a6 || !a7 || !a8 || !a9 || a11 > 1 || !a12 )
  {
    v21 = 0LL;
    v22 = 0LL;
    goto LABEL_27;
  }
  v21 = 0LL;
  v22 = 0LL;
  if ( !a13 )
    goto LABEL_27;
  v35 = a2;
  v36 = a4;
  v37 = a6;
  v38 = a8;
  v39 = a5;
  v40 = a7;
  v23 = a2 + a4 + a6 + a8 + 20;
  v19 = (char *)malloc(v23);
  if ( !v19 )
  {
    v19 = 0LL;
    goto LABEL_18;
  }
  v24 = malloc(v23 + 16);
  if ( !v24 )
  {
LABEL_18:
    v21 = 0LL;
    v22 = 0LL;
    v20 = 2;
    goto LABEL_27;
  }
  *(_DWORD *)v19 = a11;
  *((_DWORD *)v19 + 1) = v16;
  v25 = v24;
  memcpy(v19 + 8, v18, v35);
  v26 = &v19[v35 + 8];
  *(_DWORD *)v26 = v15;
  v26 += 4;
  memcpy(v26, v17, v36);
  *(_DWORD *)&v26[v36] = v14;
  v27 = &v26[v36 + 4];
  memcpy(v27, v39, v37);
  *(_DWORD *)&v27[v37] = v13;
  memcpy(&v27[v37 + 4], v40, v38);
  v28 = sub_42B80(*(_QWORD *)a9, *(_DWORD *)(a9 + 8), v19, v23, (__int64)v25, &v41, v23 + 16);
  v29 = v41;
  v20 = v28;
  if ( v28 )
  {
    v22 = 0LL;
  }
  else
  {
    v30 = malloc(v41 + 36);
    v22 = v30;
    if ( v30 )
    {
      v31 = *(_DWORD *)(a9 + 28);
      *v30 = 1;
      v30[1] = v31;
      v30[2] = a10;
      v30[3] = v29 + 20;
      memcpy(v30 + 4, v25, v29);
      v32 = *(_QWORD *)(a9 + 16);
      v33 = *(_DWORD *)(a9 + 24);
      v42 = 0;
      v20 = sub_42848(v32, v33, (__int64)v22, (signed int)v29 + 16, (__int64)v22 + v29 + 16, &v42, 0x14u);
      if ( v20 || v42 == 20 )
      {
        if ( !v20 )
        {
          v20 = 0;
          *a12 = v22;
          v22 = 0LL;
          *a13 = v29 + 36;
        }
      }
      else
      {
        v20 = 5;
      }
    }
    else
    {
      v20 = 2;
    }
  }
  v21 = (void *)v25;
LABEL_27:
  v34 = v21;
  free(v19);
  free(v34);
  free(v22);
  if ( v20 )
  {
    memset(&v42, 0, 0xFFuLL);
    sub_3E02C(v20);
    __snprintf_chk();
    sub_3E16C();
  }
}

//----- (000000000004238C) ----------------------------------------------------
void __fastcall sub_4238C(_DWORD *a1, int a2, __int64 a3, _QWORD *a4, unsigned int *a5, _QWORD *a6, unsigned int *a7, _QWORD *a8, unsigned int *a9, _QWORD *a10, unsigned int *a11, _DWORD *a12, _DWORD *a13)
{
  unsigned int *v13; // x25
  _QWORD *v14; // x26
  __int64 v15; // x23
  __int64 v16; // x24
  _DWORD *v17; // x19
  int v18; // w21
  void *v19; // x20
  unsigned int v20; // w8
  int v21; // w21
  int v22; // w0
  bool v23; // zf
  char *v24; // x24
  unsigned int v25; // [xsp+8h] [xbp-198h]
  int v26; // [xsp+14h] [xbp-18Ch]
  _QWORD *v27; // [xsp+20h] [xbp-180h]
  _QWORD *v28; // [xsp+28h] [xbp-178h]
  unsigned int *v29; // [xsp+30h] [xbp-170h]
  _DWORD *v30; // [xsp+38h] [xbp-168h]
  int v31; // [xsp+40h] [xbp-160h]
  int v32; // [xsp+44h] [xbp-15Ch]
  char v33; // [xsp+49h] [xbp-157h]

  v13 = a5;
  v14 = a4;
  v15 = a3;
  v16 = (__int64)a1;
  v17 = 0LL;
  v18 = 3;
  v31 = 0;
  v32 = 0;
  v30 = 0LL;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          if ( a5 )
          {
            if ( a6 )
            {
              if ( a7 )
              {
                if ( a8 )
                {
                  if ( a9 )
                  {
                    if ( a10 )
                    {
                      if ( a11 )
                      {
                        if ( a12 )
                        {
                          v19 = 0LL;
                          if ( a13 )
                          {
                            if ( *a1 != 1 || (a1[1] & 0xFFFFFFFE) != 2 )
                            {
                              v17 = 0LL;
                              v19 = 0LL;
                              v18 = 3;
                            }
                            else
                            {
                              v27 = a8;
                              v28 = a6;
                              v29 = a7;
                              *a12 = a1[2];
                              v19 = malloc(0x14uLL);
                              if ( v19 )
                              {
                                v20 = *(_DWORD *)(v16 + 12);
                                if ( v20 < 0x15 )
                                {
                                  v17 = 0LL;
                                  v18 = 3;
                                }
                                else
                                {
                                  v21 = v20 - 4;
                                  v26 = *(_DWORD *)(v16 + 12);
                                  v17 = malloc(v20 - 4);
                                  if ( v17 )
                                  {
                                    v25 = v21;
                                    v22 = sub_42848(
                                            *(_QWORD *)(v15 + 16),
                                            *(_DWORD *)(v15 + 24),
                                            v16,
                                            v21,
                                            (__int64)v19,
                                            &v32,
                                            0x14u);
                                    if ( v32 == 20 )
                                      v23 = 0;
                                    else
                                      v23 = v22 == 0;
                                    if ( v23 )
                                      v18 = 5;
                                    else
                                      v18 = v22;
                                    if ( v32 == 20 && v22 == 0 )
                                    {
                                      v24 = (char *)(v16 + 16);
                                      if ( (unsigned int)memcmp(&v24[v26 - 20], v19, 0x14uLL) )
                                      {
                                        v18 = 5;
                                      }
                                      else
                                      {
                                        v18 = sub_42ED4(
                                                *(_QWORD *)v15,
                                                *(_DWORD *)(v15 + 8),
                                                v24,
                                                v26 - 20,
                                                v17,
                                                &v31,
                                                v25);
                                        if ( !v18 )
                                        {
                                          *a13 = *v17;
                                          v30 = v17 + 1;
                                          v18 = sub_426D0(v14, v13, (const void **)&v30);
                                          if ( !v18 )
                                          {
                                            v18 = sub_426D0(v28, v29, (const void **)&v30);
                                            if ( !v18 )
                                            {
                                              v18 = sub_426D0(v27, a9, (const void **)&v30);
                                              if ( !v18 )
                                                v18 = sub_426D0(a10, a11, (const void **)&v30);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v17 = 0LL;
                                    v18 = 2;
                                  }
                                }
                              }
                              else
                              {
                                v17 = 0LL;
                                v19 = 0LL;
                                v18 = 2;
                              }
                            }
                          }
                        }
                        else
                        {
                          v19 = 0LL;
                        }
                      }
                      else
                      {
                        v19 = 0LL;
                      }
                    }
                    else
                    {
                      v19 = 0LL;
                    }
                  }
                  else
                  {
                    v19 = 0LL;
                  }
                }
                else
                {
                  v19 = 0LL;
                }
              }
              else
              {
                v19 = 0LL;
              }
            }
            else
            {
              v19 = 0LL;
            }
          }
          else
          {
            v19 = 0LL;
          }
        }
        else
        {
          v19 = 0LL;
        }
      }
      else
      {
        v19 = 0LL;
      }
    }
    else
    {
      v19 = 0LL;
    }
  }
  else
  {
    v19 = 0LL;
  }
  free(v19);
  free(v17);
  if ( v18 )
  {
    memset(&v33, 0, 0xFFuLL);
    sub_3E02C(v18);
    __snprintf_chk();
    sub_3E16C();
  }
}

//----- (00000000000426D0) ----------------------------------------------------
__int64 __fastcall sub_426D0(_QWORD *a1, unsigned int *a2, const void **a3)
{
  const void **v3; // x20
  unsigned int *v4; // x19
  _QWORD *v5; // x21
  __int64 v6; // x22
  unsigned int v7; // w19
  void *v8; // x0
  char *v9; // x21
  size_t v10; // x19
  __int64 result; // x0
  char *v12; // x8
  __int64 v13; // [xsp+0h] [xbp-140h]
  char v14; // [xsp+9h] [xbp-137h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = _stack_chk_guard;
  if ( a2 )
  {
    *a2 = *(_DWORD *)*a3;
    *a3 = (char *)*a3 + 4;
    if ( *a2 <= 0x2710 )
    {
      v8 = malloc(*a2 + 1);
      *v5 = v8;
      if ( v8 )
      {
        v9 = (char *)*v3;
        v10 = *v4;
        result = (__int64)memcpy(v8, *v3, v10);
        v12 = &v9[v10];
        v7 = 0;
        *v3 = v12;
        goto LABEL_9;
      }
      v7 = 2;
    }
    else
    {
      v7 = 3;
    }
  }
  else
  {
    memset(&v14, 0, 0xFFuLL);
    __snprintf_chk();
    sub_3E16C();
    v7 = 3;
  }
  memset(&v14, 0, 0xFFuLL);
  sub_3E02C(v7);
  __snprintf_chk();
  result = sub_3E16C();
LABEL_9:
  if ( v6 == v13 )
    result = v7;
  return result;
}

//----- (0000000000042848) ----------------------------------------------------
__int64 __fastcall sub_42848(__int64 a1, unsigned int a2, __int64 a3, int a4, __int64 a5, _DWORD *a6, unsigned int a7)
{
  _DWORD *v7; // x19
  __int64 v8; // x20
  unsigned int v9; // w24
  __int64 v10; // x23
  __int64 v11; // x25
  unsigned int v12; // w19
  __int64 result; // x0
  void *v14; // x0
  __int64 v15; // [xsp+0h] [xbp-1B0h]
  char v16; // [xsp+69h] [xbp-147h]
  __int64 v17; // [xsp+168h] [xbp-48h]

  v7 = a6;
  v8 = a5;
  v9 = a2;
  v10 = a1;
  v11 = _stack_chk_guard;
  if ( !a1 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a2 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a3 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a4 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a5 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a6 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( a7 <= 0x13 )
  {
    memset(&v16, 0, 0xFFuLL);
LABEL_15:
    __snprintf_chk();
    sub_3E16C();
    HMAC_CTX_init(&v15);
    v12 = 3;
LABEL_16:
    HMAC_CTX_cleanup(&v15);
    memset(&v16, 0, 0xFFuLL);
    sub_3E02C(v12);
    __snprintf_chk();
    result = sub_3E16C();
    goto LABEL_17;
  }
  HMAC_CTX_init(&v15);
  v14 = EVP_sha1();
  if ( HMAC_Init_ex(&v15, v10, v9, (__int64)v14) != 1 )
  {
    memset(&v16, 0, 0xFFuLL);
LABEL_26:
    __snprintf_chk();
    sub_3E16C();
    v12 = 5;
    goto LABEL_16;
  }
  if ( (unsigned int)HMAC_Update((__int64)&v15) != 1 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_26;
  }
  if ( (unsigned int)HMAC_Final((__int64)&v15, v8, v7) != 1 )
  {
    memset(&v16, 0, 0xFFuLL);
    goto LABEL_26;
  }
  result = (__int64)HMAC_CTX_cleanup(&v15);
  v12 = 0;
LABEL_17:
  if ( v11 == v17 )
    result = v12;
  return result;
}

//----- (0000000000042B80) ----------------------------------------------------
__int64 __fastcall sub_42B80(__int64 a1, int a2, char *a3, unsigned int a4, __int64 a5, _DWORD *a6, unsigned int a7)
{
  _DWORD *v7; // x19
  __int64 v8; // x20
  int v9; // w21
  char *v10; // x22
  __int64 v11; // x23
  __int64 v12; // x24
  unsigned int v13; // w19
  __int64 result; // x0
  unsigned int *v15; // x0
  int v16; // [xsp+8h] [xbp-1E8h]
  unsigned int v17; // [xsp+Ch] [xbp-1E4h]
  char v18; // [xsp+11h] [xbp-1DFh]
  unsigned int *v19[19]; // [xsp+110h] [xbp-E0h]
  __int64 v20; // [xsp+1A8h] [xbp-48h]

  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a1;
  v12 = _stack_chk_guard;
  v16 = 0;
  v17 = a7;
  if ( !a1 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a3 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a4 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a5 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( !a6 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( a2 != 16 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_15;
  }
  if ( a7 < a4 )
  {
    memset(&v18, 0, 0xFFuLL);
LABEL_15:
    __snprintf_chk();
    sub_3E16C();
    EVP_CIPHER_CTX_init(v19);
    v13 = 3;
LABEL_16:
    EVP_CIPHER_CTX_cleanup((void **)v19);
    memset(&v18, 0, 0xFFuLL);
    sub_3E02C(v13);
    __snprintf_chk();
    result = sub_3E16C();
    goto LABEL_17;
  }
  EVP_CIPHER_CTX_init(v19);
  v15 = (unsigned int *)EVP_aes_128_cbc();
  if ( (unsigned int)EVP_EncryptInit_ex(v19, v15, 0LL, v11, &unk_CFD6A) != 1 )
  {
    memset(&v18, 0, 0xFFuLL);
LABEL_26:
    __snprintf_chk();
    sub_3E16C();
    v13 = 5;
    goto LABEL_16;
  }
  if ( (unsigned int)EVP_EncryptUpdate((signed int *)v19, v8, (int *)&v17, v10, v9) != 1 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_26;
  }
  if ( (unsigned int)EVP_EncryptFinal_ex((__int64 *)v19, v8 + (signed int)v17, &v16) != 1 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_26;
  }
  *v7 = v16 + v17;
  result = EVP_CIPHER_CTX_cleanup((void **)v19);
  v13 = 0;
LABEL_17:
  if ( v12 == v20 )
    result = v13;
  return result;
}

//----- (0000000000042ED4) ----------------------------------------------------
__int64 __fastcall sub_42ED4(__int64 a1, int a2, char *a3, unsigned int a4, void *a5, _DWORD *a6, unsigned int a7)
{
  _DWORD *v7; // x19
  void *v8; // x20
  int v9; // w21
  char *v10; // x22
  __int64 v11; // x23
  __int64 v12; // x24
  unsigned int v13; // w19
  __int64 result; // x0
  unsigned int *v15; // x0
  int v16; // [xsp+8h] [xbp-1E8h]
  unsigned int v17; // [xsp+Ch] [xbp-1E4h]
  char v18; // [xsp+11h] [xbp-1DFh]
  unsigned int *v19[19]; // [xsp+110h] [xbp-E0h]
  __int64 v20; // [xsp+1A8h] [xbp-48h]

  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a1;
  v12 = _stack_chk_guard;
  v16 = 0;
  v17 = a7;
  if ( !a1 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_14;
  }
  if ( !a3 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_14;
  }
  if ( !a4 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_14;
  }
  if ( !a5 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_14;
  }
  if ( !a6 )
  {
    memset(&v18, 0, 0xFFuLL);
    goto LABEL_14;
  }
  if ( a2 != 16 || a7 < a4 )
  {
    memset(&v18, 0, 0xFFuLL);
LABEL_14:
    __snprintf_chk();
    sub_3E16C();
    EVP_CIPHER_CTX_init(v19);
    v13 = 3;
LABEL_15:
    EVP_CIPHER_CTX_cleanup((void **)v19);
    memset(&v18, 0, 0xFFuLL);
    sub_3E02C(v13);
    __snprintf_chk();
    result = sub_3E16C();
    goto LABEL_16;
  }
  EVP_CIPHER_CTX_init(v19);
  v15 = (unsigned int *)EVP_aes_128_cbc();
  if ( (unsigned int)EVP_DecryptInit_ex(v19, v15, 0LL, v11, &unk_CFD6A) != 1
    || (unsigned int)EVP_DecryptUpdate((signed int *)v19, v8, (int *)&v17, v10, v9) != 1
    || (unsigned int)EVP_DecryptFinal_ex((__int64 *)v19, (unsigned __int64)v8 + (signed int)v17, (unsigned int *)&v16) != 1 )
  {
    memset(&v18, 0, 0xFFuLL);
    __snprintf_chk();
    sub_3E16C();
    v13 = 5;
    goto LABEL_15;
  }
  *v7 = v16 + v17;
  result = EVP_CIPHER_CTX_cleanup((void **)v19);
  v13 = 0;
LABEL_16:
  if ( v12 == v20 )
    result = v13;
  return result;
}

//----- (00000000000431C8) ----------------------------------------------------
void *__fastcall EVP_get_cipherbynid(signed int a1)
{
  if ( a1 > 97 )
  {
    if ( a1 > 422 )
    {
      if ( a1 == 423 )
        return EVP_aes_192_cbc();
      if ( a1 == 427 )
        return EVP_aes_256_cbc();
    }
    else
    {
      if ( a1 == 98 )
        return sub_45898();
      if ( a1 == 419 )
        return EVP_aes_128_cbc();
    }
    return 0LL;
  }
  if ( a1 == 37 )
    return EVP_rc2_cbc();
  if ( a1 != 43 )
  {
    if ( a1 == 44 )
      return EVP_des_ede3_cbc();
    return 0LL;
  }
  return EVP_des_cbc();
}

//----- (0000000000043234) ----------------------------------------------------
void *__fastcall EVP_CIPHER_CTX_init(void *a1)
{
  return memset(a1, 0, 0x98uLL);
}

//----- (0000000000043250) ----------------------------------------------------
void *EVP_CIPHER_CTX_new()
{
  void *v0; // x0
  void *v1; // x19

  v0 = malloc(0x98uLL);
  v1 = v0;
  if ( v0 )
    memset(v0, 0, 0x98uLL);
  return v1;
}

//----- (000000000004328C) ----------------------------------------------------
signed __int64 __fastcall EVP_CIPHER_CTX_cleanup(void **a1)
{
  void **v1; // x19
  unsigned int *v2; // x8
  void (*v3)(void); // x9

  v1 = a1;
  v2 = (unsigned int *)*a1;
  if ( *a1 )
  {
    v3 = (void (*)(void))*((_QWORD *)v2 + 6);
    if ( v3 )
    {
      v3();
      v2 = (unsigned int *)*v1;
    }
    OPENSSL_cleanse(v1[2], v2[4]);
  }
  free(v1[2]);
  memset(v1, 0, 0x98uLL);
  return 1LL;
}

//----- (00000000000432EC) ----------------------------------------------------
void __fastcall EVP_CIPHER_CTX_free(void **a1)
{
  void **v1; // x19
  unsigned int *v2; // x8
  void (*v3)(void); // x9

  v1 = a1;
  if ( a1 )
  {
    v2 = (unsigned int *)*a1;
    if ( *a1 )
    {
      v3 = (void (*)(void))*((_QWORD *)v2 + 6);
      if ( v3 )
      {
        v3();
        v2 = (unsigned int *)*v1;
      }
      OPENSSL_cleanse(v1[2], v2[4]);
    }
    free(v1[2]);
    memset(v1, 0, 0x98uLL);
    free(v1);
  }
}

//----- (000000000004335C) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_CTX_copy(__int64 *a1, const void **a2)
{
  const void **v2; // x20
  __int64 *v3; // x19
  __int64 v4; // x8
  void (*v5)(void); // x9
  size_t v6; // x0
  void *v7; // x0
  size_t v8; // x2
  __int64 result; // x0
  int v10; // w2
  __int16 v11; // w4

  v2 = a2;
  v3 = a1;
  if ( !a2 || !*a2 )
  {
    v10 = 108;
    v11 = 125;
LABEL_15:
    ERR_put_error(30, 0LL, v10, (__int64)"external/boringssl/src/crypto/cipher/cipher.c", v11);
    return 0LL;
  }
  v4 = *a1;
  if ( *a1 )
  {
    v5 = *(void (**)(void))(v4 + 48);
    if ( v5 )
    {
      v5();
      v4 = *v3;
    }
    OPENSSL_cleanse((void *)v3[2], *(unsigned int *)(v4 + 16));
  }
  free((void *)v3[2]);
  memset(v3, 0, 0x98uLL);
  memcpy(v3, v2, 0x98uLL);
  if ( !v2[2] )
    goto LABEL_12;
  v6 = *((unsigned int *)*v2 + 4);
  if ( !(_DWORD)v6 )
    goto LABEL_12;
  v7 = malloc(v6);
  v3[2] = (__int64)v7;
  if ( !v7 )
  {
    *v3 = 0LL;
    v10 = 65;
    v11 = 136;
    goto LABEL_15;
  }
  v8 = *((unsigned int *)*v2 + 4);
  if ( (_DWORD)v8 )
    memcpy(v7, v2[2], v8);
LABEL_12:
  if ( !(*((_BYTE *)*v2 + 21) & 0x10) )
    return 1LL;
  result = (*((__int64 (__fastcall **)(const void **, signed __int64, _QWORD, __int64 *))*v2 + 7))(v2, 8LL, 0LL, v3);
  if ( (_DWORD)result )
    return 1LL;
  *v3 = 0LL;
  return result;
}

//----- (0000000000043488) ----------------------------------------------------
__int64 __fastcall EVP_CipherInit_ex(unsigned int **a1, unsigned int *a2, __int64 a3, __int64 a4, const void *a5, int a6)
{
  const void *v6; // x20
  __int64 v7; // x21
  unsigned int *v8; // x23
  void **v9; // x19
  unsigned int v10; // w22
  unsigned int *v11; // x8
  void (*v12)(void); // x9
  size_t v13; // x0
  void *v14; // x0
  int v15; // w2
  __int16 v16; // w4
  unsigned int v17; // w8
  unsigned int v18; // w9
  size_t v19; // x2
  void *v20; // x0
  const void *v21; // x1
  __int64 (__fastcall *v22)(void **, _QWORD, _QWORD, _QWORD); // x8
  int v23; // w0
  int v24; // w2
  __int16 v25; // w4
  __int64 result; // x0
  size_t v27; // x2
  __int64 (__fastcall **v28)(void **, __int64, const void *, _QWORD); // x8

  v6 = a5;
  v7 = a4;
  v8 = a2;
  v9 = (void **)a1;
  if ( !a6 )
  {
    v10 = 0;
    goto LABEL_7;
  }
  if ( a6 != -1 )
  {
    v10 = 1;
LABEL_7:
    *((_DWORD *)a1 + 7) = v10;
    v11 = *a1;
    if ( !a2 )
      goto LABEL_15;
    goto LABEL_8;
  }
  v10 = *((_DWORD *)a1 + 7);
  v11 = *a1;
  if ( !a2 )
  {
LABEL_15:
    if ( !v11 )
    {
      v15 = 114;
      v16 = 197;
      goto LABEL_34;
    }
LABEL_20:
    v18 = v11[5];
    if ( !(v18 & 0x100) )
      goto LABEL_21;
    goto LABEL_43;
  }
LABEL_8:
  if ( v11 )
  {
    v12 = (void (*)(void))*((_QWORD *)v11 + 6);
    if ( v12 )
    {
      v12();
      v11 = (unsigned int *)*v9;
    }
    OPENSSL_cleanse(v9[2], v11[4]);
    free(v9[2]);
    memset(v9, 0, 0x98uLL);
    *((_DWORD *)v9 + 7) = v10;
  }
  *v9 = v8;
  v13 = v8[4];
  if ( (_DWORD)v13 )
  {
    v14 = malloc(v13);
    v9[2] = v14;
    if ( !v14 )
    {
      *v9 = 0LL;
      v15 = 65;
      v16 = 179;
LABEL_34:
      ERR_put_error(30, 0LL, v15, (__int64)"external/boringssl/src/crypto/cipher/cipher.c", v16);
      return 0LL;
    }
  }
  else
  {
    v9[2] = 0LL;
  }
  v17 = v8[2];
  *((_DWORD *)v9 + 8) = 0;
  *((_DWORD *)v9 + 6) = v17;
  if ( !(*((_BYTE *)v8 + 21) & 2) )
  {
    v11 = v8;
    goto LABEL_20;
  }
  v22 = (__int64 (__fastcall *)(void **, _QWORD, _QWORD, _QWORD))*((_QWORD *)v8 + 7);
  if ( !v22 )
  {
    v24 = 104;
    v25 = 554;
LABEL_32:
    ERR_put_error(30, 0LL, v24, (__int64)"external/boringssl/src/crypto/cipher/cipher.c", v25);
    goto LABEL_33;
  }
  v23 = v22(v9, 0LL, 0LL, 0LL);
  if ( v23 == -1 )
  {
    v24 = 105;
    v25 = 560;
    goto LABEL_32;
  }
  if ( !v23 )
  {
LABEL_33:
    *v9 = 0LL;
    v15 = 107;
    v16 = 192;
    goto LABEL_34;
  }
  v11 = (unsigned int *)*v9;
  v18 = *((_DWORD *)*v9 + 5);
  if ( !(v18 & 0x100) )
  {
LABEL_21:
    switch ( v18 & 0x3F )
    {
      case 0u:
      case 1u:
        goto LABEL_43;
      case 2u:
        goto LABEL_37;
      case 3u:
        *((_DWORD *)v9 + 26) = 0;
LABEL_37:
        if ( v6 )
        {
          v27 = v11[3];
          if ( (_DWORD)v27 )
          {
            memcpy((char *)v9 + 36, v6, v27);
            v11 = (unsigned int *)*v9;
          }
        }
        v19 = v11[3];
        if ( !(_DWORD)v19 )
          goto LABEL_43;
        v20 = (char *)v9 + 52;
        v21 = (char *)v9 + 36;
        goto LABEL_42;
      case 4u:
      case 5u:
        *((_DWORD *)v9 + 26) = 0;
        if ( v6 )
        {
          v19 = v11[3];
          if ( (_DWORD)v19 )
          {
            v20 = (char *)v9 + 52;
            v21 = v6;
LABEL_42:
            memcpy(v20, v21, v19);
          }
        }
        goto LABEL_43;
      default:
        return 0LL;
    }
    return 0LL;
  }
LABEL_43:
  v28 = (__int64 (__fastcall **)(void **, __int64, const void *, _QWORD))*v9;
  if ( v7 || *((_BYTE *)v28 + 20) & 0x80 )
  {
    result = v28[4](v9, v7, v6, v10);
    if ( !(_DWORD)result )
      return result;
    v28 = (__int64 (__fastcall **)(void **, __int64, const void *, _QWORD))*v9;
  }
  *((_DWORD *)v9 + 25) = 0;
  *((_DWORD *)v9 + 27) = 0;
  result = 1LL;
  *((_DWORD *)v9 + 28) = *((_DWORD *)v28 + 1) - 1;
  return result;
}

//----- (00000000000436F4) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_CTX_ctrl(__int64 a1)
{
  __int64 (*v1)(void); // x8
  __int64 result; // x0
  int v3; // w2
  __int16 v4; // w4

  if ( *(_QWORD *)a1 )
  {
    v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 56LL);
    if ( v1 )
    {
      result = v1();
      if ( (_DWORD)result != -1 )
        return result;
      v3 = 105;
      v4 = 560;
    }
    else
    {
      v3 = 104;
      v4 = 554;
    }
  }
  else
  {
    v3 = 114;
    v4 = 549;
  }
  ERR_put_error(30, 0LL, v3, (__int64)"external/boringssl/src/crypto/cipher/cipher.c", v4);
  return 0LL;
}

//----- (0000000000043770) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_CTX_flags(__int64 a1)
{
  return *(_DWORD *)(*(_QWORD *)a1 + 20LL) & 0xFFFFFFC0;
}

//----- (0000000000043780) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_CTX_mode(__int64 a1)
{
  return *(_DWORD *)(*(_QWORD *)a1 + 20LL) & 0x3F;
}

//----- (0000000000043790) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_CTX_iv_length(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 12LL);
}

//----- (000000000004379C) ----------------------------------------------------
__int64 __fastcall EVP_EncryptInit_ex(unsigned int **a1, unsigned int *a2, __int64 a3, __int64 a4, const void *a5)
{
  return EVP_CipherInit_ex(a1, a2, a3, a4, a5, 1);
}

//----- (00000000000437A4) ----------------------------------------------------
__int64 __fastcall EVP_DecryptInit_ex(unsigned int **a1, unsigned int *a2, __int64 a3, __int64 a4, const void *a5)
{
  return EVP_CipherInit_ex(a1, a2, a3, a4, a5, 0);
}

//----- (00000000000437AC) ----------------------------------------------------
__int64 __fastcall EVP_EncryptUpdate(signed int *a1, __int64 a2, int *a3, char *a4, int a5)
{
  signed int *v5; // x20
  __int64 v6; // x8
  int v7; // w22
  char *v8; // x21
  int *v9; // x19
  __int64 v10; // x23
  __int64 v11; // x9
  int v12; // w26
  char *v13; // x0
  int v14; // w27
  int v15; // w0
  __int64 result; // x0
  _DWORD *v17; // x9
  int v18; // w24
  int v19; // w22

  v5 = a1;
  v6 = *(_QWORD *)a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  if ( *(_BYTE *)(*(_QWORD *)a1 + 21LL) & 4 )
  {
    v15 = (*(__int64 (**)(void))(v6 + 40))();
    if ( v15 & 0x80000000 )
      return 0LL;
    *v9 = v15;
    return 1LL;
  }
  if ( a5 <= 0 )
  {
    *a3 = 0;
    return a5 == 0;
  }
  v11 = a1[25];
  if ( (_DWORD)v11 )
  {
    v12 = *(_DWORD *)(v6 + 4);
    v13 = (char *)a1 + v11 + 68;
    v14 = v12 - v11;
    if ( v12 - (signed int)v11 > a5 )
    {
      memcpy(v13, a4, a5);
      v5[25] += v7;
      *v9 = 0;
      return 1LL;
    }
    if ( v12 != (_DWORD)v11 )
    {
      memcpy(v13, a4, v14);
      v6 = *(_QWORD *)v5;
    }
    result = (*(__int64 (__fastcall **)(signed int *, __int64, signed int *, _QWORD))(v6 + 40))(v5, v10, v5 + 17, v12);
    if ( (_DWORD)result )
    {
      v7 -= v14;
      v8 += v14;
      v10 += v12;
      v17 = v5 + 28;
      goto LABEL_16;
    }
  }
  else
  {
    v17 = a1 + 28;
    if ( a1[28] & a5 )
    {
      v12 = 0;
LABEL_16:
      *v9 = v12;
      v18 = *v17 & v7;
      v19 = v7 - v18;
      if ( v19 >= 1 )
      {
        result = (*(__int64 (__fastcall **)(signed int *, __int64, char *, _QWORD))(*(_QWORD *)v5 + 40LL))(
                   v5,
                   v10,
                   v8,
                   v19);
        if ( !(_DWORD)result )
          return result;
        *v9 += v19;
      }
      if ( v18 )
        memcpy(v5 + 17, &v8[v19], v18);
      v5[25] = v18;
      return 1LL;
    }
    result = (*(__int64 (**)(void))(v6 + 40))();
    if ( (_DWORD)result )
    {
      *v9 = v7;
      return 1LL;
    }
    *v9 = 0;
  }
  return result;
}

//----- (0000000000043970) ----------------------------------------------------
__int64 __fastcall EVP_EncryptFinal_ex(__int64 *a1, __int64 a2, _DWORD *a3)
{
  __int64 *v3; // x20
  __int64 v4; // x23
  _DWORD *v5; // x19
  __int64 v6; // x22
  __int64 v7; // x21
  __int64 result; // x0
  int v9; // w0
  __int64 v10; // x9

  v3 = a1;
  v4 = *a1;
  v5 = a3;
  v6 = a2;
  if ( *(_BYTE *)(*a1 + 21) & 4 )
  {
    v9 = (*(__int64 (**)(void))(v4 + 40))();
    if ( !(v9 & 0x80000000) )
    {
      *v5 = v9;
      return 1LL;
    }
    return 0LL;
  }
  v7 = *(unsigned int *)(v4 + 4);
  if ( (_DWORD)v7 == 1 )
  {
LABEL_3:
    *a3 = 0;
    return 1LL;
  }
  v10 = *((unsigned int *)a1 + 25);
  if ( *((_BYTE *)a1 + 33) & 8 )
  {
    if ( !(_DWORD)v10 )
      goto LABEL_3;
    ERR_put_error(30, 0LL, 106, (__int64)"external/boringssl/src/crypto/cipher/cipher.c", 352);
    return 0LL;
  }
  if ( (unsigned int)v7 > (unsigned int)v10 )
    memset((char *)a1 + v10 + 68, v7 - v10, (unsigned int)(v7 - 1 - v10) + 1LL);
  result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64, __int64))(v4 + 40))(v3, v6, (__int64)v3 + 68, v7);
  if ( (_DWORD)result )
    *v5 = v7;
  return result;
}

//----- (0000000000043A64) ----------------------------------------------------
__int64 __fastcall EVP_DecryptUpdate(signed int *a1, void *a2, int *a3, char *a4, int a5)
{
  signed int *v5; // x20
  __int64 v6; // x8
  int v7; // w24
  char *v8; // x23
  int *v9; // x19
  __int64 v10; // x21
  size_t v11; // x22
  signed int v12; // w25
  int v13; // w0
  int v14; // w8
  __int64 result; // x0

  v5 = a1;
  v6 = *(_QWORD *)a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = (__int64)a2;
  if ( *(_BYTE *)(*(_QWORD *)a1 + 21LL) & 4 )
  {
    v13 = (*(__int64 (**)(void))(v6 + 40))();
    if ( v13 >= 0 )
      v14 = v13;
    else
      v14 = 0;
    result = v13 >= 0;
    *v9 = v14;
  }
  else
  {
    if ( a5 <= 0 )
    {
      *a3 = 0;
      return a5 == 0;
    }
    if ( *((_BYTE *)a1 + 33) & 8 )
      return EVP_EncryptUpdate(a1, (__int64)a2, a3, a4, a5);
    v11 = *(unsigned int *)(v6 + 4);
    if ( a1[27] )
    {
      if ( (_DWORD)v11 )
        memcpy(a2, a1 + 29, v11);
      v10 += v11;
      v12 = 1;
    }
    else
    {
      v12 = 0;
    }
    result = EVP_EncryptUpdate(v5, v10, v9, v8, v7);
    if ( (_DWORD)result )
    {
      if ( (unsigned int)v11 < 2 || v5[25] )
      {
        v5[27] = 0;
        if ( !v12 )
          return 1LL;
      }
      else
      {
        *v9 -= v11;
        v5[27] = 1;
        memcpy(v5 + 29, (const void *)(v10 + *v9), v11);
        if ( !v12 )
          return 1LL;
      }
      *v9 += v11;
      return 1LL;
    }
  }
  return result;
}

//----- (0000000000043BCC) ----------------------------------------------------
signed __int64 __fastcall EVP_DecryptFinal_ex(__int64 *a1, unsigned __int64 a2, unsigned int *a3)
{
  unsigned int *v3; // x19
  __int64 v4; // x8
  unsigned int v5; // w8
  int v6; // w2
  __int16 v7; // w4
  unsigned int v8; // w0
  unsigned int v10; // w8
  __int64 v11; // x9
  int v12; // w10
  unsigned __int8 v13; // vf
  int v14; // w11
  __int64 v15; // x10
  __int64 v16; // x11
  __int128 *v17; // x12
  _OWORD *v18; // x13
  __int64 v19; // x14
  __int128 v20; // q0
  __int128 v21; // q1
  _BYTE *v22; // x11
  char *v23; // x12
  __int64 v24; // x9
  char v25; // t1

  v3 = a3;
  *a3 = 0;
  v4 = *a1;
  if ( !(*(_BYTE *)(*a1 + 21) & 4) )
  {
    if ( *((_BYTE *)a1 + 33) & 8 )
    {
      if ( !*((_DWORD *)a1 + 25) )
      {
        *a3 = 0;
        return 1LL;
      }
      v6 = 106;
      v7 = 447;
    }
    else
    {
      v5 = *(_DWORD *)(v4 + 4);
      if ( v5 < 2 )
      {
        v10 = 0;
        goto LABEL_13;
      }
      if ( *((_DWORD *)a1 + 25) || !*((_DWORD *)a1 + 27) )
      {
        v6 = 123;
        v7 = 456;
      }
      else
      {
        v11 = v5 - 1;
        v12 = *((unsigned __int8 *)a1 + v11 + 116);
        if ( *((_BYTE *)a1 + v11 + 116) )
        {
          v13 = __OFSUB__(v5, v12);
          v10 = v5 - v12;
          if ( !(((v10 & 0x80000000) != 0) ^ v13) )
          {
            v14 = 0;
            do
            {
              if ( *((unsigned __int8 *)a1 + (unsigned int)v11 + 116) != v12 )
              {
                v6 = 101;
                v7 = 471;
                goto LABEL_10;
              }
              ++v14;
              LODWORD(v11) = v11 - 1;
            }
            while ( v14 < v12 );
            if ( (signed int)v10 < 1 )
              goto LABEL_13;
            if ( v10 >= 0x20 )
            {
              v16 = v10 & 0x1F;
              v15 = v10 - v16;
              if ( v10 != v16 )
              {
                if ( (unsigned __int64)a1 + v10 + 116 <= a2 || (unsigned __int64)a1 + 116 >= a2 + v10 )
                {
                  v17 = (__int128 *)((char *)a1 + 132);
                  v18 = (_OWORD *)(a2 + 16);
                  v19 = v10 - v16;
                  do
                  {
                    v20 = *(v17 - 1);
                    v21 = *v17;
                    v17 += 2;
                    v19 -= 32LL;
                    *(v18 - 1) = v20;
                    *v18 = v21;
                    v18 += 2;
                  }
                  while ( v19 );
                  if ( !(v10 & 0x1F) )
                    goto LABEL_13;
                }
                else
                {
                  v15 = 0LL;
                }
              }
            }
            else
            {
              v15 = 0LL;
            }
            v22 = (_BYTE *)(a2 + v15);
            v23 = (char *)a1 + v15 + 116;
            v24 = v10 - v15;
            do
            {
              v25 = *v23++;
              --v24;
              *v22++ = v25;
            }
            while ( v24 );
LABEL_13:
            *a3 = v10;
            return 1LL;
          }
        }
        v6 = 101;
        v7 = 465;
      }
    }
LABEL_10:
    ERR_put_error(30, 0LL, v6, (__int64)"external/boringssl/src/crypto/cipher/cipher.c", v7);
    return 0LL;
  }
  v8 = (*(__int64 (**)(void))(v4 + 40))();
  if ( v8 & 0x80000000 )
    return 0LL;
  *v3 = v8;
  return 1LL;
}

//----- (0000000000043D98) ----------------------------------------------------
__int64 __fastcall EVP_Cipher(__int64 a1)
{
  return (*(__int64 (**)(void))(*(_QWORD *)a1 + 40LL))();
}

//----- (0000000000043DA4) ----------------------------------------------------
__int64 __fastcall EVP_CipherUpdate(signed int *a1, __int64 a2, int *a3, char *a4, int a5)
{
  __int64 result; // x0

  if ( a1[7] )
    result = EVP_EncryptUpdate(a1, a2, a3, a4, a5);
  else
    result = EVP_DecryptUpdate(a1, (void *)a2, a3, a4, a5);
  return result;
}

//----- (0000000000043DB4) ----------------------------------------------------
__int64 __fastcall EVP_CipherFinal_ex(__int64 *a1, __int64 a2, _DWORD *a3)
{
  __int64 result; // x0

  if ( *((_DWORD *)a1 + 7) )
    result = EVP_EncryptFinal_ex(a1, a2, a3);
  else
    result = EVP_DecryptFinal_ex(a1, a2, a3);
  return result;
}

//----- (0000000000043DC4) ----------------------------------------------------
__int64 __fastcall lh_num_items(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000043DCC) ----------------------------------------------------
__int64 __fastcall EVP_MD_CTX_type(unsigned int **a1)
{
  return **a1;
}

//----- (0000000000043DD8) ----------------------------------------------------
__int64 __fastcall EVP_MD_CTX_size(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 4LL);
}

//----- (0000000000043DE4) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_CTX_key_length(__int64 a1)
{
  return *(unsigned int *)(a1 + 24);
}

//----- (0000000000043DEC) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_CTX_get_app_data(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (0000000000043DF4) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_set_cert(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

//----- (0000000000043DFC) ----------------------------------------------------
signed __int64 __fastcall EVP_CIPHER_CTX_set_padding(__int64 a1, int a2)
{
  __int64 v2; // x8
  int v3; // w9
  signed __int64 result; // x0
  int v5; // w10
  unsigned int v6; // w9

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 32);
  result = 1LL;
  v5 = v3 | 0x800;
  v6 = v3 & 0xFFFFF7FF;
  if ( !a2 )
    v6 = v5;
  *(_DWORD *)(v2 + 32) = v6;
  return result;
}

//----- (0000000000043E20) ----------------------------------------------------
signed __int64 __fastcall EVP_CIPHER_CTX_set_key_length(_DWORD *a1, int a2)
{
  if ( a1[6] != a2 )
  {
    if ( !a2 || !(*(_BYTE *)(*(_QWORD *)a1 + 20LL) & 0x40) )
    {
      ERR_put_error(30, 0LL, 110, (__int64)"external/boringssl/src/crypto/cipher/cipher.c", 582);
      return 0LL;
    }
    a1[6] = a2;
  }
  return 1LL;
}

//----- (0000000000043E78) ----------------------------------------------------
__int64 __fastcall X509_TRUST_get_trust(unsigned int *a1)
{
  return *a1;
}

//----- (0000000000043E80) ----------------------------------------------------
__int64 __fastcall X509_TRUST_get_flags(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}

//----- (0000000000043E88) ----------------------------------------------------
__int64 __fastcall EVP_MD_flags(__int64 a1)
{
  return *(unsigned int *)(a1 + 8);
}

//----- (0000000000043E90) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_iv_length(__int64 a1)
{
  return *(unsigned int *)(a1 + 12);
}

//----- (0000000000043E98) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_flags(__int64 a1)
{
  return *(_DWORD *)(a1 + 20) & 0xFFFFFFC0;
}

//----- (0000000000043EA4) ----------------------------------------------------
__int64 __fastcall EVP_CIPHER_mode(__int64 a1)
{
  return *(_DWORD *)(a1 + 20) & 0x3F;
}

//----- (0000000000043EB0) ----------------------------------------------------
__int64 __fastcall EVP_CipherInit(unsigned int **a1, unsigned int *a2, __int64 a3, const void *a4, int a5)
{
  int v5; // w19
  const void *v6; // x20
  __int64 v7; // x21
  unsigned int *v8; // x22
  unsigned int **v9; // x23

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a2 )
    memset(a1, 0, 0x98uLL);
  return EVP_CipherInit_ex(v9, v8, a3, v7, v6, v5);
}

//----- (0000000000043F14) ----------------------------------------------------
__int64 __fastcall EVP_EncryptInit(unsigned int **a1, unsigned int *a2, __int64 a3, const void *a4)
{
  const void *v4; // x19
  __int64 v5; // x20
  unsigned int *v6; // x21
  unsigned int **v7; // x22

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a2 )
    memset(a1, 0, 0x98uLL);
  return EVP_CipherInit_ex(v7, v6, a3, v5, v4, 1);
}

//----- (0000000000043F6C) ----------------------------------------------------
__int64 __fastcall EVP_DecryptInit(unsigned int **a1, unsigned int *a2, __int64 a3, const void *a4)
{
  const void *v4; // x19
  __int64 v5; // x20
  unsigned int *v6; // x21
  unsigned int **v7; // x22

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a2 )
    memset(a1, 0, 0x98uLL);
  return EVP_CipherInit_ex(v7, v6, a3, v5, v4, 0);
}

//----- (0000000000043FC4) ----------------------------------------------------
signed __int64 X509V3_add_standard_extensions()
{
  return 1LL;
}

//----- (0000000000043FCC) ----------------------------------------------------
void *__fastcall EVP_get_cipherbyname(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  if ( !(unsigned int)OPENSSL_strcasecmp(a1, "rc4") )
    return EVP_rc4();
  if ( !(unsigned int)OPENSSL_strcasecmp(v1, "des-cbc") )
    return EVP_des_cbc();
  if ( !(unsigned int)OPENSSL_strcasecmp(v1, "des-ede3-cbc") || !(unsigned int)OPENSSL_strcasecmp(v1, "3des") )
    return EVP_des_ede3_cbc();
  if ( !(unsigned int)OPENSSL_strcasecmp(v1, "aes-128-cbc") )
    return EVP_aes_128_cbc();
  if ( !(unsigned int)OPENSSL_strcasecmp(v1, "aes-256-cbc") )
    return EVP_aes_256_cbc();
  if ( !(unsigned int)OPENSSL_strcasecmp(v1, "aes-128-ctr") )
    return EVP_aes_128_ctr();
  if ( !(unsigned int)OPENSSL_strcasecmp(v1, "aes-256-ctr") )
    return EVP_aes_256_ctr();
  if ( !(unsigned int)OPENSSL_strcasecmp(v1, "aes-128-ecb") )
    return EVP_aes_128_ecb();
  if ( (unsigned int)OPENSSL_strcasecmp(v1, "aes-256-ecb") )
    return 0LL;
  return EVP_aes_256_ecb();
}
// 4BCAC: using guessed type __int64 __fastcall OPENSSL_strcasecmp(_QWORD, _QWORD);

//----- (000000000004411C) ----------------------------------------------------
void *EVP_aes_128_cbc()
{
  return &unk_F64F0;
}

//----- (0000000000044128) ----------------------------------------------------
void *EVP_aes_128_ctr()
{
  return &unk_F6530;
}

//----- (0000000000044134) ----------------------------------------------------
void *EVP_aes_128_ecb()
{
  return &unk_F6570;
}

//----- (0000000000044140) ----------------------------------------------------
void *EVP_aes_128_ofb()
{
  return &unk_F65B0;
}

//----- (000000000004414C) ----------------------------------------------------
void *EVP_aes_128_gcm()
{
  return &unk_F65F0;
}

//----- (0000000000044158) ----------------------------------------------------
void *EVP_aes_192_cbc()
{
  return &unk_F6630;
}

//----- (0000000000044164) ----------------------------------------------------
void *EVP_aes_192_ctr()
{
  return &unk_F6670;
}

//----- (0000000000044170) ----------------------------------------------------
void *EVP_aes_192_ecb()
{
  return &unk_F66B0;
}

//----- (000000000004417C) ----------------------------------------------------
void *EVP_aes_192_gcm()
{
  return &unk_F66F0;
}

//----- (0000000000044188) ----------------------------------------------------
void *EVP_aes_256_cbc()
{
  return &unk_F6730;
}

//----- (0000000000044194) ----------------------------------------------------
void *EVP_aes_256_ctr()
{
  return &unk_F6770;
}

//----- (00000000000441A0) ----------------------------------------------------
void *EVP_aes_256_ecb()
{
  return &unk_F67B0;
}

//----- (00000000000441AC) ----------------------------------------------------
void *EVP_aes_256_ofb()
{
  return &unk_F67F0;
}

//----- (00000000000441B8) ----------------------------------------------------
void *EVP_aes_256_gcm()
{
  return &unk_F6830;
}

//----- (00000000000441C4) ----------------------------------------------------
void *EVP_aead_aes_128_gcm()
{
  return &unk_F6870;
}

//----- (00000000000441D0) ----------------------------------------------------
void *EVP_aead_aes_256_gcm()
{
  return &unk_F68A8;
}

//----- (00000000000441DC) ----------------------------------------------------
void *EVP_aead_aes_128_ctr_hmac_sha256()
{
  return &unk_F68E0;
}

//----- (00000000000441E8) ----------------------------------------------------
void *EVP_aead_aes_256_ctr_hmac_sha256()
{
  return &unk_F6918;
}

//----- (00000000000441F4) ----------------------------------------------------
__int64 EVP_has_aes_hardware()
{
  __int64 result; // x0

  result = sub_4632C();
  if ( (_DWORD)result )
    result = (unsigned int)sub_46340() != 0;
  return result;
}

//----- (0000000000044218) ----------------------------------------------------
signed __int64 __fastcall sub_44218(_QWORD *a1, unsigned __int8 *a2, __int64 a3, int a4)
{
  _QWORD *v4; // x21
  __int64 v5; // x19
  int v6; // w22
  unsigned __int8 *v7; // x20
  int v8; // w23
  int v9; // w0
  int v10; // w0
  __int64 *v11; // x9
  int v12; // w0
  void (__fastcall *v13)(_QWORD *, long double *, unsigned __int64, __int64, _OWORD *, int); // x9

  v4 = a1;
  v5 = a1[2];
  v6 = a4;
  v7 = a2;
  v8 = *(_DWORD *)(*a1 + 20LL) & 0x3F;
  v9 = sub_4632C();
  if ( !v6 && (unsigned int)(v8 - 1) <= 1 )
  {
    if ( !v9 )
    {
      v10 = AES_set_decrypt_key(v7, 8 * *((_DWORD *)v4 + 6), (unsigned int *)v5);
      v11 = (__int64 *)AES_cbc_encrypt;
      *(_QWORD *)(v5 + 248) = AES_decrypt;
      if ( v8 != 2 )
        v11 = 0LL;
LABEL_12:
      *(_QWORD *)(v5 + 256) = v11;
      if ( v10 & 0x80000000 )
        goto LABEL_22;
      return 1LL;
    }
    v10 = ((__int64 (__fastcall *)(unsigned __int8 *, _QWORD, __int64))loc_4FDC0)(
            v7,
            (unsigned int)(8 * *((_DWORD *)v4 + 6)),
            v5);
    *(_QWORD *)(v5 + 248) = qword_4FEA0;
    *(_QWORD *)(v5 + 256) = 0LL;
    if ( v8 == 2 )
    {
      v11 = qword_4FF00;
      goto LABEL_12;
    }
    goto LABEL_20;
  }
  if ( !v9 )
  {
    v12 = AES_set_encrypt_key(v7, 8 * *((_DWORD *)v4 + 6), (unsigned int *)v5);
    v13 = AES_cbc_encrypt;
    if ( v8 != 2 )
      v13 = 0LL;
    *(_QWORD *)(v5 + 248) = AES_encrypt;
    *(_QWORD *)(v5 + 256) = v13;
    if ( v12 & 0x80000000 )
      goto LABEL_22;
    return 1LL;
  }
  v10 = ((__int64 (__fastcall *)(unsigned __int8 *, _QWORD, __int64))loc_4FBA0)(
          v7,
          (unsigned int)(8 * *((_DWORD *)v4 + 6)),
          v5);
  *(_QWORD *)(v5 + 248) = qword_4FE40;
  *(_QWORD *)(v5 + 256) = 0LL;
  if ( v8 != 2 )
  {
    if ( v8 == 5 )
      *(_QWORD *)(v5 + 256) = qword_50300;
LABEL_20:
    if ( !(v10 & 0x80000000) )
      return 1LL;
    goto LABEL_22;
  }
  *(_QWORD *)(v5 + 256) = qword_4FF00;
  if ( !(v10 & 0x80000000) )
    return 1LL;
LABEL_22:
  ERR_put_error(30, 0LL, 100, (__int64)"external/boringssl/src/crypto/cipher/e_aes.c", 339);
  return 0LL;
}
// 4FE40: using guessed type __int64 qword_4FE40[12];
// 4FEA0: using guessed type __int64 qword_4FEA0[12];
// 4FF00: using guessed type __int64 qword_4FF00[128];
// 50300: using guessed type __int64 qword_50300[82];

//----- (00000000000443A0) ----------------------------------------------------
signed __int64 __fastcall sub_443A0(__int64 a1, long double *a2, _QWORD *a3, unsigned __int64 a4)
{
  __int64 v4; // x8
  unsigned int v5; // w9
  void (__fastcall *v6)(_QWORD *, long double *, unsigned __int64, __int64, signed __int64, _QWORD); // x10
  void (__fastcall *v7)(long double *, long double *, __int64); // x5
  _OWORD *v8; // x4

  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 28);
  v6 = *(void (__fastcall **)(_QWORD *, long double *, unsigned __int64, __int64, signed __int64, _QWORD))(v4 + 256);
  if ( v6 )
  {
    v6(a3, a2, a4, v4, a1 + 52, v5);
  }
  else
  {
    v7 = *(void (__fastcall **)(long double *, long double *, __int64))(v4 + 248);
    v8 = (_OWORD *)(a1 + 52);
    if ( v5 )
      sub_4BDC0(a3, a2, a4, v4, v8, v7);
    else
      sub_4BFD4(
        (unsigned __int64)a3,
        (unsigned __int64)a2,
        a4,
        v4,
        v8,
        (__int64 (__fastcall *)(_QWORD *, __int64 *, __int64))v7);
  }
  return 1LL;
}

//----- (0000000000044404) ----------------------------------------------------
signed __int64 __fastcall sub_44404(__int64 a1, _BYTE *a2, char *a3, unsigned __int64 a4)
{
  __int64 v4; // x8
  _BYTE *v5; // x4
  char *v6; // x5
  unsigned int *v7; // x6
  __int64 (__fastcall *v8)(char *, char *, unsigned __int64, __int64, _BYTE *); // x7

  v4 = *(_QWORD *)(a1 + 16);
  v5 = (_BYTE *)(a1 + 52);
  v6 = (char *)(a1 + 68);
  v7 = (unsigned int *)(a1 + 104);
  v8 = *(__int64 (__fastcall **)(char *, char *, unsigned __int64, __int64, _BYTE *))(v4 + 256);
  if ( v8 )
    sub_4C608((__int64)a3, a2, a4, v4, (__int64)v5, v6, v7, v8);
  else
    sub_4C3D8(
      a3,
      (unsigned __int64)a2,
      a4,
      v4,
      v5,
      v6,
      v7,
      *(void (__fastcall **)(_BYTE *, _QWORD *, __int64))(v4 + 248));
  return 1LL;
}

//----- (0000000000044458) ----------------------------------------------------
signed __int64 __fastcall sub_44458(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  unsigned __int64 v6; // x22
  __int64 v7; // x21
  unsigned __int64 v8; // x23
  unsigned __int64 v9; // x24

  v4 = a3;
  v5 = a2;
  v6 = *(unsigned int *)(*a1 + 4LL);
  if ( v6 <= a4 )
  {
    v7 = a1[2];
    v8 = 0LL;
    v9 = a4 - v6;
    do
    {
      (*(void (__fastcall **)(unsigned __int64, unsigned __int64, __int64))(v7 + 248))(v4 + v8, v5 + v8, v7);
      v8 += v6;
    }
    while ( v8 <= v9 );
  }
  return 1LL;
}

//----- (00000000000444C8) ----------------------------------------------------
signed __int64 __fastcall sub_444C8(__int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 a4)
{
  sub_4DCBC(
    a3,
    a2,
    a4,
    *(_QWORD *)(a1 + 16),
    a1 + 52,
    (unsigned int *)(a1 + 104),
    *(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(a1 + 16) + 248LL));
  return 1LL;
}

//----- (00000000000444FC) ----------------------------------------------------
signed __int64 __fastcall sub_444FC(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x20
  unsigned __int8 *v4; // x22
  __int64 v5; // x19
  int v6; // w23
  int v7; // w0
  __int64 v8; // x1
  unsigned __int64 v9; // x3

  v3 = a3;
  v4 = a2;
  if ( (unsigned __int64)a2 | a3 )
  {
    v5 = *(_QWORD *)(a1 + 16);
    if ( a2 )
    {
      v6 = *(_DWORD *)(a1 + 24);
      v7 = sub_4632C();
      v8 = (unsigned int)(8 * v6);
      if ( v7 )
      {
        ((void (__fastcall *)(unsigned __int8 *, __int64, __int64))loc_4FBA0)(v4, v8, v5);
        CRYPTO_gcm128_init((void *)(v5 + 256), v5, (void (__fastcall *)(__int64 *, __int64 *, __int64))qword_4FE40);
        *(_QWORD *)(v5 + 664) = qword_50300;
        if ( !v3 )
          goto LABEL_9;
      }
      else
      {
        AES_set_encrypt_key(v4, v8, (unsigned int *)v5);
        CRYPTO_gcm128_init((void *)(v5 + 256), v5, (void (__fastcall *)(__int64 *, __int64 *, __int64))AES_encrypt);
        *(_QWORD *)(v5 + 664) = 0LL;
        if ( !v3 )
        {
LABEL_9:
          if ( !*(_DWORD *)(v5 + 252) )
            goto LABEL_12;
          v3 = *(_QWORD *)(v5 + 640);
          if ( !v3 )
            goto LABEL_12;
          goto LABEL_11;
        }
      }
LABEL_11:
      CRYPTO_gcm128_setiv(v5 + 256, v5, v3, *(signed int *)(v5 + 648));
      *(_DWORD *)(v5 + 252) = 1;
LABEL_12:
      *(_DWORD *)(v5 + 248) = 1;
      return 1LL;
    }
    v9 = *(signed int *)(v5 + 648);
    if ( *(_DWORD *)(v5 + 248) )
    {
      CRYPTO_gcm128_setiv(v5 + 256, v5, a3, v9);
    }
    else if ( (_DWORD)v9 )
    {
      memcpy(*(void **)(v5 + 640), (const void *)a3, *(signed int *)(v5 + 648));
    }
    *(_DWORD *)(v5 + 252) = 1;
    *(_DWORD *)(v5 + 656) = 0;
  }
  return 1LL;
}
// 4FE40: using guessed type __int64 qword_4FE40[12];
// 50300: using guessed type __int64 qword_50300[82];

//----- (000000000004462C) ----------------------------------------------------
__int64 __fastcall sub_4462C(__int64 a1, _BYTE *a2, int8x16_t *a3, unsigned __int64 a4)
{
  int8x16_t *v4; // x20
  unsigned int v5; // w19
  void (__fastcall *v6)(char *, _BYTE *, signed __int64, __int64, __int64); // x5
  int v7; // w9
  __int64 v8; // x0
  unsigned __int64 v9; // x2

  v4 = *(int8x16_t **)(a1 + 16);
  v5 = a4;
  if ( !v4[15].n128_u32[2] || !v4[15].n128_u32[3] )
    return (unsigned int)-1;
  if ( a3 )
  {
    if ( a2 )
    {
      v6 = (void (__fastcall *)(char *, _BYTE *, signed __int64, __int64, __int64))v4[41].n128_u64[1];
      v7 = *(_DWORD *)(a1 + 28);
      v8 = (__int64)&v4[16];
      if ( v7 )
      {
        if ( v6 )
        {
          if ( !(unsigned int)CRYPTO_gcm128_encrypt_ctr32(v8, (__int64)v4, (char *)a3, a2, a4, v6) )
            return (unsigned int)-1;
        }
        else if ( !(unsigned int)CRYPTO_gcm128_encrypt(v8, (__int64)v4, (char *)a3, a2, a4) )
        {
          return (unsigned int)-1;
        }
      }
      else if ( v6 )
      {
        if ( !(unsigned int)CRYPTO_gcm128_decrypt_ctr32(v8, (__int64)v4, (char *)a3, a2, a4, v6) )
          return (unsigned int)-1;
      }
      else if ( !(unsigned int)CRYPTO_gcm128_decrypt(v8, (__int64)v4, (char *)a3, a2, a4) )
      {
        return (unsigned int)-1;
      }
    }
    else if ( !(unsigned int)CRYPTO_gcm128_aad(v4 + 16, a3, a4) )
    {
      return (unsigned int)-1;
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 28) )
    {
      CRYPTO_gcm128_tag((__int64)&v4[16], (void *)(a1 + 68), 0x10uLL);
      v5 = 0;
      v4[40].n128_u32[3] = 16;
    }
    else
    {
      v9 = v4[40].n128_i32[3];
      if ( v9 & 0x80000000 || !CRYPTO_gcm128_finish((__int64)&v4[16], a1 + 68, v9) )
        return (unsigned int)-1;
      v5 = 0;
    }
    v4[15].n128_u32[3] = 0;
  }
  return v5;
}

//----- (0000000000044758) ----------------------------------------------------
void __fastcall sub_44758(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x20
  void *v3; // x0

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 16);
  OPENSSL_cleanse((void *)(v2 + 256), 0x180uLL);
  v3 = *(void **)(v2 + 640);
  if ( v3 != (void *)(v1 + 52) )
    free(v3);
}

//----- (00000000000447A0) ----------------------------------------------------
void *__fastcall sub_447A0(__int64 a1, int a2, size_t a3, _QWORD *a4)
{
  void *v4; // x21
  int v5; // w20
  __int64 v6; // x22
  void *result; // x0
  __int64 v8; // x19
  int v9; // w8
  __int64 v10; // x20
  const void *v11; // x1
  void *v12; // x0
  int v13; // w9
  bool v14; // nf
  unsigned __int8 v15; // vf
  int v16; // w8
  __int64 v17; // x8
  signed __int64 v18; // x9
  char v19; // w10
  size_t v20; // x2
  unsigned __int64 v21; // x2
  __int64 v22; // x8

  v4 = a4;
  v5 = a3;
  v6 = a1;
  result = (void *)0xFFFFFFFFLL;
  v8 = *(_QWORD *)(v6 + 16);
  switch ( a2 )
  {
    case 0:
      *(_QWORD *)(v8 + 248) = 0LL;
      v9 = *(_DWORD *)(*(_QWORD *)v6 + 12LL);
      *(_QWORD *)(v8 + 640) = v6 + 52;
      *(_DWORD *)(v8 + 648) = v9;
      *(_QWORD *)(v8 + 652) = 0xFFFFFFFFLL;
      return &dword_0 + 1;
    case 8:
      v10 = a4[2];
      if ( *(_QWORD *)(v8 + 640) == v6 + 52 )
      {
        *(_QWORD *)(v10 + 640) = (char *)a4 + 52;
      }
      else
      {
        result = malloc(*(signed int *)(v8 + 648));
        *(_QWORD *)(v10 + 640) = result;
        if ( !result )
          return result;
        a3 = *(signed int *)(v8 + 648);
        if ( (_DWORD)a3 )
        {
          v11 = *(const void **)(v8 + 640);
          goto LABEL_43;
        }
      }
      return &dword_0 + 1;
    case 9:
      if ( (signed int)a3 < 1 )
        return 0LL;
      if ( (signed int)a3 < 17 || *(_DWORD *)(v8 + 648) >= (signed int)a3 )
        goto LABEL_66;
      v12 = *(void **)(v8 + 640);
      if ( v12 != (void *)(v6 + 52) )
        free(v12);
      result = malloc(v5);
      *(_QWORD *)(v8 + 640) = result;
      if ( result )
      {
LABEL_66:
        *(_DWORD *)(v8 + 648) = v5;
        return &dword_0 + 1;
      }
      return result;
    case 16:
      if ( (unsigned int)(a3 - 1) > 0xF )
        return 0LL;
      if ( !*(_DWORD *)(v6 + 28) )
        return 0LL;
      if ( *(_DWORD *)(v8 + 652) & 0x80000000 )
        return 0LL;
      a3 = (signed int)a3;
      v11 = (const void *)(v6 + 68);
      result = a4;
LABEL_43:
      memcpy(result, v11, a3);
      return &dword_0 + 1;
    case 17:
      if ( (unsigned int)(a3 - 1) > 0xF )
        return 0LL;
      if ( *(_DWORD *)(v6 + 28) )
        return 0LL;
      memcpy((void *)(v6 + 68), a4, (signed int)a3);
      *(_DWORD *)(v8 + 652) = v5;
      return &dword_0 + 1;
    case 18:
      if ( (_DWORD)a3 == -1 )
      {
        v20 = *(signed int *)(v8 + 648);
        if ( (_DWORD)v20 )
          memcpy(*(void **)(v8 + 640), a4, v20);
        goto LABEL_50;
      }
      if ( (signed int)a3 < 4 )
        return 0LL;
      if ( *(_DWORD *)(v8 + 648) - (signed int)a3 < 8 )
        return 0LL;
      memcpy(*(void **)(v8 + 640), a4, (signed int)a3);
      if ( !*(_DWORD *)(v6 + 28)
        || (result = (void *)RAND_pseudo_bytes(
                               *(_QWORD *)(v8 + 640) + v5,
                               *(signed int *)(v8 + 648) - (signed __int64)v5),
            (_DWORD)result) )
      {
LABEL_50:
        result = &dword_0 + 1;
        *(_DWORD *)(v8 + 656) = 1;
      }
      return result;
    case 19:
      if ( !*(_DWORD *)(v8 + 656) )
        return 0LL;
      if ( !*(_DWORD *)(v8 + 248) )
        return 0LL;
      CRYPTO_gcm128_setiv(v8 + 256, *(_QWORD *)(v6 + 16), *(_QWORD *)(v8 + 640), *(signed int *)(v8 + 648));
      v13 = *(_DWORD *)(v8 + 648);
      if ( v13 >= v5 )
      {
        v15 = __OFSUB__(v5, 1);
        v14 = v5 - 1 < 0;
      }
      else
      {
        v15 = 0;
        v14 = 1;
      }
      if ( v14 ^ v15 )
        v16 = *(_DWORD *)(v8 + 648);
      else
        v16 = v5;
      if ( v16 )
      {
        memcpy(v4, (const void *)(*(_QWORD *)(v8 + 640) + v13 - v16), v16);
        v13 = *(_DWORD *)(v8 + 648);
      }
      v17 = 0LL;
      v18 = *(_QWORD *)(v8 + 640) + v13 - 1LL;
      do
      {
        v19 = *(_BYTE *)(v18 + v17) + 1;
        *(_BYTE *)(v18 + v17) = v19;
        if ( v17 == -7 )
          break;
        --v17;
      }
      while ( !v19 );
      goto LABEL_62;
    case 24:
      if ( !*(_DWORD *)(v8 + 656) )
        return 0LL;
      if ( !*(_DWORD *)(v8 + 248) )
        return 0LL;
      if ( *(_DWORD *)(v6 + 28) )
        return 0LL;
      v21 = *(_QWORD *)(v8 + 640);
      v22 = *(signed int *)(v8 + 648);
      if ( v5 )
      {
        memcpy((void *)(v21 + v22 - v5), a4, v5);
        v21 = *(_QWORD *)(v8 + 640);
        LODWORD(v22) = *(_DWORD *)(v8 + 648);
      }
      CRYPTO_gcm128_setiv(v8 + 256, v8, v21, (signed int)v22);
LABEL_62:
      result = &dword_0 + 1;
      *(_DWORD *)(v8 + 252) = 1;
      return result;
    default:
      return result;
  }
}
// 0: using guessed type int dword_0;

//----- (0000000000044AA4) ----------------------------------------------------
signed __int64 __fastcall sub_44AA4(__int64 a1, unsigned __int8 *a2, __int64 a3, unsigned __int64 a4)
{
  int v4; // w22
  unsigned __int8 *v5; // x21
  __int64 v6; // x19
  unsigned __int64 v7; // x24
  int v8; // w2
  __int16 v9; // w4
  signed __int64 result; // x0
  unsigned int *v11; // x20
  int v12; // w0
  __int64 v13; // x1
  __int64 *v14; // x8

  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( 8 * a3 != 128 && 8 * a3 != 256 )
  {
    v8 = 102;
    v9 = 1024;
    goto LABEL_9;
  }
  if ( a4 )
    v7 = a4;
  else
    v7 = 16LL;
  if ( v7 >= 0x11 )
  {
    v8 = 116;
    v9 = 1033;
LABEL_9:
    ERR_put_error(30, 0LL, v8, (__int64)"external/boringssl/src/crypto/cipher/e_aes.c", v9);
    return 0LL;
  }
  v11 = (unsigned int *)malloc(0x288uLL);
  if ( !v11 )
    return 0LL;
  v12 = sub_4632C();
  v13 = (unsigned int)(8 * v4);
  if ( v12 )
  {
    ((void (__fastcall *)(unsigned __int8 *, __int64, unsigned int *))loc_4FBA0)(v5, v13, v11);
    CRYPTO_gcm128_init(v11 + 62, (__int64)v11, (void (__fastcall *)(__int64 *, __int64 *, __int64))qword_4FE40);
    v14 = qword_50300;
  }
  else
  {
    AES_set_encrypt_key(v5, v13, v11);
    CRYPTO_gcm128_init(v11 + 62, (__int64)v11, (void (__fastcall *)(__int64 *, __int64 *, __int64))AES_encrypt);
    v14 = 0LL;
  }
  result = 1LL;
  *((_QWORD *)v11 + 79) = v14;
  *((_BYTE *)v11 + 640) = v7;
  *(_QWORD *)(v6 + 8) = v11;
  return result;
}
// 4FE40: using guessed type __int64 qword_4FE40[12];
// 50300: using guessed type __int64 qword_50300[82];

//----- (0000000000044BC4) ----------------------------------------------------
void __fastcall sub_44BC4(__int64 a1)
{
  void *v1; // x19

  v1 = *(void **)(a1 + 8);
  OPENSSL_cleanse(*(void **)(a1 + 8), 0x288uLL);
  free(v1);
}

//----- (0000000000044BF0) ----------------------------------------------------
signed __int64 __fastcall sub_44BF0(__int64 a1, _BYTE *a2, _QWORD *a3, unsigned __int64 a4, unsigned __int64 a5, unsigned __int64 a6, char *a7, unsigned __int64 a8, int8x16_t *a9, unsigned __int64 a10)
{
  unsigned __int64 v10; // x19
  char *v11; // x23
  unsigned __int64 v12; // x24
  __int64 v13; // x21
  unsigned __int64 v14; // x25
  _QWORD *v15; // x20
  _BYTE *v16; // x22
  __int64 v17; // x8
  unsigned __int8 v18; // cf
  unsigned __int64 v19; // x8
  int v20; // w2
  __int16 v21; // w4
  signed __int64 result; // x0
  void (__fastcall *v23)(char *, _BYTE *, signed __int64, __int64, __int64); // x5
  char v24; // [xsp+8h] [xbp-1D8h]
  __int64 v25; // [xsp+188h] [xbp-58h]

  v10 = a8;
  v11 = a7;
  v12 = a6;
  v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = *(_QWORD *)(a1 + 8);
  v14 = a5;
  v15 = a3;
  v16 = a2;
  v17 = *(unsigned __int8 *)(v13 + 640);
  v18 = __CFADD__(v17, a8);
  v19 = v17 + a8;
  if ( v18 )
  {
    v20 = 117;
    v21 = 1065;
LABEL_6:
    ERR_put_error(30, 0LL, v20, (__int64)"external/boringssl/src/crypto/cipher/e_aes.c", v21);
    result = 0LL;
    goto LABEL_7;
  }
  if ( v19 > a4 )
  {
    v20 = 103;
    v21 = 1070;
    goto LABEL_6;
  }
  memcpy(&v24, (const void *)(v13 + 248), 0x180uLL);
  CRYPTO_gcm128_setiv((unsigned __int64)&v24, v13, v14, v12);
  if ( !a10 || (result = CRYPTO_gcm128_aad((int8x16_t *)&v24, a9, a10), (_DWORD)result) )
  {
    v23 = *(void (__fastcall **)(char *, _BYTE *, signed __int64, __int64, __int64))(v13 + 632);
    if ( v23 )
    {
      result = CRYPTO_gcm128_encrypt_ctr32((__int64)&v24, v13, v11, v16, v10, v23);
      if ( !(_DWORD)result )
        goto LABEL_7;
    }
    else
    {
      result = CRYPTO_gcm128_encrypt((__int64)&v24, v13, v11, v16, v10);
      if ( !(_DWORD)result )
        goto LABEL_7;
    }
    CRYPTO_gcm128_tag((__int64)&v24, &v16[v10], *(unsigned __int8 *)(v13 + 640));
    result = 1LL;
    *v15 = *(unsigned __int8 *)(v13 + 640) + v10;
  }
LABEL_7:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v25;
  return result;
}

//----- (0000000000044D64) ----------------------------------------------------
signed __int64 __fastcall sub_44D64(__int64 a1, _BYTE *a2, __int64 *a3, unsigned __int64 a4, unsigned __int64 a5, unsigned __int64 a6, char *a7, unsigned __int64 a8, int8x16_t *a9, unsigned __int64 a10)
{
  unsigned __int64 v10; // x23
  char *v11; // x20
  unsigned __int64 v12; // x24
  __int64 v13; // x21
  unsigned __int64 v14; // x25
  __int64 *v15; // x19
  _BYTE *v16; // x22
  unsigned __int64 v17; // x8
  int v18; // w2
  __int16 v19; // w4
  __int64 v20; // x28
  signed __int64 result; // x0
  void (__fastcall *v22)(char *, _BYTE *, signed __int64, __int64, __int64); // x5
  unsigned __int64 v23; // x4
  char v24; // [xsp+8h] [xbp-1E8h]
  char v25; // [xsp+188h] [xbp-68h]
  __int64 v26; // [xsp+198h] [xbp-58h]

  v10 = a8;
  v11 = a7;
  v12 = a6;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = *(_QWORD *)(a1 + 8);
  v14 = a5;
  v15 = a3;
  v16 = a2;
  v17 = *(unsigned __int8 *)(v13 + 640);
  if ( v17 <= a8 )
  {
    v20 = a8 - v17;
    if ( a8 - v17 <= a4 )
    {
      memcpy(&v24, (const void *)(v13 + 248), 0x180uLL);
      CRYPTO_gcm128_setiv((unsigned __int64)&v24, v13, v14, v12);
      result = CRYPTO_gcm128_aad((int8x16_t *)&v24, a9, a10);
      if ( !(_DWORD)result )
        goto LABEL_6;
      v22 = *(void (__fastcall **)(char *, _BYTE *, signed __int64, __int64, __int64))(v13 + 632);
      v23 = v10 - *(unsigned __int8 *)(v13 + 640);
      if ( v22 )
      {
        result = CRYPTO_gcm128_decrypt_ctr32((__int64)&v24, v13, v11, v16, v23, v22);
        if ( !(_DWORD)result )
          goto LABEL_6;
      }
      else
      {
        result = CRYPTO_gcm128_decrypt((__int64)&v24, v13, v11, v16, v23);
        if ( !(_DWORD)result )
          goto LABEL_6;
      }
      CRYPTO_gcm128_tag((__int64)&v24, &v25, *(unsigned __int8 *)(v13 + 640));
      if ( !(unsigned int)CRYPTO_memcmp((__int64)&v25, (__int64)&v11[v20], *(unsigned __int8 *)(v13 + 640)) )
      {
        result = 1LL;
        *v15 = v20;
        goto LABEL_6;
      }
      v18 = 101;
      v19 = 1143;
    }
    else
    {
      v18 = 103;
      v19 = 1117;
    }
  }
  else
  {
    v18 = 101;
    v19 = 1110;
  }
  ERR_put_error(30, 0LL, v18, (__int64)"external/boringssl/src/crypto/cipher/e_aes.c", v19);
  result = 0LL;
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v26;
  return result;
}

//----- (0000000000044EEC) ----------------------------------------------------
signed __int64 __fastcall sub_44EEC(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // x22
  unsigned __int8 *v5; // x21
  __int64 v6; // x19
  int v7; // w2
  __int16 v8; // w4
  unsigned __int64 v9; // x23
  unsigned int *v10; // x20
  signed __int64 v11; // x22
  int v12; // w0
  __int64 v13; // x1
  __int64 *v14; // x8
  __int64 *v15; // x9
  signed __int64 result; // x0
  int8x16_t v17; // q1
  int8x16_t v18; // q0
  int8x16_t v19; // q1
  int8x16_t v20; // [xsp+0h] [xbp-80h]
  int8x16_t v21; // [xsp+10h] [xbp-70h]
  __int64 v22; // [xsp+20h] [xbp-60h]
  __int64 v23; // [xsp+28h] [xbp-58h]
  __int64 v24; // [xsp+30h] [xbp-50h]
  __int64 v25; // [xsp+38h] [xbp-48h]
  __int64 v26; // [xsp+48h] [xbp-38h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 <= 0x1F )
  {
    v7 = 102;
    v8 = 1227;
LABEL_15:
    ERR_put_error(30, 0LL, v7, (__int64)"external/boringssl/src/crypto/cipher/e_aes.c", v8);
    result = 0LL;
    goto LABEL_16;
  }
  if ( a3 != 48 && a3 != 64 )
  {
    v7 = 102;
    v8 = 1233;
    goto LABEL_15;
  }
  if ( a4 )
    v9 = a4;
  else
    v9 = 32LL;
  if ( v9 >= 0x21 )
  {
    v7 = 116;
    v8 = 1242;
    goto LABEL_15;
  }
  v10 = (unsigned int *)malloc(0x1F0uLL);
  if ( !v10 )
  {
    v7 = 65;
    v8 = 1248;
    goto LABEL_15;
  }
  v11 = v4 - 32;
  v12 = sub_4632C();
  v13 = (unsigned int)(8 * v11);
  if ( v12 )
  {
    ((void (__fastcall *)(unsigned __int8 *, __int64, unsigned int *))loc_4FBA0)(v5, v13, v10);
    v14 = qword_50300;
    v15 = qword_4FE40;
  }
  else
  {
    AES_set_encrypt_key(v5, v13, v10);
    v15 = (__int64 *)AES_encrypt;
    v14 = 0LL;
  }
  *((_QWORD *)v10 + 31) = v14;
  *((_QWORD *)v10 + 32) = v15;
  *((_BYTE *)v10 + 488) = v9;
  v17.n128_u64[0] = 3906369333256140342LL;
  v17.n128_u64[1] = 3906369333256140342LL;
  v21 = *(int8x16_t *)&v5[v11 + 16];
  v18 = *(int8x16_t *)&v5[v11];
  v24 = 3906369333256140342LL;
  v25 = 3906369333256140342LL;
  v22 = 3906369333256140342LL;
  v23 = 3906369333256140342LL;
  v20 = veorq_s8(v18, v17);
  v21 = veorq_s8(v21, v17);
  SHA256_Init(v10 + 66);
  SHA256_Update(v10 + 66, (char *)&v20, 0x40uLL);
  v19.n128_u64[0] = 7668058320836127338LL;
  v19.n128_u64[1] = 7668058320836127338LL;
  v20 = veorq_s8(v20, v19);
  v24 = 6655295901103053916LL;
  v25 = 6655295901103053916LL;
  v22 = 6655295901103053916LL;
  v23 = 6655295901103053916LL;
  v21 = veorq_s8(v21, v19);
  SHA256_Init(v10 + 94);
  SHA256_Update(v10 + 94, (char *)&v20, 0x40uLL);
  result = 1LL;
  *(_QWORD *)(v6 + 8) = v10;
LABEL_16:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v26;
  return result;
}
// 4FE40: using guessed type __int64 qword_4FE40[12];
// 50300: using guessed type __int64 qword_50300[82];

//----- (0000000000045100) ----------------------------------------------------
void __fastcall sub_45100(__int64 a1)
{
  void *v1; // x19

  v1 = *(void **)(a1 + 8);
  OPENSSL_cleanse(*(void **)(a1 + 8), 0x1F0uLL);
  free(v1);
}

//----- (000000000004512C) ----------------------------------------------------
signed __int64 __fastcall sub_4512C(__int64 a1, char *a2, _QWORD *a3, unsigned __int64 a4, __int64 a5, __int64 a6, char *a7, unsigned __int64 a8, char *a9, size_t a10)
{
  unsigned __int64 v10; // x19
  char *v11; // x23
  __int64 v12; // x21
  _QWORD *v13; // x20
  char *v14; // x22
  __int64 v15; // x9
  unsigned __int8 v16; // cf
  unsigned __int64 v17; // x9
  signed int v18; // w10
  int v19; // w2
  __int16 v20; // w4
  signed __int64 result; // x0
  __int64 v22; // x9
  __int64 (__fastcall *v23)(char *, char *, unsigned __int64, __int64, _BYTE *); // x7
  __int64 v24; // x8
  int v25; // [xsp+4h] [xbp-7Ch]
  __int64 v26; // [xsp+8h] [xbp-78h]
  __int64 v27; // [xsp+10h] [xbp-70h]
  __int64 v28; // [xsp+28h] [xbp-58h]
  int v29; // [xsp+30h] [xbp-50h]
  int v30; // [xsp+34h] [xbp-4Ch]
  __int64 v31; // [xsp+38h] [xbp-48h]

  v10 = a8;
  v11 = (char *)a5;
  v31 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v12 = *(_QWORD *)(a1 + 8);
  v13 = a3;
  v14 = a2;
  v15 = *(unsigned __int8 *)(v12 + 488);
  v16 = __CFADD__(v15, a8);
  v17 = v15 + a8;
  if ( v16 )
    v18 = 1;
  else
    v18 = 0;
  if ( a8 >> 36 || v18 )
  {
    v19 = 117;
    v20 = 1348;
    goto LABEL_9;
  }
  if ( v17 > a4 )
  {
    v19 = 103;
    v20 = 1353;
LABEL_9:
    ERR_put_error(30, 0LL, v19, (__int64)"external/boringssl/src/crypto/cipher/e_aes.c", v20);
    result = 0LL;
    goto LABEL_10;
  }
  if ( a6 != 12 )
  {
    v19 = 121;
    v20 = 1358;
    goto LABEL_9;
  }
  v25 = 0;
  v26 = 0LL;
  v27 = 0LL;
  v29 = *(_DWORD *)(a5 + 8);
  v22 = *(_QWORD *)a5;
  v30 = 0;
  v28 = v22;
  v23 = *(__int64 (__fastcall **)(char *, char *, unsigned __int64, __int64, _BYTE *))(v12 + 248);
  if ( v23 )
    sub_4C608((__int64)a7, a2, v10, v12, (__int64)&v28, (char *)&v26, (unsigned int *)&v25, v23);
  else
    sub_4C3D8(
      a7,
      (unsigned __int64)a2,
      v10,
      v12,
      &v28,
      &v26,
      (unsigned int *)&v25,
      *(void (__fastcall **)(_BYTE *, _QWORD *, __int64))(v12 + 256));
  sub_45478(&v26, (const void *)(v12 + 264), (const void *)(v12 + 376), a9, a10, v11, v14, v10);
  if ( *(_BYTE *)(v12 + 488) )
  {
    memcpy(&v14[v10], &v26, *(unsigned __int8 *)(v12 + 488));
    v24 = *(unsigned __int8 *)(v12 + 488);
  }
  else
  {
    v24 = 0LL;
  }
  result = 1LL;
  *v13 = v24 + v10;
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v31;
  return result;
}

//----- (00000000000452DC) ----------------------------------------------------
signed __int64 __fastcall sub_452DC(__int64 a1, _BYTE *a2, unsigned __int64 *a3, unsigned __int64 a4, char *a5, __int64 a6, char *a7, unsigned __int64 a8, char *a9, size_t a10)
{
  char *v10; // x20
  char *v11; // x24
  unsigned __int64 *v12; // x19
  __int64 v13; // x22
  _BYTE *v14; // x21
  unsigned __int64 v15; // x8
  int v16; // w2
  __int16 v17; // w4
  unsigned __int64 v18; // x23
  signed __int64 result; // x0
  __int64 v20; // x8
  __int64 (__fastcall *v21)(char *, char *, unsigned __int64, __int64, _BYTE *); // x7
  int v22; // [xsp+4h] [xbp-7Ch]
  char v23; // [xsp+8h] [xbp-78h]
  __int64 v24; // [xsp+28h] [xbp-58h]
  int v25; // [xsp+30h] [xbp-50h]
  int v26; // [xsp+34h] [xbp-4Ch]
  __int64 v27; // [xsp+38h] [xbp-48h]
  __int64 v28; // [xsp+40h] [xbp-40h]
  __int64 v29; // [xsp+48h] [xbp-38h]

  v10 = a7;
  v11 = a5;
  v12 = a3;
  v29 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = *(_QWORD *)(a1 + 8);
  v14 = a2;
  v15 = *(unsigned __int8 *)(v13 + 488);
  if ( v15 > a8 )
  {
    v16 = 101;
    v17 = 1382;
LABEL_9:
    ERR_put_error(30, 0LL, v16, (__int64)"external/boringssl/src/crypto/cipher/e_aes.c", v17);
    result = 0LL;
    goto LABEL_10;
  }
  v18 = a8 - v15;
  if ( a8 - v15 > a4 )
  {
    v16 = 103;
    v17 = 1389;
    goto LABEL_9;
  }
  if ( a6 != 12 )
  {
    v16 = 121;
    v17 = 1394;
    goto LABEL_9;
  }
  sub_45478(&v23, (const void *)(v13 + 264), (const void *)(v13 + 376), a9, a10, a5, a7, a8 - v15);
  if ( (unsigned int)CRYPTO_memcmp((__int64)&v23, (__int64)&v10[v18], *(unsigned __int8 *)(v13 + 488)) )
  {
    v16 = 101;
    v17 = 1403;
    goto LABEL_9;
  }
  v22 = 0;
  v27 = 0LL;
  v28 = 0LL;
  v25 = *((_DWORD *)v11 + 2);
  v20 = *(_QWORD *)v11;
  v26 = 0;
  v24 = v20;
  v21 = *(__int64 (__fastcall **)(char *, char *, unsigned __int64, __int64, _BYTE *))(v13 + 248);
  if ( v21 )
    sub_4C608((__int64)v10, v14, v18, v13, (__int64)&v24, (char *)&v27, (unsigned int *)&v22, v21);
  else
    sub_4C3D8(
      v10,
      (unsigned __int64)v14,
      v18,
      v13,
      &v24,
      &v27,
      (unsigned int *)&v22,
      *(void (__fastcall **)(_BYTE *, _QWORD *, __int64))(v13 + 256));
  result = 1LL;
  *v12 = v18;
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v29;
  return result;
}

//----- (0000000000045478) ----------------------------------------------------
signed __int64 __fastcall sub_45478(_BYTE *a1, const void *a2, const void *a3, char *a4, size_t a5, char *a6, char *a7, size_t a8)
{
  const void *v8; // x20
  _BYTE *v9; // x19
  size_t v10; // x21
  char *v11; // x22
  char *v12; // x25
  size_t v13; // x23
  char *v14; // x24
  signed __int64 v15; // x23
  signed __int64 result; // x0
  char v17; // [xsp+8h] [xbp-118h]
  __int16 v18; // [xsp+28h] [xbp-F8h]
  char v19; // [xsp+2Ah] [xbp-F6h]
  char v20; // [xsp+2Bh] [xbp-F5h]
  char v21; // [xsp+2Ch] [xbp-F4h]
  char v22; // [xsp+2Dh] [xbp-F3h]
  char v23; // [xsp+2Eh] [xbp-F2h]
  char v24; // [xsp+2Fh] [xbp-F1h]
  int v25[28]; // [xsp+68h] [xbp-B8h]
  __int64 v26; // [xsp+D8h] [xbp-48h]

  v8 = a3;
  v9 = a1;
  v10 = a8;
  v11 = a7;
  v12 = a6;
  v13 = a5;
  v14 = a4;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  memcpy(v25, a2, 0x70uLL);
  v18 = v13;
  v19 = BYTE2(v13);
  v20 = BYTE3(v13);
  v21 = BYTE4(v13);
  v22 = BYTE5(v13);
  v23 = BYTE6(v13);
  v24 = HIBYTE(v13);
  SHA256_Update(v25, (char *)&v18, 8uLL);
  v18 = v10;
  v19 = BYTE2(v10);
  v20 = BYTE3(v10);
  v21 = BYTE4(v10);
  v22 = BYTE5(v10);
  v23 = BYTE6(v10);
  v24 = HIBYTE(v10);
  SHA256_Update(v25, (char *)&v18, 8uLL);
  SHA256_Update(v25, v12, 0xCuLL);
  SHA256_Update(v25, v14, v13);
  v15 = (-28 - (signed int)v13) & 0x3FLL;
  if ( v15 )
    __memset_chk();
  SHA256_Update(v25, (char *)&v18, v15);
  SHA256_Update(v25, v11, v10);
  SHA256_Final(&v17, v25);
  memcpy(v25, v8, 0x70uLL);
  SHA256_Update(v25, &v17, 0x20uLL);
  result = SHA256_Final(v9, v25);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000045630) ----------------------------------------------------
void *EVP_des_cbc()
{
  return &unk_F6950;
}

//----- (000000000004563C) ----------------------------------------------------
void *EVP_des_ecb()
{
  return &unk_F6990;
}

//----- (0000000000045648) ----------------------------------------------------
void *EVP_des_ede3_cbc()
{
  return &unk_F69D0;
}

//----- (0000000000045654) ----------------------------------------------------
void *EVP_des_ede_cbc()
{
  return &unk_F6A10;
}

//----- (0000000000045660) ----------------------------------------------------
void *EVP_des_ede()
{
  return &unk_F6A50;
}

//----- (000000000004566C) ----------------------------------------------------
signed __int64 __fastcall sub_4566C(__int64 a1, unsigned __int8 *a2)
{
  DES_set_key(a2, *(_QWORD *)(a1 + 16));
  return 1LL;
}

//----- (0000000000045690) ----------------------------------------------------
signed __int64 __fastcall sub_45690(__int64 a1, unsigned __int64 a2, unsigned int *a3, unsigned __int64 a4)
{
  DES_ncbc_encrypt(a3, a2, a4, *(_QWORD *)(a1 + 16), (unsigned __int8 *)(a1 + 52), *(_DWORD *)(a1 + 28));
  return 1LL;
}

//----- (00000000000456C0) ----------------------------------------------------
signed __int64 __fastcall sub_456C0(int *a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  int *v4; // x21
  __int64 v5; // x19
  __int64 v6; // x20
  unsigned __int64 v7; // x8
  __int64 v8; // x22
  unsigned __int64 v9; // x23
  unsigned __int64 v10; // x24

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v7 = *(unsigned int *)(*(_QWORD *)a1 + 4LL);
  if ( v7 <= a4 )
  {
    v8 = *((_QWORD *)a1 + 2);
    v9 = 0LL;
    v10 = a4 - v7;
    do
    {
      DES_ecb_encrypt((unsigned __int8 *)(v5 + v9), v6 + v9, v8, v4[7]);
      v9 += *(unsigned int *)(*(_QWORD *)v4 + 4LL);
    }
    while ( v9 <= v10 );
  }
  return 1LL;
}

//----- (000000000004573C) ----------------------------------------------------
signed __int64 __fastcall sub_4573C(__int64 a1, unsigned __int8 *a2)
{
  __int64 v2; // x19
  unsigned __int8 *v3; // x20

  v2 = *(_QWORD *)(a1 + 16);
  v3 = a2;
  DES_set_key(a2, v2);
  DES_set_key(v3 + 8, v2 + 128);
  DES_set_key(v3 + 16, v2 + 256);
  return 1LL;
}

//----- (0000000000045784) ----------------------------------------------------
signed __int64 __fastcall sub_45784(__int64 a1, _BYTE *a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  DES_ede3_cbc_encrypt(
    a3,
    a2,
    a4,
    *(_QWORD *)(a1 + 16),
    *(_QWORD *)(a1 + 16) + 128LL,
    *(_QWORD *)(a1 + 16) + 256LL,
    (unsigned __int8 *)(a1 + 52),
    *(_DWORD *)(a1 + 28));
  return 1LL;
}

//----- (00000000000457BC) ----------------------------------------------------
signed __int64 __fastcall sub_457BC(__int64 a1, unsigned __int8 *a2)
{
  __int64 v2; // x19
  unsigned __int8 *v3; // x20

  v2 = *(_QWORD *)(a1 + 16);
  v3 = a2;
  DES_set_key(a2, v2);
  DES_set_key(v3 + 8, v2 + 128);
  DES_set_key(v3, v2 + 256);
  return 1LL;
}

//----- (0000000000045804) ----------------------------------------------------
signed __int64 __fastcall sub_45804(int *a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  int *v4; // x21
  __int64 v5; // x19
  __int64 v6; // x20
  unsigned __int64 v7; // x8
  __int64 v8; // x22
  unsigned __int64 v9; // x25
  unsigned __int64 v10; // x26

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v7 = *(unsigned int *)(*(_QWORD *)a1 + 4LL);
  if ( v7 <= a4 )
  {
    v8 = *((_QWORD *)a1 + 2);
    v9 = 0LL;
    v10 = a4 - v7;
    do
    {
      DES_ecb3_encrypt((unsigned __int8 *)(v5 + v9), v6 + v9, v8, v8 + 128, v8 + 256, v4[7]);
      v9 += *(unsigned int *)(*(_QWORD *)v4 + 4LL);
    }
    while ( v9 <= v10 );
  }
  return 1LL;
}

//----- (0000000000045898) ----------------------------------------------------
void *sub_45898()
{
  return &unk_F6A90;
}

//----- (00000000000458A4) ----------------------------------------------------
void *EVP_rc2_cbc()
{
  return &unk_F6AD0;
}

//----- (00000000000458B0) ----------------------------------------------------
signed __int64 __fastcall sub_458B0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x20
  unsigned __int64 v3; // x19
  signed int v4; // w0
  signed int v5; // w9
  signed __int64 v6; // x8
  signed int v7; // w10
  unsigned __int64 v8; // x13
  signed __int64 v9; // x12
  signed __int64 v10; // x14
  __int128 *v11; // x14
  _OWORD *v12; // x15
  signed __int64 v13; // x16
  __int128 v14; // q0
  __int128 v15; // q1
  char v16; // w13
  signed __int64 v17; // x14
  char v18; // w12
  __int64 v19; // x10
  __int64 v20; // x11
  char v21; // w15
  __int64 v22; // x16
  int v23; // w11
  signed __int64 v24; // x12
  char v25; // w10
  int v26; // w8
  __int64 v27; // x11
  __int64 v28; // x12
  __int64 v29; // x13
  __int64 v30; // x8
  __int64 v31; // x9
  __int16 v32; // w10
  unsigned __int8 v33; // w11
  signed __int64 v34; // x12

  v2 = *(_QWORD *)(a1 + 16);
  v3 = a2;
  v4 = EVP_CIPHER_CTX_key_length(a1);
  v5 = *(_DWORD *)v2;
  *(_BYTE *)(v2 + 4) = 0;
  v6 = v2 + 4;
  if ( v4 <= 128 )
    v7 = v4;
  else
    v7 = 128;
  if ( v5 < 1 )
    v5 = 1024;
  if ( v5 > 1024 )
    v5 = 1024;
  if ( v4 >= 1 )
  {
    if ( v7 <= 1LL )
      v8 = 1LL;
    else
      v8 = v7;
    if ( v8 < 0x20 )
    {
      v9 = 0LL;
      goto LABEL_24;
    }
    v9 = v8 & 0x7FFFFFFFFFFFFFE0LL;
    if ( !(v8 & 0x7FFFFFFFFFFFFFE0LL) )
    {
      do
      {
LABEL_24:
        v16 = *(_BYTE *)(v3 + v9);
        v17 = v2 + v9++;
        *(_BYTE *)(v17 + 4) = v16;
      }
      while ( v9 < v7 );
      goto LABEL_25;
    }
    if ( v7 <= 1LL )
      v10 = 1LL;
    else
      v10 = v7;
    if ( v2 + 4 < v3 + v10 && v2 + v10 + 4 > v3 )
    {
      v9 = 0LL;
      goto LABEL_24;
    }
    v11 = (__int128 *)(v3 + 16);
    v12 = (_OWORD *)(v2 + 20);
    v13 = v8 & 0x7FFFFFFFFFFFFFE0LL;
    do
    {
      v14 = *(v11 - 1);
      v15 = *v11;
      v11 += 2;
      v13 -= 32LL;
      *(v12 - 1) = v14;
      *v12 = v15;
      v12 += 2;
    }
    while ( v13 );
    if ( v8 != v9 )
      goto LABEL_24;
  }
LABEL_25:
  if ( v7 <= 127 )
  {
    v18 = *(_BYTE *)(v6 + v7 - 1);
    v19 = v7 + 1;
    v20 = 0LL;
    do
    {
      v21 = *(_BYTE *)(v2 + v20 + 4);
      v22 = v2 + v19 + v20++;
      v18 = byte_CFE30[(unsigned __int8)(v21 + v18)];
      *(_BYTE *)(v22 + 3) = v18;
    }
    while ( v19 + v20 - 1 < 128 );
  }
  v23 = (v5 + 7) >> 3;
  v24 = 128LL - v23;
  v25 = byte_CFE30[*(unsigned __int8 *)(v6 + v24) & (0xFFu >> (-(char)v5 & 7))];
  *(_BYTE *)(v6 + v24) = v25;
  if ( 128 != v23 )
  {
    v26 = v23 - 128;
    v27 = 127 - v23;
    v28 = v2;
    do
    {
      ++v26;
      v25 = byte_CFE30[(unsigned __int8)(*(_BYTE *)(v28 + 131) ^ v25)];
      v29 = v27 + v28--;
      *(_BYTE *)(v29 + 4) = v25;
    }
    while ( v26 );
  }
  v30 = 0LL;
  do
  {
    v31 = v2 + v30;
    v32 = *(unsigned __int8 *)(v2 + v30 + 131);
    v33 = *(_BYTE *)(v2 + v30 + 130);
    v34 = v30 + 125;
    v30 -= 2LL;
    *(_WORD *)(v31 + 130) = v33 | (unsigned __int16)(v32 << 8);
  }
  while ( !(v34 & 0x8000000000000000LL) );
  return 1LL;
}

//----- (0000000000045A94) ----------------------------------------------------
signed __int64 __fastcall sub_45A94(__int64 a1, unsigned __int64 a2, int *a3, unsigned __int64 a4)
{
  __int64 v4; // x21
  __int64 v5; // x8
  unsigned __int64 v6; // x19
  int *v7; // x23
  unsigned __int64 v8; // x20
  signed __int64 v9; // x28
  unsigned __int64 v10; // x27
  unsigned __int64 v11; // x22
  unsigned __int16 *v12; // x24
  unsigned __int64 v13; // x26
  int *v14; // x0
  int *v16; // [xsp+0h] [xbp-60h]
  __int64 v17; // [xsp+8h] [xbp-58h]

  v4 = a1;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a4 - 0x10000;
  if ( a4 < 0x10000 )
  {
    v14 = a3;
    if ( !a4 )
      return 1LL;
LABEL_7:
    sub_45BB8(v14, v8, v6, (unsigned __int16 *)(v5 + 4), (unsigned __int8 *)(v4 + 52), *(_DWORD *)(v4 + 28));
    return 1LL;
  }
  v10 = v9 & 0xFFFFFFFFFFFF0000LL;
  v11 = (v9 & 0xFFFFFFFFFFFF0000LL) + 0x10000;
  v17 = *(_QWORD *)(a1 + 16);
  v12 = (unsigned __int16 *)(v5 + 4);
  v13 = a2;
  v16 = (int *)((char *)a3 + v11);
  do
  {
    sub_45BB8(v7, v13, 0x10000LL, v12, (unsigned __int8 *)(v4 + 52), *(_DWORD *)(v4 + 28));
    v6 -= 0x10000LL;
    v7 += 0x4000;
    v13 += 0x10000LL;
  }
  while ( v6 >> 16 );
  v14 = v16;
  v5 = v17;
  v6 = v9 - v10;
  v8 += v11;
  if ( v9 != v10 )
    goto LABEL_7;
  return 1LL;
}

//----- (0000000000045B78) ----------------------------------------------------
signed __int64 __fastcall sub_45B78(__int64 a1, int a2, int a3)
{
  _DWORD *v3; // x19
  signed __int64 result; // x0

  v3 = *(_DWORD **)(a1 + 16);
  if ( a2 == 3 )
    goto LABEL_4;
  if ( !a2 )
  {
    a3 = 8 * (unsigned __int64)EVP_CIPHER_CTX_key_length(a1);
LABEL_4:
    result = 1LL;
    *v3 = a3;
    return result;
  }
  return 0xFFFFFFFFLL;
}

//----- (0000000000045BB8) ----------------------------------------------------
int *__fastcall sub_45BB8(int *result, unsigned __int64 a2, __int64 a3, unsigned __int16 *a4, unsigned __int8 *a5, int a6)
{
  unsigned __int8 *v6; // x19
  unsigned __int16 *v7; // x21
  unsigned __int64 v8; // x28
  unsigned __int8 *v9; // x22
  signed __int64 v10; // x25
  unsigned int v11; // w23
  int v12; // w24
  unsigned __int64 v13; // x27
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  int v16; // w11
  unsigned int v17; // w9
  int *v18; // x11
  unsigned __int8 *v19; // x27
  unsigned __int64 v20; // x20
  unsigned int v21; // w28
  int v22; // w26
  unsigned __int8 v23; // w10
  __int16 v24; // x8^2
  unsigned int v25; // w10
  int v26; // w9
  int v27; // w8
  signed __int64 v28; // x11
  signed __int64 v29; // x9
  int v30; // w10
  int v31; // t1
  int v32; // t1
  int v33; // t1
  int v34; // t1
  int v35; // t1
  int v36; // w22
  unsigned int v37; // w9
  int v38; // w26
  unsigned __int8 v39; // w10
  __int64 v40; // x8
  int v41; // w10
  signed __int64 v42; // x9
  signed __int64 v43; // [xsp+0h] [xbp-80h]
  unsigned __int64 v44; // [xsp+8h] [xbp-78h]
  signed __int64 v45; // [xsp+10h] [xbp-70h]
  unsigned __int64 v46; // [xsp+10h] [xbp-70h]
  int *v47; // [xsp+18h] [xbp-68h]
  unsigned __int64 v48; // [xsp+18h] [xbp-68h]
  unsigned int v49; // [xsp+20h] [xbp-60h]
  int v50; // [xsp+24h] [xbp-5Ch]
  __int64 v51; // [xsp+28h] [xbp-58h]

  v6 = a5;
  v7 = a4;
  v8 = a2;
  v51 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = (unsigned __int8 *)result;
  v10 = a3 - 8;
  v11 = ((*a5 | (a5[3] << 24)) & 0xFFFF00FF | (a5[1] << 8)) & 0xFF00FFFF | (a5[2] << 16);
  v12 = ((a5[4] | (a5[7] << 24)) & 0xFF00FFFF | (a5[6] << 16)) & 0xFFFF00FF | (a5[5] << 8);
  if ( a6 )
  {
    if ( !(v10 & 0x8000000000000000LL) )
    {
      v13 = v10 & 0xFFFFFFFFFFFFFFF8LL;
      v14 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      v47 = (int *)((char *)result + v14);
      v15 = a2;
      v45 = a3 - 16;
      do
      {
        v16 = ((unsigned __int16)(v9[4] | (unsigned __int16)(v9[5] << 8)) | (v9[6] << 16)) & 0xFFFFFF | (v9[7] << 24);
        v49 = (((unsigned __int16)(*v9 | (unsigned __int16)(v9[1] << 8)) | (v9[2] << 16)) & 0xFFFFFF | (v9[3] << 24)) ^ v11;
        v50 = v16 ^ v12;
        result = sub_46010((int *)&v49, v7);
        v11 = v49;
        v10 -= 8LL;
        v9 += 8;
        v17 = v49 >> 16;
        *(_WORD *)v8 = v49;
        *(_BYTE *)(v8 + 2) = v17;
        *(_BYTE *)(v8 + 3) = HIBYTE(v11);
        v12 = v50;
        *(_BYTE *)(v8 + 5) = BYTE1(v50);
        *(_BYTE *)(v8 + 6) = BYTE2(v12);
        *(_BYTE *)(v8 + 4) = v12;
        *(_BYTE *)(v8 + 7) = HIBYTE(v12);
        v8 += 8LL;
      }
      while ( !(v10 & 0x8000000000000000LL) );
      v18 = v47;
      v8 = v15 + v14;
      v10 = v45 - v13;
      if ( v45 - v13 == -8LL )
        goto LABEL_23;
      goto LABEL_13;
    }
    v18 = result;
    if ( v10 != -8 )
    {
LABEL_13:
      v27 = 0;
      v28 = (signed __int64)v18 + v10;
      v29 = v28 + 8;
      v30 = 0;
      switch ( v28 + 8 )
      {
        case 0LL:
          goto LABEL_20;
        case 1LL:
          goto LABEL_19;
        case 2LL:
          goto LABEL_18;
        case 3LL:
          goto LABEL_17;
        case 4LL:
          goto LABEL_16;
        case 5LL:
          goto LABEL_15;
        case 6LL:
          v29 = v28 + 7;
          v27 = *(unsigned __int8 *)(v28 + 7) << 16;
LABEL_15:
          v31 = *(unsigned __int8 *)(v29-- - 1);
          v27 |= v31 << 8;
LABEL_16:
          v32 = *(unsigned __int8 *)(v29-- - 1);
          v27 |= v32;
LABEL_17:
          v33 = *(unsigned __int8 *)(v29-- - 1);
          v30 = v27;
          v27 = v33 << 24;
LABEL_18:
          v34 = *(unsigned __int8 *)(v29-- - 1);
          v27 |= v34 << 16;
LABEL_19:
          v35 = *(unsigned __int8 *)(v29-- - 1);
          v27 |= v35 << 8;
LABEL_20:
          v27 |= *(unsigned __int8 *)(v29 - 1);
          break;
        default:
          v30 = 0;
          break;
      }
      v49 = v27 ^ v11;
      v50 = v30 ^ v12;
      result = sub_46010((int *)&v49, v7);
      v36 = v49;
      v37 = v49 >> 16;
      *(_WORD *)v8 = v49;
      *(_BYTE *)(v8 + 2) = v37;
      *(_BYTE *)(v8 + 3) = HIBYTE(v36);
      v38 = v50;
      *(_BYTE *)(v8 + 5) = BYTE1(v50);
      *(_BYTE *)(v8 + 6) = BYTE2(v38);
      *(_BYTE *)(v8 + 4) = v38;
      *(_BYTE *)(v8 + 7) = HIBYTE(v38);
      goto def_45F64;
    }
LABEL_23:
    v36 = v11;
    v38 = v12;
    goto def_45F64;
  }
  if ( v10 & 0x8000000000000000LL )
  {
    v19 = (unsigned __int8 *)result;
    if ( v10 == -8 )
      goto LABEL_23;
  }
  else
  {
    v46 = v10 & 0xFFFFFFFFFFFFFFF8LL;
    v48 = a2;
    v44 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    v19 = (unsigned __int8 *)result + v44;
    v20 = a2;
    v43 = a3 - 16;
    do
    {
      v21 = v11;
      v22 = v12;
      v11 = ((unsigned __int16)(*v9 | (unsigned __int16)(v9[1] << 8)) | (v9[2] << 16)) & 0xFFFFFF | (v9[3] << 24);
      v49 = ((unsigned __int16)(*v9 | (unsigned __int16)(v9[1] << 8)) | (v9[2] << 16)) & 0xFFFFFF | (v9[3] << 24);
      v23 = v9[7];
      v12 = ((unsigned __int16)(v9[4] | (unsigned __int16)(v9[5] << 8)) | (v9[6] << 16)) & 0xFFFFFF | (v23 << 24);
      v50 = ((unsigned __int16)(v9[4] | (unsigned __int16)(v9[5] << 8)) | (v9[6] << 16)) & 0xFFFFFF | (v23 << 24);
      result = sub_4614C((int *)&v49, (__int64)v7);
      v10 -= 8LL;
      v9 += 8;
      v24 = HIWORD(v49) ^ HIWORD(v21);
      v25 = (v49 ^ v21) >> 8;
      v26 = v50 ^ v22;
      *(_BYTE *)v20 = v49 ^ v21;
      *(_BYTE *)(v20 + 1) = v25;
      *(_BYTE *)(v20 + 4) = v26;
      *(_WORD *)(v20 + 2) = __PAIR__(HIBYTE(v24), (unsigned __int8)v24);
      *(_BYTE *)(v20 + 5) = BYTE1(v26);
      *(_BYTE *)(v20 + 6) = BYTE2(v26);
      *(_BYTE *)(v20 + 7) = HIBYTE(v26);
      v20 += 8LL;
    }
    while ( !(v10 & 0x8000000000000000LL) );
    v8 = v48 + v44;
    v10 = v43 - v46;
    if ( v43 - v46 == -8LL )
      goto LABEL_23;
  }
  v36 = ((unsigned __int16)(*v19 | (unsigned __int16)(v19[1] << 8)) | (v19[2] << 16)) & 0xFFFFFF | (v19[3] << 24);
  v49 = ((unsigned __int16)(*v19 | (unsigned __int16)(v19[1] << 8)) | (v19[2] << 16)) & 0xFFFFFF | (v19[3] << 24);
  v39 = v19[7];
  v38 = ((unsigned __int16)(v19[4] | (unsigned __int16)(v19[5] << 8)) | (v19[6] << 16)) & 0xFFFFFF | (v39 << 24);
  v50 = ((unsigned __int16)(v19[4] | (unsigned __int16)(v19[5] << 8)) | (v19[6] << 16)) & 0xFFFFFF | (v39 << 24);
  result = sub_4614C((int *)&v49, (__int64)v7);
  v40 = v49 ^ v11;
  v41 = v50 ^ v12;
  v42 = v8 + v10 + 8;
  switch ( v40 )
  {
    case 0LL:
      goto LABEL_31;
    case 1LL:
      goto LABEL_30;
    case 2LL:
      goto LABEL_29;
    case 3LL:
      goto LABEL_28;
    case 4LL:
      goto LABEL_27;
    case 5LL:
      goto LABEL_26;
    case 6LL:
      *(_BYTE *)(v8 + v10 + 7) = BYTE2(v41);
      v42 = v8 + v10 + 7;
LABEL_26:
      *(_BYTE *)(v42-- - 1) = BYTE1(v41);
LABEL_27:
      *(_BYTE *)(v42-- - 1) = v41;
LABEL_28:
      *(_BYTE *)(v42-- - 1) = BYTE3(v40);
LABEL_29:
      *(_BYTE *)(v42-- - 1) = BYTE2(v40);
LABEL_30:
      *(_BYTE *)(v42-- - 1) = BYTE1(v40);
LABEL_31:
      *(_BYTE *)(v42 - 1) = v40;
      break;
    default:
      break;
  }
def_45F64:
  v6[1] = BYTE1(v36);
  v6[2] = BYTE2(v36);
  v6[3] = HIBYTE(v36);
  *v6 = v36;
  *((_WORD *)v6 + 2) = v38;
  v6[6] = BYTE2(v38);
  v6[7] = HIBYTE(v38);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v51;
  return result;
}

//----- (0000000000046010) ----------------------------------------------------
int *__fastcall sub_46010(int *result, unsigned __int16 *a2)
{
  unsigned int v2; // w12
  int v3; // w16
  signed int v4; // w9
  unsigned __int16 *v5; // x11
  int v6; // w13
  int v7; // w10
  signed int v8; // w14
  int v9; // w18
  int v10; // w16
  int v11; // w18
  int v12; // w15
  signed __int64 v13; // x15
  unsigned __int16 *v14; // x17
  unsigned int v15; // w16
  int v16; // w2
  int v17; // w18
  int v18; // w12
  int v19; // w10
  int v20; // w10
  int v21; // w14

  v3 = *result;
  v2 = result[1];
  v4 = 3;
  v5 = a2;
  v6 = (unsigned int)*result >> 16;
  v7 = v2 >> 16;
  v8 = 5;
  while ( 1 )
  {
    v13 = 4LL * (unsigned int)(v8 - 1);
    v14 = v5;
    do
    {
      v15 = (v7 & v2) + v3 + (v6 & ~v7) + *v14;
      --v8;
      v16 = v14[3] + v7;
      v3 = (v15 >> 15) & 1 | 2 * (unsigned __int16)v15;
      v17 = v14[2] + v2;
      v18 = v14[1] + v6 + (v3 & v7) + (v2 & ~v3);
      v6 = ((unsigned __int16)v18 >> 14) & 0xFFFC0003 | 4 * (unsigned __int16)v18;
      v19 = v17 + (v6 & v3) + (v7 & ~v6);
      v2 = ((unsigned __int16)v19 >> 13) & 0xFFF80007 | 8 * (unsigned __int16)v19;
      v20 = v16 + (v2 & v6) + (v3 & ~v2);
      v7 = ((unsigned __int16)v20 >> 11) & 0xFFE0001F | 32 * (unsigned __int16)v20;
      v14 += 4;
    }
    while ( v8 );
    v21 = (unsigned __int16)v3;
    if ( !--v4 )
      break;
    v9 = a2[v7 & 0x3F];
    v5 += v13 + 4;
    v10 = a2[(v9 + v3) & 0x3F];
    v11 = v9 + v21;
    if ( v4 == 2 )
      v8 = 6;
    else
      v8 = 5;
    v12 = a2[(v10 + v6) & 0x3F];
    v6 = v10 + (unsigned __int16)v6;
    v3 = v11;
    v7 = a2[(v12 + v2) & 0x3F] + (unsigned __int16)v7;
    v2 = v12 + (unsigned __int16)v2;
  }
  *result = (unsigned __int16)v3 | ((unsigned __int16)v6 << 16);
  result[1] = (unsigned __int16)v2 | ((unsigned __int16)v7 << 16);
  return result;
}

//----- (000000000004614C) ----------------------------------------------------
int *__fastcall sub_4614C(int *result, __int64 a2)
{
  int v2; // w11
  unsigned int v3; // w14
  signed __int64 v4; // x10
  signed int v5; // w9
  unsigned int v6; // w13
  unsigned int v7; // w17
  signed int v8; // w12
  signed __int64 v9; // x15
  _WORD *v10; // x16
  unsigned int v11; // w18
  int v12; // w3
  unsigned int v13; // w2
  unsigned int v14; // w4

  v2 = *result;
  v3 = result[1];
  v4 = a2 + 126;
  v5 = 3;
  v6 = (unsigned int)*result >> 16;
  v7 = v3 >> 16;
  v8 = 5;
  while ( 1 )
  {
    v9 = -4LL * (unsigned int)(v8 - 1);
    v10 = (_WORD *)v4;
    do
    {
      v11 = (((v7 & 0x1F) << 11) | (v7 >> 5))
          - ((((v3 | 0xFFFF0000) ^ 0xFFFF) & v2)
           + (v3 & v6))
          - (unsigned __int16)*v10;
      v12 = (((unsigned __int16)v3 >> 3) | ((v3 & 7) << 13))
          - (v6 & v2)
          - (unsigned __int16)*(v10 - 1)
          - (v11 & (v6 ^ 0xFFFF));
      v13 = (((v6 & 3) << 14) | (v6 >> 2))
          - (v11 & v2)
          - (unsigned __int16)*(v10 - 2)
          - (v12 & ((v2 | 0xFFFF0000) ^ 0xFFFF));
      v14 = (((unsigned __int16)v2 >> 1) | ((v2 & 1) << 15))
          - (unsigned __int16)*(v10 - 3)
          - (v12 & v11)
          - (v13 & ((v11 | 0xFFFF0000) ^ 0xFFFF));
      --v8;
      v7 = (unsigned __int16)((((v7 & 0x1F) << 11) | (v7 >> 5)) - ((~(_WORD)v3 & v2) + (v3 & v6)) - *v10);
      v3 = (unsigned __int16)((((unsigned __int16)v3 >> 3) | ((v3 & 7) << 13))
                            - (v6 & v2)
                            - *(v10 - 1)
                            - (v11 & ~(_WORD)v6));
      v6 = (unsigned __int16)((((v6 & 3) << 14) | (v6 >> 2)) - (v11 & v2) - *(v10 - 2) - (v12 & ~(_WORD)v2));
      v2 = (unsigned __int16)((((unsigned __int16)v2 >> 1) | ((v2 & 1) << 15))
                            - *(v10 - 3)
                            - (v12 & v11)
                            - (v13 & ~(_WORD)v11));
      v10 -= 4;
    }
    while ( v8 );
    if ( !--v5 )
      break;
    v7 = (unsigned __int16)(v11 - *(_WORD *)(a2 + 2LL * (v12 & 0x3F)));
    v4 = v4 + 2 * v9 - 8;
    if ( v5 == 2 )
      v8 = 6;
    else
      v8 = 5;
    v3 = (unsigned __int16)(v12 - *(_WORD *)(a2 + 2LL * (v13 & 0x3F)));
    v6 = (unsigned __int16)(v13 - *(_WORD *)(a2 + 2LL * (v14 & 0x3F)));
    v2 = (unsigned __int16)(v14 - *(_WORD *)(a2 + 2LL * (((_WORD)v11 - *(_WORD *)(a2 + 2LL * (v12 & 0x3F))) & 0x3F)));
  }
  *result = (unsigned __int16)v14 | ((unsigned __int16)v13 << 16);
  result[1] = (unsigned __int16)v12 | ((unsigned __int16)v11 << 16);
  return result;
}

//----- (00000000000462AC) ----------------------------------------------------
void *EVP_rc4()
{
  return &unk_F6B10;
}

//----- (00000000000462B8) ----------------------------------------------------
signed __int64 __fastcall sub_462B8(__int64 a1, __int64 a2)
{
  _QWORD *v2; // x19
  __int64 v3; // x20
  int v4; // w0

  v2 = *(_QWORD **)(a1 + 16);
  v3 = a2;
  v4 = EVP_CIPHER_CTX_key_length(a1);
  RC4_set_key(v2, v4, v3);
  return 1LL;
}

//----- (00000000000462F0) ----------------------------------------------------
signed __int64 __fastcall sub_462F0(__int64 a1, _BYTE *a2, char *a3, __int64 a4)
{
  RC4(*(_DWORD **)(a1 + 16), a4, a3, a2);
  return 1LL;
}

//----- (0000000000046318) ----------------------------------------------------
__int64 CRYPTO_is_NEON_capable_at_runtime()
{
  return dword_106E2C & 1;
}
// 106E2C: using guessed type int dword_106E2C;

//----- (000000000004632C) ----------------------------------------------------
__int64 sub_4632C()
{
  return ((unsigned int)dword_106E2C >> 2) & 1;
}
// 106E2C: using guessed type int dword_106E2C;

//----- (0000000000046340) ----------------------------------------------------
__int64 sub_46340()
{
  return ((unsigned int)dword_106E2C >> 5) & 1;
}
// 106E2C: using guessed type int dword_106E2C;

//----- (0000000000046358) ----------------------------------------------------
const char *SSLeay_version()
{
  return "BoringSSL";
}

//----- (0000000000046364) ----------------------------------------------------
signed __int64 SSLeay()
{
  return 268443823LL;
}

//----- (0000000000046370) ----------------------------------------------------
__int64 __fastcall DES_set_key(unsigned __int8 *a1, __int64 a2)
{
  int v2; // w10
  unsigned int v3; // w11
  int v4; // w12
  unsigned int v5; // w13
  unsigned int v6; // w12
  int v7; // w14
  unsigned int v8; // w13
  int v9; // w12
  int v10; // w14
  unsigned int v11; // w15
  int v12; // w12
  int v13; // w13
  unsigned int v14; // w12
  unsigned int v15; // w14
  __int64 v16; // x8
  _DWORD *v17; // x9
  char v18; // w16
  char v19; // w17
  unsigned int v20; // w15
  unsigned int v21; // w17
  unsigned int v22; // w14
  __int64 result; // x0
  unsigned int v24; // w15
  unsigned int v25; // w16

  v2 = ((unsigned __int16)(*a1 | (unsigned __int16)(a1[1] << 8)) | (a1[2] << 16)) & 0xFFFFFF | (a1[3] << 24);
  v3 = ((unsigned __int16)(a1[4] | (unsigned __int16)(a1[5] << 8)) | (a1[6] << 16)) & 0xFFFFFF | (a1[7] << 24);
  v4 = (v2 ^ (v3 >> 4)) & 0xF0F0F0F;
  v5 = (v4 ^ v2 ^ ((v4 ^ v2) << 18)) & 0xCCCC0000 ^ v4 ^ v2 ^ (((v4 ^ v2 ^ ((v4 ^ v2) << 18)) & 0xCCCC0000) >> 18);
  v6 = (v3 ^ 16 * v4 ^ ((v3 ^ 16 * v4) << 18)) & 0xCCCC0000 ^ v3 ^ 16 * v4 ^ (((v3 ^ 16 * v4 ^ ((v3 ^ 16 * v4) << 18)) & 0xCCCC0000) >> 18);
  v7 = (v5 ^ (v6 >> 1)) & 0x55555555;
  v8 = v7 ^ v5;
  v9 = v6 ^ 2 * v7;
  v10 = (v9 ^ (v8 >> 8)) & 0xFF00FF;
  v11 = v10 ^ v9;
  v12 = v8 ^ (v10 << 8);
  v13 = (v12 ^ (v11 >> 1)) & 0x55555555;
  v14 = v13 ^ v12;
  v15 = (((v14 >> 4) & 0xF000000 | (v11 ^ 2 * v13) & 0xFFFF) & 0xFF00FFFF | (((v11 ^ 2 * v13) & 0xFF) << 16)) & 0xFFFFFF00 | ((v11 ^ 2 * v13) >> 16) & 0xFF;
  v16 = 0LL;
  v17 = (_DWORD *)(a2 + 4);
  do
  {
    v18 = (0x7EFCuLL >> v16) & 1;
    v19 = v18 + 1;
    v20 = (v14 & 0xFFFFFFF) >> (v18 + 1);
    v18 = 27 - v18;
    v21 = v15 >> v19;
    v14 = v20 | (v14 << v18);
    v22 = v21 | (v15 << v18);
    result = (unsigned int)(dword_CFFA0[((v21 >> 8) & 0x3C | (v21 >> 7) & 3) + 320] | dword_CFFA0[(v21 & 0x3F) + 256]);
    v24 = dword_CFFA0[((v20 >> 7) & 0x3C | ((unsigned __int8)v20 >> 6)) + 64] | dword_CFFA0[v20 & 0x3F] | dword_CFFA0[((v20 >> 14) & 0x30 | (v20 >> 13) & 0xF) + 128] | dword_CFFA0[((v20 >> 21) & 6 | (v20 >> 20) & 1 | (v14 >> 22) & 0x38) + 192];
    v25 = result | dword_CFFA0[((v21 >> 15) & 0x3F) + 384] | dword_CFFA0[((v22 >> 22) & 0x30 | (v21 >> 21) & 0xF) + 448];
    ++v16;
    v15 = v22 & 0xFFFFFFF;
    *(v17 - 1) = ((unsigned __int16)v25 >> 14) | 4 * ((unsigned __int16)v24 | ((unsigned __int16)v25 << 16));
    *v17 = __PAIR__(v25 & 0x3FF0000 | (v24 >> 16), v25) >> 26;
    v17 += 2;
  }
  while ( v16 != 16 );
  return result;
}

//----- (0000000000046540) ----------------------------------------------------
unsigned __int8 *__fastcall DES_set_odd_parity(unsigned __int8 *result)
{
  unsigned __int8 v1; // w10
  unsigned __int8 v2; // w11
  unsigned __int8 v3; // w12
  unsigned __int8 v4; // w13
  unsigned __int8 v5; // w14
  unsigned __int8 v6; // w15
  unsigned __int8 v7; // w9

  v1 = byte_D07A0[result[1]];
  v2 = byte_D07A0[result[2]];
  v3 = byte_D07A0[result[3]];
  v4 = byte_D07A0[result[4]];
  v5 = byte_D07A0[result[5]];
  v6 = byte_D07A0[result[6]];
  v7 = byte_D07A0[result[7]];
  *result = byte_D07A0[*result];
  result[1] = v1;
  result[2] = v2;
  result[3] = v3;
  result[4] = v4;
  result[5] = v5;
  result[6] = v6;
  result[7] = v7;
  return result;
}

//----- (00000000000465AC) ----------------------------------------------------
_DWORD *__fastcall DES_encrypt3(int *a1, __int64 a2, __int64 a3, __int64 a4)
{
  int *v4; // x19
  unsigned int v5; // w9
  __int64 v6; // x21
  __int64 v7; // x20
  int v8; // w10
  int v9; // w9
  unsigned int v10; // w8
  int v11; // w10
  unsigned int v12; // w9
  int v13; // w8
  int v14; // w10
  unsigned int v15; // w8
  int v16; // w9
  int v17; // w10
  unsigned int v18; // w9
  int v19; // w8
  int v20; // w10
  _DWORD *result; // x0
  unsigned int v22; // w9
  int v23; // w10
  unsigned int v24; // w8
  int v25; // w9
  int v26; // w10
  unsigned int v27; // w9
  int v28; // w8
  int v29; // w10
  int v30; // w9
  unsigned int v31; // w8
  int v32; // w10
  unsigned int v33; // w9
  int v34; // w8
  int v35; // w10

  v4 = a1;
  v5 = a1[1];
  v6 = a3;
  v7 = a4;
  v8 = (*a1 ^ (v5 >> 4)) & 0xF0F0F0F;
  v9 = v5 ^ 16 * v8;
  v10 = v8 ^ *a1;
  v11 = (unsigned __int16)v9 ^ (v10 >> 16);
  v12 = v11 ^ v9;
  v13 = v10 ^ (v11 << 16);
  v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  v15 = v14 ^ v13;
  v16 = v12 ^ 4 * v14;
  v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  v18 = v17 ^ v16;
  v19 = v15 ^ (v17 << 8);
  v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *a1 = v20 ^ v19;
  a1[1] = v18 ^ 2 * v20;
  sub_466B0(a1, a2, 1);
  sub_466B0(v4, v6, 0);
  result = sub_466B0(v4, v7, 1);
  v22 = v4[1];
  v23 = (*v4 ^ (v22 >> 1)) & 0x55555555;
  v24 = v23 ^ *v4;
  v25 = v22 ^ 2 * v23;
  v26 = (v25 ^ (v24 >> 8)) & 0xFF00FF;
  v27 = v26 ^ v25;
  v28 = v24 ^ (v26 << 8);
  v29 = (v28 ^ (v27 >> 2)) & 0x33333333;
  v30 = v27 ^ 4 * v29;
  v31 = v29 ^ v28;
  v32 = (unsigned __int16)v30 ^ (v31 >> 16);
  v33 = v32 ^ v30;
  v34 = v31 ^ (v32 << 16);
  v35 = (v34 ^ (v33 >> 4)) & 0xF0F0F0F;
  *v4 = v35 ^ v34;
  v4[1] = v33 ^ 16 * v35;
  return result;
}

//----- (00000000000466B0) ----------------------------------------------------
_DWORD *__fastcall sub_466B0(_DWORD *result, __int64 a2, int a3)
{
  bool v3; // zf
  signed __int64 v4; // x8
  signed __int64 v5; // x15
  signed __int64 v6; // x24
  int v7; // w26
  unsigned __int64 v8; // t2
  unsigned int v9; // w25
  signed __int64 v10; // x9
  int v11; // w25
  int v12; // w28
  unsigned int v13; // w27
  unsigned int v14; // w24
  signed __int64 v15; // x22
  signed __int64 v16; // x22
  int v17; // w25
  unsigned int v18; // w28
  int v19; // w24
  signed __int64 v20; // x18
  unsigned int v21; // w25
  int v22; // w27
  int v23; // w25
  unsigned int v24; // w26
  int v25; // w27
  unsigned int v26; // w28
  unsigned __int64 v27; // t2
  unsigned int v28; // w22
  int v29; // w26
  signed __int64 v30; // x23
  unsigned int *v31; // x23
  int v32; // w25
  unsigned int v33; // w27
  int v34; // w22
  unsigned int v35; // w25
  int v36; // w26
  unsigned int v37; // w23
  signed __int64 v38; // x3
  int v39; // w24
  unsigned int v40; // w25
  unsigned __int64 v41; // t2
  signed __int64 v42; // x28
  _DWORD *v43; // x28
  int v44; // w23
  signed __int64 v45; // x5
  unsigned int v46; // w27
  int v47; // w22
  unsigned int v48; // w24
  int v49; // w25
  unsigned int v50; // w28
  unsigned __int64 v51; // t2
  unsigned int v52; // w27
  int v53; // w24
  signed __int64 v54; // x26
  _DWORD *v55; // x26
  int v56; // w22
  unsigned int v57; // w24
  int v58; // w25
  unsigned int v59; // w26
  signed __int64 v60; // x7
  int v61; // w23
  unsigned int v62; // w24
  unsigned __int64 v63; // t2
  signed __int64 v64; // x28
  _DWORD *v65; // x28
  int v66; // w23
  signed __int64 v67; // x20
  unsigned int v68; // w27
  int v69; // w22
  unsigned int v70; // w24
  int v71; // w26
  unsigned int v72; // w28
  unsigned __int64 v73; // t2
  unsigned int v74; // w27
  int v75; // w24
  signed __int64 v76; // x25
  _DWORD *v77; // x25
  int v78; // w22
  unsigned int v79; // w24
  int v80; // w26
  unsigned int v81; // w25
  int v82; // w23
  int v83; // w27
  int v84; // w24
  signed __int64 v85; // x26
  unsigned __int64 v86; // t2
  int *v87; // x26
  int v88; // w23
  int v89; // w26
  int v90; // w27
  int v91; // w23
  unsigned int v92; // w24
  int v93; // w25
  int v94; // w27
  unsigned int v95; // w26
  int v96; // w22
  signed __int64 v97; // x25
  _DWORD *v98; // x25
  unsigned __int64 v99; // t2
  int v100; // w22
  int *v101; // x20
  int v102; // w21
  unsigned int v103; // w20
  int v104; // w23
  int v105; // w21
  unsigned int v106; // w23
  unsigned __int64 v107; // t2
  unsigned int *v108; // x7
  int v109; // w19
  unsigned int v110; // w7
  unsigned int v111; // w22
  int v112; // w19
  unsigned __int64 v113; // t2
  unsigned int *v114; // x5
  int v115; // w6
  unsigned int v116; // w5
  unsigned int v117; // w21
  int v118; // w6
  unsigned __int64 v119; // t2
  unsigned int *v120; // x3
  int v121; // w4
  unsigned int v122; // w3
  unsigned int v123; // w19
  int v124; // w4
  unsigned __int64 v125; // t2
  unsigned int *v126; // x18
  int v127; // w2
  unsigned int v128; // w6
  unsigned int v129; // w18
  int v130; // w2
  unsigned int v131; // w18
  _DWORD *v132; // x9
  unsigned __int64 v133; // t2
  _DWORD *v134; // x8
  int v135; // w18
  int v136; // w9
  int v137; // w9

  v3 = a3 == 0;
  v4 = 15LL;
  if ( a3 )
    v5 = 0LL;
  else
    v5 = 15LL;
  v6 = a2 + 8 * v5;
  HIDWORD(v8) = *result;
  LODWORD(v8) = *result;
  v7 = v8 >> 29;
  v9 = v7 ^ *(_DWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 4) ^ v7;
  v10 = 14LL;
  v11 = dword_D08A0[(unsigned __int8)v9 >> 2] ^ __ROR4__(result[1], 29) ^ dword_D08A0[((unsigned __int16)v9 >> 10) + 128] ^ dword_D08A0[((v9 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v9 >> 26) + 384] ^ dword_D08A0[(((unsigned int)v6 >> 6) & 0x3F) + 64];
  v12 = dword_D08A0[(((unsigned int)v6 >> 14) & 0x3F) + 192];
  HIDWORD(v8) = v6;
  LODWORD(v8) = v6;
  v13 = v8 >> 4;
  v14 = ((unsigned int)v6 >> 22) & 0x3F;
  if ( a3 )
    v15 = 1LL;
  else
    v15 = 14LL;
  v16 = a2 + 8 * v15;
  v17 = v11 ^ v12;
  v18 = *(_DWORD *)v16;
  v19 = v17 ^ dword_D08A0[v14 + 320] ^ dword_D08A0[(v13 >> 26) + 448];
  v20 = 2LL;
  v21 = v19 ^ *(_DWORD *)v16;
  v22 = dword_D08A0[(unsigned __int8)(v19 ^ *(_DWORD *)v16) >> 2];
  LODWORD(v16) = v19 ^ *(_DWORD *)(v16 + 4);
  v23 = v22 ^ v7 ^ dword_D08A0[((unsigned __int16)(v19 ^ v18) >> 10) + 128] ^ dword_D08A0[((v21 >> 18) & 0x3F) + 256] ^ dword_D08A0[((v19 ^ v18) >> 26) + 384];
  v24 = ((unsigned int)v16 >> 14) & 0x3F;
  v25 = dword_D08A0[(((unsigned int)v16 >> 6) & 0x3F) + 64];
  HIDWORD(v27) = v16;
  LODWORD(v27) = v16;
  v26 = v27 >> 4;
  v28 = ((unsigned int)v16 >> 22) & 0x3F;
  v29 = dword_D08A0[v24 + 192];
  if ( a3 )
    v30 = 2LL;
  else
    v30 = 13LL;
  v31 = (unsigned int *)(a2 + 8 * v30);
  v32 = v23 ^ v25;
  v33 = *v31;
  v34 = v32 ^ v29 ^ dword_D08A0[v28 + 320] ^ dword_D08A0[(v26 >> 26) + 448];
  v35 = v34 ^ *v31;
  v36 = dword_D08A0[(unsigned __int8)(v34 ^ *v31) >> 2];
  v37 = v34 ^ v31[1];
  v38 = 3LL;
  v39 = v36 ^ v19 ^ dword_D08A0[((unsigned __int16)(v34 ^ v33) >> 10) + 128] ^ dword_D08A0[(((v34 ^ v33) >> 18) & 0x3F)
                                                                                         + 256] ^ dword_D08A0[(v35 >> 26) + 384];
  HIDWORD(v41) = v37;
  LODWORD(v41) = v37;
  v40 = v41 >> 4;
  if ( a3 )
    v42 = 3LL;
  else
    v42 = 12LL;
  v43 = (_DWORD *)(a2 + 8 * v42);
  v44 = v39 ^ dword_D08A0[((v37 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v37 >> 14) & 0x3F) + 192] ^ dword_D08A0[((v37 >> 22) & 0x3F) + 320] ^ dword_D08A0[(v40 >> 26) + 448];
  v45 = 4LL;
  v46 = v44 ^ v43[1];
  v47 = dword_D08A0[(unsigned __int8)(v44 ^ *v43) >> 2] ^ v34 ^ dword_D08A0[((unsigned __int16)(v44 ^ *(_WORD *)v43) >> 10)
                                                                          + 128] ^ dword_D08A0[((((unsigned int)v44 ^ *v43) >> 18) & 0x3F)
                                                                                             + 256] ^ dword_D08A0[(((unsigned int)v44 ^ *v43) >> 26) + 384];
  v48 = (v46 >> 14) & 0x3F;
  v49 = dword_D08A0[((v46 >> 6) & 0x3F) + 64];
  HIDWORD(v51) = v44 ^ v43[1];
  LODWORD(v51) = v44 ^ v43[1];
  v50 = v51 >> 4;
  v52 = (v46 >> 22) & 0x3F;
  v53 = dword_D08A0[v48 + 192];
  if ( a3 )
    v54 = 4LL;
  else
    v54 = 11LL;
  v55 = (_DWORD *)(a2 + 8 * v54);
  v56 = v47 ^ v49 ^ v53 ^ dword_D08A0[v52 + 320] ^ dword_D08A0[(v50 >> 26) + 448];
  v57 = v56 ^ *v55;
  v58 = dword_D08A0[(unsigned __int8)(v56 ^ *v55) >> 2];
  v59 = v56 ^ v55[1];
  v60 = 5LL;
  v61 = v58 ^ v44 ^ dword_D08A0[((unsigned __int16)v57 >> 10) + 128] ^ dword_D08A0[((v57 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v57 >> 26) + 384];
  HIDWORD(v63) = v59;
  LODWORD(v63) = v59;
  v62 = v63 >> 4;
  if ( a3 )
    v64 = 5LL;
  else
    v64 = 10LL;
  v65 = (_DWORD *)(a2 + 8 * v64);
  v66 = v61 ^ dword_D08A0[((v59 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v59 >> 14) & 0x3F) + 192] ^ dword_D08A0[((v59 >> 22) & 0x3F) + 320] ^ dword_D08A0[(v62 >> 26) + 448];
  v67 = 6LL;
  v68 = v66 ^ v65[1];
  v69 = dword_D08A0[(unsigned __int8)(v66 ^ *v65) >> 2] ^ v56 ^ dword_D08A0[((unsigned __int16)(v66 ^ *(_WORD *)v65) >> 10)
                                                                          + 128] ^ dword_D08A0[((((unsigned int)v66 ^ *v65) >> 18) & 0x3F)
                                                                                             + 256] ^ dword_D08A0[(((unsigned int)v66 ^ *v65) >> 26) + 384];
  v70 = (v68 >> 14) & 0x3F;
  v71 = dword_D08A0[((v68 >> 6) & 0x3F) + 64];
  HIDWORD(v73) = v66 ^ v65[1];
  LODWORD(v73) = v66 ^ v65[1];
  v72 = v73 >> 4;
  v74 = (v68 >> 22) & 0x3F;
  v75 = dword_D08A0[v70 + 192];
  if ( a3 )
    v76 = 6LL;
  else
    v76 = 9LL;
  v77 = (_DWORD *)(a2 + 8 * v76);
  v78 = v69 ^ v71 ^ v75 ^ dword_D08A0[v74 + 320] ^ dword_D08A0[(v72 >> 26) + 448];
  v79 = v78 ^ *v77;
  v80 = dword_D08A0[(unsigned __int8)(v78 ^ *v77) >> 2];
  v81 = v78 ^ v77[1];
  v82 = v80 ^ v66 ^ dword_D08A0[((unsigned __int16)v79 >> 10) + 128];
  v83 = dword_D08A0[((v79 >> 18) & 0x3F) + 256];
  v84 = dword_D08A0[(v79 >> 26) + 384];
  if ( a3 )
    v85 = 7LL;
  else
    v85 = 8LL;
  HIDWORD(v86) = v81;
  LODWORD(v86) = v81;
  v87 = (int *)(a2 + 8 * v85);
  v88 = v82 ^ v83 ^ v84 ^ dword_D08A0[((v81 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v81 >> 14) & 0x3F) + 192];
  v90 = *v87;
  v89 = v87[1];
  v91 = v88 ^ dword_D08A0[((v81 >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v86 >> 4) >> 26) + 448];
  if ( a3 )
    v67 = 9LL;
  v92 = v91 ^ v90;
  v93 = dword_D08A0[(unsigned __int8)(v91 ^ v90) >> 2];
  v94 = dword_D08A0[((unsigned __int16)(v91 ^ v90) >> 10) + 128];
  v95 = v91 ^ v89;
  v96 = v93 ^ v78;
  if ( a3 )
    v97 = 8LL;
  else
    v97 = 7LL;
  v98 = (_DWORD *)(a2 + 8 * v97);
  HIDWORD(v99) = v95;
  LODWORD(v99) = v95;
  v100 = v96 ^ v94 ^ dword_D08A0[((v92 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v92 >> 26) + 384] ^ dword_D08A0[((v95 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v95 >> 14) & 0x3F) + 192] ^ dword_D08A0[((v95 >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v99 >> 4) >> 26) + 448];
  v101 = (int *)(a2 + 8 * v67);
  HIDWORD(v99) = v100 ^ v98[1];
  LODWORD(v99) = HIDWORD(v99);
  v102 = dword_D08A0[(unsigned __int8)(v100 ^ *v98) >> 2] ^ v91 ^ dword_D08A0[((unsigned __int16)(v100 ^ *v98) >> 10)
                                                                            + 128] ^ dword_D08A0[((((unsigned int)v100 ^ *v98) >> 18) & 0x3F)
                                                                                               + 256] ^ dword_D08A0[(((unsigned int)v100 ^ *v98) >> 26) + 384] ^ dword_D08A0[((HIDWORD(v99) >> 6) & 0x3F) + 64];
  v104 = *v101;
  v103 = v101[1];
  v105 = v102 ^ dword_D08A0[((HIDWORD(v99) >> 14) & 0x3F) + 192] ^ dword_D08A0[((HIDWORD(v99) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v99 >> 4) >> 26) + 448];
  if ( a3 )
    v60 = 10LL;
  v106 = v105 ^ v104;
  HIDWORD(v107) = v105 ^ v103;
  LODWORD(v107) = v105 ^ v103;
  v108 = (unsigned int *)(a2 + 8 * v60);
  v109 = dword_D08A0[(unsigned __int8)v106 >> 2] ^ v100 ^ dword_D08A0[((unsigned __int16)v106 >> 10) + 128] ^ dword_D08A0[((v106 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v106 >> 26) + 384] ^ dword_D08A0[(((v105 ^ v103) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v105 ^ v103) >> 14) & 0x3F) + 192];
  v111 = *v108;
  v110 = v108[1];
  v112 = v109 ^ dword_D08A0[(((v105 ^ v103) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v107 >> 4) >> 26) + 448];
  if ( a3 )
    v45 = 11LL;
  HIDWORD(v113) = v112 ^ v110;
  LODWORD(v113) = v112 ^ v110;
  v114 = (unsigned int *)(a2 + 8 * v45);
  v115 = dword_D08A0[(unsigned __int8)(v112 ^ v111) >> 2] ^ v105 ^ dword_D08A0[((unsigned __int16)(v112 ^ v111) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v112 ^ v111) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v112 ^ v111) >> 26) + 384] ^ dword_D08A0[(((v112 ^ v110) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v112 ^ v110) >> 14) & 0x3F) + 192];
  v117 = *v114;
  v116 = v114[1];
  v118 = v115 ^ dword_D08A0[(((v112 ^ v110) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v113 >> 4) >> 26) + 448];
  if ( a3 )
    v38 = 12LL;
  HIDWORD(v119) = v118 ^ v116;
  LODWORD(v119) = v118 ^ v116;
  v120 = (unsigned int *)(a2 + 8 * v38);
  v121 = dword_D08A0[(unsigned __int8)(v118 ^ v117) >> 2] ^ v112 ^ dword_D08A0[((unsigned __int16)(v118 ^ v117) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v118 ^ v117) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v118 ^ v117) >> 26) + 384] ^ dword_D08A0[(((v118 ^ v116) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v118 ^ v116) >> 14) & 0x3F) + 192];
  v123 = *v120;
  v122 = v120[1];
  v124 = v121 ^ dword_D08A0[(((v118 ^ v116) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v119 >> 4) >> 26) + 448];
  if ( a3 )
    v20 = 13LL;
  HIDWORD(v125) = v124 ^ v122;
  LODWORD(v125) = v124 ^ v122;
  v126 = (unsigned int *)(a2 + 8 * v20);
  v127 = dword_D08A0[(unsigned __int8)(v124 ^ v123) >> 2] ^ v118 ^ dword_D08A0[((unsigned __int16)(v124 ^ v123) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v124 ^ v123) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v124 ^ v123) >> 26) + 384] ^ dword_D08A0[(((v124 ^ v122) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v124 ^ v122) >> 14) & 0x3F) + 192];
  v128 = *v126;
  v129 = v126[1];
  v130 = v127 ^ dword_D08A0[(((v124 ^ v122) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v125 >> 4) >> 26) + 448];
  if ( v3 )
    v10 = 1LL;
  v131 = v130 ^ v129;
  v132 = (_DWORD *)(a2 + 8 * v10);
  if ( v3 )
    v4 = 0LL;
  HIDWORD(v133) = v131;
  LODWORD(v133) = v131;
  v134 = (_DWORD *)(a2 + 8 * v4);
  v135 = dword_D08A0[(unsigned __int8)(v130 ^ v128) >> 2] ^ v124 ^ dword_D08A0[((unsigned __int16)(v130 ^ v128) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v130 ^ v128) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v130 ^ v128) >> 26) + 384] ^ dword_D08A0[((v131 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v131 >> 14) & 0x3F) + 192] ^ dword_D08A0[((v131 >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v133 >> 4) >> 26) + 448];
  HIDWORD(v133) = v135 ^ v132[1];
  LODWORD(v133) = v135 ^ v132[1];
  v136 = dword_D08A0[(unsigned __int8)(v135 ^ *v132) >> 2] ^ v130 ^ dword_D08A0[((unsigned __int16)(v135 ^ *(_WORD *)v132) >> 10)
                                                                              + 128] ^ dword_D08A0[((((unsigned int)v135 ^ *v132) >> 18) & 0x3F)
                                                                                                 + 256] ^ dword_D08A0[(((unsigned int)v135 ^ *v132) >> 26) + 384] ^ dword_D08A0[((HIDWORD(v133) >> 6) & 0x3F) + 64] ^ dword_D08A0[((HIDWORD(v133) >> 14) & 0x3F) + 192] ^ dword_D08A0[((HIDWORD(v133) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v133 >> 4) >> 26) + 448];
  HIDWORD(v133) = v136 ^ v134[1];
  LODWORD(v133) = v136 ^ v134[1];
  LODWORD(v134) = dword_D08A0[(unsigned __int8)(v136 ^ *v134) >> 2] ^ v135 ^ dword_D08A0[((unsigned __int16)(v136 ^ *v134) >> 10)
                                                                                       + 128] ^ dword_D08A0[((((unsigned int)v136 ^ *v134) >> 18) & 0x3F) + 256] ^ dword_D08A0[(((unsigned int)v136 ^ *v134) >> 26) + 384] ^ dword_D08A0[((HIDWORD(v133) >> 6) & 0x3F) + 64] ^ dword_D08A0[((HIDWORD(v133) >> 14) & 0x3F) + 192] ^ dword_D08A0[((HIDWORD(v133) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v133 >> 4) >> 26) + 448];
  HIDWORD(v133) = v136;
  LODWORD(v133) = v136;
  v137 = v133 >> 3;
  HIDWORD(v133) = (_DWORD)v134;
  LODWORD(v133) = (_DWORD)v134;
  *result = v137;
  result[1] = v133 >> 3;
  return result;
}

//----- (0000000000046ECC) ----------------------------------------------------
_DWORD *__fastcall DES_decrypt3(int *a1, __int64 a2, __int64 a3, __int64 a4)
{
  int *v4; // x19
  unsigned int v5; // w9
  __int64 v6; // x20
  __int64 v7; // x21
  int v8; // w10
  int v9; // w9
  unsigned int v10; // w8
  int v11; // w10
  unsigned int v12; // w9
  int v13; // w8
  int v14; // w10
  unsigned int v15; // w8
  int v16; // w9
  int v17; // w10
  unsigned int v18; // w9
  int v19; // w8
  int v20; // w10
  _DWORD *result; // x0
  unsigned int v22; // w9
  int v23; // w10
  unsigned int v24; // w8
  int v25; // w9
  int v26; // w10
  unsigned int v27; // w9
  int v28; // w8
  int v29; // w10
  int v30; // w9
  unsigned int v31; // w8
  int v32; // w10
  unsigned int v33; // w9
  int v34; // w8
  int v35; // w10

  v4 = a1;
  v5 = a1[1];
  v6 = a3;
  v7 = a2;
  v8 = (*a1 ^ (v5 >> 4)) & 0xF0F0F0F;
  v9 = v5 ^ 16 * v8;
  v10 = v8 ^ *a1;
  v11 = (unsigned __int16)v9 ^ (v10 >> 16);
  v12 = v11 ^ v9;
  v13 = v10 ^ (v11 << 16);
  v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  v15 = v14 ^ v13;
  v16 = v12 ^ 4 * v14;
  v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  v18 = v17 ^ v16;
  v19 = v15 ^ (v17 << 8);
  v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *a1 = v20 ^ v19;
  a1[1] = v18 ^ 2 * v20;
  sub_466B0(a1, a4, 0);
  sub_466B0(v4, v6, 1);
  result = sub_466B0(v4, v7, 0);
  v22 = v4[1];
  v23 = (*v4 ^ (v22 >> 1)) & 0x55555555;
  v24 = v23 ^ *v4;
  v25 = v22 ^ 2 * v23;
  v26 = (v25 ^ (v24 >> 8)) & 0xFF00FF;
  v27 = v26 ^ v25;
  v28 = v24 ^ (v26 << 8);
  v29 = (v28 ^ (v27 >> 2)) & 0x33333333;
  v30 = v27 ^ 4 * v29;
  v31 = v29 ^ v28;
  v32 = (unsigned __int16)v30 ^ (v31 >> 16);
  v33 = v32 ^ v30;
  v34 = v31 ^ (v32 << 16);
  v35 = (v34 ^ (v33 >> 4)) & 0xF0F0F0F;
  *v4 = v35 ^ v34;
  v4[1] = v33 ^ 16 * v35;
  return result;
}

//----- (0000000000046FD4) ----------------------------------------------------
unsigned int *__fastcall DES_ecb_encrypt(unsigned __int8 *a1, __int64 a2, __int64 a3, int a4)
{
  unsigned __int64 v4; // x20
  __int64 v5; // x19
  unsigned int *result; // x0
  __int16 v7; // x8^2
  unsigned int v8; // w9
  __int16 v9; // x8^2
  unsigned int v10; // w9
  unsigned int v11; // [xsp+0h] [xbp-20h]
  unsigned int v12; // [xsp+4h] [xbp-1Ch]
  __int64 v13; // [xsp+8h] [xbp-18h]

  v4 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v5 = a2;
  v13 = *(_QWORD *)(v4 + 40);
  v11 = ((unsigned __int16)(*a1 | (unsigned __int16)(a1[1] << 8)) | (a1[2] << 16)) & 0xFFFFFF | (a1[3] << 24);
  v12 = ((unsigned __int16)(a1[4] | (unsigned __int16)(a1[5] << 8)) | (a1[6] << 16)) & 0xFFFFFF | (a1[7] << 24);
  result = sub_470A8(&v11, a3, a4);
  v7 = HIWORD(v11);
  v8 = v11 >> 8;
  *(_BYTE *)v5 = v11;
  *(_BYTE *)(v5 + 1) = v8;
  *(_WORD *)(v5 + 2) = __PAIR__(HIBYTE(v7), (unsigned __int8)v7);
  v9 = HIWORD(v12);
  v10 = v12 >> 8;
  *(_BYTE *)(v5 + 4) = v12;
  *(_BYTE *)(v5 + 5) = v10;
  *(_WORD *)(v5 + 6) = __PAIR__(HIBYTE(v9), (unsigned __int8)v9);
  *(_QWORD *)(v4 + 40);
  return result;
}

//----- (00000000000470A8) ----------------------------------------------------
unsigned int *__fastcall sub_470A8(unsigned int *result, __int64 a2, int a3)
{
  unsigned int v3; // w20
  unsigned int v4; // w21
  bool v5; // zf
  signed __int64 v6; // x8
  signed __int64 v7; // x22
  int v8; // w26
  int v9; // w21
  unsigned int v10; // w20
  int v11; // w26
  unsigned int v12; // w21
  int v13; // w20
  int v14; // w26
  unsigned int v15; // w20
  int v16; // w21
  int v17; // w26
  signed __int64 v18; // x22
  unsigned int v19; // w21
  int v20; // w20
  int v21; // w26
  int v22; // w20
  int v23; // w20
  unsigned __int64 v24; // t2
  unsigned int v25; // w25
  int v26; // w21
  int v27; // w25
  int v28; // w27
  signed __int64 v29; // x9
  int v30; // w22
  unsigned int v31; // w26
  signed __int64 v32; // x23
  signed __int64 v33; // x23
  unsigned int v34; // w28
  int v35; // w22
  unsigned int v36; // w21
  int v37; // w21
  int v38; // w28
  unsigned __int64 v39; // t2
  int v40; // w25
  signed __int64 v41; // x18
  int v42; // w23
  unsigned int v43; // w26
  signed __int64 v44; // x24
  _DWORD *v45; // x24
  int v46; // w23
  unsigned int v47; // w25
  int v48; // w26
  int v49; // w27
  unsigned int v50; // w24
  signed __int64 v51; // x3
  int v52; // w22
  int v53; // w26
  int v54; // w25
  signed __int64 v55; // x28
  unsigned __int64 v56; // t2
  int *v57; // x28
  int v58; // w22
  unsigned int v59; // w28
  int v60; // w26
  int v61; // w22
  signed __int64 v62; // x5
  unsigned int v63; // w24
  int v64; // w25
  signed __int64 v65; // x27
  _DWORD *v66; // x26
  unsigned __int64 v67; // t2
  int v68; // w23
  unsigned int v69; // w24
  int v70; // w25
  unsigned int v71; // w26
  signed __int64 v72; // x7
  int v73; // w22
  unsigned int v74; // w24
  signed __int64 v75; // x28
  _DWORD *v76; // x28
  int v77; // w22
  signed __int64 v78; // x20
  unsigned int v79; // w27
  int v80; // w23
  int v81; // w24
  int v82; // w26
  unsigned int v83; // w28
  unsigned __int64 v84; // t2
  int v85; // w27
  int v86; // w24
  signed __int64 v87; // x25
  _DWORD *v88; // x25
  int v89; // w23
  unsigned int v90; // w24
  int v91; // w26
  unsigned int v92; // w25
  int v93; // w22
  int v94; // w27
  int v95; // w24
  signed __int64 v96; // x26
  unsigned __int64 v97; // t2
  int *v98; // x26
  int v99; // w22
  int v100; // w26
  int v101; // w27
  int v102; // w22
  unsigned int v103; // w24
  int v104; // w25
  int v105; // w27
  unsigned int v106; // w26
  int v107; // w23
  signed __int64 v108; // x25
  _DWORD *v109; // x25
  unsigned __int64 v110; // t2
  int v111; // w23
  int *v112; // x20
  int v113; // w21
  unsigned int v114; // w20
  int v115; // w22
  int v116; // w21
  unsigned int v117; // w22
  unsigned __int64 v118; // t2
  unsigned int *v119; // x7
  int v120; // w19
  unsigned int v121; // w7
  unsigned int v122; // w23
  int v123; // w19
  unsigned __int64 v124; // t2
  unsigned int *v125; // x5
  int v126; // w6
  unsigned int v127; // w5
  unsigned int v128; // w21
  int v129; // w6
  unsigned __int64 v130; // t2
  unsigned int *v131; // x3
  int v132; // w4
  unsigned int v133; // w3
  unsigned int v134; // w19
  int v135; // w4
  unsigned __int64 v136; // t2
  unsigned int *v137; // x18
  int v138; // w2
  unsigned int v139; // w6
  unsigned int v140; // w18
  int v141; // w2
  unsigned int v142; // w18
  _DWORD *v143; // x9
  unsigned __int64 v144; // t2
  signed __int64 v145; // x8
  int v146; // w18
  int v147; // w9
  int v148; // w9
  unsigned int v149; // w10
  unsigned int v150; // w9
  int v151; // w10
  int v152; // w9
  unsigned int v153; // w10
  unsigned int v154; // w9
  int v155; // w10
  int v156; // w9
  unsigned int v157; // w10

  v3 = *result;
  v4 = result[1];
  v5 = a3 == 0;
  v6 = 15LL;
  if ( a3 )
    v7 = 0LL;
  else
    v7 = 15LL;
  v8 = (v3 ^ (v4 >> 4)) & 0xF0F0F0F;
  v9 = v4 ^ 16 * v8;
  v10 = v8 ^ v3;
  v11 = (unsigned __int16)v9 ^ (v10 >> 16);
  v12 = v11 ^ v9;
  v13 = v10 ^ (v11 << 16);
  v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  v15 = v14 ^ v13;
  v16 = v12 ^ 4 * v14;
  v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  v18 = a2 + 8 * v7;
  v19 = v17 ^ v16;
  v20 = v15 ^ (v17 << 8);
  v21 = (v20 ^ (v19 >> 1)) & 0x55555555;
  v22 = v21 ^ v20;
  HIDWORD(v24) = v22;
  LODWORD(v24) = v22;
  v23 = v24 >> 29;
  v25 = v23 ^ *(_DWORD *)v18;
  v26 = v19 ^ 2 * v21;
  LODWORD(v18) = v23 ^ *(_DWORD *)(v18 + 4);
  v27 = dword_D08A0[((unsigned __int16)v25 >> 10) + 128] ^ dword_D08A0[(unsigned __int8)v25 >> 2] ^ dword_D08A0[((v25 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v25 >> 26) + 384] ^ dword_D08A0[(((unsigned int)v18 >> 6) & 0x3F) + 64];
  HIDWORD(v24) = v18;
  LODWORD(v24) = v18;
  v28 = dword_D08A0[(((unsigned int)v18 >> 14) & 0x3F) + 192];
  v29 = 14LL;
  v30 = dword_D08A0[(((unsigned int)v18 >> 22) & 0x3F) + 320];
  v31 = (unsigned int)(v24 >> 4) >> 26;
  if ( a3 )
    v32 = 1LL;
  else
    v32 = 14LL;
  v33 = a2 + 8 * v32;
  v34 = *(_DWORD *)v33;
  v35 = v27 ^ v28 ^ v30 ^ dword_D08A0[v31 + 448] ^ __ROR4__(v26, 29);
  v36 = v35 ^ *(_DWORD *)v33;
  LODWORD(v33) = v35 ^ *(_DWORD *)(v33 + 4);
  v37 = dword_D08A0[((unsigned __int16)(v35 ^ v34) >> 10) + 128] ^ dword_D08A0[(unsigned __int8)(v35 ^ v34) >> 2] ^ dword_D08A0[(((v35 ^ v34) >> 18) & 0x3F) + 256] ^ dword_D08A0[(v36 >> 26) + 384];
  v38 = dword_D08A0[(((unsigned int)v33 >> 6) & 0x3F) + 64];
  HIDWORD(v39) = v33;
  LODWORD(v39) = v33;
  v40 = dword_D08A0[(((unsigned int)v33 >> 14) & 0x3F) + 192];
  v41 = 2LL;
  v42 = dword_D08A0[(((unsigned int)v33 >> 22) & 0x3F) + 320];
  v43 = (unsigned int)(v39 >> 4) >> 26;
  if ( a3 )
    v44 = 2LL;
  else
    v44 = 13LL;
  v45 = (_DWORD *)(a2 + 8 * v44);
  v46 = v37 ^ v38 ^ v40 ^ v42 ^ dword_D08A0[v43 + 448] ^ v23;
  v47 = v46 ^ *v45;
  v48 = dword_D08A0[(unsigned __int8)(v46 ^ *v45) >> 2];
  v49 = dword_D08A0[((unsigned __int16)(v46 ^ *v45) >> 10) + 128];
  v50 = v46 ^ v45[1];
  v51 = 3LL;
  v52 = v49 ^ v48 ^ v35;
  v53 = dword_D08A0[((v47 >> 18) & 0x3F) + 256];
  v54 = dword_D08A0[(v47 >> 26) + 384];
  if ( a3 )
    v55 = 3LL;
  else
    v55 = 12LL;
  HIDWORD(v56) = v50;
  LODWORD(v56) = v50;
  v57 = (int *)(a2 + 8 * v55);
  v58 = v52 ^ v53 ^ v54 ^ dword_D08A0[((v50 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v50 >> 14) & 0x3F) + 192];
  v60 = *v57;
  v59 = v57[1];
  v61 = v58 ^ dword_D08A0[((v50 >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v56 >> 4) >> 26) + 448];
  v62 = 4LL;
  v63 = v61 ^ v60;
  v64 = dword_D08A0[(unsigned __int8)(v61 ^ v60) >> 2];
  if ( a3 )
    v65 = 4LL;
  else
    v65 = 11LL;
  v66 = (_DWORD *)(a2 + 8 * v65);
  HIDWORD(v67) = v61 ^ v59;
  LODWORD(v67) = v61 ^ v59;
  v68 = v64 ^ v46 ^ dword_D08A0[((unsigned __int16)v63 >> 10) + 128] ^ dword_D08A0[((v63 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v63 >> 26) + 384] ^ dword_D08A0[(((v61 ^ v59) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v61 ^ v59) >> 14) & 0x3F) + 192] ^ dword_D08A0[(((v61 ^ v59) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v67 >> 4) >> 26) + 448];
  v69 = v68 ^ *v66;
  v70 = dword_D08A0[(unsigned __int8)(v68 ^ *v66) >> 2];
  v71 = v68 ^ v66[1];
  v72 = 5LL;
  v73 = v70 ^ v61 ^ dword_D08A0[((unsigned __int16)v69 >> 10) + 128] ^ dword_D08A0[((v69 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v69 >> 26) + 384];
  HIDWORD(v67) = v71;
  LODWORD(v67) = v71;
  v74 = v67 >> 4;
  if ( a3 )
    v75 = 5LL;
  else
    v75 = 10LL;
  v76 = (_DWORD *)(a2 + 8 * v75);
  v77 = v73 ^ dword_D08A0[((v71 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v71 >> 14) & 0x3F) + 192] ^ dword_D08A0[((v71 >> 22) & 0x3F) + 320] ^ dword_D08A0[(v74 >> 26) + 448];
  v78 = 6LL;
  v79 = v77 ^ v76[1];
  v80 = dword_D08A0[(unsigned __int8)(v77 ^ *v76) >> 2] ^ v68 ^ dword_D08A0[((unsigned __int16)(v77 ^ *(_WORD *)v76) >> 10)
                                                                          + 128] ^ dword_D08A0[((((unsigned int)v77 ^ *v76) >> 18) & 0x3F)
                                                                                             + 256] ^ dword_D08A0[(((unsigned int)v77 ^ *v76) >> 26) + 384];
  v81 = (v79 >> 14) & 0x3F;
  v82 = dword_D08A0[((v79 >> 6) & 0x3F) + 64];
  HIDWORD(v84) = v77 ^ v76[1];
  LODWORD(v84) = v77 ^ v76[1];
  v83 = v84 >> 4;
  v85 = (v79 >> 22) & 0x3F;
  v86 = dword_D08A0[v81 + 192];
  if ( a3 )
    v87 = 6LL;
  else
    v87 = 9LL;
  v88 = (_DWORD *)(a2 + 8 * v87);
  v89 = v80 ^ v82 ^ v86 ^ dword_D08A0[v85 + 320] ^ dword_D08A0[(v83 >> 26) + 448];
  v90 = v89 ^ *v88;
  v91 = dword_D08A0[(unsigned __int8)(v89 ^ *v88) >> 2];
  v92 = v89 ^ v88[1];
  v93 = v91 ^ v77 ^ dword_D08A0[((unsigned __int16)v90 >> 10) + 128];
  v94 = dword_D08A0[((v90 >> 18) & 0x3F) + 256];
  v95 = dword_D08A0[(v90 >> 26) + 384];
  if ( a3 )
    v96 = 7LL;
  else
    v96 = 8LL;
  HIDWORD(v97) = v92;
  LODWORD(v97) = v92;
  v98 = (int *)(a2 + 8 * v96);
  v99 = v93 ^ v94 ^ v95 ^ dword_D08A0[((v92 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v92 >> 14) & 0x3F) + 192];
  v101 = *v98;
  v100 = v98[1];
  v102 = v99 ^ dword_D08A0[((v92 >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v97 >> 4) >> 26) + 448];
  if ( a3 )
    v78 = 9LL;
  v103 = v102 ^ v101;
  v104 = dword_D08A0[(unsigned __int8)(v102 ^ v101) >> 2];
  v105 = dword_D08A0[((unsigned __int16)(v102 ^ v101) >> 10) + 128];
  v106 = v102 ^ v100;
  v107 = v104 ^ v89;
  if ( a3 )
    v108 = 8LL;
  else
    v108 = 7LL;
  v109 = (_DWORD *)(a2 + 8 * v108);
  HIDWORD(v110) = v106;
  LODWORD(v110) = v106;
  v111 = v107 ^ v105 ^ dword_D08A0[((v103 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v103 >> 26) + 384] ^ dword_D08A0[((v106 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v106 >> 14) & 0x3F) + 192] ^ dword_D08A0[((v106 >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v110 >> 4) >> 26) + 448];
  v112 = (int *)(a2 + 8 * v78);
  HIDWORD(v110) = v111 ^ v109[1];
  LODWORD(v110) = HIDWORD(v110);
  v113 = dword_D08A0[(unsigned __int8)(v111 ^ *v109) >> 2] ^ v102 ^ dword_D08A0[((unsigned __int16)(v111 ^ *v109) >> 10)
                                                                              + 128] ^ dword_D08A0[((((unsigned int)v111 ^ *v109) >> 18) & 0x3F)
                                                                                                 + 256] ^ dword_D08A0[(((unsigned int)v111 ^ *v109) >> 26) + 384] ^ dword_D08A0[((HIDWORD(v110) >> 6) & 0x3F) + 64];
  v115 = *v112;
  v114 = v112[1];
  v116 = v113 ^ dword_D08A0[((HIDWORD(v110) >> 14) & 0x3F) + 192] ^ dword_D08A0[((HIDWORD(v110) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v110 >> 4) >> 26) + 448];
  if ( a3 )
    v72 = 10LL;
  v117 = v116 ^ v115;
  HIDWORD(v118) = v116 ^ v114;
  LODWORD(v118) = v116 ^ v114;
  v119 = (unsigned int *)(a2 + 8 * v72);
  v120 = dword_D08A0[(unsigned __int8)v117 >> 2] ^ v111 ^ dword_D08A0[((unsigned __int16)v117 >> 10) + 128] ^ dword_D08A0[((v117 >> 18) & 0x3F) + 256] ^ dword_D08A0[(v117 >> 26) + 384] ^ dword_D08A0[(((v116 ^ v114) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v116 ^ v114) >> 14) & 0x3F) + 192];
  v122 = *v119;
  v121 = v119[1];
  v123 = v120 ^ dword_D08A0[(((v116 ^ v114) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v118 >> 4) >> 26) + 448];
  if ( a3 )
    v62 = 11LL;
  HIDWORD(v124) = v123 ^ v121;
  LODWORD(v124) = v123 ^ v121;
  v125 = (unsigned int *)(a2 + 8 * v62);
  v126 = dword_D08A0[(unsigned __int8)(v123 ^ v122) >> 2] ^ v116 ^ dword_D08A0[((unsigned __int16)(v123 ^ v122) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v123 ^ v122) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v123 ^ v122) >> 26) + 384] ^ dword_D08A0[(((v123 ^ v121) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v123 ^ v121) >> 14) & 0x3F) + 192];
  v128 = *v125;
  v127 = v125[1];
  v129 = v126 ^ dword_D08A0[(((v123 ^ v121) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v124 >> 4) >> 26) + 448];
  if ( a3 )
    v51 = 12LL;
  HIDWORD(v130) = v129 ^ v127;
  LODWORD(v130) = v129 ^ v127;
  v131 = (unsigned int *)(a2 + 8 * v51);
  v132 = dword_D08A0[(unsigned __int8)(v129 ^ v128) >> 2] ^ v123 ^ dword_D08A0[((unsigned __int16)(v129 ^ v128) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v129 ^ v128) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v129 ^ v128) >> 26) + 384] ^ dword_D08A0[(((v129 ^ v127) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v129 ^ v127) >> 14) & 0x3F) + 192];
  v134 = *v131;
  v133 = v131[1];
  v135 = v132 ^ dword_D08A0[(((v129 ^ v127) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v130 >> 4) >> 26) + 448];
  if ( a3 )
    v41 = 13LL;
  HIDWORD(v136) = v135 ^ v133;
  LODWORD(v136) = v135 ^ v133;
  v137 = (unsigned int *)(a2 + 8 * v41);
  v138 = dword_D08A0[(unsigned __int8)(v135 ^ v134) >> 2] ^ v129 ^ dword_D08A0[((unsigned __int16)(v135 ^ v134) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v135 ^ v134) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v135 ^ v134) >> 26) + 384] ^ dword_D08A0[(((v135 ^ v133) >> 6) & 0x3F) + 64] ^ dword_D08A0[(((v135 ^ v133) >> 14) & 0x3F) + 192];
  v139 = *v137;
  v140 = v137[1];
  v141 = v138 ^ dword_D08A0[(((v135 ^ v133) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v136 >> 4) >> 26) + 448];
  if ( v5 )
    v29 = 1LL;
  v142 = v141 ^ v140;
  v143 = (_DWORD *)(a2 + 8 * v29);
  if ( v5 )
    v6 = 0LL;
  HIDWORD(v144) = v142;
  LODWORD(v144) = v142;
  v145 = a2 + 8 * v6;
  v146 = dword_D08A0[(unsigned __int8)(v141 ^ v139) >> 2] ^ v135 ^ dword_D08A0[((unsigned __int16)(v141 ^ v139) >> 10)
                                                                             + 128] ^ dword_D08A0[(((v141 ^ v139) >> 18) & 0x3F)
                                                                                                + 256] ^ dword_D08A0[((v141 ^ v139) >> 26) + 384] ^ dword_D08A0[((v142 >> 6) & 0x3F) + 64] ^ dword_D08A0[((v142 >> 14) & 0x3F) + 192] ^ dword_D08A0[((v142 >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v144 >> 4) >> 26) + 448];
  HIDWORD(v144) = v146 ^ v143[1];
  LODWORD(v144) = v146 ^ v143[1];
  v147 = dword_D08A0[(unsigned __int8)(v146 ^ *v143) >> 2] ^ v141 ^ dword_D08A0[((unsigned __int16)(v146 ^ *(_WORD *)v143) >> 10)
                                                                              + 128] ^ dword_D08A0[((((unsigned int)v146 ^ *v143) >> 18) & 0x3F)
                                                                                                 + 256] ^ dword_D08A0[(((unsigned int)v146 ^ *v143) >> 26) + 384] ^ dword_D08A0[((HIDWORD(v144) >> 6) & 0x3F) + 64] ^ dword_D08A0[((HIDWORD(v144) >> 14) & 0x3F) + 192] ^ dword_D08A0[((HIDWORD(v144) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v144 >> 4) >> 26) + 448];
  HIDWORD(v144) = v147 ^ *(_DWORD *)(v145 + 4);
  LODWORD(v144) = v147 ^ *(_DWORD *)(v145 + 4);
  LODWORD(v145) = dword_D08A0[(unsigned __int8)(v147 ^ *(_DWORD *)v145) >> 2] ^ v146 ^ dword_D08A0[((unsigned __int16)(v147 ^ *(_DWORD *)v145) >> 10)
                                                                                                 + 128] ^ dword_D08A0[((((unsigned int)v147 ^ *(_DWORD *)v145) >> 18) & 0x3F) + 256] ^ dword_D08A0[(((unsigned int)v147 ^ *(_DWORD *)v145) >> 26) + 384] ^ dword_D08A0[((HIDWORD(v144) >> 6) & 0x3F) + 64] ^ dword_D08A0[((HIDWORD(v144) >> 14) & 0x3F) + 192] ^ dword_D08A0[((HIDWORD(v144) >> 22) & 0x3F) + 320] ^ dword_D08A0[((unsigned int)(v144 >> 4) >> 26) + 448];
  HIDWORD(v144) = v147;
  LODWORD(v144) = v147;
  v148 = v144 >> 3;
  HIDWORD(v144) = v145;
  LODWORD(v144) = v145;
  LODWORD(v145) = v144 >> 3;
  v149 = (v148 ^ ((unsigned int)v145 >> 1)) & 0x55555555;
  v150 = v149 ^ v148;
  LODWORD(v145) = v145 ^ 2 * v149;
  v151 = (v145 ^ (v150 >> 8)) & 0xFF00FF;
  LODWORD(v145) = v151 ^ v145;
  v152 = v150 ^ (v151 << 8);
  v153 = (v152 ^ ((unsigned int)v145 >> 2)) & 0x33333333;
  LODWORD(v145) = v145 ^ 4 * v153;
  v154 = v153 ^ v152;
  v155 = (unsigned __int16)v145 ^ (v154 >> 16);
  LODWORD(v145) = v155 ^ v145;
  v156 = v154 ^ (v155 << 16);
  v157 = (v156 ^ ((unsigned int)v145 >> 4)) & 0xF0F0F0F;
  *result = v157 ^ v156;
  result[1] = v145 ^ 16 * v157;
  return result;
}

//----- (0000000000047964) ----------------------------------------------------
unsigned int *__fastcall DES_ncbc_encrypt(unsigned int *result, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, unsigned __int8 *a5, int a6)
{
  unsigned __int8 *v6; // x19
  __int64 v7; // x20
  unsigned __int64 v8; // x21
  unsigned __int64 v9; // x23
  unsigned __int8 *v10; // x26
  int v11; // w24
  int v12; // w25
  signed __int64 v13; // x27
  unsigned __int64 v14; // x22
  unsigned __int8 *v15; // x28
  int v16; // w11
  unsigned int v17; // w9
  unsigned __int8 *v18; // x22
  int v19; // w28
  int v20; // w27
  unsigned __int8 v21; // w10
  __int16 v22; // x8^2
  unsigned int v23; // w10
  int v24; // w9
  signed __int64 v25; // x22
  int v26; // w8
  unsigned __int8 *v27; // x9
  int v28; // w10
  int v29; // t1
  int v30; // t1
  int v31; // t1
  int v32; // t1
  int v33; // t1
  int v34; // t1
  int v35; // w23
  unsigned int v36; // w9
  int v37; // w27
  unsigned __int8 v38; // w10
  __int64 v39; // x8
  int v40; // w10
  unsigned __int64 v41; // x9
  unsigned __int64 v42; // [xsp+8h] [xbp-78h]
  signed __int64 v43; // [xsp+10h] [xbp-70h]
  unsigned __int64 v44; // [xsp+18h] [xbp-68h]
  signed __int64 v45; // [xsp+18h] [xbp-68h]
  unsigned int v46; // [xsp+20h] [xbp-60h]
  int v47; // [xsp+24h] [xbp-5Ch]
  __int64 v48; // [xsp+28h] [xbp-58h]

  v6 = a5;
  v7 = a4;
  v8 = a3;
  v48 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = a2;
  v10 = (unsigned __int8 *)result;
  v11 = ((unsigned __int16)(*a5 | (unsigned __int16)(a5[1] << 8)) | (a5[2] << 16)) & 0xFFFFFF | (a5[3] << 24);
  v12 = ((unsigned __int16)(a5[4] | (unsigned __int16)(a5[5] << 8)) | (a5[6] << 16)) & 0xFFFFFF | (a5[7] << 24);
  if ( a6 )
  {
    v13 = a3 - 8;
    if ( a3 >= 8 )
    {
      v44 = v13 & 0xFFFFFFFFFFFFFFF8LL;
      v14 = a2 + (v13 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      v15 = (unsigned __int8 *)result;
      do
      {
        v16 = ((unsigned __int16)(v15[4] | (unsigned __int16)(v15[5] << 8)) | (v15[6] << 16)) & 0xFFFFFF | (v15[7] << 24);
        v46 = (((unsigned __int16)(*v15 | (unsigned __int16)(v15[1] << 8)) | (v15[2] << 16)) & 0xFFFFFF | (v15[3] << 24)) ^ v11;
        v47 = v16 ^ v12;
        result = sub_470A8(&v46, v7, 1);
        v11 = v46;
        v8 -= 8LL;
        v15 += 8;
        v17 = v46 >> 16;
        *(_WORD *)v9 = v46;
        *(_BYTE *)(v9 + 2) = v17;
        *(_BYTE *)(v9 + 3) = HIBYTE(v11);
        v12 = v47;
        *(_BYTE *)(v9 + 5) = BYTE1(v47);
        *(_BYTE *)(v9 + 6) = BYTE2(v12);
        *(_BYTE *)(v9 + 4) = v12;
        *(_BYTE *)(v9 + 7) = HIBYTE(v12);
        v9 += 8LL;
      }
      while ( v8 > 7 );
      v10 += (v13 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      v8 = v13 - v44;
      if ( v13 == v44 )
        goto LABEL_31;
      goto LABEL_13;
    }
    v14 = a2;
    if ( a3 )
    {
LABEL_13:
      v26 = 0;
      v27 = &v10[v8];
      v28 = 0;
      switch ( (unsigned __int64)&v10[v8] )
      {
        case 0uLL:
          goto LABEL_20;
        case 1uLL:
          goto LABEL_19;
        case 2uLL:
          goto LABEL_18;
        case 3uLL:
          goto LABEL_17;
        case 4uLL:
          goto LABEL_16;
        case 5uLL:
          goto LABEL_15;
        case 6uLL:
          v29 = *(v27-- - 1);
          v26 = v29 << 16;
LABEL_15:
          v30 = *(v27-- - 1);
          v26 |= v30 << 8;
LABEL_16:
          v31 = *(v27-- - 1);
          v26 |= v31;
LABEL_17:
          v32 = *(v27-- - 1);
          v28 = v26;
          v26 = v32 << 24;
LABEL_18:
          v33 = *(v27-- - 1);
          v26 |= v33 << 16;
LABEL_19:
          v34 = *(v27-- - 1);
          v26 |= v34 << 8;
LABEL_20:
          v26 |= *(v27 - 1);
          break;
        default:
          v28 = 0;
          break;
      }
      v46 = v26 ^ v11;
      v47 = v28 ^ v12;
      result = sub_470A8(&v46, v7, 1);
      v35 = v46;
      v36 = v46 >> 16;
      *(_WORD *)v14 = v46;
      *(_BYTE *)(v14 + 2) = v36;
      *(_BYTE *)(v14 + 3) = HIBYTE(v35);
      v37 = v47;
      *(_BYTE *)(v14 + 5) = BYTE1(v47);
      *(_BYTE *)(v14 + 6) = BYTE2(v37);
      *(_BYTE *)(v14 + 4) = v37;
      *(_BYTE *)(v14 + 7) = HIBYTE(v37);
      goto def_47D04;
    }
LABEL_31:
    v35 = v11;
    v37 = v12;
    goto def_47D04;
  }
  if ( a3 < 8 )
  {
    v25 = a2;
    if ( !a3 )
      goto LABEL_31;
  }
  else
  {
    v43 = a3 - 8;
    v42 = (a3 - 8) & 0xFFFFFFFFFFFFFFF8LL;
    v18 = (unsigned __int8 *)result;
    v45 = a2 + v42 + 8;
    do
    {
      v19 = v11;
      v20 = v12;
      v11 = ((unsigned __int16)(*v18 | (unsigned __int16)(v18[1] << 8)) | (v18[2] << 16)) & 0xFFFFFF | (v18[3] << 24);
      v46 = ((unsigned __int16)(*v18 | (unsigned __int16)(v18[1] << 8)) | (v18[2] << 16)) & 0xFFFFFF | (v18[3] << 24);
      v21 = v18[7];
      v12 = ((unsigned __int16)(v18[4] | (unsigned __int16)(v18[5] << 8)) | (v18[6] << 16)) & 0xFFFFFF | (v21 << 24);
      v47 = ((unsigned __int16)(v18[4] | (unsigned __int16)(v18[5] << 8)) | (v18[6] << 16)) & 0xFFFFFF | (v21 << 24);
      result = sub_470A8(&v46, v7, 0);
      v8 -= 8LL;
      v18 += 8;
      v22 = HIWORD(v46) ^ HIWORD(v19);
      v23 = (v46 ^ v19) >> 8;
      v24 = v47 ^ v20;
      *(_BYTE *)v9 = v46 ^ v19;
      *(_BYTE *)(v9 + 1) = v23;
      *(_BYTE *)(v9 + 4) = v24;
      *(_WORD *)(v9 + 2) = __PAIR__(HIBYTE(v22), (unsigned __int8)v22);
      *(_BYTE *)(v9 + 5) = BYTE1(v24);
      *(_BYTE *)(v9 + 6) = BYTE2(v24);
      *(_BYTE *)(v9 + 7) = HIBYTE(v24);
      v9 += 8LL;
    }
    while ( v8 > 7 );
    v10 += v42 + 8;
    v25 = v45;
    v8 = v43 - v42;
    if ( v43 == v42 )
      goto LABEL_31;
  }
  v35 = ((unsigned __int16)(*v10 | (unsigned __int16)(v10[1] << 8)) | (v10[2] << 16)) & 0xFFFFFF | (v10[3] << 24);
  v46 = ((unsigned __int16)(*v10 | (unsigned __int16)(v10[1] << 8)) | (v10[2] << 16)) & 0xFFFFFF | (v10[3] << 24);
  v38 = v10[7];
  v37 = ((unsigned __int16)(v10[4] | (unsigned __int16)(v10[5] << 8)) | (v10[6] << 16)) & 0xFFFFFF | (v38 << 24);
  v47 = ((unsigned __int16)(v10[4] | (unsigned __int16)(v10[5] << 8)) | (v10[6] << 16)) & 0xFFFFFF | (v38 << 24);
  result = sub_470A8(&v46, v7, 0);
  v39 = v46 ^ v11;
  v40 = v47 ^ v12;
  v41 = v25 + v8;
  switch ( v39 )
  {
    case 0LL:
      goto LABEL_30;
    case 1LL:
      goto LABEL_29;
    case 2LL:
      goto LABEL_28;
    case 3LL:
      goto LABEL_27;
    case 4LL:
      goto LABEL_26;
    case 5LL:
      goto LABEL_25;
    case 6LL:
      *(_BYTE *)(v41-- - 1) = BYTE2(v40);
LABEL_25:
      *(_BYTE *)(v41-- - 1) = BYTE1(v40);
LABEL_26:
      *(_BYTE *)(v41-- - 1) = v40;
LABEL_27:
      *(_BYTE *)(v41-- - 1) = BYTE3(v39);
LABEL_28:
      *(_BYTE *)(v41-- - 1) = BYTE2(v39);
LABEL_29:
      *(_BYTE *)(v41-- - 1) = BYTE1(v39);
LABEL_30:
      *(_BYTE *)(v41 - 1) = v39;
      break;
    default:
      break;
  }
def_47D04:
  v6[1] = BYTE1(v35);
  v6[2] = BYTE2(v35);
  v6[3] = HIBYTE(v35);
  *v6 = v35;
  *((_WORD *)v6 + 2) = v37;
  v6[6] = BYTE2(v37);
  v6[7] = HIBYTE(v37);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v48;
  return result;
}

//----- (0000000000047DBC) ----------------------------------------------------
_DWORD *__fastcall DES_ecb3_encrypt(unsigned __int8 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)
{
  __int64 v6; // x19
  int v7; // w10
  _DWORD *result; // x0
  __int16 v9; // x8^2
  int v10; // w9
  unsigned int v11; // w10
  unsigned int v12; // [xsp+0h] [xbp-20h]
  int v13; // [xsp+4h] [xbp-1Ch]
  __int64 v14; // [xsp+8h] [xbp-18h]

  v6 = a2;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = ((unsigned __int16)(a1[4] | (unsigned __int16)(a1[5] << 8)) | (a1[6] << 16)) & 0xFFFFFF | (a1[7] << 24);
  v12 = ((unsigned __int16)(*a1 | (unsigned __int16)(a1[1] << 8)) | (a1[2] << 16)) & 0xFFFFFF | (a1[3] << 24);
  v13 = v7;
  if ( a6 )
    result = DES_encrypt3((int *)&v12, a3, a4, a5);
  else
    result = DES_decrypt3((int *)&v12, a3, a4, a5);
  v9 = HIWORD(v12);
  v10 = v13;
  v11 = v12 >> 8;
  *(_BYTE *)v6 = v12;
  *(_BYTE *)(v6 + 1) = v11;
  *(_BYTE *)(v6 + 4) = v10;
  *(_WORD *)(v6 + 2) = __PAIR__(HIBYTE(v9), (unsigned __int8)v9);
  *(_BYTE *)(v6 + 5) = BYTE1(v10);
  *(_BYTE *)(v6 + 6) = BYTE2(v10);
  *(_BYTE *)(v6 + 7) = HIBYTE(v10);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000047E9C) ----------------------------------------------------
unsigned __int8 *__fastcall DES_ede3_cbc_encrypt(unsigned __int8 *result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int8 *a7, int a8)
{
  unsigned __int8 *v8; // x19
  __int64 v9; // x20
  __int64 v10; // x21
  __int64 v11; // x22
  unsigned __int64 v12; // x23
  _BYTE *v13; // x25
  int v14; // w26
  int v15; // w27
  signed __int64 v16; // x28
  unsigned __int8 *v17; // x24
  int v18; // w11
  _BYTE *v19; // x24
  unsigned __int8 *v20; // x24
  int v21; // w28
  int v22; // w19
  unsigned __int8 v23; // w11
  char v24; // x8^3
  int v25; // w9
  unsigned int v26; // w10
  unsigned int v27; // w11
  signed __int64 v28; // x24
  int v29; // w8
  unsigned __int8 *v30; // x9
  int v31; // w10
  int v32; // t1
  int v33; // t1
  int v34; // t1
  int v35; // t1
  int v36; // t1
  int v37; // t1
  int v38; // w25
  int v39; // w28
  __int64 v40; // x8
  int v41; // w10
  unsigned __int64 v42; // x9
  unsigned __int64 v43; // [xsp+8h] [xbp-88h]
  unsigned __int64 v44; // [xsp+10h] [xbp-80h]
  signed __int64 v45; // [xsp+10h] [xbp-80h]
  unsigned __int64 v46; // [xsp+18h] [xbp-78h]
  signed __int64 v47; // [xsp+18h] [xbp-78h]
  _BYTE *v48; // [xsp+20h] [xbp-70h]
  unsigned __int8 *v49; // [xsp+20h] [xbp-70h]
  unsigned __int8 *v50; // [xsp+28h] [xbp-68h]
  unsigned __int8 *v51; // [xsp+28h] [xbp-68h]
  unsigned int v52; // [xsp+30h] [xbp-60h]
  int v53; // [xsp+34h] [xbp-5Ch]
  __int64 v54; // [xsp+38h] [xbp-58h]

  v8 = a7;
  v9 = a6;
  v10 = a5;
  v54 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = a4;
  v12 = a3;
  v13 = a2;
  v14 = ((unsigned __int16)(*a7 | (unsigned __int16)(a7[1] << 8)) | (a7[2] << 16)) & 0xFFFFFF | (a7[3] << 24);
  v15 = ((unsigned __int16)(a7[4] | (unsigned __int16)(a7[5] << 8)) | (a7[6] << 16)) & 0xFFFFFF | (a7[7] << 24);
  if ( a8 )
  {
    v16 = a3 - 8;
    if ( a3 >= 8 )
    {
      v46 = v16 & 0xFFFFFFFFFFFFFFF8LL;
      v44 = (v16 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      v17 = result;
      v48 = &a2[v44];
      v50 = result;
      do
      {
        v18 = ((unsigned __int16)(v17[4] | (unsigned __int16)(v17[5] << 8)) | (v17[6] << 16)) & 0xFFFFFF | (v17[7] << 24);
        v52 = (((unsigned __int16)(*v17 | (unsigned __int16)(v17[1] << 8)) | (v17[2] << 16)) & 0xFFFFFF | (v17[3] << 24)) ^ v14;
        v53 = v18 ^ v15;
        DES_encrypt3((int *)&v52, v11, v10, v9);
        v14 = v52;
        v15 = v53;
        v12 -= 8LL;
        v17 += 8;
        v13[1] = BYTE1(v52);
        v13[2] = BYTE2(v14);
        v13[3] = HIBYTE(v14);
        v13[5] = BYTE1(v15);
        v13[6] = BYTE2(v15);
        *v13 = v14;
        v13[4] = v15;
        v13[7] = HIBYTE(v15);
        v13 += 8;
      }
      while ( v12 > 7 );
      v19 = v48;
      result = &v50[v44];
      v12 = v16 - v46;
      if ( v16 == v46 )
        goto LABEL_31;
      goto LABEL_13;
    }
    v19 = a2;
    if ( a3 )
    {
LABEL_13:
      v29 = 0;
      v30 = &result[v12];
      v31 = 0;
      switch ( (unsigned __int64)&result[v12] )
      {
        case 0uLL:
          goto LABEL_20;
        case 1uLL:
          goto LABEL_19;
        case 2uLL:
          goto LABEL_18;
        case 3uLL:
          goto LABEL_17;
        case 4uLL:
          goto LABEL_16;
        case 5uLL:
          goto LABEL_15;
        case 6uLL:
          v32 = *(v30-- - 1);
          v29 = v32 << 16;
LABEL_15:
          v33 = *(v30-- - 1);
          v29 |= v33 << 8;
LABEL_16:
          v34 = *(v30-- - 1);
          v29 |= v34;
LABEL_17:
          v35 = *(v30-- - 1);
          v31 = v29;
          v29 = v35 << 24;
LABEL_18:
          v36 = *(v30-- - 1);
          v29 |= v36 << 16;
LABEL_19:
          v37 = *(v30-- - 1);
          v29 |= v37 << 8;
LABEL_20:
          v29 |= *(v30 - 1);
          break;
        default:
          v31 = 0;
          break;
      }
      v52 = v29 ^ v14;
      v53 = v31 ^ v15;
      result = (unsigned __int8 *)DES_encrypt3((int *)&v52, v11, v10, v9);
      v38 = v52;
      v39 = v53;
      v19[1] = BYTE1(v52);
      v19[2] = BYTE2(v38);
      v19[3] = HIBYTE(v38);
      v19[5] = BYTE1(v39);
      v19[6] = BYTE2(v39);
      *v19 = v38;
      v19[4] = v39;
      v19[7] = HIBYTE(v39);
      goto def_48250;
    }
LABEL_31:
    v38 = v14;
    v39 = v15;
    goto def_48250;
  }
  if ( a3 < 8 )
  {
    v28 = (signed __int64)a2;
    if ( !a3 )
      goto LABEL_31;
  }
  else
  {
    v45 = a3 - 8;
    v43 = (a3 - 8) & 0xFFFFFFFFFFFFFFF8LL;
    v20 = result;
    v47 = (signed __int64)&a2[v43 + 8];
    v49 = a7;
    v51 = result;
    do
    {
      v21 = v14;
      v22 = v15;
      v23 = v20[3];
      v14 = ((unsigned __int16)(*v20 | (unsigned __int16)(v20[1] << 8)) | (v20[2] << 16)) & 0xFFFFFF | (v23 << 24);
      v15 = ((unsigned __int16)(v20[4] | (unsigned __int16)(v20[5] << 8)) | (v20[6] << 16)) & 0xFFFFFF | (v20[7] << 24);
      v52 = ((unsigned __int16)(*v20 | (unsigned __int16)(v20[1] << 8)) | (v20[2] << 16)) & 0xFFFFFF | (v23 << 24);
      v53 = v15;
      DES_decrypt3((int *)&v52, v11, v10, v9);
      v12 -= 8LL;
      v20 += 8;
      v24 = HIBYTE(v52) ^ HIBYTE(v21);
      v25 = v53 ^ v22;
      v26 = (v52 ^ v21) >> 8;
      v27 = (v52 ^ v21) >> 16;
      *v13 = v52 ^ v21;
      v13[4] = v25;
      v13[1] = v26;
      v13[2] = v27;
      v13[3] = v24;
      v13[5] = BYTE1(v25);
      v13[6] = BYTE2(v25);
      v13[7] = HIBYTE(v25);
      v13 += 8;
    }
    while ( v12 > 7 );
    v8 = v49;
    result = &v51[v43 + 8];
    v28 = v47;
    v12 = v45 - v43;
    if ( v45 == v43 )
      goto LABEL_31;
  }
  v38 = ((unsigned __int16)(*result | (unsigned __int16)(result[1] << 8)) | (result[2] << 16)) & 0xFFFFFF | (result[3] << 24);
  v39 = ((unsigned __int16)(result[4] | (unsigned __int16)(result[5] << 8)) | (result[6] << 16)) & 0xFFFFFF | (result[7] << 24);
  v52 = ((unsigned __int16)(*result | (unsigned __int16)(result[1] << 8)) | (result[2] << 16)) & 0xFFFFFF | (result[3] << 24);
  v53 = v39;
  result = (unsigned __int8 *)DES_decrypt3((int *)&v52, v11, v10, v9);
  v40 = v52 ^ v14;
  v41 = v53 ^ v15;
  v42 = v28 + v12;
  switch ( v40 )
  {
    case 0LL:
      goto LABEL_30;
    case 1LL:
      goto LABEL_29;
    case 2LL:
      goto LABEL_28;
    case 3LL:
      goto LABEL_27;
    case 4LL:
      goto LABEL_26;
    case 5LL:
      goto LABEL_25;
    case 6LL:
      *(_BYTE *)(v42-- - 1) = BYTE2(v41);
LABEL_25:
      *(_BYTE *)(v42-- - 1) = BYTE1(v41);
LABEL_26:
      *(_BYTE *)(v42-- - 1) = v41;
LABEL_27:
      *(_BYTE *)(v42-- - 1) = BYTE3(v40);
LABEL_28:
      *(_BYTE *)(v42-- - 1) = BYTE2(v40);
LABEL_29:
      *(_BYTE *)(v42-- - 1) = BYTE1(v40);
LABEL_30:
      *(_BYTE *)(v42 - 1) = v40;
      break;
    default:
      break;
  }
def_48250:
  v8[1] = BYTE1(v38);
  v8[2] = BYTE2(v38);
  v8[3] = HIBYTE(v38);
  *v8 = v38;
  *((_WORD *)v8 + 2) = v39;
  v8[6] = BYTE2(v39);
  v8[7] = HIBYTE(v39);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v54;
  return result;
}

//----- (0000000000048308) ----------------------------------------------------
unsigned __int8 *__fastcall DES_ede2_cbc_encrypt(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned __int8 *a6, int a7)
{
  return DES_ede3_cbc_encrypt(a1, a2, a3, a4, a5, a4, a6, a7);
}

//----- (0000000000048324) ----------------------------------------------------
void *EVP_md4()
{
  return &unk_F6B50;
}

//----- (0000000000048330) ----------------------------------------------------
void *EVP_md5()
{
  return &unk_F6B80;
}

//----- (000000000004833C) ----------------------------------------------------
void *EVP_sha1()
{
  return &unk_F6BB0;
}

//----- (0000000000048348) ----------------------------------------------------
void *EVP_sha224()
{
  return &unk_F6BE0;
}

//----- (0000000000048354) ----------------------------------------------------
void *EVP_sha256()
{
  return &unk_F6C10;
}

//----- (0000000000048360) ----------------------------------------------------
void *EVP_sha384()
{
  return &unk_F6C40;
}

//----- (000000000004836C) ----------------------------------------------------
void *EVP_sha512()
{
  return &unk_F6C70;
}

//----- (0000000000048378) ----------------------------------------------------
void *EVP_md5_sha1()
{
  return &unk_F6CA0;
}

//----- (0000000000048384) ----------------------------------------------------
__int64 __fastcall EVP_get_digestbynid(signed int a1)
{
  signed __int64 v1; // x8

  if ( a1 > 256 )
  {
    switch ( a1 )
    {
      case 672:
        v1 = 4LL;
        return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v1 + 1))();
      case 673:
        v1 = 5LL;
        return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v1 + 1))();
      case 674:
        v1 = 6LL;
        return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v1 + 1))();
      case 675:
        v1 = 3LL;
        return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v1 + 1))();
      default:
        if ( a1 != 257 )
          return 0LL;
        v1 = 0LL;
        break;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 4:
        v1 = 1LL;
        break;
      case 64:
        v1 = 2LL;
        break;
      case 114:
        v1 = 7LL;
        break;
      default:
        return 0LL;
    }
  }
  return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v1 + 1))();
}
// F6CD0: using guessed type void *off_F6CD0;

//----- (0000000000048424) ----------------------------------------------------
__int64 __fastcall EVP_get_digestbyobj(__int64 a1)
{
  __int64 v1; // x8
  __int64 result; // x0
  signed int v3; // w9
  signed __int64 v4; // x8
  char v5; // [xsp+8h] [xbp-18h]
  __int64 v6; // [xsp+18h] [xbp-8h]

  v1 = a1;
  result = 0LL;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *(_DWORD *)(v1 + 16);
  if ( v3 > 113 )
  {
    switch ( v3 )
    {
      case 672:
        v4 = 4LL;
        goto LABEL_17;
      case 673:
        v4 = 5LL;
        goto LABEL_17;
      case 674:
        v4 = 6LL;
        goto LABEL_17;
      case 675:
        v4 = 3LL;
        goto LABEL_17;
      default:
        if ( v3 == 114 )
        {
          v4 = 7LL;
          goto LABEL_17;
        }
        v4 = 0LL;
        if ( v3 == 257 )
          goto LABEL_17;
        break;
    }
  }
  else if ( v3 )
  {
    if ( v3 == 4 )
    {
      v4 = 1LL;
      goto LABEL_17;
    }
    if ( v3 == 64 )
    {
      v4 = 2LL;
LABEL_17:
      result = ((__int64 (__fastcall *)(_QWORD))*(&off_F6CD0 + 4 * v4 + 1))(0LL);
      goto LABEL_18;
    }
  }
  else
  {
    CBS_init(&v5, *(_QWORD *)(v1 + 24), *(signed int *)(v1 + 20));
    result = sub_48524((__int64)&v5);
  }
LABEL_18:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// F6CD0: using guessed type void *off_F6CD0;

//----- (0000000000048524) ----------------------------------------------------
__int64 __fastcall sub_48524(__int64 a1)
{
  __int64 v1; // x19
  const void *v2; // x0
  const void *v3; // x0
  const void *v4; // x0
  const void *v5; // x0
  const void *v6; // x0
  signed __int64 v8; // x8

  v1 = a1;
  if ( EVP_CIPHER_CTX_get_app_data(a1) == 8 && *(_QWORD *)lh_num_items(v1) == 288808682866116138LL )
  {
    v8 = 0LL;
  }
  else if ( EVP_CIPHER_CTX_get_app_data(v1) == 8 && *(_QWORD *)lh_num_items(v1) == 360866276904044074LL )
  {
    v8 = 1LL;
  }
  else if ( EVP_CIPHER_CTX_get_app_data(v1) != 5
         || (v2 = (const void *)lh_num_items(v1), (unsigned int)memcmp(v2, &unk_F6F20, 5uLL)) )
  {
    if ( EVP_CIPHER_CTX_get_app_data(v1) != 9
      || (v3 = (const void *)lh_num_items(v1), (unsigned int)memcmp(v3, &unk_F6F38, 9uLL)) )
    {
      if ( EVP_CIPHER_CTX_get_app_data(v1) != 9
        || (v4 = (const void *)lh_num_items(v1), (unsigned int)memcmp(v4, &unk_F6F50, 9uLL)) )
      {
        if ( EVP_CIPHER_CTX_get_app_data(v1) != 9
          || (v5 = (const void *)lh_num_items(v1), (unsigned int)memcmp(v5, &unk_F6F68, 9uLL)) )
        {
          if ( EVP_CIPHER_CTX_get_app_data(v1) != 9 )
            return 0LL;
          v6 = (const void *)lh_num_items(v1);
          if ( (unsigned int)memcmp(v6, &unk_F6F80, 9uLL) )
            return 0LL;
          v8 = 6LL;
        }
        else
        {
          v8 = 5LL;
        }
      }
      else
      {
        v8 = 4LL;
      }
    }
    else
    {
      v8 = 3LL;
    }
  }
  else
  {
    v8 = 2LL;
  }
  return (*((__int64 (**)(void))&unk_F6EF0 + 3 * v8 + 2))();
}

//----- (00000000000486EC) ----------------------------------------------------
void __fastcall sub_486EC(unsigned __int8 **a1)
{
  __int16 v1; // w4
  char v2; // [xsp+8h] [xbp-48h]
  char v3; // [xsp+18h] [xbp-38h]
  unsigned __int8 *v4[2]; // [xsp+28h] [xbp-28h]
  __int64 v5; // [xsp+38h] [xbp-18h]

  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBS_get_asn1(a1, (char *)v4, 48) || !(unsigned int)CBS_get_asn1(v4, &v3, 6) )
  {
    v1 = 359;
    goto LABEL_10;
  }
  if ( !sub_48524((__int64)&v3) )
  {
    ERR_put_error(29, 0LL, 102, (__int64)"external/boringssl/src/crypto/digest/digests.c", 365);
    goto LABEL_11;
  }
  if ( EVP_CIPHER_CTX_get_app_data((__int64)v4)
    && (!(unsigned int)CBS_get_asn1(v4, &v2, 5)
     || EVP_CIPHER_CTX_get_app_data((__int64)&v2)
     || EVP_CIPHER_CTX_get_app_data((__int64)v4)) )
  {
    v1 = 378;
LABEL_10:
    ERR_put_error(29, 0LL, 101, (__int64)"external/boringssl/src/crypto/digest/digests.c", v1);
  }
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v5;
}

//----- (00000000000487F8) ----------------------------------------------------
__int64 __fastcall EVP_get_digestbyname(const char *a1)
{
  const char *v1; // x19
  signed __int64 v2; // x21
  const char *v3; // x20
  void **v4; // x8

  v1 = a1;
  v2 = 0LL;
  if ( !(unsigned int)strcmp("MD4", a1) )
    return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v2 + 1))();
  v3 = "md4";
  while ( v2 == 10 )
  {
    v2 = 11LL;
LABEL_7:
    v4 = &off_F6CD0 + 4 * v2;
    v3 = (const char *)v4[3];
    if ( !(unsigned int)strcmp((const char *)v4[2], v1) )
      return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v2 + 1))();
  }
  if ( !(unsigned int)strcmp(v3, v1) )
    return ((__int64 (*)(void))*(&off_F6CD0 + 4 * v2 + 1))();
  if ( (unsigned __int64)++v2 < 0x11 )
    goto LABEL_7;
  return 0LL;
}
// F6CD0: using guessed type void *off_F6CD0;

//----- (00000000000488A8) ----------------------------------------------------
signed __int64 __fastcall sub_488A8(__int64 a1)
{
  return MD5_Init(*(_OWORD **)(a1 + 8));
}

//----- (00000000000488B0) ----------------------------------------------------
signed __int64 __fastcall sub_488B0(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  return MD4_Update(*(_DWORD **)(a1 + 8), a2, a3);
}

//----- (00000000000488B8) ----------------------------------------------------
signed __int64 __fastcall sub_488B8(__int64 a1, __int64 a2)
{
  return MD4_Final(a2, *(_QWORD *)(a1 + 8));
}

//----- (00000000000488C8) ----------------------------------------------------
signed __int64 __fastcall sub_488C8(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  return MD5_Update(*(_DWORD **)(a1 + 8), a2, a3);
}

//----- (00000000000488D0) ----------------------------------------------------
signed __int64 __fastcall sub_488D0(__int64 a1, __int64 a2)
{
  return MD5_Final(a2, *(_QWORD *)(a1 + 8));
}

//----- (00000000000488E0) ----------------------------------------------------
signed __int64 __fastcall sub_488E0(__int64 a1)
{
  return SHA1_Init(*(_DWORD **)(a1 + 8));
}

//----- (00000000000488E8) ----------------------------------------------------
signed __int64 __fastcall sub_488E8(__int64 a1, char *a2, size_t a3)
{
  return SHA1_Update(*(_DWORD **)(a1 + 8), a2, a3);
}

//----- (00000000000488F0) ----------------------------------------------------
signed __int64 __fastcall sub_488F0(__int64 a1, _BYTE *a2)
{
  return SHA1_Final(a2, *(int **)(a1 + 8));
}

//----- (0000000000048900) ----------------------------------------------------
signed __int64 __fastcall sub_48900(__int64 a1)
{
  return SHA224_Init(*(_DWORD **)(a1 + 8));
}

//----- (0000000000048908) ----------------------------------------------------
signed __int64 __fastcall sub_48908(__int64 a1, char *a2, size_t a3)
{
  return SHA224_Update(*(_DWORD **)(a1 + 8), a2, a3);
}

//----- (0000000000048910) ----------------------------------------------------
__int64 __fastcall sub_48910(__int64 a1, __int64 a2)
{
  return SHA224_Final(a2, *(_QWORD *)(a1 + 8));
}
// 4E9DC: using guessed type __int64 __fastcall SHA224_Final(_QWORD, _QWORD);

//----- (0000000000048920) ----------------------------------------------------
signed __int64 __fastcall sub_48920(__int64 a1)
{
  return SHA256_Init(*(_DWORD **)(a1 + 8));
}

//----- (0000000000048928) ----------------------------------------------------
signed __int64 __fastcall sub_48928(__int64 a1, char *a2, size_t a3)
{
  return SHA256_Update(*(_DWORD **)(a1 + 8), a2, a3);
}

//----- (0000000000048930) ----------------------------------------------------
signed __int64 __fastcall sub_48930(__int64 a1, _BYTE *a2)
{
  return SHA256_Final(a2, *(int **)(a1 + 8));
}

//----- (0000000000048940) ----------------------------------------------------
signed __int64 __fastcall sub_48940(__int64 a1)
{
  return SHA384_Init(*(_QWORD **)(a1 + 8));
}

//----- (0000000000048948) ----------------------------------------------------
signed __int64 __fastcall sub_48948(__int64 a1, unsigned __int64 *a2, size_t a3)
{
  return SHA384_Update(*(_QWORD *)(a1 + 8), a2, a3);
}

//----- (0000000000048950) ----------------------------------------------------
__int64 __fastcall sub_48950(__int64 a1, __int64 a2)
{
  return SHA384_Final(a2, *(_QWORD *)(a1 + 8));
}
// 4F194: using guessed type __int64 __fastcall SHA384_Final(_QWORD, _QWORD);

//----- (0000000000048960) ----------------------------------------------------
signed __int64 __fastcall sub_48960(__int64 a1)
{
  return SHA512_Init(*(_QWORD **)(a1 + 8));
}

//----- (0000000000048968) ----------------------------------------------------
signed __int64 __fastcall sub_48968(__int64 a1, unsigned __int64 *a2, size_t a3)
{
  return SHA512_Update(*(_QWORD *)(a1 + 8), a2, a3);
}

//----- (0000000000048970) ----------------------------------------------------
signed __int64 __fastcall sub_48970(__int64 a1, _BYTE *a2)
{
  return SHA512_Final(a2, *(_QWORD *)(a1 + 8));
}

//----- (0000000000048980) ----------------------------------------------------
signed __int64 __fastcall sub_48980(__int64 a1)
{
  __int64 v1; // x19
  signed __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  result = MD5_Init(*(_OWORD **)(a1 + 8));
  if ( (_DWORD)result )
    result = SHA1_Init((_DWORD *)(v1 + 92));
  return result;
}

//----- (00000000000489B8) ----------------------------------------------------
signed __int64 __fastcall sub_489B8(__int64 a1, unsigned __int8 *a2, size_t a3)
{
  __int64 v3; // x21
  size_t v4; // x19
  char *v5; // x20
  signed __int64 result; // x0

  v3 = *(_QWORD *)(a1 + 8);
  v4 = a3;
  v5 = (char *)a2;
  result = MD5_Update(*(_DWORD **)(a1 + 8), a2, a3);
  if ( (_DWORD)result )
    result = SHA1_Update((_DWORD *)(v3 + 92), v5, v4);
  return result;
}

//----- (0000000000048A0C) ----------------------------------------------------
signed __int64 __fastcall sub_48A0C(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  signed __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a2;
  result = MD5_Final(a2, v2);
  if ( (_DWORD)result )
    result = SHA1_Final((_BYTE *)(v3 + 16), (int *)(v2 + 92));
  return result;
}

//----- (0000000000048A50) ----------------------------------------------------
__int64 ERR_get_error()
{
  return sub_48A6C(1, 0, 0LL, 0LL, 0LL, 0LL);
}

//----- (0000000000048A6C) ----------------------------------------------------
__int64 __fastcall sub_48A6C(int a1, int a2, _QWORD *a3, _DWORD *a4, _QWORD *a5, int *a6)
{
  int v6; // w20
  int *v7; // x22
  _QWORD *v8; // x23
  _DWORD *v9; // x24
  _QWORD *v10; // x25
  int v11; // w21
  _QWORD *v12; // x19
  int v13; // w9
  unsigned int v14; // w8
  unsigned int v15; // w21
  unsigned int v16; // w9
  __int64 v17; // x26
  signed __int64 v18; // x27
  __int64 v19; // x8
  _QWORD *v20; // x0
  signed __int64 v21; // x24
  __int64 v22; // x8
  _QWORD *v23; // x24
  __int64 v24; // t1
  signed __int64 v25; // x22
  _BYTE *v26; // x22
  char v27; // t1
  signed __int64 v28; // x20
  char v29; // w8
  char *v30; // x20
  char v31; // t1
  void **v32; // x22

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  v12 = CRYPTO_get_thread_local(0);
  if ( !v12 )
  {
    v20 = malloc(0x190uLL);
    v12 = v20;
    if ( !v20 )
      return 0;
    memset(v20, 0, 0x190uLL);
    if ( !(unsigned int)CRYPTO_set_thread_local(0, (__int64)v12, (void (__fastcall *)(__int64))sub_49A74) )
      return 0;
  }
  v13 = *((_DWORD *)v12 + 97);
  v14 = *((_DWORD *)v12 + 96);
  if ( v13 == v14 )
    return 0;
  v16 = (v13 + 1) & 0xF;
  if ( v11 )
    v17 = v14;
  else
    v17 = v16;
  v18 = (signed __int64)&v12[3 * (unsigned int)v17];
  v15 = *(_DWORD *)(v18 + 16);
  if ( v10 && v9 )
  {
    v19 = *(_QWORD *)v18;
    if ( *(_QWORD *)v18 )
    {
      *v10 = v19;
      LODWORD(v19) = WORD2(v12[3 * v17 + 2]);
    }
    else
    {
      *v10 = "NA";
    }
    *v9 = v19;
  }
  if ( !v8 )
    goto LABEL_27;
  v21 = (signed __int64)&v12[3 * v17];
  v24 = *(_QWORD *)(v21 + 8);
  v23 = (_QWORD *)(v21 + 8);
  v22 = v24;
  if ( !v24 )
  {
    *v8 = &unk_B8A4C;
    if ( v7 )
      *v7 = 0;
LABEL_27:
    if ( !v6 )
      return v15;
    goto LABEL_28;
  }
  *v8 = v22;
  if ( v7 )
    *v7 = BYTE6(v12[3 * v17 + 2]) & 0xF;
  if ( v6 )
  {
    v25 = (signed __int64)&v12[3 * v17];
    v27 = *(_BYTE *)(v25 + 22);
    v26 = (_BYTE *)(v25 + 22);
    if ( v27 & 0x10 )
    {
      free((void *)v12[49]);
      v12[49] = *v23;
    }
    *v23 = 0LL;
    *v26 = 0;
    if ( v6 )
    {
LABEL_28:
      v28 = (signed __int64)&v12[3 * v17];
      v31 = *(_BYTE *)(v28 + 22);
      v30 = (char *)(v28 + 22);
      v29 = v31;
      v32 = (void **)(v30 - 14);
      if ( v31 & 0x10 )
      {
        free(*v32);
        v29 = *v30;
      }
      *v32 = 0LL;
      *v30 = v29 & 0xEF;
      *(_QWORD *)(v18 + 8) = 0LL;
      *(_QWORD *)(v18 + 16) = 0LL;
      *(_QWORD *)v18 = 0LL;
      *((_DWORD *)v12 + 97) = v17;
      return v15;
    }
  }
  return v15;
}

//----- (0000000000048C30) ----------------------------------------------------
__int64 __fastcall ERR_get_error_line(_QWORD *a1, _DWORD *a2)
{
  return sub_48A6C(1, 0, a1, a2, 0LL, 0LL);
}

//----- (0000000000048C54) ----------------------------------------------------
__int64 __fastcall ERR_get_error_line_data(_QWORD *a1, _DWORD *a2, _QWORD *a3, int *a4)
{
  return sub_48A6C(1, 0, a1, a2, a3, a4);
}

//----- (0000000000048C80) ----------------------------------------------------
signed __int64 ERR_peek_error()
{
  _QWORD *v0; // x19
  int v1; // w8
  signed __int64 result; // x0
  _QWORD *v3; // x0

  v0 = CRYPTO_get_thread_local(0);
  if ( v0 )
    goto LABEL_10;
  v3 = malloc(0x190uLL);
  v0 = v3;
  if ( !v3 )
    return 0LL;
  memset(v3, 0, 0x190uLL);
  result = CRYPTO_set_thread_local(0, (__int64)v0, (void (__fastcall *)(__int64))sub_49A74);
  if ( (_DWORD)result )
  {
LABEL_10:
    v1 = *((_DWORD *)v0 + 97);
    if ( v1 != *((_DWORD *)v0 + 96) )
      return LODWORD(v0[3 * ((v1 + 1) & 0xF) + 2]);
    return 0LL;
  }
  return result;
}

//----- (0000000000048D10) ----------------------------------------------------
__int64 __fastcall ERR_peek_error_line(_QWORD *a1, _DWORD *a2)
{
  return sub_48A6C(0, 0, a1, a2, 0LL, 0LL);
}

//----- (0000000000048D34) ----------------------------------------------------
__int64 __fastcall ERR_peek_error_line_data(_QWORD *a1, _DWORD *a2, _QWORD *a3, int *a4)
{
  return sub_48A6C(0, 0, a1, a2, a3, a4);
}

//----- (0000000000048D60) ----------------------------------------------------
signed __int64 ERR_peek_last_error()
{
  _QWORD *v0; // x19
  __int64 v1; // x8
  signed __int64 result; // x0
  _QWORD *v3; // x0

  v0 = CRYPTO_get_thread_local(0);
  if ( v0 )
    goto LABEL_10;
  v3 = malloc(0x190uLL);
  v0 = v3;
  if ( !v3 )
    return 0LL;
  memset(v3, 0, 0x190uLL);
  result = CRYPTO_set_thread_local(0, (__int64)v0, (void (__fastcall *)(__int64))sub_49A74);
  if ( (_DWORD)result )
  {
LABEL_10:
    v1 = *((unsigned int *)v0 + 96);
    if ( *((_DWORD *)v0 + 97) != (_DWORD)v1 )
      return LODWORD(v0[3 * v1 + 2]);
    return 0LL;
  }
  return result;
}

//----- (0000000000048DE8) ----------------------------------------------------
__int64 __fastcall ERR_peek_last_error_line(_QWORD *a1, _DWORD *a2)
{
  return sub_48A6C(0, 1, a1, a2, 0LL, 0LL);
}

//----- (0000000000048E0C) ----------------------------------------------------
__int64 __fastcall ERR_peek_last_error_line_data(_QWORD *a1, _DWORD *a2, _QWORD *a3, int *a4)
{
  return sub_48A6C(0, 1, a1, a2, a3, a4);
}

//----- (0000000000048E38) ----------------------------------------------------
void ERR_clear_error()
{
  _QWORD *v0; // x19
  __int64 v1; // x20
  _QWORD *v2; // x22
  char v3; // w8
  _QWORD *v4; // x0

  v0 = CRYPTO_get_thread_local(0);
  if ( v0
    || (v4 = malloc(0x190uLL), (v0 = v4) != 0LL)
    && (memset(v4, 0, 0x190uLL),
        (unsigned int)CRYPTO_set_thread_local(0, (__int64)v0, (void (__fastcall *)(__int64))sub_49A74)) )
  {
    v1 = 0LL;
    do
    {
      v2 = &v0[v1];
      v3 = BYTE6(v0[v1 + 2]);
      if ( v0[v1 + 2] & 0x10000000000000LL )
      {
        free((void *)v2[1]);
        v3 = *((_BYTE *)v2 + 22);
      }
      v1 += 3LL;
      *v2 = 0LL;
      v2[1] = 0LL;
      *((_BYTE *)v2 + 22) = v3 & 0xEF;
      v2[1] = 0LL;
      v2[2] = 0LL;
    }
    while ( v1 != 48 );
    free((void *)v0[49]);
    v0[48] = 0LL;
    v0[49] = 0LL;
  }
}

//----- (0000000000048EEC) ----------------------------------------------------
void __fastcall ERR_remove_thread_state(__int64 a1)
{
  if ( !a1 )
    ERR_clear_error();
}

//----- (0000000000048EF8) ----------------------------------------------------
__int64 ERR_get_next_error_library()
{
  unsigned int v0; // w20

  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_106E30);
  v0 = dword_106484++;
  CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_106E30);
  return v0;
}
// 106484: using guessed type int dword_106484;

//----- (0000000000048F40) ----------------------------------------------------
_DWORD *ERR_clear_system_error()
{
  _DWORD *result; // x0

  result = (_DWORD *)__errno();
  *result = 0;
  return result;
}

//----- (0000000000048F58) ----------------------------------------------------
const char *__fastcall ERR_error_string(char *a1, const char *a2)
{
  const char *v2; // x19

  if ( a2 )
    v2 = a2;
  else
    v2 = (const char *)&unk_106E68;
  ERR_error_string_n(a1, v2, 0x100uLL);
  return v2;
}

//----- (0000000000048F90) ----------------------------------------------------
char *__fastcall ERR_error_string_n(char *result, const char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x20
  const char *v4; // x19
  unsigned int v5; // w21
  unsigned int v6; // w24
  char *v7; // x22
  char *v8; // x23
  __int64 v9; // x4
  __int64 v10; // x5
  __int64 v11; // x6
  __int64 v12; // x7
  __int64 v13; // x4
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  unsigned __int64 v17; // x20
  char *v18; // x8
  signed int v19; // w9
  char *v20; // x8
  char *v21; // x8
  char *v22; // x8
  __int64 v23; // [xsp+0h] [xbp-C0h]
  char v24; // [xsp+8h] [xbp-B8h]
  char v25; // [xsp+48h] [xbp-78h]
  __int64 v26; // [xsp+88h] [xbp-38h]

  v3 = a3;
  v4 = a2;
  v5 = (unsigned int)result;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a3 )
    goto LABEL_21;
  v6 = (unsigned int)result >> 24;
  if ( (unsigned int)result >> 24 < 0x21 )
  {
    v7 = off_F6F98[v6];
    v8 = ERR_reason_error_string((char *)(unsigned int)result);
    if ( !v8 )
    {
LABEL_6:
      v8 = &v24;
      BIO_snprintf((__int64)&v24, 64LL, (__int64)"reason(%u)", v5 & 0xFFF, v13, v14, v15, v16, v23);
      goto LABEL_7;
    }
  }
  else
  {
    v7 = &v25;
    v8 = ERR_reason_error_string((char *)(unsigned int)result);
    BIO_snprintf((__int64)&v25, 64LL, (__int64)"lib(%u)", v6, v9, v10, v11, v12, v23);
    if ( !v8 )
      goto LABEL_6;
  }
LABEL_7:
  BIO_snprintf(
    (__int64)v4,
    v3,
    (__int64)"error:%08x:%s:OPENSSL_internal:%s",
    v5,
    (__int64)v7,
    (__int64)v8,
    v15,
    v16,
    v23);
  result = (char *)strlen(v4);
  if ( v3 >= 5 && result == (char *)(v3 - 1) )
  {
    v17 = (unsigned __int64)&result[(_QWORD)v4 - 4];
    v18 = strchr(v4, 58);
    v19 = 0;
    if ( v18 )
    {
      result = (char *)v17;
      if ( (unsigned __int64)v18 <= v17 )
      {
        v20 = strchr(v18 + 1, 58);
        result = (char *)(v17 + 1);
        v19 = 1;
        if ( v20 )
        {
          if ( v20 <= result )
          {
            v21 = strchr(v20 + 1, 58);
            result = (char *)(v17 + 2);
            v19 = 2;
            if ( v21 )
            {
              if ( v21 <= result )
              {
                v22 = strchr(v21 + 1, 58);
                result = (char *)(v17 + 3);
                v19 = 3;
                if ( v22 )
                {
                  if ( v22 <= result )
                    goto LABEL_21;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      result = (char *)v17;
    }
    if ( 4 != v19 )
      result = (char *)memset(result, 58, (unsigned int)(4 - v19));
  }
LABEL_21:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// F6F98: using guessed type char *off_F6F98[38];

//----- (0000000000049158) ----------------------------------------------------
char *__fastcall ERR_lib_error_string(unsigned int a1)
{
  char *result; // x0

  if ( a1 >> 24 <= 0x20 )
    result = off_F6F98[a1 >> 24];
  else
    result = 0LL;
  return result;
}
// F6F98: using guessed type char *off_F6F98[38];

//----- (000000000004917C) ----------------------------------------------------
char *__fastcall ERR_reason_error_string(char *result)
{
  unsigned int v1; // w9
  unsigned int v2; // w10
  __int64 v3; // x8
  unsigned int v4; // [xsp+4h] [xbp-Ch]
  __int64 v5; // [xsp+8h] [xbp-8h]

  v1 = (unsigned int)result;
  v2 = (unsigned int)result >> 24;
  LODWORD(v3) = (unsigned __int16)result & 0xFFF;
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)result >> 24 == 2 )
  {
    if ( (unsigned int)v3 > 0x7E )
      goto LABEL_10;
    result = strerror(v3);
    v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    v1 = v5;
    if ( v3 == v5 )
      return result;
  }
  if ( (unsigned int)v3 <= 0x20 )
  {
    result = off_F6F98[(unsigned int)v3];
LABEL_11:
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v5;
    return result;
  }
  if ( (unsigned int)v3 > 0x63 )
  {
    result = 0LL;
    if ( !(v1 >> 30) && (unsigned int)v3 <= 0x7FF )
    {
      v4 = ((_DWORD)v3 << 15) | (v2 << 26);
      result = (char *)bsearch(&v4, &unk_D11B0, (size_t)&stru_288.st_info, 4uLL, (__compar_fn_t)sub_49AF4);
      if ( result )
        result = &aAsn1LengthMism[*(_DWORD *)result & 0x7FFF];
    }
    goto LABEL_11;
  }
  if ( (((_WORD)v1 + 4031) & 0xFFFu) >= 5 )
  {
LABEL_10:
    result = 0LL;
    goto LABEL_11;
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v5 )
    result = off_F70A0[(signed __int64)((unsigned __int64)(v1 + 4031) << 52) >> 52];
  return result;
}
// 288: using guessed type Elf64_Sym stru_288;
// F6F98: using guessed type char *off_F6F98[38];
// F70A0: using guessed type char *off_F70A0[5];

//----- (00000000000492B4) ----------------------------------------------------
const char *ERR_func_error_string()
{
  return "OPENSSL_internal";
}

//----- (00000000000492C0) ----------------------------------------------------
char *__fastcall ERR_print_errors_cb(__int64 (__fastcall *a1)(char *, __int64, __int64), __int64 a2)
{
  __int64 (__fastcall *v2)(char *, __int64, __int64); // x20
  __int64 v3; // x19
  _QWORD *v4; // x21
  char *result; // x0
  __int64 v6; // x7
  __int64 v7; // x0
  _QWORD *v8; // x0
  int v9; // [xsp+0h] [xbp-550h]
  unsigned int v10; // [xsp+4h] [xbp-54Ch]
  void *v11; // [xsp+8h] [xbp-548h]
  __int64 v12; // [xsp+10h] [xbp-540h]
  char v13; // [xsp+18h] [xbp-538h]
  char v14; // [xsp+418h] [xbp-138h]
  __int64 v15; // [xsp+518h] [xbp-38h]

  v2 = a1;
  v3 = a2;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = CRYPTO_get_thread_local(0);
  if ( !v4 )
  {
    v8 = malloc(0x190uLL);
    v4 = v8;
    if ( v8 )
    {
      memset(v8, 0, 0x190uLL);
      if ( !(unsigned int)CRYPTO_set_thread_local(0, (__int64)v4, (void (__fastcall *)(__int64))sub_49A74) )
        v4 = 0LL;
    }
  }
  do
  {
    result = (char *)sub_48A6C(1, 0, &v12, &v10, &v11, &v9);
    if ( !(_DWORD)result )
      break;
    ERR_error_string_n(result, &v14, 0x100uLL);
    v6 = (__int64)(v9 & 1 ? v11 : &unk_B8A4C);
    BIO_snprintf(
      (__int64)&v13,
      1024LL,
      (__int64)"%lu:%s:%s:%d:%s\n",
      (__int64)v4,
      (__int64)&v14,
      v12,
      v10,
      v6,
      *(__int64 *)&v9);
    v7 = __strlen_chk();
    result = (char *)v2(&v13, v7, v3);
  }
  while ( (signed int)result > 0 );
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v15;
  return result;
}

//----- (00000000000493F4) ----------------------------------------------------
char *__fastcall ERR_print_errors_fp(__int64 a1)
{
  return ERR_print_errors_cb((__int64 (__fastcall *)(char *, __int64, __int64))sub_4940C, a1);
}

//----- (000000000004940C) ----------------------------------------------------
__int64 __fastcall sub_4940C(const char *a1, __int64 a2, FILE *a3)
{
  return ((unsigned int)fputs(a1, a3) >> 31) ^ 1;
}

//----- (000000000004942C) ----------------------------------------------------
void __fastcall ERR_put_error(int a1, __int64 a2, int a3, __int64 a4, __int16 a5)
{
  int v5; // w21
  __int16 v6; // w19
  __int64 v7; // x20
  int v8; // w22
  _QWORD *v9; // x23
  int v10; // w8
  int v11; // w9
  __int64 v12; // x24
  _QWORD *v13; // x25
  signed __int64 v14; // x26
  char v15; // w8
  char *v16; // x26
  char v17; // t1
  void **v18; // x27
  signed __int64 v19; // x9
  _QWORD *v20; // x0

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = CRYPTO_get_thread_local(0);
  if ( v9
    || (v20 = malloc(0x190uLL), (v9 = v20) != 0LL)
    && (memset(v20, 0, 0x190uLL),
        (unsigned int)CRYPTO_set_thread_local(0, (__int64)v9, (void (__fastcall *)(__int64))sub_49A74)) )
  {
    if ( v5 == 2 && !v8 )
      v8 = *(_DWORD *)__errno();
    v10 = *((_DWORD *)v9 + 96);
    v11 = *((_DWORD *)v9 + 97);
    v12 = (v10 + 1) & 0xF;
    *((_DWORD *)v9 + 96) = v12;
    if ( (_DWORD)v12 == v11 )
      *((_DWORD *)v9 + 97) = (v10 + 2) & 0xF;
    v13 = &v9[3 * (unsigned int)v12];
    v14 = (signed __int64)&v9[3 * (unsigned int)v12];
    v17 = *(_BYTE *)(v14 + 22);
    v16 = (char *)(v14 + 22);
    v15 = v17;
    v18 = (void **)(v13 + 1);
    if ( v17 & 0x10 )
    {
      free(*v18);
      v15 = *v16;
    }
    v19 = (signed __int64)&v9[3 * v12];
    *v18 = 0LL;
    *v16 = v15 & 0xEF;
    v13[1] = 0LL;
    v13[2] = 0LL;
    *v13 = 0LL;
    *v13 = v7;
    *(_WORD *)(v19 + 20) = v6;
    *(_DWORD *)(v19 + 16) = v8 & 0xFFF | ((unsigned __int8)v5 << 24);
  }
}

//----- (0000000000049554) ----------------------------------------------------
void __fastcall ERR_add_error_data(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  signed int v9; // w25
  unsigned int v10; // w20
  const char **v11; // x24
  char *v12; // x19
  unsigned int v13; // w26
  size_t v14; // x28
  unsigned __int64 v15; // x27
  const char **v16; // x10
  signed __int64 v17; // x8
  const char *v18; // x21
  size_t v19; // x22
  size_t v20; // x23
  char *v21; // x0
  _QWORD *v22; // x20
  __int64 v23; // x8
  signed __int64 v24; // x20
  _BYTE *v25; // x20
  char v26; // t1
  void **v27; // x21
  _QWORD *v28; // x0
  __int64 v29; // [xsp+90h] [xbp-B0h]
  __int64 v30; // [xsp+98h] [xbp-A8h]
  __int64 v31; // [xsp+A0h] [xbp-A0h]
  __int64 v32; // [xsp+A8h] [xbp-98h]
  __int64 v33; // [xsp+B0h] [xbp-90h]
  __int64 v34; // [xsp+B8h] [xbp-88h]
  __int64 v35; // [xsp+C0h] [xbp-80h]
  __int64 *v36; // [xsp+C8h] [xbp-78h]
  __int64 *v37; // [xsp+D0h] [xbp-70h]
  __int64 *v38; // [xsp+D8h] [xbp-68h]
  int v39; // [xsp+E0h] [xbp-60h]
  int v40; // [xsp+E4h] [xbp-5Ch]
  __int64 v41; // [xsp+E8h] [xbp-58h]

  v34 = a7;
  v35 = a8;
  v32 = a5;
  v33 = a6;
  v30 = a3;
  v31 = a4;
  v29 = a2;
  v41 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v39 = -56;
  v40 = -128;
  v9 = -7;
  v10 = a1;
  v37 = (__int64 *)&v36;
  v38 = &v29;
  v36 = &a9;
  v11 = (const char **)&a9;
  v12 = (char *)malloc(0x51uLL);
  if ( v12 )
  {
    if ( v10 )
    {
      v13 = 0;
      v14 = 0LL;
      v15 = 80LL;
      while ( 1 )
      {
        if ( v9 * 8 & 0x80000000 )
        {
          if ( v9 * 8 + 8 <= 0 )
          {
            v16 = (const char **)&(&v36)[v9];
            v17 = (signed __int64)v11;
            ++v9;
            v11 = v16;
            goto LABEL_9;
          }
          ++v9;
        }
        v17 = (signed __int64)(v11 + 1);
LABEL_9:
        v18 = *v11;
        v11 = (const char **)v17;
        if ( v18 )
        {
          v19 = strlen(v18);
          v20 = v19 + v14;
          if ( v19 + v14 > v15 )
          {
            if ( v15 >= 0xFFFFFFFFFFFFFFEBLL )
              goto LABEL_27;
            v21 = (char *)realloc(v12, v20 + 21);
            if ( !v21 )
              goto LABEL_27;
            v15 = v20 + 20;
            v12 = v21;
          }
          if ( v19 )
            memcpy(&v12[v14], v18, v19);
        }
        else
        {
          v20 = v14;
        }
        ++v13;
        v14 = v20;
        if ( v13 >= v10 )
          goto LABEL_20;
      }
    }
    v20 = 0LL;
LABEL_20:
    v12[v20] = 0;
    v22 = CRYPTO_get_thread_local(0);
    if ( (v22
       || (v28 = malloc(0x190uLL), (v22 = v28) != 0LL)
       && (memset(v28, 0, 0x190uLL),
           (unsigned int)CRYPTO_set_thread_local(0, (__int64)v22, (void (__fastcall *)(__int64))sub_49A74)))
      && (v23 = *((unsigned int *)v22 + 96), (_DWORD)v23 != *((_DWORD *)v22 + 97)) )
    {
      v24 = (signed __int64)&v22[3 * v23];
      v26 = *(_BYTE *)(v24 + 22);
      v25 = (_BYTE *)(v24 + 22);
      v27 = (void **)(v25 - 14);
      if ( v26 & 0x10 )
        free(*v27);
      *v27 = v12;
      *v25 = 17;
    }
    else
    {
LABEL_27:
      free(v12);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000049770) ----------------------------------------------------
void ERR_add_error_dataf(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, ...)
{
  __int64 v9; // x20
  __int64 v10; // ST08_8
  _BYTE *v11; // x0
  _BYTE *v12; // x19
  _QWORD *v13; // x20
  __int64 v14; // x8
  signed __int64 v15; // x20
  _BYTE *v16; // x20
  char v17; // t1
  void **v18; // x21
  _QWORD *v19; // x0
  gcc_va_list va1; // [xsp+D0h] [xbp-70h]
  gcc_va_list va; // [xsp+F8h] [xbp-48h]

  v9 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = malloc(0x101uLL);
  v12 = v11;
  if ( v11 )
  {
    va[0].__vr_offs = -128;
    va_start(va, a9);
    va_copy(va1, va);
    BIO_vsnprintf((__int64)v11, 256LL, v9, (__int128 *)va1);
    v12[256] = 0;
    v13 = CRYPTO_get_thread_local(0);
    if ( (v13
       || (v19 = malloc(0x190uLL), (v13 = v19) != 0LL)
       && (memset(v19, 0, 0x190uLL),
           (unsigned int)CRYPTO_set_thread_local(0, (__int64)v13, (void (__fastcall *)(__int64))sub_49A74)))
      && (v14 = *((unsigned int *)v13 + 96), (_DWORD)v14 != *((_DWORD *)v13 + 97)) )
    {
      v15 = (signed __int64)&v13[3 * v14];
      v17 = *(_BYTE *)(v15 + 22);
      v16 = (_BYTE *)(v15 + 22);
      v18 = (void **)(v16 - 14);
      if ( v17 & 0x10 )
        free(*v18);
      *v18 = v12;
      *v16 = 17;
    }
    else
    {
      free(v12);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000498D0) ----------------------------------------------------
signed __int64 ERR_set_mark()
{
  _QWORD *v0; // x19
  __int64 v1; // x8
  signed __int64 result; // x0
  _QWORD *v3; // x0

  v0 = CRYPTO_get_thread_local(0);
  if ( v0 )
    goto LABEL_10;
  v3 = malloc(0x190uLL);
  v0 = v3;
  if ( !v3 )
    return 0LL;
  memset(v3, 0, 0x190uLL);
  result = CRYPTO_set_thread_local(0, (__int64)v0, (void (__fastcall *)(__int64))sub_49A74);
  if ( (_DWORD)result )
  {
LABEL_10:
    v1 = *((unsigned int *)v0 + 96);
    if ( *((_DWORD *)v0 + 97) != (_DWORD)v1 )
    {
      result = 1LL;
      BYTE6(v0[3 * v1 + 2]) |= 0x20u;
      return result;
    }
    return 0LL;
  }
  return result;
}

//----- (0000000000049964) ----------------------------------------------------
signed __int64 ERR_pop_to_mark()
{
  _QWORD *v0; // x19
  unsigned int v1; // w9
  signed __int64 v2; // x23
  char v3; // w8
  char *v4; // x23
  char v5; // t1
  _QWORD *v6; // x24
  void **v7; // x25
  int v8; // w8
  int v9; // w10
  _QWORD *v10; // x0
  signed __int64 result; // x0

  v0 = CRYPTO_get_thread_local(0);
  if ( !v0 )
  {
    v10 = malloc(0x190uLL);
    v0 = v10;
    if ( !v10 )
      return 0LL;
    memset(v10, 0, 0x190uLL);
    result = CRYPTO_set_thread_local(0, (__int64)v0, (void (__fastcall *)(__int64))sub_49A74);
    if ( !(_DWORD)result )
      return result;
  }
  v1 = *((_DWORD *)v0 + 96);
  if ( *((_DWORD *)v0 + 97) == v1 )
    return 0LL;
  while ( 1 )
  {
    v2 = (signed __int64)&v0[3 * v1];
    v5 = *(_BYTE *)(v2 + 22);
    v4 = (char *)(v2 + 22);
    v3 = v5;
    if ( v5 & 0x20 )
      break;
    v6 = &v0[3 * v1];
    v7 = (void **)(v6 + 1);
    if ( v3 & 0x10 )
    {
      free(*v7);
      v3 = *v4;
    }
    *v7 = 0LL;
    *v4 = v3 & 0xEF;
    v6[1] = 0LL;
    v6[2] = 0LL;
    *v6 = 0LL;
    v8 = *((_DWORD *)v0 + 96);
    v9 = *((_DWORD *)v0 + 97);
    v1 = v8 - 1;
    if ( !v8 )
      v1 = 15;
    *((_DWORD *)v0 + 96) = v1;
    if ( v9 == v1 )
      return 0LL;
  }
  *v4 = v3 & 0xDF;
  return 1LL;
}

//----- (0000000000049A74) ----------------------------------------------------
void __fastcall sub_49A74(void **a1)
{
  void **v1; // x19
  __int64 v2; // x20
  void **v3; // x22
  char v4; // w8

  v1 = a1;
  if ( a1 )
  {
    v2 = 0LL;
    do
    {
      v3 = &v1[v2];
      v4 = BYTE6(v1[v2 + 2]);
      if ( BYTE6(v1[v2 + 2]) & 0x10 )
      {
        free(v3[1]);
        v4 = *((_BYTE *)v3 + 22);
      }
      v2 += 3LL;
      *v3 = 0LL;
      v3[1] = 0LL;
      *((_BYTE *)v3 + 22) = v4 & 0xEF;
      v3[1] = 0LL;
      v3[2] = 0LL;
    }
    while ( v2 != 48 );
    free(v1[49]);
    free(v1);
  }
}

//----- (0000000000049AF4) ----------------------------------------------------
signed __int64 __fastcall sub_49AF4(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2; // w8
  bool v3; // cf
  _BOOL4 v4; // w8
  signed __int64 result; // x0

  v2 = *a1 >> 15;
  v3 = v2 >= *a2 >> 15;
  v4 = v2 > *a2 >> 15;
  if ( v3 )
    result = (unsigned int)v4;
  else
    result = 1LL;
  return result;
}

//----- (0000000000049B10) ----------------------------------------------------
void *__fastcall HMAC(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, void *a6, _DWORD *a7)
{
  __int64 v7; // x8
  _DWORD *v8; // x22
  unsigned __int64 v9; // x26
  __int64 v10; // x27
  __int64 v11; // x28
  void *v12; // x19
  void *result; // x0
  __int64 v14; // [xsp+8h] [xbp-108h]
  __int64 v15; // [xsp+10h] [xbp-100h]
  __int64 v16; // [xsp+30h] [xbp-E0h]
  __int64 v17; // [xsp+50h] [xbp-C0h]
  int v18; // [xsp+74h] [xbp-9Ch]
  char v19; // [xsp+78h] [xbp-98h]
  __int64 v20; // [xsp+B8h] [xbp-58h]

  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a7;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  if ( a6 )
    v12 = a6;
  else
    v12 = &unk_106F68;
  v20 = v7;
  v14 = 0LL;
  EVP_MD_CTX_init(&v16);
  EVP_MD_CTX_init(&v17);
  EVP_MD_CTX_init(&v15);
  if ( HMAC_Init_ex(&v14, v10, v9, v11) && (unsigned int)EVP_DigestUpdate((__int64)&v15) )
  {
    if ( !(unsigned int)EVP_DigestFinal_ex((void **)&v15, (__int64)&v19, &v18)
      || !(unsigned int)EVP_MD_CTX_copy_ex(&v15, &v17)
      || !(unsigned int)EVP_DigestUpdate((__int64)&v15)
      || !(unsigned int)EVP_DigestFinal_ex((void **)&v15, (__int64)v12, v8) )
    {
      v12 = 0LL;
      *v8 = 0;
    }
  }
  else
  {
    v12 = 0LL;
  }
  EVP_MD_CTX_cleanup(&v16);
  EVP_MD_CTX_cleanup(&v17);
  EVP_MD_CTX_cleanup(&v15);
  result = OPENSSL_cleanse(&v14, 0x68uLL);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v20 )
    result = v12;
  return result;
}

//----- (0000000000049C7C) ----------------------------------------------------
_QWORD *__fastcall HMAC_CTX_init(_QWORD *a1)
{
  _QWORD *v1; // x19
  _QWORD *v2; // x20

  v1 = a1;
  *a1 = 0LL;
  v2 = a1 + 1;
  EVP_MD_CTX_init(a1 + 5);
  EVP_MD_CTX_init(v1 + 9);
  return EVP_MD_CTX_init(v2);
}

//----- (0000000000049CB4) ----------------------------------------------------
bool __fastcall HMAC_Init_ex(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 *v4; // x19
  unsigned __int64 v5; // x22
  __int64 v6; // x20
  _QWORD *v7; // x22
  _BOOL8 result; // x0
  int8x16_t v9; // q2
  int8x16_t v10; // q2
  int v11; // [xsp+Ch] [xbp-154h]
  int8x16_t v12; // [xsp+10h] [xbp-150h]
  int8x16_t v13; // [xsp+20h] [xbp-140h]
  int8x16_t v14; // [xsp+30h] [xbp-130h]
  int8x16_t v15; // [xsp+40h] [xbp-120h]
  int8x16_t v16; // [xsp+50h] [xbp-110h]
  int8x16_t v17; // [xsp+60h] [xbp-100h]
  int8x16_t v18; // [xsp+70h] [xbp-F0h]
  int8x16_t v19; // [xsp+80h] [xbp-E0h]
  int8x16_t v20; // [xsp+90h] [xbp-D0h]
  int8x16_t v21; // [xsp+A0h] [xbp-C0h]
  int8x16_t v22; // [xsp+B0h] [xbp-B0h]
  int8x16_t v23; // [xsp+C0h] [xbp-A0h]
  int8x16_t v24; // [xsp+D0h] [xbp-90h]
  int8x16_t v25; // [xsp+E0h] [xbp-80h]
  int8x16_t v26; // [xsp+F0h] [xbp-70h]
  int8x16_t v27; // [xsp+100h] [xbp-60h]
  __int64 v28; // [xsp+118h] [xbp-48h]

  v4 = a1;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = a3;
  if ( a4 )
    v6 = a4;
  else
    v6 = *a1;
  if ( a2 || v6 != *a1 )
  {
    if ( X509_VERIFY_PARAM_get_depth(v6) >= a3 )
    {
      if ( v5 )
        __memcpy_chk();
      v11 = v5;
      if ( (_DWORD)v5 == 128 )
        goto LABEL_19;
    }
    else
    {
      if ( !(unsigned int)EVP_DigestInit_ex(v4 + 1, v6)
        || !(unsigned int)EVP_DigestUpdate((__int64)(v4 + 1))
        || !(unsigned int)EVP_DigestFinal_ex((void **)v4 + 1, (__int64)&v12, &v11) )
      {
        goto LABEL_24;
      }
      LODWORD(v5) = v11;
      if ( v11 == 128 )
      {
LABEL_19:
        v9.n128_u64[0] = 3906369333256140342LL;
        v9.n128_u64[1] = 3906369333256140342LL;
        v7 = v4 + 5;
        v20 = veorq_s8(v12, v9);
        v21 = veorq_s8(v13, v9);
        v22 = veorq_s8(v14, v9);
        v23 = veorq_s8(v15, v9);
        v24 = veorq_s8(v16, v9);
        v25 = veorq_s8(v17, v9);
        v26 = veorq_s8(v18, v9);
        v27 = veorq_s8(v19, v9);
        if ( (unsigned int)EVP_DigestInit_ex(v4 + 5, v6) )
        {
          X509_VERIFY_PARAM_get_depth(v6);
          if ( (unsigned int)EVP_DigestUpdate((__int64)(v4 + 5)) )
          {
            v10.n128_u64[0] = 6655295901103053916LL;
            v10.n128_u64[1] = 6655295901103053916LL;
            v20 = veorq_s8(v12, v10);
            v21 = veorq_s8(v13, v10);
            v22 = veorq_s8(v14, v10);
            v23 = veorq_s8(v15, v10);
            v24 = veorq_s8(v16, v10);
            v25 = veorq_s8(v17, v10);
            v26 = veorq_s8(v18, v10);
            v27 = veorq_s8(v19, v10);
            if ( (unsigned int)EVP_DigestInit_ex(v4 + 9, v6) )
            {
              X509_VERIFY_PARAM_get_depth(v6);
              if ( (unsigned int)EVP_DigestUpdate((__int64)(v4 + 9)) )
              {
                *v4 = v6;
                goto LABEL_7;
              }
            }
          }
        }
LABEL_24:
        result = 0LL;
        goto LABEL_25;
      }
    }
    if ( 128LL != (unsigned int)v5 )
      memset((char *)&v12 + (unsigned int)v5, 0, 128LL - (unsigned int)v5);
    goto LABEL_19;
  }
  v7 = a1 + 5;
LABEL_7:
  result = (unsigned int)EVP_MD_CTX_copy_ex(v4 + 1, v7) != 0;
LABEL_25:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000049EF8) ----------------------------------------------------
signed __int64 __fastcall HMAC_Update(__int64 a1)
{
  return EVP_DigestUpdate(a1 + 8);
}

//----- (0000000000049F00) ----------------------------------------------------
signed __int64 __fastcall HMAC_Final(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // x22
  void **v4; // x21
  _DWORD *v5; // x19
  __int64 v6; // x20
  signed __int64 result; // x0
  int v8; // [xsp+4h] [xbp-6Ch]
  char v9; // [xsp+8h] [xbp-68h]
  __int64 v10; // [xsp+48h] [xbp-28h]

  v3 = a1;
  v4 = (void **)(a1 + 8);
  v5 = a3;
  v6 = a2;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)EVP_DigestFinal_ex((void **)(a1 + 8), (__int64)&v9, &v8)
    && (unsigned int)EVP_MD_CTX_copy_ex(v4, (_QWORD *)(v3 + 72))
    && (unsigned int)EVP_DigestUpdate((__int64)v4)
    && (unsigned int)EVP_DigestFinal_ex(v4, v6, v5) )
  {
    result = 1LL;
  }
  else
  {
    result = 0LL;
    *v5 = 0;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000049FB8) ----------------------------------------------------
void *__fastcall HMAC_CTX_cleanup(_QWORD *a1)
{
  _QWORD *v1; // x19

  v1 = a1;
  EVP_MD_CTX_cleanup(a1 + 5);
  EVP_MD_CTX_cleanup(v1 + 9);
  EVP_MD_CTX_cleanup(v1 + 1);
  return OPENSSL_cleanse(v1, 0x68uLL);
}

//----- (0000000000049FF4) ----------------------------------------------------
__int64 __fastcall HMAC_size(__int64 *a1)
{
  return X509_TRUST_get_flags(*a1);
}

//----- (0000000000049FFC) ----------------------------------------------------
signed __int64 __fastcall HMAC_CTX_copy_ex(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  _QWORD *v3; // x19
  signed __int64 result; // x0

  v2 = a2;
  v3 = a1;
  result = EVP_MD_CTX_copy_ex(a1 + 5, a2 + 5);
  if ( (_DWORD)result )
  {
    result = EVP_MD_CTX_copy_ex(v3 + 9, v2 + 9);
    if ( (_DWORD)result )
    {
      result = EVP_MD_CTX_copy_ex(v3 + 1, v2 + 1);
      if ( (_DWORD)result )
      {
        result = 1LL;
        *v3 = *v2;
      }
    }
  }
  return result;
}

//----- (000000000004A058) ----------------------------------------------------
bool __fastcall HMAC_Init(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // x19
  int v5; // w22
  __int64 v6; // x20
  __int64 *v7; // x21

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a2 && a4 )
  {
    *a1 = 0LL;
    EVP_MD_CTX_init(a1 + 5);
    EVP_MD_CTX_init(v7 + 9);
    EVP_MD_CTX_init(v7 + 1);
  }
  return HMAC_Init_ex(v7, v6, v5, v4);
}

//----- (000000000004A0CC) ----------------------------------------------------
signed __int64 __fastcall HMAC_CTX_copy(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // x19
  _QWORD *v3; // x23
  _QWORD *v4; // x20
  _QWORD *v5; // x21
  signed __int64 result; // x0

  v2 = a1;
  v3 = a1 + 5;
  v4 = a2;
  *a1 = 0LL;
  v5 = a1 + 1;
  EVP_MD_CTX_init(a1 + 5);
  EVP_MD_CTX_init(v2 + 9);
  EVP_MD_CTX_init(v5);
  result = EVP_MD_CTX_copy_ex(v3, v4 + 5);
  if ( (_DWORD)result )
  {
    result = EVP_MD_CTX_copy_ex(v2 + 9, v4 + 9);
    if ( (_DWORD)result )
    {
      result = EVP_MD_CTX_copy_ex(v5, v4 + 1);
      if ( (_DWORD)result )
      {
        result = 1LL;
        *v2 = *v4;
      }
    }
  }
  return result;
}

//----- (000000000004A160) ----------------------------------------------------
signed __int64 __fastcall MD4(unsigned __int8 *a1, size_t a2, __int64 a3)
{
  unsigned __int64 v3; // x22
  __int64 v4; // x19
  size_t v5; // x20
  unsigned __int8 *v6; // x21
  signed __int64 result; // x0
  __int128 v8; // [xsp+0h] [xbp-90h]
  __int64 v9; // [xsp+10h] [xbp-80h]
  __int64 v10; // [xsp+68h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a3;
  v5 = a2;
  v6 = a1;
  v10 = *(_QWORD *)(v3 + 40);
  memset(&v9, 0, 0x4CuLL);
  v8 = xmmword_D10C0;
  MD4_Update(&v8, v6, v5);
  result = MD4_Final(v4, (__int64)&v8);
  if ( *(_QWORD *)(v3 + 40) == v10 )
    result = v4;
  return result;
}
// D10C0: using guessed type __int128 xmmword_D10C0;

//----- (000000000004A1F4) ----------------------------------------------------
signed __int64 __fastcall MD5_Init(_OWORD *a1)
{
  _OWORD *v1; // x19
  signed __int64 result; // x0

  v1 = a1;
  memset(a1, 0, 0x5CuLL);
  result = 1LL;
  *v1 = xmmword_D10C0;
  return result;
}
// D10C0: using guessed type __int128 xmmword_D10C0;

//----- (000000000004A22C) ----------------------------------------------------
signed __int64 __fastcall MD4_Update(_DWORD *a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3; // x19
  unsigned __int8 *v4; // x21
  _DWORD *v5; // x20
  int v6; // w10
  int v7; // w8
  int v8; // w9
  __int64 v9; // x8
  _QWORD *v10; // x22
  signed __int64 v11; // x23
  size_t v12; // x22

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v7 = a1[4];
    v6 = a1[5];
    v8 = v7 + 8 * a3;
    if ( __CFADD__(v7, 8 * a3) )
      a1[5] = ++v6;
    v9 = (unsigned int)a1[22];
    a1[4] = v8;
    a1[5] = v6 + (a3 >> 29);
    if ( (_DWORD)v9 )
    {
      if ( ((v9 + a3) | a3) < 0x40 )
      {
        memcpy((char *)a1 + v9 + 24, a2, a3);
        v5[22] += v3;
        return 1LL;
      }
      v10 = a1 + 6;
      v11 = 64 - v9;
      if ( 64 != v9 )
        memcpy((char *)v10 + v9, a2, 64 - v9);
      sub_4A4C0(v5, (unsigned __int8 *)v5 + 24, 1LL);
      v4 += v11;
      v3 -= v11;
      v5[22] = 0;
      *((_QWORD *)v5 + 9) = 0LL;
      *((_QWORD *)v5 + 10) = 0LL;
      *((_QWORD *)v5 + 7) = 0LL;
      *((_QWORD *)v5 + 8) = 0LL;
      *((_QWORD *)v5 + 5) = 0LL;
      *((_QWORD *)v5 + 6) = 0LL;
      *v10 = 0LL;
      *((_QWORD *)v5 + 4) = 0LL;
    }
    v12 = v3 >> 6;
    if ( v3 >> 6 )
    {
      sub_4A4C0(v5, v4, v3 >> 6);
      v4 += 64 * v12;
      v3 -= v12 << 6;
    }
    if ( v3 )
    {
      v5[22] = v3;
      memcpy(v5 + 6, v4, v3);
    }
  }
  return 1LL;
}

//----- (000000000004A34C) ----------------------------------------------------
signed __int64 __fastcall MD4_Final(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x9
  signed __int64 v4; // x21
  __int64 v5; // x19
  signed __int64 v6; // x8
  int v7; // w8
  int v8; // w9
  int v9; // w8
  signed __int64 result; // x0
  int v11; // w9
  int v12; // w8
  int v13; // w8
  int v14; // w8

  v2 = a2;
  v3 = *(unsigned int *)(a2 + 88);
  v4 = a2 + 24;
  v5 = a1;
  *(_BYTE *)(a2 + 24 + v3) = -128;
  v6 = v3 + 1;
  if ( (unsigned __int64)(v3 + 1) >= 0x39 )
  {
    if ( 63 != v3 )
      memset((void *)(a2 + v6 + 24), 0, 63 - v3);
    sub_4A4C0((int *)v2, (unsigned __int8 *)v4, 1LL);
    v6 = 0LL;
  }
  if ( 56 != v6 )
    memset((void *)(v2 + v6 + 24), 0, 56 - v6);
  v7 = *(_DWORD *)(v2 + 16);
  v8 = *(_DWORD *)(v2 + 20);
  *(_WORD *)(v2 + 80) = v7;
  *(_BYTE *)(v2 + 83) = HIBYTE(v7);
  *(_WORD *)(v2 + 84) = v8;
  *(_BYTE *)(v2 + 82) = BYTE2(v7);
  *(_BYTE *)(v2 + 86) = BYTE2(v8);
  *(_BYTE *)(v2 + 87) = HIBYTE(v8);
  sub_4A4C0((int *)v2, (unsigned __int8 *)v4, 1LL);
  *(_DWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v4 + 48) = 0LL;
  *(_QWORD *)(v4 + 56) = 0LL;
  *(_QWORD *)(v4 + 32) = 0LL;
  *(_QWORD *)(v4 + 40) = 0LL;
  *(_QWORD *)(v4 + 16) = 0LL;
  *(_QWORD *)(v4 + 24) = 0LL;
  *(_QWORD *)v4 = 0LL;
  *(_QWORD *)(v4 + 8) = 0LL;
  v9 = *(_DWORD *)v2;
  result = 1LL;
  v11 = *(_DWORD *)v2 >> 8;
  *(_BYTE *)v5 = *(_DWORD *)v2;
  *(_BYTE *)(v5 + 1) = v11;
  *(_BYTE *)(v5 + 2) = BYTE2(v9);
  *(_BYTE *)(v5 + 3) = HIBYTE(v9);
  v12 = *(_DWORD *)(v2 + 4);
  *(_WORD *)(v5 + 4) = v12;
  *(_BYTE *)(v5 + 6) = BYTE2(v12);
  *(_BYTE *)(v5 + 7) = HIBYTE(v12);
  v13 = *(_DWORD *)(v2 + 8);
  *(_WORD *)(v5 + 8) = v13;
  *(_BYTE *)(v5 + 10) = BYTE2(v13);
  *(_BYTE *)(v5 + 11) = HIBYTE(v13);
  v14 = *(_DWORD *)(v2 + 12);
  *(_WORD *)(v5 + 12) = v14;
  *(_BYTE *)(v5 + 14) = BYTE2(v14);
  *(_BYTE *)(v5 + 15) = HIBYTE(v14);
  return result;
}

//----- (000000000004A4C0) ----------------------------------------------------
int *__fastcall sub_4A4C0(int *result, unsigned __int8 *a2, __int64 a3)
{
  int v3; // w16
  int v4; // w17
  int v5; // w6
  int v6; // w18
  int v7; // ST0C_4
  int v8; // w12
  int v9; // w11
  int v10; // w15
  int v11; // w13
  int v12; // w5
  int v13; // w3
  int v14; // w19
  int v15; // w6
  int v16; // w22
  int v17; // w20
  int v18; // w8
  unsigned __int64 v19; // t2
  int v20; // w10
  int v21; // w23
  int v22; // w16
  int v23; // w16
  int v24; // w17
  int v25; // w17
  int v26; // w25
  int v27; // w14
  int v28; // w8
  int v29; // w16
  int v30; // w16
  int v31; // w17
  int v32; // w17
  int v33; // w4
  int v34; // w25
  int v35; // w8
  int v36; // w16
  int v37; // w16
  int v38; // w7
  int v39; // w17
  int v40; // w17
  int v41; // w25
  int v42; // w8
  int v43; // w21
  int v44; // w16
  int v45; // w16
  int v46; // w17
  int v47; // w17
  int v48; // w18
  int v49; // w8
  int v50; // w26
  int v51; // w16
  int v52; // w16
  int v53; // w25
  int v54; // w17
  int v55; // w17
  int v56; // w18
  int v57; // w8
  int v58; // w26
  int v59; // w16
  int v60; // w16
  int v61; // w25
  int v62; // w17
  int v63; // w17
  int v64; // w18
  int v65; // w8
  int v66; // w26
  int v67; // w16
  int v68; // w16
  int v69; // w25
  int v70; // w17
  int v71; // w17
  int v72; // w18
  int v73; // w8
  int v74; // w26
  int v75; // w16
  int v76; // w16
  int v77; // w25
  int v78; // w17
  int v79; // w17
  int v80; // w18
  int v81; // w8
  int v82; // w26
  int v83; // w16
  int v84; // w16
  int v85; // w25
  int v86; // w17
  int v87; // w17
  int v88; // w11
  int v89; // w26
  int v90; // w16
  int v91; // w18
  int v92; // w8
  int v93; // w16
  int v94; // w16
  int v95; // w14
  int v96; // w11
  int v97; // w8
  int v98; // w12
  int v99; // w14
  int v100; // w17
  int v101; // w11
  int v102; // w8
  int v103; // w18
  int v104; // w12
  int v105; // w10
  int v106; // w11
  int v107; // w8
  int v108; // w15
  int v109; // w10
  int v110; // w16
  int v111; // w11
  int v112; // w12
  int v113; // w8
  int v114; // w13
  int v115; // w10
  int v116; // w14
  int v117; // w11
  int v118; // w15
  int v119; // w8
  int v120; // w10
  int v121; // w11
  int v122; // w8

  if ( a3 )
  {
    v4 = result[2];
    v3 = result[3];
    v5 = *result;
    v6 = result[1];
    do
    {
      v7 = ((v4 ^ v3) & v6 ^ v3) + v5;
      v8 = ((unsigned __int16)(a2[8] | (unsigned __int16)(a2[9] << 8)) | (a2[10] << 16)) & 0xFFFFFF | (a2[11] << 24);
      v9 = ((unsigned __int16)(*a2 | (unsigned __int16)(a2[1] << 8)) | (a2[2] << 16)) & 0xFFFFFF | (a2[3] << 24);
      v10 = ((unsigned __int16)(a2[20] | (unsigned __int16)(a2[21] << 8)) | (a2[22] << 16)) & 0xFFFFFF | (a2[23] << 24);
      v11 = ((unsigned __int16)(a2[12] | (unsigned __int16)(a2[13] << 8)) | (a2[14] << 16)) & 0xFFFFFF | (a2[15] << 24);
      v12 = ((unsigned __int16)(a2[32] | (unsigned __int16)(a2[33] << 8)) | (a2[34] << 16)) & 0xFFFFFF | (a2[35] << 24);
      v13 = ((unsigned __int16)(a2[24] | (unsigned __int16)(a2[25] << 8)) | (a2[26] << 16)) & 0xFFFFFF | (a2[27] << 24);
      v14 = ((unsigned __int16)(a2[44] | (unsigned __int16)(a2[45] << 8)) | (a2[46] << 16)) & 0xFFFFFF | (a2[47] << 24);
      v15 = ((unsigned __int16)(a2[36] | (unsigned __int16)(a2[37] << 8)) | (a2[38] << 16)) & 0xFFFFFF | (a2[39] << 24);
      v16 = ((unsigned __int16)(a2[56] | (unsigned __int16)(a2[57] << 8)) | (a2[58] << 16)) & 0xFFFFFF | (a2[59] << 24);
      v17 = ((unsigned __int16)(a2[48] | (unsigned __int16)(a2[49] << 8)) | (a2[50] << 16)) & 0xFFFFFF | (a2[51] << 24);
      HIDWORD(v19) = v7 + v9;
      LODWORD(v19) = v7 + v9;
      v18 = v19 >> 29;
      v20 = ((unsigned __int16)(a2[4] | (unsigned __int16)(a2[5] << 8)) | (a2[6] << 16)) & 0xFFFFFF | (a2[7] << 24);
      v21 = ((unsigned __int16)(a2[60] | (unsigned __int16)(a2[61] << 8)) | (a2[62] << 16)) & 0xFFFFFF | (a2[63] << 24);
      v22 = v20 + v3 + (v18 & (v6 ^ v4) ^ v4);
      HIDWORD(v19) = v22;
      LODWORD(v19) = v22;
      v23 = v19 >> 25;
      v24 = v8 + v4 + (v23 & (v18 ^ v6) ^ v6);
      HIDWORD(v19) = v24;
      LODWORD(v19) = v24;
      v25 = v19 >> 21;
      HIDWORD(v19) = v11 + v6 + (v25 & (v23 ^ v18) ^ v18);
      LODWORD(v19) = v11 + v6 + (v25 & (v23 ^ v18) ^ v18);
      v26 = v19 >> 13;
      v27 = ((unsigned __int16)(a2[16] | (unsigned __int16)(a2[17] << 8)) | (a2[18] << 16)) & 0xFFFFFF | (a2[19] << 24);
      HIDWORD(v19) = v27 + v18 + (v26 & (v25 ^ v23) ^ v23);
      LODWORD(v19) = v27 + v18 + (v26 & (v25 ^ v23) ^ v23);
      v28 = v19 >> 29;
      v29 = v10 + v23 + (v28 & (v26 ^ v25) ^ v25);
      HIDWORD(v19) = v29;
      LODWORD(v19) = v29;
      v30 = v19 >> 25;
      v31 = v13 + v25 + (v30 & (v28 ^ v26) ^ v26);
      HIDWORD(v19) = v31;
      LODWORD(v19) = v31;
      v32 = v19 >> 21;
      v33 = ((unsigned __int16)(a2[28] | (unsigned __int16)(a2[29] << 8)) | (a2[30] << 16)) & 0xFFFFFF | (a2[31] << 24);
      HIDWORD(v19) = v33 + v26 + (v32 & (v30 ^ v28) ^ v28);
      LODWORD(v19) = v33 + v26 + (v32 & (v30 ^ v28) ^ v28);
      v34 = v19 >> 13;
      HIDWORD(v19) = v12 + v28 + (v34 & (v32 ^ v30) ^ v30);
      LODWORD(v19) = v12 + v28 + (v34 & (v32 ^ v30) ^ v30);
      v35 = v19 >> 29;
      v36 = v15 + v30 + (v35 & (v34 ^ v32) ^ v32);
      HIDWORD(v19) = v36;
      LODWORD(v19) = v36;
      v37 = v19 >> 25;
      v38 = ((unsigned __int16)(a2[40] | (unsigned __int16)(a2[41] << 8)) | (a2[42] << 16)) & 0xFFFFFF | (a2[43] << 24);
      v39 = v32 + v38 + (v37 & (v35 ^ v34) ^ v34);
      HIDWORD(v19) = v39;
      LODWORD(v19) = v39;
      v40 = v19 >> 21;
      HIDWORD(v19) = v34 + v14 + (v40 & (v37 ^ v35) ^ v35);
      LODWORD(v19) = v34 + v14 + (v40 & (v37 ^ v35) ^ v35);
      v41 = v19 >> 13;
      HIDWORD(v19) = v35 + v17 + (v41 & (v40 ^ v37) ^ v37);
      LODWORD(v19) = v35 + v17 + (v41 & (v40 ^ v37) ^ v37);
      v42 = v19 >> 29;
      v43 = ((unsigned __int16)(a2[52] | (unsigned __int16)(a2[53] << 8)) | (a2[54] << 16)) & 0xFFFFFF | (a2[55] << 24);
      v44 = v37 + v43 + (v42 & (v41 ^ v40) ^ v40);
      HIDWORD(v19) = v44;
      LODWORD(v19) = v44;
      v45 = v19 >> 25;
      v46 = v40 + v16 + (v45 & (v42 ^ v41) ^ v41);
      HIDWORD(v19) = v46;
      LODWORD(v19) = v46;
      v47 = v19 >> 21;
      v48 = v9 + 1518500249 + v42;
      HIDWORD(v19) = v41 + v21 + (v47 & (v45 ^ v42) ^ v42);
      LODWORD(v19) = v41 + v21 + (v47 & (v45 ^ v42) ^ v42);
      v49 = v19 >> 13;
      v50 = v27 + 1518500249 + v45;
      v51 = v48 + ((v49 | v47) & v45 | v49 & v47);
      HIDWORD(v19) = v51;
      LODWORD(v19) = v51;
      v52 = v19 >> 29;
      v53 = v12 + 1518500249 + v47;
      v54 = v50 + ((v52 | v49) & v47 | v52 & v49);
      HIDWORD(v19) = v54;
      LODWORD(v19) = v54;
      v55 = v19 >> 27;
      v56 = v17 + 1518500249 + v49;
      HIDWORD(v19) = v53 + ((v55 | v52) & v49 | v55 & v52);
      LODWORD(v19) = v53 + ((v55 | v52) & v49 | v55 & v52);
      v57 = v19 >> 23;
      v58 = v20 + 1518500249 + v52;
      v59 = v56 + ((v57 | v55) & v52 | v57 & v55);
      HIDWORD(v19) = v59;
      LODWORD(v19) = v59;
      v60 = v19 >> 19;
      v61 = v10 + 1518500249 + v55;
      v62 = v58 + ((v60 | v57) & v55 | v60 & v57);
      HIDWORD(v19) = v62;
      LODWORD(v19) = v62;
      v63 = v19 >> 29;
      v64 = v15 + 1518500249 + v57;
      HIDWORD(v19) = v61 + ((v63 | v60) & v57 | v63 & v60);
      LODWORD(v19) = v61 + ((v63 | v60) & v57 | v63 & v60);
      v65 = v19 >> 27;
      v66 = v43 + 1518500249 + v60;
      v67 = v64 + ((v65 | v63) & v60 | v65 & v63);
      HIDWORD(v19) = v67;
      LODWORD(v19) = v67;
      v68 = v19 >> 23;
      v69 = v8 + 1518500249 + v63;
      v70 = v66 + ((v68 | v65) & v63 | v68 & v65);
      HIDWORD(v19) = v70;
      LODWORD(v19) = v70;
      v71 = v19 >> 19;
      v72 = v13 + 1518500249 + v65;
      HIDWORD(v19) = v69 + ((v71 | v68) & v65 | v71 & v68);
      LODWORD(v19) = v69 + ((v71 | v68) & v65 | v71 & v68);
      v73 = v19 >> 29;
      v74 = v38 + 1518500249 + v68;
      v75 = v72 + ((v73 | v71) & v68 | v73 & v71);
      HIDWORD(v19) = v75;
      LODWORD(v19) = v75;
      v76 = v19 >> 27;
      v77 = v16 + 1518500249 + v71;
      v78 = v74 + ((v76 | v73) & v71 | v76 & v73);
      HIDWORD(v19) = v78;
      LODWORD(v19) = v78;
      v79 = v19 >> 23;
      v80 = v11 + 1518500249 + v73;
      HIDWORD(v19) = v77 + ((v79 | v76) & v73 | v79 & v76);
      LODWORD(v19) = v77 + ((v79 | v76) & v73 | v79 & v76);
      v81 = v19 >> 19;
      v82 = v33 + 1518500249 + v76;
      v83 = v80 + ((v81 | v79) & v76 | v81 & v79);
      HIDWORD(v19) = v83;
      LODWORD(v19) = v83;
      v84 = v19 >> 29;
      v85 = v14 + 1518500249 + v79;
      v86 = v82 + ((v84 | v81) & v79 | v84 & v81);
      HIDWORD(v19) = v86;
      LODWORD(v19) = v86;
      v87 = v19 >> 27;
      v88 = v9 + 1859775393 + v84;
      v89 = v87 & v84;
      v90 = v87 | v84;
      v91 = v21 + 1518500249 + v81;
      HIDWORD(v19) = v85 + (v90 & v81 | v89);
      LODWORD(v19) = v85 + (v90 & v81 | v89);
      v92 = v19 >> 23;
      v93 = v91 + (v92 & v90 | v89);
      HIDWORD(v19) = v93;
      LODWORD(v19) = v93;
      v94 = v19 >> 19;
      v95 = v27 + 1859775393 + v92;
      HIDWORD(v19) = v88 + (v92 ^ v87 ^ v94);
      LODWORD(v19) = v88 + (v92 ^ v87 ^ v94);
      v96 = v19 >> 29;
      HIDWORD(v19) = v12 + 1859775393 + v87 + (v94 ^ v92 ^ v96);
      LODWORD(v19) = v12 + 1859775393 + v87 + (v94 ^ v92 ^ v96);
      v97 = v19 >> 23;
      v98 = v8 + 1859775393 + v96;
      HIDWORD(v19) = v95 + (v96 ^ v94 ^ v97);
      LODWORD(v19) = v95 + (v96 ^ v94 ^ v97);
      v99 = v19 >> 21;
      v100 = v38 + 1859775393 + v97;
      HIDWORD(v19) = v17 + 1859775393 + v94 + (v97 ^ v96 ^ v99);
      LODWORD(v19) = v17 + 1859775393 + v94 + (v97 ^ v96 ^ v99);
      v101 = v19 >> 17;
      HIDWORD(v19) = v98 + (v99 ^ v97 ^ v101);
      LODWORD(v19) = v98 + (v99 ^ v97 ^ v101);
      v102 = v19 >> 29;
      v103 = v16 + 1859775393 + v101;
      HIDWORD(v19) = v100 + (v101 ^ v99 ^ v102);
      LODWORD(v19) = v100 + (v101 ^ v99 ^ v102);
      v104 = v19 >> 23;
      v105 = v20 + 1859775393 + v102;
      HIDWORD(v19) = v13 + 1859775393 + v99 + (v102 ^ v101 ^ v104);
      LODWORD(v19) = v13 + 1859775393 + v99 + (v102 ^ v101 ^ v104);
      v106 = v19 >> 21;
      HIDWORD(v19) = v103 + (v104 ^ v102 ^ v106);
      LODWORD(v19) = v103 + (v104 ^ v102 ^ v106);
      v107 = v19 >> 17;
      v108 = v10 + 1859775393 + v106;
      HIDWORD(v19) = v105 + (v106 ^ v104 ^ v107);
      LODWORD(v19) = v105 + (v106 ^ v104 ^ v107);
      v109 = v19 >> 29;
      v110 = v43 + 1859775393 + v107;
      HIDWORD(v19) = v15 + 1859775393 + v104 + (v107 ^ v106 ^ v109);
      LODWORD(v19) = v15 + 1859775393 + v104 + (v107 ^ v106 ^ v109);
      v111 = v19 >> 23;
      v112 = v11 + 1859775393 + v109;
      HIDWORD(v19) = v108 + (v109 ^ v107 ^ v111);
      LODWORD(v19) = v108 + (v109 ^ v107 ^ v111);
      v113 = v19 >> 21;
      v114 = v14 + 1859775393 + v111;
      HIDWORD(v19) = v110 + (v111 ^ v109 ^ v113);
      LODWORD(v19) = v110 + (v111 ^ v109 ^ v113);
      v115 = v19 >> 17;
      v116 = v33 + 1859775393 + v113;
      HIDWORD(v19) = v112 + (v113 ^ v111 ^ v115);
      LODWORD(v19) = v112 + (v113 ^ v111 ^ v115);
      v117 = v19 >> 29;
      v118 = v21 + 1859775393 + v115;
      HIDWORD(v19) = v114 + (v115 ^ v113 ^ v117);
      LODWORD(v19) = v114 + (v115 ^ v113 ^ v117);
      v119 = v19 >> 23;
      v120 = v117 ^ v115 ^ v119;
      v5 = v117 + *result;
      v121 = v119 ^ v117;
      v3 = v119 + result[3];
      HIDWORD(v19) = v116 + v120;
      LODWORD(v19) = v116 + v120;
      v122 = v19 >> 21;
      v4 = v122 + result[2];
      HIDWORD(v19) = v118 + (v121 ^ v122);
      LODWORD(v19) = v118 + (v121 ^ v122);
      --a3;
      v6 = (v19 >> 17) + result[1];
      a2 += 64;
      result[2] = v4;
      result[3] = v3;
      *result = v5;
      result[1] = v6;
    }
    while ( a3 );
  }
  return result;
}

//----- (000000000004AC04) ----------------------------------------------------
int *__fastcall MD4_Transform(int *a1, unsigned __int8 *a2)
{
  return sub_4A4C0(a1, a2, 1LL);
}

//----- (000000000004AC0C) ----------------------------------------------------
signed __int64 __fastcall MD5(unsigned __int8 *a1, size_t a2, void *a3)
{
  unsigned __int64 v3; // x22
  size_t v4; // x20
  unsigned __int8 *v5; // x21
  void *v6; // x19
  signed __int64 result; // x0
  __int128 v8; // [xsp+0h] [xbp-90h]
  __int64 v9; // [xsp+10h] [xbp-80h]
  __int64 v10; // [xsp+68h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a2;
  v5 = a1;
  if ( a3 )
    v6 = a3;
  else
    v6 = &unk_106FA8;
  v10 = *(_QWORD *)(v3 + 40);
  memset(&v9, 0, 0x4CuLL);
  v8 = xmmword_D10C0;
  MD5_Update(&v8, v5, v4);
  result = MD5_Final((__int64)v6, (__int64)&v8);
  if ( *(_QWORD *)(v3 + 40) == v10 )
    result = (signed __int64)v6;
  return result;
}
// D10C0: using guessed type __int128 xmmword_D10C0;

//----- (000000000004ACAC) ----------------------------------------------------
signed __int64 __fastcall MD5_Update(_DWORD *a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3; // x19
  unsigned __int8 *v4; // x21
  _DWORD *v5; // x20
  int v6; // w10
  int v7; // w8
  int v8; // w9
  __int64 v9; // x8
  _QWORD *v10; // x22
  signed __int64 v11; // x23
  size_t v12; // x22

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v7 = a1[4];
    v6 = a1[5];
    v8 = v7 + 8 * a3;
    if ( __CFADD__(v7, 8 * a3) )
      a1[5] = ++v6;
    v9 = (unsigned int)a1[22];
    a1[4] = v8;
    a1[5] = v6 + (a3 >> 29);
    if ( (_DWORD)v9 )
    {
      if ( ((v9 + a3) | a3) < 0x40 )
      {
        memcpy((char *)a1 + v9 + 24, a2, a3);
        v5[22] += v3;
        return 1LL;
      }
      v10 = a1 + 6;
      v11 = 64 - v9;
      if ( 64 != v9 )
        memcpy((char *)v10 + v9, a2, 64 - v9);
      sub_4AF40(v5, (unsigned __int8 *)v5 + 24, 1LL);
      v4 += v11;
      v3 -= v11;
      v5[22] = 0;
      *((_QWORD *)v5 + 9) = 0LL;
      *((_QWORD *)v5 + 10) = 0LL;
      *((_QWORD *)v5 + 7) = 0LL;
      *((_QWORD *)v5 + 8) = 0LL;
      *((_QWORD *)v5 + 5) = 0LL;
      *((_QWORD *)v5 + 6) = 0LL;
      *v10 = 0LL;
      *((_QWORD *)v5 + 4) = 0LL;
    }
    v12 = v3 >> 6;
    if ( v3 >> 6 )
    {
      sub_4AF40(v5, v4, v3 >> 6);
      v4 += 64 * v12;
      v3 -= v12 << 6;
    }
    if ( v3 )
    {
      v5[22] = v3;
      memcpy(v5 + 6, v4, v3);
    }
  }
  return 1LL;
}

//----- (000000000004ADCC) ----------------------------------------------------
signed __int64 __fastcall MD5_Final(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x9
  signed __int64 v4; // x21
  __int64 v5; // x19
  signed __int64 v6; // x8
  int v7; // w8
  int v8; // w9
  int v9; // w8
  signed __int64 result; // x0
  int v11; // w9
  int v12; // w8
  int v13; // w8
  int v14; // w8

  v2 = a2;
  v3 = *(unsigned int *)(a2 + 88);
  v4 = a2 + 24;
  v5 = a1;
  *(_BYTE *)(a2 + 24 + v3) = -128;
  v6 = v3 + 1;
  if ( (unsigned __int64)(v3 + 1) >= 0x39 )
  {
    if ( 63 != v3 )
      memset((void *)(a2 + v6 + 24), 0, 63 - v3);
    sub_4AF40((int *)v2, (unsigned __int8 *)v4, 1LL);
    v6 = 0LL;
  }
  if ( 56 != v6 )
    memset((void *)(v2 + v6 + 24), 0, 56 - v6);
  v7 = *(_DWORD *)(v2 + 16);
  v8 = *(_DWORD *)(v2 + 20);
  *(_WORD *)(v2 + 80) = v7;
  *(_BYTE *)(v2 + 83) = HIBYTE(v7);
  *(_WORD *)(v2 + 84) = v8;
  *(_BYTE *)(v2 + 82) = BYTE2(v7);
  *(_BYTE *)(v2 + 86) = BYTE2(v8);
  *(_BYTE *)(v2 + 87) = HIBYTE(v8);
  sub_4AF40((int *)v2, (unsigned __int8 *)v4, 1LL);
  *(_DWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v4 + 48) = 0LL;
  *(_QWORD *)(v4 + 56) = 0LL;
  *(_QWORD *)(v4 + 32) = 0LL;
  *(_QWORD *)(v4 + 40) = 0LL;
  *(_QWORD *)(v4 + 16) = 0LL;
  *(_QWORD *)(v4 + 24) = 0LL;
  *(_QWORD *)v4 = 0LL;
  *(_QWORD *)(v4 + 8) = 0LL;
  v9 = *(_DWORD *)v2;
  result = 1LL;
  v11 = *(_DWORD *)v2 >> 8;
  *(_BYTE *)v5 = *(_DWORD *)v2;
  *(_BYTE *)(v5 + 1) = v11;
  *(_BYTE *)(v5 + 2) = BYTE2(v9);
  *(_BYTE *)(v5 + 3) = HIBYTE(v9);
  v12 = *(_DWORD *)(v2 + 4);
  *(_WORD *)(v5 + 4) = v12;
  *(_BYTE *)(v5 + 6) = BYTE2(v12);
  *(_BYTE *)(v5 + 7) = HIBYTE(v12);
  v13 = *(_DWORD *)(v2 + 8);
  *(_WORD *)(v5 + 8) = v13;
  *(_BYTE *)(v5 + 10) = BYTE2(v13);
  *(_BYTE *)(v5 + 11) = HIBYTE(v13);
  v14 = *(_DWORD *)(v2 + 12);
  *(_WORD *)(v5 + 12) = v14;
  *(_BYTE *)(v5 + 14) = BYTE2(v14);
  *(_BYTE *)(v5 + 15) = HIBYTE(v14);
  return result;
}

//----- (000000000004AF40) ----------------------------------------------------
int *__fastcall sub_4AF40(int *result, unsigned __int8 *a2, __int64 a3)
{
  int v3; // w25
  int v4; // w27
  int v5; // w6
  int v6; // w26
  int v7; // w30
  int v8; // w3
  int v9; // w4
  int v10; // w16
  int v11; // w5
  int v12; // w17
  int v13; // w7
  int v14; // w6
  int v15; // w18
  int v16; // w19
  int v17; // w24
  int v18; // w21
  int v19; // w20
  int v20; // w28
  int v21; // w22
  unsigned __int64 v22; // t2
  int v23; // w29
  int v24; // w9
  int v25; // w23
  int v26; // w8
  int v27; // w10
  int v28; // w13
  int v29; // w9
  int v30; // w11
  int v31; // w8
  int v32; // w12
  int v33; // w10
  int v34; // w13
  int v35; // w9
  int v36; // w11
  int v37; // w8
  int v38; // w12
  int v39; // w10
  int v40; // w13
  int v41; // w9
  int v42; // w11
  int v43; // w8
  int v44; // w12
  int v45; // w10
  int v46; // w13
  int v47; // w9
  int v48; // w11
  int v49; // w8
  int v50; // w12
  int v51; // w10
  int v52; // w13
  int v53; // w9
  int v54; // w11
  int v55; // w8
  int v56; // w12
  int v57; // w10
  int v58; // w13
  int v59; // w9
  int v60; // w11
  int v61; // w8
  int v62; // w12
  int v63; // w10
  int v64; // w13
  int v65; // w9
  int v66; // w11
  int v67; // w8
  int v68; // w12
  int v69; // w10
  int v70; // w13
  int v71; // w9
  int v72; // w11
  int v73; // w8
  int v74; // w12
  int v75; // w10
  int v76; // w13
  int v77; // w9
  int v78; // w11
  int v79; // w8
  int v80; // w12
  int v81; // w10
  int v82; // w13
  int v83; // w9
  int v84; // w12
  int v85; // w11
  int v86; // w8
  int v87; // w10
  int v88; // w9
  int v89; // w12
  int v90; // w11
  int v91; // w10
  int v92; // w8
  int v93; // w12
  int v94; // w9
  int v95; // w11
  int v96; // w10
  int v97; // w12
  int v98; // w8
  int v99; // w11
  int v100; // w9
  int v101; // w12
  int v102; // w10
  int v103; // w11
  int v104; // w8
  int v105; // w12
  int v106; // w9
  int v107; // w11
  int v108; // w10
  int v109; // w12
  int v110; // w8
  int v111; // w9
  int v112; // w12
  int v113; // w11
  int v114; // w8
  int v115; // w10
  int v116; // w9
  int v117; // w12
  int v118; // w10
  int v119; // w11
  int v120; // w8
  int v121; // w12
  int v122; // w9
  int v123; // w11
  int v124; // w10
  int v125; // w12
  int v126; // w8
  int v127; // w11
  int v128; // w9
  int v129; // w12
  int v130; // w10
  int v131; // w11
  int v132; // w8
  int v133; // w12
  int v134; // w9
  int v135; // w11
  int v136; // w10
  int v137; // w12
  int v138; // w8
  int v139; // w13
  int v140; // w9
  int v141; // w16
  int v142; // w10
  int v143; // w17
  int v144; // w8
  int v145; // w8
  int v146; // w9

  if ( a3 )
  {
    v3 = result[2];
    v4 = result[3];
    v5 = *result;
    v6 = result[1];
    do
    {
      v7 = v5 + ((v3 ^ v4) & v6 ^ v4);
      v8 = ((unsigned __int16)(*a2 | (unsigned __int16)(a2[1] << 8)) | (a2[2] << 16)) & 0xFFFFFF | (a2[3] << 24);
      v9 = ((unsigned __int16)(a2[12] | (unsigned __int16)(a2[13] << 8)) | (a2[14] << 16)) & 0xFFFFFF | (a2[15] << 24);
      v10 = ((unsigned __int16)(a2[8] | (unsigned __int16)(a2[9] << 8)) | (a2[10] << 16)) & 0xFFFFFF | (a2[11] << 24);
      v11 = ((unsigned __int16)(a2[24] | (unsigned __int16)(a2[25] << 8)) | (a2[26] << 16)) & 0xFFFFFF | (a2[27] << 24);
      v12 = ((unsigned __int16)(a2[4] | (unsigned __int16)(a2[5] << 8)) | (a2[6] << 16)) & 0xFFFFFF | (a2[7] << 24);
      v13 = ((unsigned __int16)(a2[20] | (unsigned __int16)(a2[21] << 8)) | (a2[22] << 16)) & 0xFFFFFF | (a2[23] << 24);
      v14 = ((unsigned __int16)(a2[36] | (unsigned __int16)(a2[37] << 8)) | (a2[38] << 16)) & 0xFFFFFF | (a2[39] << 24);
      v15 = ((unsigned __int16)(a2[16] | (unsigned __int16)(a2[17] << 8)) | (a2[18] << 16)) & 0xFFFFFF | (a2[19] << 24);
      v16 = ((unsigned __int16)(a2[32] | (unsigned __int16)(a2[33] << 8)) | (a2[34] << 16)) & 0xFFFFFF | (a2[35] << 24);
      v17 = ((unsigned __int16)(a2[48] | (unsigned __int16)(a2[49] << 8)) | (a2[50] << 16)) & 0xFFFFFF | (a2[51] << 24);
      v18 = ((unsigned __int16)(a2[28] | (unsigned __int16)(a2[29] << 8)) | (a2[30] << 16)) & 0xFFFFFF | (a2[31] << 24);
      v19 = ((unsigned __int16)(a2[44] | (unsigned __int16)(a2[45] << 8)) | (a2[46] << 16)) & 0xFFFFFF | (a2[47] << 24);
      v20 = ((unsigned __int16)(a2[60] | (unsigned __int16)(a2[61] << 8)) | (a2[62] << 16)) & 0xFFFFFF | (a2[63] << 24);
      v21 = ((unsigned __int16)(a2[40] | (unsigned __int16)(a2[41] << 8)) | (a2[42] << 16)) & 0xFFFFFF | (a2[43] << 24);
      HIDWORD(v22) = v7 + v8 - 680876936;
      LODWORD(v22) = v7 + v8 - 680876936;
      v23 = ((unsigned __int16)(a2[56] | (unsigned __int16)(a2[57] << 8)) | (a2[58] << 16)) & 0xFFFFFF | (a2[59] << 24);
      v24 = (v22 >> 25) + v6;
      v25 = ((unsigned __int16)(a2[52] | (unsigned __int16)(a2[53] << 8)) | (a2[54] << 16)) & 0xFFFFFF | (a2[55] << 24);
      HIDWORD(v22) = v4 + v12 + (v24 & (v6 ^ v3) ^ v3) - 389564586;
      LODWORD(v22) = v4 + v12 + (v24 & (v6 ^ v3) ^ v3) - 389564586;
      v26 = (v22 >> 20) + v24;
      HIDWORD(v22) = v3 + v10 + (v26 & (v24 ^ v6) ^ v6) + 606105819;
      LODWORD(v22) = v3 + v10 + (v26 & (v24 ^ v6) ^ v6) + 606105819;
      v27 = (v22 >> 15) + v26;
      v28 = v24 + v15;
      HIDWORD(v22) = v6 + v9 + (v27 & (v26 ^ v24) ^ v24) - 1044525330;
      LODWORD(v22) = v6 + v9 + (v27 & (v26 ^ v24) ^ v24) - 1044525330;
      v29 = (v22 >> 10) + v27;
      v30 = v26 + v13;
      HIDWORD(v22) = v28 + (v29 & (v27 ^ v26) ^ v26) - 176418897;
      LODWORD(v22) = v28 + (v29 & (v27 ^ v26) ^ v26) - 176418897;
      v31 = (v22 >> 25) + v29;
      v32 = v11 + v27;
      HIDWORD(v22) = v30 + (v31 & (v29 ^ v27) ^ v27) + 1200080426;
      LODWORD(v22) = v30 + (v31 & (v29 ^ v27) ^ v27) + 1200080426;
      v33 = (v22 >> 20) + v31;
      v34 = v18 + v29;
      HIDWORD(v22) = v32 + (v33 & (v31 ^ v29) ^ v29) - 1473231341;
      LODWORD(v22) = v32 + (v33 & (v31 ^ v29) ^ v29) - 1473231341;
      v35 = (v22 >> 15) + v33;
      v36 = v16 + v31;
      HIDWORD(v22) = v34 + (v35 & (v33 ^ v31) ^ v31) - 45705983;
      LODWORD(v22) = v34 + (v35 & (v33 ^ v31) ^ v31) - 45705983;
      v37 = (v22 >> 10) + v35;
      v38 = v14 + v33;
      HIDWORD(v22) = v36 + (v37 & (v35 ^ v33) ^ v33) + 1770035416;
      LODWORD(v22) = v36 + (v37 & (v35 ^ v33) ^ v33) + 1770035416;
      v39 = (v22 >> 25) + v37;
      v40 = v21 + v35;
      HIDWORD(v22) = v38 + (v39 & (v37 ^ v35) ^ v35) - 1958414417;
      LODWORD(v22) = v38 + (v39 & (v37 ^ v35) ^ v35) - 1958414417;
      v41 = (v22 >> 20) + v39;
      v42 = v19 + v37;
      HIDWORD(v22) = v40 + (v41 & (v39 ^ v37) ^ v37) - 42063;
      LODWORD(v22) = v40 + (v41 & (v39 ^ v37) ^ v37) - 42063;
      v43 = (v22 >> 15) + v41;
      v44 = v17 + v39;
      HIDWORD(v22) = v42 + (v43 & (v41 ^ v39) ^ v39) - 1990404162;
      LODWORD(v22) = v42 + (v43 & (v41 ^ v39) ^ v39) - 1990404162;
      v45 = (v22 >> 10) + v43;
      v46 = v25 + v41;
      HIDWORD(v22) = v44 + (v45 & (v43 ^ v41) ^ v41) + 1804603682;
      LODWORD(v22) = v44 + (v45 & (v43 ^ v41) ^ v41) + 1804603682;
      v47 = (v22 >> 25) + v45;
      v48 = v23 + v43;
      HIDWORD(v22) = v46 + (v47 & (v45 ^ v43) ^ v43) - 40341101;
      LODWORD(v22) = v46 + (v47 & (v45 ^ v43) ^ v43) - 40341101;
      v49 = (v22 >> 20) + v47;
      v50 = v20 + v45;
      HIDWORD(v22) = v48 + (v49 & (v47 ^ v45) ^ v45) - 1502002290;
      LODWORD(v22) = v48 + (v49 & (v47 ^ v45) ^ v45) - 1502002290;
      v51 = (v22 >> 15) + v49;
      v52 = v12 + v47;
      HIDWORD(v22) = v50 + (v51 & (v49 ^ v47) ^ v47) + 1236535329;
      LODWORD(v22) = v50 + (v51 & (v49 ^ v47) ^ v47) + 1236535329;
      v53 = (v22 >> 10) + v51;
      v54 = v11 + v49;
      HIDWORD(v22) = v52 + ((v53 ^ v51) & v49 ^ v51) - 165796510;
      LODWORD(v22) = v52 + ((v53 ^ v51) & v49 ^ v51) - 165796510;
      v55 = (v22 >> 27) + v53;
      v56 = v19 + v51;
      HIDWORD(v22) = v54 + ((v55 ^ v53) & v51 ^ v53) - 1069501632;
      LODWORD(v22) = v54 + ((v55 ^ v53) & v51 ^ v53) - 1069501632;
      v57 = (v22 >> 23) + v55;
      v58 = v8 + v53;
      HIDWORD(v22) = v56 + ((v57 ^ v55) & v53 ^ v55) + 643717713;
      LODWORD(v22) = v56 + ((v57 ^ v55) & v53 ^ v55) + 643717713;
      v59 = (v22 >> 18) + v57;
      v60 = v13 + v55;
      HIDWORD(v22) = v58 + ((v59 ^ v57) & v55 ^ v57) - 373897302;
      LODWORD(v22) = v58 + ((v59 ^ v57) & v55 ^ v57) - 373897302;
      v61 = (v22 >> 12) + v59;
      v62 = v21 + v57;
      HIDWORD(v22) = v60 + ((v61 ^ v59) & v57 ^ v59) - 701558691;
      LODWORD(v22) = v60 + ((v61 ^ v59) & v57 ^ v59) - 701558691;
      v63 = (v22 >> 27) + v61;
      v64 = v20 + v59;
      HIDWORD(v22) = v62 + ((v63 ^ v61) & v59 ^ v61) + 38016083;
      LODWORD(v22) = v62 + ((v63 ^ v61) & v59 ^ v61) + 38016083;
      v65 = (v22 >> 23) + v63;
      v66 = v15 + v61;
      HIDWORD(v22) = v64 + ((v65 ^ v63) & v61 ^ v63) - 660478335;
      LODWORD(v22) = v64 + ((v65 ^ v63) & v61 ^ v63) - 660478335;
      v67 = (v22 >> 18) + v65;
      v68 = v14 + v63;
      HIDWORD(v22) = v66 + ((v67 ^ v65) & v63 ^ v65) - 405537848;
      LODWORD(v22) = v66 + ((v67 ^ v65) & v63 ^ v65) - 405537848;
      v69 = (v22 >> 12) + v67;
      v70 = v23 + v65;
      HIDWORD(v22) = v68 + ((v69 ^ v67) & v65 ^ v67) + 568446438;
      LODWORD(v22) = v68 + ((v69 ^ v67) & v65 ^ v67) + 568446438;
      v71 = (v22 >> 27) + v69;
      v72 = v9 + v67;
      HIDWORD(v22) = v70 + ((v71 ^ v69) & v67 ^ v69) - 1019803690;
      LODWORD(v22) = v70 + ((v71 ^ v69) & v67 ^ v69) - 1019803690;
      v73 = (v22 >> 23) + v71;
      v74 = v16 + v69;
      HIDWORD(v22) = v72 + ((v73 ^ v71) & v69 ^ v71) - 187363961;
      LODWORD(v22) = v72 + ((v73 ^ v71) & v69 ^ v71) - 187363961;
      v75 = (v22 >> 18) + v73;
      v76 = v25 + v71;
      HIDWORD(v22) = v74 + ((v75 ^ v73) & v71 ^ v73) + 1163531501;
      LODWORD(v22) = v74 + ((v75 ^ v73) & v71 ^ v73) + 1163531501;
      v77 = (v22 >> 12) + v75;
      v78 = v10 + v73;
      HIDWORD(v22) = v76 + ((v77 ^ v75) & v73 ^ v75) - 1444681467;
      LODWORD(v22) = v76 + ((v77 ^ v75) & v73 ^ v75) - 1444681467;
      v79 = (v22 >> 27) + v77;
      v80 = v18 + v75;
      HIDWORD(v22) = v78 + ((v79 ^ v77) & v75 ^ v77) - 51403784;
      LODWORD(v22) = v78 + ((v79 ^ v77) & v75 ^ v77) - 51403784;
      v81 = (v22 >> 23) + v79;
      v82 = v17 + v77;
      HIDWORD(v22) = v80 + ((v81 ^ v79) & v77 ^ v79) + 1735328473;
      LODWORD(v22) = v80 + ((v81 ^ v79) & v77 ^ v79) + 1735328473;
      v83 = (v22 >> 18) + v81;
      HIDWORD(v22) = v82 + ((v83 ^ v81) & v79 ^ v81) - 1926607734;
      LODWORD(v22) = v82 + ((v83 ^ v81) & v79 ^ v81) - 1926607734;
      v84 = (v22 >> 12) + v83;
      HIDWORD(v22) = v13 + v79 + (v83 ^ v81 ^ v84) - 378558;
      LODWORD(v22) = v13 + v79 + (v83 ^ v81 ^ v84) - 378558;
      v85 = v19 + v83;
      v86 = (v22 >> 28) + v84;
      HIDWORD(v22) = v16 + v81 + (v84 ^ v83 ^ v86) - 2022574463;
      LODWORD(v22) = v16 + v81 + (v84 ^ v83 ^ v86) - 2022574463;
      v87 = v23 + v84;
      v88 = (v22 >> 21) + v86;
      HIDWORD(v22) = v85 + (v86 ^ v84 ^ v88) + 1839030562;
      LODWORD(v22) = v85 + (v86 ^ v84 ^ v88) + 1839030562;
      v89 = v12 + v86;
      v90 = (v22 >> 16) + v88;
      HIDWORD(v22) = v87 + (v88 ^ v86 ^ v90) - 35309556;
      LODWORD(v22) = v87 + (v88 ^ v86 ^ v90) - 35309556;
      v91 = v15 + v88;
      v92 = (v22 >> 9) + v90;
      HIDWORD(v22) = v89 + (v90 ^ v88 ^ v92) - 1530992060;
      LODWORD(v22) = v89 + (v90 ^ v88 ^ v92) - 1530992060;
      v93 = v18 + v90;
      v94 = (v22 >> 28) + v92;
      HIDWORD(v22) = v91 + (v92 ^ v90 ^ v94) + 1272893353;
      LODWORD(v22) = v91 + (v92 ^ v90 ^ v94) + 1272893353;
      v95 = v21 + v92;
      v96 = (v22 >> 21) + v94;
      HIDWORD(v22) = v93 + (v94 ^ v92 ^ v96) - 155497632;
      LODWORD(v22) = v93 + (v94 ^ v92 ^ v96) - 155497632;
      v97 = v25 + v94;
      v98 = (v22 >> 16) + v96;
      HIDWORD(v22) = v95 + (v96 ^ v94 ^ v98) - 1094730640;
      LODWORD(v22) = v95 + (v96 ^ v94 ^ v98) - 1094730640;
      v99 = v8 + v96;
      v100 = (v22 >> 9) + v98;
      HIDWORD(v22) = v97 + (v98 ^ v96 ^ v100) + 681279174;
      LODWORD(v22) = v97 + (v98 ^ v96 ^ v100) + 681279174;
      v101 = v9 + v98;
      v102 = (v22 >> 28) + v100;
      HIDWORD(v22) = v99 + (v100 ^ v98 ^ v102) - 358537222;
      LODWORD(v22) = v99 + (v100 ^ v98 ^ v102) - 358537222;
      v103 = v11 + v100;
      v104 = (v22 >> 21) + v102;
      HIDWORD(v22) = v101 + (v102 ^ v100 ^ v104) - 722521979;
      LODWORD(v22) = v101 + (v102 ^ v100 ^ v104) - 722521979;
      v105 = v14 + v102;
      v106 = (v22 >> 16) + v104;
      HIDWORD(v22) = v103 + (v104 ^ v102 ^ v106) + 76029189;
      LODWORD(v22) = v103 + (v104 ^ v102 ^ v106) + 76029189;
      v107 = v17 + v104;
      v108 = (v22 >> 9) + v106;
      HIDWORD(v22) = v105 + (v106 ^ v104 ^ v108) - 640364487;
      LODWORD(v22) = v105 + (v106 ^ v104 ^ v108) - 640364487;
      v109 = v20 + v106;
      v110 = (v22 >> 28) + v108;
      HIDWORD(v22) = v107 + (v108 ^ v106 ^ v110) - 421815835;
      LODWORD(v22) = v107 + (v108 ^ v106 ^ v110) - 421815835;
      v111 = (v22 >> 21) + v110;
      HIDWORD(v22) = v109 + (v110 ^ v108 ^ v111) + 530742520;
      LODWORD(v22) = v109 + (v110 ^ v108 ^ v111) + 530742520;
      v112 = v8 + v110;
      v113 = (v22 >> 16) + v111;
      HIDWORD(v22) = v10 + v108 + (v111 ^ v110 ^ v113) - 995338651;
      LODWORD(v22) = v10 + v108 + (v111 ^ v110 ^ v113) - 995338651;
      v114 = (v22 >> 9) + v113;
      v115 = v18 + v111;
      HIDWORD(v22) = v112 + ((v114 | ~v111) ^ v113) - 198630844;
      LODWORD(v22) = v112 + ((v114 | ~v111) ^ v113) - 198630844;
      v116 = (v22 >> 26) + v114;
      v117 = v23 + v113;
      HIDWORD(v22) = v115 + ((v116 | ~v113) ^ v114) + 1126891415;
      LODWORD(v22) = v115 + ((v116 | ~v113) ^ v114) + 1126891415;
      v118 = (v22 >> 22) + v116;
      v119 = v13 + v114;
      HIDWORD(v22) = v117 + ((v118 | ~v114) ^ v116) - 1416354905;
      LODWORD(v22) = v117 + ((v118 | ~v114) ^ v116) - 1416354905;
      v120 = (v22 >> 17) + v118;
      v121 = v17 + v116;
      HIDWORD(v22) = v119 + ((v120 | ~v116) ^ v118) - 57434055;
      LODWORD(v22) = v119 + ((v120 | ~v116) ^ v118) - 57434055;
      v122 = (v22 >> 11) + v120;
      v123 = v9 + v118;
      HIDWORD(v22) = v121 + ((v122 | ~v118) ^ v120) + 1700485571;
      LODWORD(v22) = v121 + ((v122 | ~v118) ^ v120) + 1700485571;
      v124 = (v22 >> 26) + v122;
      v125 = v21 + v120;
      HIDWORD(v22) = v123 + ((v124 | ~v120) ^ v122) - 1894986606;
      LODWORD(v22) = v123 + ((v124 | ~v120) ^ v122) - 1894986606;
      v126 = (v22 >> 22) + v124;
      v127 = v12 + v122;
      HIDWORD(v22) = v125 + ((v126 | ~v122) ^ v124) - 1051523;
      LODWORD(v22) = v125 + ((v126 | ~v122) ^ v124) - 1051523;
      v128 = (v22 >> 17) + v126;
      v129 = v16 + v124;
      HIDWORD(v22) = v127 + ((v128 | ~v124) ^ v126) - 2054922799;
      LODWORD(v22) = v127 + ((v128 | ~v124) ^ v126) - 2054922799;
      v130 = (v22 >> 11) + v128;
      v131 = v20 + v126;
      HIDWORD(v22) = v129 + ((v130 | ~v126) ^ v128) + 1873313359;
      LODWORD(v22) = v129 + ((v130 | ~v126) ^ v128) + 1873313359;
      v132 = (v22 >> 26) + v130;
      v133 = v11 + v128;
      HIDWORD(v22) = v131 + ((v132 | ~v128) ^ v130) - 30611744;
      LODWORD(v22) = v131 + ((v132 | ~v128) ^ v130) - 30611744;
      v134 = (v22 >> 22) + v132;
      v135 = v25 + v130;
      HIDWORD(v22) = v133 + ((v134 | ~v130) ^ v132) - 1560198380;
      LODWORD(v22) = v133 + ((v134 | ~v130) ^ v132) - 1560198380;
      v136 = (v22 >> 17) + v134;
      v137 = v15 + v132;
      HIDWORD(v22) = v135 + ((v136 | ~v132) ^ v134) + 1309151649;
      LODWORD(v22) = v135 + ((v136 | ~v132) ^ v134) + 1309151649;
      v138 = (v22 >> 11) + v136;
      v139 = v19 + v134;
      HIDWORD(v22) = v137 + ((v138 | ~v134) ^ v136) - 145523070;
      LODWORD(v22) = v137 + ((v138 | ~v134) ^ v136) - 145523070;
      v140 = (v22 >> 26) + v138;
      v141 = v10 + v136;
      HIDWORD(v22) = v139 + ((v140 | ~v136) ^ v138) - 1120210379;
      LODWORD(v22) = v139 + ((v140 | ~v136) ^ v138) - 1120210379;
      v142 = (v22 >> 22) + v140;
      v143 = v14 + v138;
      v144 = v141 + ((v142 | ~v138) ^ v140);
      HIDWORD(v22) = v144 + 718787259;
      LODWORD(v22) = v144 + 718787259;
      v145 = (v22 >> 17) + v142;
      v5 = v140 + *result;
      v146 = v145 | ~v140;
      v3 = v145 + result[2];
      HIDWORD(v22) = v143 + (v146 ^ v142) - 343485551;
      LODWORD(v22) = v143 + (v146 ^ v142) - 343485551;
      v4 = v142 + result[3];
      v6 = v145 + result[1] + (v22 >> 11);
      --a3;
      a2 += 64;
      *result = v5;
      result[1] = v6;
      result[2] = v3;
      result[3] = v4;
    }
    while ( a3 );
  }
  return result;
}

//----- (000000000004BAE4) ----------------------------------------------------
int *__fastcall MD5_Transform(int *a1, unsigned __int8 *a2)
{
  return sub_4AF40(a1, a2, 1LL);
}

//----- (000000000004BAEC) ----------------------------------------------------
void *__fastcall sub_4BAEC(void *a1, size_t a2, size_t a3)
{
  size_t v3; // x21
  void *v4; // x20
  void *v5; // x19
  void *v6; // x0

  v3 = a2;
  v4 = a1;
  if ( !a1 )
    return malloc(a3);
  v5 = 0LL;
  if ( a3 )
  {
    if ( a3 >= a2 )
    {
      v6 = malloc(a3);
      v5 = v6;
      if ( v6 )
      {
        if ( v3 )
        {
          memcpy(v6, v4, v3);
          memset(v4, 0, v3);
        }
        free(v4);
      }
    }
  }
  return v5;
}

//----- (000000000004BB7C) ----------------------------------------------------
void *__fastcall OPENSSL_cleanse(void *result, size_t a2)
{
  if ( a2 )
    result = memset(result, 0, a2);
  return result;
}

//----- (000000000004BBB0) ----------------------------------------------------
__int64 __fastcall CRYPTO_memcmp(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // w8
  unsigned __int64 v4; // x9
  int v5; // w10
  unsigned __int8 *v6; // x11
  unsigned __int8 *v7; // x12
  unsigned __int64 v8; // x13
  int v9; // w14
  int v10; // w15
  int v11; // t1
  int v12; // w16
  int v13; // t1
  unsigned __int8 *v14; // x10
  unsigned __int8 *v15; // x11
  unsigned __int64 v16; // x9
  int v17; // w12
  int v18; // t1
  int v19; // t1

  v3 = 0;
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v4 = 0LL;
LABEL_8:
      v14 = (unsigned __int8 *)(a1 + v4);
      v15 = (unsigned __int8 *)(a2 + v4);
      v16 = a3 - v4;
      do
      {
        v18 = *v14++;
        v17 = v18;
        v19 = *v15++;
        --v16;
        v3 |= (v19 ^ v17) & 0xFF;
      }
      while ( v16 );
      return v3;
    }
    v3 = 0;
    v4 = a3 & 0xFFFFFFFFFFFFFFFELL;
    if ( !(a3 & 0xFFFFFFFFFFFFFFFELL) )
      goto LABEL_8;
    v5 = 0;
    v6 = (unsigned __int8 *)(a1 + 1);
    v7 = (unsigned __int8 *)(a2 + 1);
    v8 = a3 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v9 = *(v6 - 1);
      v11 = *v6;
      v6 += 2;
      v10 = v11;
      v12 = *(v7 - 1);
      v13 = *v7;
      v7 += 2;
      v8 -= 2LL;
      v3 |= (v12 ^ v9) & 0xFF;
      v5 |= (v13 ^ v10) & 0xFF;
    }
    while ( v8 );
    v3 |= v5;
    if ( v4 != a3 )
      goto LABEL_8;
  }
  return v3;
}

//----- (000000000004BC50) ----------------------------------------------------
signed __int64 __fastcall OPENSSL_hash32(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 *v2; // x8
  signed __int64 result; // x0
  int v4; // t1

  v2 = a1;
  for ( result = 2166136261LL; a2; result = 16777619 * (v4 ^ (unsigned int)result) )
  {
    v4 = *v2++;
    --a2;
  }
  return result;
}

//----- (000000000004BC80) ----------------------------------------------------
unsigned __int64 __fastcall OPENSSL_strnlen(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 result; // x0

  v2 = a1;
  result = 0LL;
  if ( a2 )
  {
    while ( *(_BYTE *)(v2 + result) )
    {
      if ( ++result >= a2 )
        return a2;
    }
  }
  return result;
}

//----- (000000000004BCB4) ----------------------------------------------------
__int64 __fastcall BIO_snprintf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  unsigned __int64 v9; // x19
  __int64 result; // x0
  __int64 v11; // [xsp+80h] [xbp-90h]
  __int64 v12; // [xsp+88h] [xbp-88h]
  __int64 v13; // [xsp+90h] [xbp-80h]
  __int64 v14; // [xsp+98h] [xbp-78h]
  __int64 v15; // [xsp+A0h] [xbp-70h]
  __int64 v16; // [xsp+A8h] [xbp-68h]
  __int128 v17; // [xsp+B0h] [xbp-60h]
  __int64 *v18; // [xsp+C0h] [xbp-50h]
  int v19; // [xsp+C8h] [xbp-48h]
  int v20; // [xsp+CCh] [xbp-44h]
  __int128 v21; // [xsp+D0h] [xbp-40h]
  __int128 v22; // [xsp+E0h] [xbp-30h]
  __int64 v23; // [xsp+F8h] [xbp-18h]

  v15 = a7;
  v16 = a8;
  v13 = a5;
  v14 = a6;
  v12 = a4;
  v9 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v23 = *(_QWORD *)(v9 + 40);
  v19 = -40;
  v20 = -128;
  *((_QWORD *)&v17 + 1) = &v17;
  v18 = &v11;
  *(_QWORD *)&v17 = &a9;
  v21 = v17;
  v22 = *(_OWORD *)&v18;
  result = __vsnprintf_chk();
  *(_QWORD *)(v9 + 40);
  return result;
}

//----- (000000000004BD58) ----------------------------------------------------
__int64 __fastcall BIO_vsnprintf(__int64 a1, __int64 a2, __int64 a3, __int128 *a4)
{
  unsigned __int64 v4; // x19
  __int64 v5; // ST28_8
  __int128 v6; // ST10_16
  __int128 v7; // ST00_16
  __int64 result; // x0

  v4 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v5 = *(_QWORD *)(v4 + 40);
  v6 = a4[1];
  v7 = *a4;
  result = __vsnprintf_chk();
  *(_QWORD *)(v4 + 40);
  return result;
}

//----- (000000000004BDC0) ----------------------------------------------------
long double __fastcall sub_4BDC0(_QWORD *a1, long double *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, void (__fastcall *a6)(long double *, long double *, __int64))
{
  unsigned __int64 v6; // x23
  void (__fastcall *v7)(long double *, long double *, __int64); // x20
  __int64 v8; // x21
  signed __int64 v9; // x22
  _QWORD *v10; // x24
  signed __int64 v11; // x19
  unsigned __int64 v12; // x28
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x27
  unsigned __int64 v15; // x26
  long double *v16; // x8
  long double *v17; // x25
  __int64 v18; // x25
  signed __int64 v19; // x28
  signed __int64 v20; // x9
  long double *v21; // x24
  unsigned __int64 v22; // x8
  signed __int64 v23; // x14
  _OWORD *v24; // x15
  signed __int64 v25; // x11
  unsigned __int64 v26; // x12
  char v27; // w16
  char v28; // w17
  __int128 *v29; // x9
  _OWORD *v30; // x10
  signed __int64 v31; // x14
  unsigned __int64 v32; // x11
  __int128 v33; // q0
  __int128 v34; // q1
  long double result; // q0
  unsigned __int64 v36; // [xsp+0h] [xbp-60h]
  _OWORD *v37; // [xsp+8h] [xbp-58h]

  v6 = a3;
  v7 = a6;
  v8 = a4;
  v9 = (signed __int64)a2;
  v10 = a1;
  v11 = a3 - 16;
  v37 = a5;
  if ( a3 < 0x10 )
  {
    v15 = (unsigned __int64)a1;
    v14 = (unsigned __int64)a5;
    if ( !a3 )
    {
LABEL_23:
      v21 = (long double *)v14;
      goto LABEL_24;
    }
  }
  else
  {
    v12 = v11 & 0xFFFFFFFFFFFFFFF0LL;
    v13 = (v11 & 0xFFFFFFFFFFFFFFF0LL) + 16;
    v14 = (unsigned __int64)a2 + (v11 & 0xFFFFFFFFFFFFFFF0LL);
    v36 = v13;
    v15 = (unsigned __int64)a1 + v13;
    v16 = a5;
    v17 = (long double *)a2;
    do
    {
      *(_QWORD *)v17 = *v16 ^ *v10;
      *((_QWORD *)v17 + 1) = v16[1] ^ v10[1];
      v7(v17, v17, v8);
      v6 -= 16LL;
      v16 = v17;
      ++v17;
      v10 += 2;
    }
    while ( v6 > 0xF );
    v6 = v11 - v12;
    v9 += v36;
    if ( v11 == v12 )
      goto LABEL_23;
  }
  v18 = 0LL;
  v19 = v9 + 17;
  v20 = v9;
  do
  {
    v21 = (long double *)v20;
    v22 = 0LL;
    v23 = v14 + 17;
    v24 = (_OWORD *)v19;
    v25 = 16LL;
    do
    {
      v26 = v22;
      v27 = *(_BYTE *)(v15 + v22);
      v28 = *(_BYTE *)(v14 + v22);
      v29 = (__int128 *)v23;
      v30 = v24;
      ++v22;
      --v25;
      *((_BYTE *)v21 + v26) = v28 ^ v27;
      if ( v22 > 0xF )
        break;
      ++v23;
      v24 = (_OWORD *)((char *)v24 + 1);
    }
    while ( v22 < v6 );
    if ( v22 <= 0xF )
    {
      v31 = 16 - v22;
      if ( 16 - v22 <= 0x1F
        || !(v31 & 0xFFFFFFFFFFFFFFE0LL)
        || (unsigned __int64)v21 + v22 < v14 + 16 && v14 + v22 < v9 + 16 * v18 + 16 )
      {
        goto LABEL_27;
      }
      v22 += v25 & 0xFFFFFFFFFFFFFFE0LL;
      v32 = (15 - v26) & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v33 = *(v29 - 1);
        v34 = *v29;
        v29 += 2;
        v32 -= 32LL;
        *(v30 - 1) = v33;
        *v30 = v34;
        v30 += 2;
      }
      while ( v32 );
      if ( v31 != (v31 & 0xFFFFFFFFFFFFFFE0LL) )
      {
LABEL_27:
        do
        {
          *((_BYTE *)v21 + v22) = *(_BYTE *)(v14 + v22);
          ++v22;
        }
        while ( v22 != 16 );
      }
    }
    v7(v21, v21, v8);
    if ( v6 < 0x11 )
      break;
    v6 -= 16LL;
    v15 += 16LL;
    v20 = (signed __int64)(v21 + 1);
    ++v18;
    v19 += 16LL;
    v14 = (unsigned __int64)v21;
  }
  while ( v6 );
LABEL_24:
  result = *v21;
  *v37 = *(_OWORD *)v21;
  return result;
}
// 4BDC0: too many cbuild loops

//----- (000000000004BFD4) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BFD4(unsigned __int64 result, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, __int64 (__fastcall *a6)(_QWORD *, __int64 *, __int64))
{
  _QWORD *v6; // x24
  __int64 (__fastcall *v7)(_QWORD *, __int64 *, __int64); // x26
  unsigned __int64 v8; // x19
  __int64 v9; // x27
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x28
  signed __int64 v12; // x21
  __int64 *v13; // x25
  _QWORD *v14; // x28
  _QWORD *v15; // x26
  __int64 v16; // x10
  __int64 v17; // x8
  _OWORD *v18; // x8
  signed __int64 v19; // x20
  unsigned __int64 v20; // x23
  unsigned __int64 v21; // x21
  _QWORD *v22; // x25
  __int64 v23; // x10
  __int64 v24; // x10
  unsigned __int64 v25; // x24
  unsigned __int64 v26; // x28
  signed __int64 v27; // x9
  unsigned __int64 v28; // x26
  unsigned __int64 v29; // x23
  unsigned __int64 v30; // x8
  unsigned __int64 v31; // x12
  unsigned __int64 v32; // x15
  __int64 v33; // x9
  __int128 v34; // q2
  signed __int64 v35; // x21
  signed __int64 v36; // x8
  signed __int64 v37; // x20
  signed __int64 v38; // x25
  char v39; // w11
  bool v40; // cf
  signed __int64 v41; // x10
  unsigned __int64 v42; // x9
  unsigned __int64 v43; // x11
  unsigned __int64 v44; // x12
  __int128 v45; // q0
  __int128 v46; // q1
  _OWORD *v47; // x13
  unsigned __int64 v48; // [xsp+8h] [xbp-98h]
  unsigned __int64 v49; // [xsp+10h] [xbp-90h]
  unsigned __int64 v50; // [xsp+10h] [xbp-90h]
  __int64 v51; // [xsp+18h] [xbp-88h]
  __int64 (__fastcall *v52)(_QWORD *, __int64 *, __int64); // [xsp+20h] [xbp-80h]
  unsigned __int64 v53; // [xsp+28h] [xbp-78h]
  signed __int64 v54; // [xsp+28h] [xbp-78h]
  unsigned __int64 v55; // [xsp+30h] [xbp-70h]
  signed __int64 v56; // [xsp+30h] [xbp-70h]
  __int64 v57; // [xsp+38h] [xbp-68h]
  __int64 v58; // [xsp+40h] [xbp-60h]
  __int64 v59; // [xsp+48h] [xbp-58h]

  v6 = (_QWORD *)result;
  v7 = a6;
  v8 = (unsigned __int64)a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  v59 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v51 = a4;
  v52 = a6;
  if ( result < 0x20 )
  {
    if ( result < a2 )
    {
LABEL_6:
      v12 = a3 - 16;
      if ( a3 < 0x10 )
      {
        v18 = a5;
        v48 = result;
      }
      else
      {
        v55 = result + (v12 & 0xFFFFFFFFFFFFFFF0LL);
        v53 = (v12 & 0xFFFFFFFFFFFFFFF0LL) + 16;
        v48 = result + v53;
        v49 = a2;
        v13 = (__int64 *)a2;
        v14 = a5;
        do
        {
          v15 = v6;
          result = v52(v6, v13, v51);
          v16 = v13[1];
          v10 -= 16LL;
          v6 += 2;
          *v13 ^= *v14;
          v17 = v14[1];
          v14 = v15;
          v13[1] = v16 ^ v17;
          v13 += 2;
        }
        while ( v10 > 0xF );
        v10 = v12 - (v12 & 0xFFFFFFFFFFFFFFF0LL);
        v11 = v49 + v53;
        v18 = (_OWORD *)v55;
      }
      v50 = v11;
      *(_OWORD *)v8 = *v18;
      if ( !v10 )
        goto LABEL_55;
      goto LABEL_19;
    }
  }
  else if ( result < a2 || a2 <= result - 32 )
  {
    goto LABEL_6;
  }
  v19 = a3 - 16;
  if ( a3 < 0x10 )
  {
    v48 = result;
    v50 = a2;
    if ( !a3 )
      goto LABEL_55;
  }
  else
  {
    v20 = v19 & 0xFFFFFFFFFFFFFFF0LL;
    v21 = (v19 & 0xFFFFFFFFFFFFFFF0LL) + 16;
    v22 = (_QWORD *)a2;
    v48 = result + v21;
    do
    {
      result = v7(v6, &v57, v9);
      v23 = *v6;
      v10 -= 16LL;
      *v22 = *(_QWORD *)v8 ^ v57;
      *(_QWORD *)v8 = v23;
      v24 = v6[1];
      v6 += 2;
      v22[1] = *(_QWORD *)(v8 + 8) ^ v58;
      v22 += 2;
      *(_QWORD *)(v8 + 8) = v24;
    }
    while ( v10 > 0xF );
    v10 = v19 - v20;
    v50 = v11 + v21;
    if ( v19 == v20 )
      goto LABEL_55;
  }
LABEL_19:
  v25 = v48;
  v26 = v50;
  v27 = 0LL;
  v28 = -(signed __int64)v10;
  v29 = v10;
  while ( 1 )
  {
    v35 = 16 * v27;
    if ( v28 <= 0xFFFFFFFFFFFFFFF0LL )
      v36 = -16LL;
    else
      v36 = v28;
    v54 = v36;
    v56 = v27;
    if ( v35 - v10 <= 0xFFFFFFFFFFFFFFF0LL )
      v37 = -16LL;
    else
      v37 = v35 - v10;
    v38 = -v37;
    result = v52((_QWORD *)v25, &v57, v51);
    v30 = 0LL;
    if ( (unsigned __int64)-v37 >= 0x10 )
    {
      if ( v38 & 0x10 )
      {
        v30 = 0LL;
        v31 = v50 + v35 - v37;
        v32 = v48 + v35 - v37;
        if ( (v50 + v35 >= v8 - v37 || v31 <= v8)
          && (v50 + v35 >= v32 || v48 + v35 >= v31)
          && (v50 + v35 >= (unsigned __int64)&v57 - v37 || (unsigned __int64)&v57 >= v31)
          && (v32 <= v8 || v48 + v35 >= v8 - v37)
          && ((unsigned __int64)&v57 - v37 <= v8 || (unsigned __int64)&v57 >= v8 - v37) )
        {
          v33 = 0LL;
          v30 = v38 & 0x10;
          do
          {
            v34 = *(_OWORD *)(v25 + v33);
            *(int8x16_t *)(v26 + v33) = veorq_s8(*(int8x16_t *)(v8 + v33), *(int8x16_t *)((char *)&v57 + v33));
            *(_OWORD *)(v8 + v33) = v34;
            v33 += 16LL;
          }
          while ( (-v54 & 0xFFFFFFFFFFFFFFF0LL) != v33 );
          if ( v30 == v38 )
            goto LABEL_42;
        }
      }
      else
      {
        v30 = 0LL;
      }
    }
    do
    {
      v39 = *(_BYTE *)(v25 + v30);
      *(_BYTE *)(v26 + v30) = *(_BYTE *)(v8 + v30) ^ *((_BYTE *)&v57 + v30);
      *(_BYTE *)(v8 + v30++) = v39;
    }
    while ( v30 <= 0xF && v30 < v29 );
LABEL_42:
    v40 = v29 >= 0x10;
    v29 -= 16LL;
    if ( v29 == 0 || !v40 )
      break;
    v25 += 16LL;
    v26 += 16LL;
    v28 += 16LL;
    v27 = v56 + 1;
    if ( !v29 )
      goto LABEL_55;
  }
  if ( v30 <= 0xF )
  {
    v41 = 16 - v30;
    if ( 16 - v30 < 0x20 )
    {
      v42 = v30;
      goto LABEL_54;
    }
    v43 = v41 & 0xFFFFFFFFFFFFFFE0LL;
    if ( !(v41 & 0xFFFFFFFFFFFFFFE0LL) )
    {
      v42 = v30;
      goto LABEL_54;
    }
    if ( v8 + v30 < v25 + 16 && v25 + v30 < v8 + 16 )
    {
      v42 = v30;
      goto LABEL_54;
    }
    v42 = v30 + v43;
    v44 = v41 & 0xFFFFFFFFFFFFFFE0LL;
    do
    {
      v45 = *(_OWORD *)(v25 + v30);
      v46 = *(_OWORD *)(v25 + v30 + 16);
      v47 = (_OWORD *)(v8 + v30);
      v30 += 32LL;
      v44 -= 32LL;
      *v47 = v45;
      v47[1] = v46;
    }
    while ( v44 );
    if ( v41 != v43 )
    {
      do
      {
LABEL_54:
        *(_BYTE *)(v8 + v42) = *(_BYTE *)(v25 + v42);
        ++v42;
      }
      while ( v42 != 16 );
    }
  }
LABEL_55:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000004C3D8) ----------------------------------------------------
char *__fastcall sub_4C3D8(char *result, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, _BYTE *a5, _QWORD *a6, unsigned int *a7, void (__fastcall *a8)(_BYTE *, _QWORD *, __int64))
{
  unsigned int v8; // w27
  void (__fastcall *v9)(_BYTE *, _QWORD *, __int64); // x24
  _QWORD *v10; // x20
  _BYTE *v11; // x23
  __int64 v12; // x25
  unsigned __int64 v13; // x21
  unsigned __int64 v14; // x26
  char *i; // x22
  char v16; // t1
  char v17; // w9
  signed __int64 v18; // x19
  unsigned __int64 v19; // x28
  char *v20; // x27
  __int64 v21; // x8
  int v22; // w8
  __int64 v23; // x9
  char v24; // w10
  char v25; // w11
  unsigned __int64 v26; // [xsp+8h] [xbp-68h]
  unsigned int *v27; // [xsp+18h] [xbp-58h]

  v27 = a7;
  v8 = *a7;
  v9 = a8;
  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  for ( i = result; v13 && v8; ++v14 )
  {
    v16 = *i++;
    v17 = *((_BYTE *)a6 + v8);
    --v13;
    v8 = (v8 + 1) & 0xF;
    *(_BYTE *)v14 = v17 ^ v16;
  }
  v18 = v13 - 16;
  if ( v13 < 0x10 )
  {
    v19 = v14;
    if ( !v13 )
      goto LABEL_14;
    goto LABEL_11;
  }
  v26 = v18 & 0xFFFFFFFFFFFFFFF0LL;
  v19 = v14 + (v18 & 0xFFFFFFFFFFFFFFF0LL) + 16;
  v20 = i;
  do
  {
    v9(v11, v10, v12);
    result = sub_4C544(v11);
    v13 -= 16LL;
    *(_QWORD *)v14 = *v10 ^ *(_QWORD *)v20;
    v21 = *((_QWORD *)v20 + 1);
    v20 += 16;
    *(_QWORD *)(v14 + 8) = v10[1] ^ v21;
    v14 += 16LL;
  }
  while ( v13 > 0xF );
  v8 = 0;
  v13 = v18 - v26;
  i += (v18 & 0xFFFFFFFFFFFFFFF0LL) + 16;
  if ( v18 != v26 )
  {
LABEL_11:
    v9(v11, v10, v12);
    result = sub_4C544(v11);
    v22 = v8 + v13 - 1;
    do
    {
      v23 = v8;
      v24 = i[v8];
      v25 = *((_BYTE *)v10 + v8);
      --v13;
      ++v8;
      *(_BYTE *)(v19 + v23) = v25 ^ v24;
    }
    while ( v13 );
    v8 = v22 + 1;
  }
LABEL_14:
  *v27 = v8;
  return result;
}

//----- (000000000004C544) ----------------------------------------------------
_BYTE *__fastcall sub_4C544(_BYTE *result)
{
  int v1; // w9
  int v2; // w10
  unsigned int v3; // w8
  unsigned int v4; // w8
  int v5; // w9
  unsigned int v6; // w8
  int v7; // w10
  unsigned int v8; // w8
  int v9; // w9
  unsigned int v10; // w8
  int v11; // w10
  unsigned int v12; // w8
  int v13; // w9
  unsigned int v14; // w8
  int v15; // w10
  unsigned int v16; // w8
  int v17; // w9
  unsigned int v18; // w8
  int v19; // w10
  unsigned int v20; // w8
  int v21; // w9
  unsigned int v22; // w8
  int v23; // w10
  unsigned int v24; // w8
  int v25; // w9
  unsigned int v26; // w8
  int v27; // w10
  unsigned int v28; // w8
  int v29; // w8

  v1 = (unsigned __int8)result[14];
  v2 = (unsigned __int8)result[13];
  v3 = (unsigned __int8)result[15] + 1;
  result[15] = v3;
  v4 = v1 + (v3 >> 8);
  v5 = (unsigned __int8)result[12];
  result[14] = v4;
  v6 = v2 + (v4 >> 8);
  v7 = (unsigned __int8)result[11];
  result[13] = v6;
  v8 = v5 + (v6 >> 8);
  v9 = (unsigned __int8)result[10];
  result[12] = v8;
  v10 = v7 + (v8 >> 8);
  v11 = (unsigned __int8)result[9];
  result[11] = v10;
  v12 = v9 + (v10 >> 8);
  v13 = (unsigned __int8)result[8];
  result[10] = v12;
  v14 = v11 + (v12 >> 8);
  v15 = (unsigned __int8)result[7];
  result[9] = v14;
  v16 = v13 + (v14 >> 8);
  v17 = (unsigned __int8)result[6];
  result[8] = v16;
  v18 = v15 + (v16 >> 8);
  v19 = (unsigned __int8)result[5];
  result[7] = v18;
  v20 = v17 + (v18 >> 8);
  v21 = (unsigned __int8)result[4];
  result[6] = v20;
  v22 = v19 + (v20 >> 8);
  v23 = (unsigned __int8)result[3];
  result[5] = v22;
  v24 = v21 + (v22 >> 8);
  v25 = (unsigned __int8)result[2];
  result[4] = v24;
  v26 = v23 + (v24 >> 8);
  v27 = (unsigned __int8)result[1];
  result[3] = v26;
  v28 = v25 + (v26 >> 8);
  LOBYTE(v25) = *result;
  result[2] = v28;
  v29 = v27 + (v28 >> 8);
  result[1] = v29;
  *result = v25 + BYTE1(v29);
  return result;
}

//----- (000000000004C608) ----------------------------------------------------
__int64 __fastcall sub_4C608(__int64 result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, char *a6, unsigned int *a7, __int64 (__fastcall *a8)(char *, char *, unsigned __int64, __int64, _BYTE *))
{
  char *v8; // x20
  _BYTE *v9; // x24
  unsigned __int64 v10; // x21
  __int64 v11; // ST28_8
  unsigned int v12; // w28
  char *v13; // x22
  char *v14; // x23
  char v15; // t1
  char v16; // w9
  _DWORD *v17; // x19
  unsigned int v18; // w25
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // x9
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x27
  int v23; // w9
  int v24; // w10
  unsigned int v25; // w8
  unsigned int v26; // w8
  int v27; // w9
  unsigned int v28; // w8
  int v29; // w10
  unsigned int v30; // w8
  int v31; // w9
  unsigned int v32; // w8
  int v33; // w10
  unsigned int v34; // w8
  int v35; // w9
  unsigned int v36; // w8
  int v37; // w10
  unsigned int v38; // w8
  int v39; // w9
  unsigned int v40; // w8
  int v41; // w10
  unsigned int v42; // w8
  int v43; // w8
  int v44; // w9
  int v45; // w10
  unsigned int v46; // w8
  unsigned int v47; // w8
  int v48; // w9
  unsigned int v49; // w8
  int v50; // w10
  unsigned int v51; // w8
  int v52; // w9
  unsigned int v53; // w8
  int v54; // w10
  unsigned int v55; // w8
  int v56; // w9
  unsigned int v57; // w8
  int v58; // w10
  unsigned int v59; // w8
  int v60; // w9
  unsigned int v61; // w8
  int v62; // w10
  unsigned int v63; // w8
  int v64; // w8
  int v65; // w8
  __int64 v66; // x9
  char v67; // w10
  char v68; // w11
  unsigned int *v69; // [xsp+8h] [xbp-78h]
  __int64 v70; // [xsp+10h] [xbp-70h]
  __int64 (__fastcall *v71)(char *, char *, unsigned __int64, __int64, _BYTE *); // [xsp+18h] [xbp-68h]

  v70 = a4;
  v71 = a8;
  v8 = a6;
  v9 = (_BYTE *)a5;
  v10 = a3;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v69 = a7;
  v12 = *a7;
  v13 = a2;
  v14 = (char *)result;
  if ( a3 && v12 )
  {
    do
    {
      v15 = *v14++;
      v16 = a6[v12];
      --v10;
      v12 = (v12 + 1) & 0xF;
      *v13++ = v16 ^ v15;
    }
    while ( v10 && v12 );
  }
  v17 = (_DWORD *)(a5 + 12);
  v18 = bswap32(*(_DWORD *)(a5 + 12));
  if ( v10 >= 0x10 )
  {
    do
    {
      v19 = v10 >> 4;
      if ( v10 >> 4 <= 0x10000000 )
        v20 = v10 >> 4;
      else
        v20 = 0x10000000LL;
      if ( v10 >> 4 > 0x10000000 )
        LODWORD(v19) = 0x10000000;
      v21 = (unsigned int)v19 + v18;
      if ( v20 <= v21 )
        v18 = v21;
      else
        v18 = 0;
      if ( v20 <= v21 )
        v21 = 0LL;
      v22 = v20 - v21;
      result = v71(v14, v13, v20 - v21, v70, v9);
      *v17 = bswap32(v18);
      if ( !v18 )
      {
        v23 = (unsigned __int8)v9[10];
        v24 = (unsigned __int8)v9[9];
        v25 = (unsigned __int8)v9[11] + 1;
        v9[11] = v25;
        v26 = v23 + (v25 >> 8);
        v27 = (unsigned __int8)v9[8];
        v9[10] = v26;
        v28 = v24 + (v26 >> 8);
        v29 = (unsigned __int8)v9[7];
        v9[9] = v28;
        v30 = v27 + (v28 >> 8);
        v31 = (unsigned __int8)v9[6];
        v9[8] = v30;
        v32 = v29 + (v30 >> 8);
        v33 = (unsigned __int8)v9[5];
        v9[7] = v32;
        v34 = v31 + (v32 >> 8);
        v35 = (unsigned __int8)v9[4];
        v9[6] = v34;
        v36 = v33 + (v34 >> 8);
        v37 = (unsigned __int8)v9[3];
        v9[5] = v36;
        v38 = v35 + (v36 >> 8);
        v39 = (unsigned __int8)v9[2];
        v9[4] = v38;
        v40 = v37 + (v38 >> 8);
        v41 = (unsigned __int8)v9[1];
        v9[3] = v40;
        v42 = v39 + (v40 >> 8);
        LOBYTE(v39) = *v9;
        v9[2] = v42;
        v43 = v41 + (v42 >> 8);
        v9[1] = v43;
        *v9 = v39 + BYTE1(v43);
      }
      v10 -= 16 * v22;
      v13 += 16 * v22;
      v14 += 16 * v22;
    }
    while ( v10 > 0xF );
  }
  if ( v10 )
  {
    *(_QWORD *)v8 = 0LL;
    *((_QWORD *)v8 + 1) = 0LL;
    result = v71(v8, v8, 1uLL, v70, v9);
    *v17 = bswap32(v18 + 1);
    if ( v18 == -1 )
    {
      v44 = (unsigned __int8)v9[10];
      v45 = (unsigned __int8)v9[9];
      v46 = (unsigned __int8)v9[11] + 1;
      v9[11] = v46;
      v47 = v44 + (v46 >> 8);
      v48 = (unsigned __int8)v9[8];
      v9[10] = v47;
      v49 = v45 + (v47 >> 8);
      v50 = (unsigned __int8)v9[7];
      v9[9] = v49;
      v51 = v48 + (v49 >> 8);
      v52 = (unsigned __int8)v9[6];
      v9[8] = v51;
      v53 = v50 + (v51 >> 8);
      v54 = (unsigned __int8)v9[5];
      v9[7] = v53;
      v55 = v52 + (v53 >> 8);
      v56 = (unsigned __int8)v9[4];
      v9[6] = v55;
      v57 = v54 + (v55 >> 8);
      v58 = (unsigned __int8)v9[3];
      v9[5] = v57;
      v59 = v56 + (v57 >> 8);
      v60 = (unsigned __int8)v9[2];
      v9[4] = v59;
      v61 = v58 + (v59 >> 8);
      v62 = (unsigned __int8)v9[1];
      v9[3] = v61;
      v63 = v60 + (v61 >> 8);
      LOBYTE(v60) = *v9;
      v9[2] = v63;
      v64 = v62 + (v63 >> 8);
      v9[1] = v64;
      *v9 = v60 + BYTE1(v64);
    }
    v65 = v12 + v10 - 1;
    do
    {
      v66 = v12;
      v67 = v14[v12];
      v68 = v8[v12];
      --v10;
      ++v12;
      v13[v66] = v68 ^ v67;
    }
    while ( v10 );
    v12 = v65 + 1;
  }
  *v69 = v12;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 4C608: too many cbuild loops

//----- (000000000004C8BC) ----------------------------------------------------
void __fastcall sub_4C8BC(_QWORD *a1, int8x16_t (__fastcall **a2)(int8x16_t *a1, uint64x2_t *a2, int8x16_t *a3, unsigned __int64 a4), __int128 *a3, __int64 a4, __int128 *a5)
{
  __int64 v5; // x21
  int8x16_t (__fastcall **v6)(int8x16_t *, uint64x2_t *, int8x16_t *, unsigned __int64); // x19
  _QWORD *v7; // x20
  int8x16_t (__fastcall *v8)(int8x16_t *, uint64x2_t *, int8x16_t *, unsigned __int64); // x11
  void *v9; // x8
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x13
  __int128 v13; // t2
  unsigned __int64 v14; // x12
  __int64 v15; // x16
  unsigned __int64 v16; // x15
  __int64 v17; // x18
  __int64 v18; // x17
  unsigned __int64 v19; // x10
  __int64 v20; // x0
  __int64 v21; // x1
  __int64 v22; // x16
  unsigned __int64 v23; // x2
  unsigned __int64 v24; // x4
  unsigned __int64 v25; // x15
  __int64 v26; // x18
  __int64 v27; // x3
  unsigned __int64 v28; // x17
  __int64 v29; // x13
  unsigned __int64 v30; // x12
  unsigned __int64 v31; // x2
  unsigned __int64 v32; // x10
  unsigned __int64 v33; // x15
  __int128 v34; // [xsp+0h] [xbp-40h]
  __int64 v35; // [xsp+18h] [xbp-28h]

  v5 = a4;
  v6 = a2;
  v7 = a1;
  v35 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v34 = *a5;
  *(_QWORD *)&v34 = bswap32(v34);
  *((_QWORD *)&v34 + 1) = bswap32(*((unsigned __int64 *)&v34 + 1));
  *a3 = v34;
  if ( (unsigned int)sub_46340() )
  {
    sub_50590((int8x16_t *)v5, (int8x16_t *)&v34);
    v8 = sub_506A0;
    v9 = sub_50630;
  }
  else
  {
    *(_QWORD *)v5 = 0LL;
    *(_QWORD *)(v5 + 8) = 0LL;
    v11 = *((_QWORD *)&v34 + 1);
    v10 = v34;
    v8 = (int8x16_t (__fastcall *)(int8x16_t *, uint64x2_t *, int8x16_t *, unsigned __int64))sub_4CAEC;
    *(_QWORD *)&v13 = *((_QWORD *)&v34 + 1);
    *((_QWORD *)&v13 + 1) = v34;
    v12 = v13 >> 1;
    v14 = -(signed __int64)(BYTE8(v34) & 1) & 0xE100000000000000LL ^ ((unsigned __int64)v34 >> 1);
    *((_QWORD *)&v13 + 1) = (unsigned __int64)v34 >> 1;
    *(_QWORD *)&v13 = v12;
    v15 = v13 >> 1;
    v16 = (v14 >> 1) ^ -((*((_QWORD *)&v34 + 1) >> 1) & 1LL) & 0xE100000000000000LL;
    v17 = v12 ^ *((_QWORD *)&v34 + 1);
    *((_QWORD *)&v13 + 1) = v14 >> 1;
    *(_QWORD *)&v13 = v15;
    v18 = v13 >> 1;
    v19 = -(signed __int64)((v12 >> 1) & 1) & 0xE100000000000000LL ^ (v16 >> 1);
    v20 = v15 ^ v12;
    v21 = v15 ^ *((_QWORD *)&v34 + 1);
    *(_QWORD *)(v5 + 192) = v14 ^ v34;
    *(_QWORD *)(v5 + 200) = v17;
    *(_QWORD *)(v5 + 32) = v16;
    *(_QWORD *)(v5 + 40) = v15;
    v22 = v18 ^ v15;
    v23 = v16 ^ v14;
    v24 = v16 ^ v10;
    v25 = v19 ^ v16;
    *(_QWORD *)(v5 + 64) = v14;
    *(_QWORD *)(v5 + 72) = v12;
    v26 = v18 ^ v12;
    v27 = v18 ^ v11;
    *(_QWORD *)(v5 + 16) = v19;
    *(_QWORD *)(v5 + 24) = v18;
    v28 = v19 ^ v14;
    v29 = v22 ^ v12;
    v30 = v25 ^ v14;
    *(_OWORD *)(v5 + 128) = __PAIR__(v11, v10);
    *(_QWORD *)(v5 + 96) = v23;
    *(_QWORD *)(v5 + 104) = v20;
    *(_QWORD *)(v5 + 160) = v24;
    *(_QWORD *)(v5 + 168) = v21;
    v31 = v23 ^ v10;
    *(_QWORD *)(v5 + 48) = v25;
    *(_QWORD *)(v5 + 56) = v22;
    *(_QWORD *)(v5 + 144) = v19 ^ v10;
    *(_QWORD *)(v5 + 152) = v27;
    v32 = v25 ^ v10;
    v33 = v28 ^ v10;
    *(_QWORD *)(v5 + 240) = v30 ^ v10;
    *(_QWORD *)(v5 + 248) = v29 ^ v11;
    v9 = sub_4CA60;
    *(_QWORD *)(v5 + 80) = v28;
    *(_QWORD *)(v5 + 88) = v26;
    *(_QWORD *)(v5 + 224) = v31;
    *(_QWORD *)(v5 + 232) = v20 ^ v11;
    *(_QWORD *)(v5 + 112) = v30;
    *(_QWORD *)(v5 + 120) = v29;
    *(_QWORD *)(v5 + 176) = v32;
    *(_QWORD *)(v5 + 184) = v22 ^ v11;
    *(_QWORD *)(v5 + 208) = v33;
    *(_QWORD *)(v5 + 216) = v26 ^ v11;
  }
  *v7 = v9;
  *v6 = v8;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 4CAEC: using guessed type __int64 __fastcall sub_4CAEC();

//----- (000000000004CA60) ----------------------------------------------------
__int64 __fastcall sub_4CA60(__int64 result, __int64 a2)
{
  __int64 v2; // x10
  unsigned __int64 *v3; // x8
  unsigned __int64 v4; // x11
  unsigned __int64 v5; // x12
  signed __int64 v6; // x8
  __int128 v7; // t2
  _QWORD *v8; // x14
  _QWORD *v9; // x10
  __int128 v10; // t2
  unsigned __int64 v11; // x12
  unsigned __int64 v12; // x11

  v2 = *(unsigned __int8 *)(result + 15);
  v3 = (unsigned __int64 *)(a2 + 16 * (v2 & 0xF));
  v4 = *v3;
  v5 = v3[1];
  v6 = 14LL;
  while ( 1 )
  {
    v9 = (_QWORD *)(a2 + (v2 & 0xFFFFFFFFFFFFFFF0LL));
    *((_QWORD *)&v10 + 1) = v4;
    *(_QWORD *)&v10 = v5;
    v11 = qword_D1130[v5 & 0xF] ^ (v4 >> 4) ^ *v9;
    v12 = v9[1] ^ (unsigned __int128)(v10 >> 4);
    if ( v6 + 1 < 1 )
      break;
    v2 = *(unsigned __int8 *)(result + v6);
    *((_QWORD *)&v7 + 1) = v11;
    *(_QWORD *)&v7 = v12;
    v8 = (_QWORD *)(a2 + 16 * (v2 & 0xF));
    --v6;
    v4 = qword_D1130[v12 & 0xF] ^ (v11 >> 4) ^ *v8;
    v5 = v8[1] ^ (unsigned __int128)(v7 >> 4);
  }
  *(_QWORD *)result = bswap32(v11);
  *(_QWORD *)(result + 8) = bswap32(v12);
  return result;
}

//----- (000000000004CBA0) ----------------------------------------------------
void __fastcall CRYPTO_gcm128_init(void *a1, __int64 a2, void (__fastcall *a3)(__int64 *, __int64 *, __int64))
{
  unsigned __int64 v3; // x22
  void (__fastcall *v4)(__int64 *, __int64 *, __int64); // x19
  __int64 v5; // x20
  __int64 v6; // x21
  __int64 v7; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+10h] [xbp-30h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a3;
  v5 = a2;
  v6 = (__int64)a1;
  v9 = *(_QWORD *)(v3 + 40);
  memset(a1, 0, 0x180uLL);
  *(_QWORD *)(v6 + 376) = v4;
  v7 = 0LL;
  v8 = 0LL;
  v4(&v7, &v7, v5);
  sub_4C8BC(
    (_QWORD *)(v6 + 352),
    (int8x16_t (__fastcall **)(int8x16_t *, uint64x2_t *, int8x16_t *, unsigned __int64))(v6 + 360),
    (__int128 *)(v6 + 80),
    v6 + 96,
    (__int128 *)&v7);
  *(_QWORD *)(v3 + 40);
}

//----- (000000000004CC30) ----------------------------------------------------
__int64 __fastcall CRYPTO_gcm128_setiv(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // x19
  void (__fastcall *v5)(unsigned __int64, unsigned __int64); // x24
  unsigned __int64 v6; // x21
  _BYTE *v7; // x22
  __int64 v8; // x20
  unsigned int v9; // w21
  __int64 v10; // x8
  signed __int64 v11; // x26
  unsigned __int64 v12; // x27
  char v13; // w8
  char v14; // w9
  char v15; // w10
  char v16; // w11
  char v17; // w12
  char v18; // w13
  char v19; // w14
  char v20; // w15
  char v21; // w16
  char v22; // w17
  char v23; // w18
  char v24; // w0
  char v25; // w1
  char v26; // w2
  char v27; // w3
  char v28; // w4
  unsigned __int64 v29; // x25
  unsigned __int64 v30; // x28
  bool v31; // cf
  unsigned __int64 v32; // x8
  unsigned __int64 v33; // x9
  char *v34; // x10
  _BYTE *v35; // x11
  unsigned __int64 v36; // x8
  char v37; // t1
  signed __int64 v38; // x22
  __int64 result; // x0
  int8x16_t *v40; // x10
  int8x16_t *v41; // x11
  unsigned __int64 v42; // x12
  int8x16_t v43; // q0
  int8x16_t v44; // q1
  int8x16_t v45; // q1

  v4 = a1;
  v5 = *(void (__fastcall **)(unsigned __int64, unsigned __int64))(a1 + 352);
  v6 = a4;
  v7 = (_BYTE *)a3;
  v8 = a2;
  *(_QWORD *)(a1 + 368) = 0LL;
  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  if ( a4 != 12 )
  {
    v11 = a4 - 16;
    if ( a4 < 0x10 )
    {
      v32 = a4;
      v29 = a3;
      if ( !a4 )
      {
LABEL_18:
        v38 = v4 + 96;
        goto LABEL_19;
      }
    }
    else
    {
      v12 = v11 & 0xFFFFFFFFFFFFFFF0LL;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = (unsigned __int64)&v7[(v11 & 0xFFFFFFFFFFFFFFF0LL) + 16];
      v30 = v6 - 16;
      while ( 1 )
      {
        *(_BYTE *)v4 = v28 ^ *v7;
        *(_BYTE *)(v4 + 1) = v27 ^ v7[1];
        *(_BYTE *)(v4 + 2) = v26 ^ v7[2];
        *(_BYTE *)(v4 + 3) = v25 ^ v7[3];
        *(_BYTE *)(v4 + 4) = v24 ^ v7[4];
        *(_BYTE *)(v4 + 5) = v23 ^ v7[5];
        *(_BYTE *)(v4 + 6) = v22 ^ v7[6];
        *(_BYTE *)(v4 + 7) = v21 ^ v7[7];
        *(_BYTE *)(v4 + 8) = v20 ^ v7[8];
        *(_BYTE *)(v4 + 9) = v19 ^ v7[9];
        *(_BYTE *)(v4 + 10) = v18 ^ v7[10];
        *(_BYTE *)(v4 + 11) = v17 ^ v7[11];
        *(_BYTE *)(v4 + 12) = v16 ^ v7[12];
        *(_BYTE *)(v4 + 13) = v15 ^ v7[13];
        *(_BYTE *)(v4 + 14) = v14 ^ v7[14];
        *(_BYTE *)(v4 + 15) = v13 ^ v7[15];
        v5(v4, v4 + 96);
        v31 = v30 >= 0x10;
        v30 -= 16LL;
        if ( !v31 )
          break;
        v28 = *(_BYTE *)v4;
        v27 = *(_BYTE *)(v4 + 1);
        v26 = *(_BYTE *)(v4 + 2);
        v25 = *(_BYTE *)(v4 + 3);
        v24 = *(_BYTE *)(v4 + 4);
        v23 = *(_BYTE *)(v4 + 5);
        v22 = *(_BYTE *)(v4 + 6);
        v21 = *(_BYTE *)(v4 + 7);
        v20 = *(_BYTE *)(v4 + 8);
        v19 = *(_BYTE *)(v4 + 9);
        v18 = *(_BYTE *)(v4 + 10);
        v17 = *(_BYTE *)(v4 + 11);
        v16 = *(_BYTE *)(v4 + 12);
        v15 = *(_BYTE *)(v4 + 13);
        v14 = *(_BYTE *)(v4 + 14);
        v13 = *(_BYTE *)(v4 + 15);
        v7 += 16;
      }
      v32 = v11 - v12;
      if ( v11 == v12 )
        goto LABEL_18;
    }
    if ( v32 > 0x1F )
    {
      v33 = v32 & 0xFFFFFFFFFFFFFFE0LL;
      if ( !(v32 & 0xFFFFFFFFFFFFFFE0LL) )
        goto LABEL_15;
      if ( v4 >= v29 + v32 || v29 >= v4 + v32 )
      {
        v40 = (int8x16_t *)(v29 + 16);
        v41 = (int8x16_t *)(v4 + 16);
        v42 = v32 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v43 = v40[-1];
          v44 = *v40;
          v40 += 2;
          v42 -= 32LL;
          v45 = veorq_s8(*v41, v44);
          v41[-1] = veorq_s8(v41[-1], v43);
          *v41 = v45;
          v41 += 2;
        }
        while ( v42 );
        if ( v32 == v33 )
          goto LABEL_17;
        goto LABEL_15;
      }
    }
    v33 = 0LL;
LABEL_15:
    v34 = (char *)(v29 + v33);
    v35 = (_BYTE *)(v4 + v33);
    v36 = v32 - v33;
    do
    {
      v37 = *v34++;
      --v36;
      *v35++ ^= v37;
    }
    while ( v36 );
LABEL_17:
    v38 = v4 + 96;
    v5(v4, v4 + 96);
LABEL_19:
    *(_QWORD *)(v4 + 8) ^= bswap32(8 * v6);
    v5(v4, v38);
    v9 = bswap32(*(_DWORD *)(v4 + 12)) + 1;
    goto LABEL_20;
  }
  v9 = 2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 8);
  v10 = *(_QWORD *)a3;
  *(_BYTE *)(a1 + 15) = 1;
  *(_QWORD *)a1 = v10;
LABEL_20:
  result = (*(__int64 (__fastcall **)(unsigned __int64, unsigned __int64, __int64))(v4 + 376))(v4, v4 + 32, v8);
  *(_DWORD *)(v4 + 12) = bswap32(v9);
  return result;
}

//----- (000000000004CF30) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_gcm128_aad(int8x16_t *a1, int8x16_t *a2, unsigned __int64 a3)
{
  int8x16_t *v3; // x19
  __int64 v4; // x8
  int8x16_t *v5; // x20
  signed __int64 result; // x0
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x10
  char v9; // w8
  void (__fastcall *v10)(int8x16_t *, int8x16_t *); // x8
  void (__fastcall *v11)(int8x16_t *, int8x16_t *, int8x16_t *, unsigned __int64); // x23
  unsigned int v12; // w9
  signed __int64 v13; // x10
  __int64 v14; // x12
  char v15; // t1
  char v16; // w13
  unsigned __int64 v17; // x22
  unsigned __int64 v18; // x21
  unsigned __int64 v19; // x8
  int8x16_t *v20; // x9
  int8x16_t *v21; // x10
  unsigned __int64 v22; // x11
  int8x16_t v23; // q0
  int8x16_t v24; // q1
  int8x16_t v25; // q1
  char *v26; // x9
  _BYTE *v27; // x10
  unsigned __int64 v28; // x8
  char v29; // t1

  v3 = a1;
  v4 = a1[3].n128_i64[1];
  v5 = a2;
  result = 0LL;
  if ( !v4 )
  {
    v7 = v3[3].n128_u64[0];
    v8 = v7 + a3;
    v9 = __CFADD__(v7, a3) ? 1 : 0;
    if ( v8 <= 0x2000000000000000LL && !(v9 & 1) )
    {
      v10 = (void (__fastcall *)(int8x16_t *, int8x16_t *))v3[22].n128_u64[0];
      v11 = (void (__fastcall *)(int8x16_t *, int8x16_t *, int8x16_t *, unsigned __int64))v3[22].n128_u64[1];
      v12 = v3[23].n128_u32[1];
      v3[3].n128_u64[0] = v8;
      if ( v12 )
      {
        if ( !a3 )
          goto LABEL_34;
        v13 = (signed __int64)&v3[4];
        do
        {
          v14 = v12;
          v15 = v5->n128_u64[0];
          v5 = (int8x16_t *)((char *)v5 + 1);
          v16 = *(_BYTE *)(v13 + v12);
          v17 = a3 - 1;
          v12 = (v12 + 1) & 0xF;
          *(_BYTE *)(v13 + v14) = v16 ^ v15;
          if ( !v12 )
            break;
          --a3;
        }
        while ( a3 );
        if ( v12 )
        {
LABEL_34:
          v3[23].n128_u32[1] = v12;
          return 1LL;
        }
        v10(v3 + 4, v3 + 6);
        v18 = v17 & 0xFFFFFFFFFFFFFFF0LL;
        if ( v17 & 0xFFFFFFFFFFFFFFF0LL )
          goto LABEL_17;
      }
      else
      {
        v17 = a3;
        v18 = a3 & 0xFFFFFFFFFFFFFFF0LL;
        if ( a3 & 0xFFFFFFFFFFFFFFF0LL )
        {
LABEL_17:
          v11(v3 + 4, v3 + 6, v5, v18);
          v5 = (int8x16_t *)((char *)v5 + v18);
          v17 -= v18;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( v17 )
      {
        if ( v17 >= 0x20 )
        {
          v19 = v17 & 0xFFFFFFFFFFFFFFE0LL;
          if ( v17 & 0xFFFFFFFFFFFFFFE0LL )
          {
            if ( &v3[4] >= (int8x16_t *)((char *)v5 + v17) || v5 >= (int8x16_t *)((char *)&v3[4] + v17) )
            {
              v20 = v5 + 1;
              v21 = v3 + 5;
              v22 = v17 & 0xFFFFFFFFFFFFFFE0LL;
              do
              {
                v23 = v20[-1];
                v24 = *v20;
                v20 += 2;
                v22 -= 32LL;
                v25 = veorq_s8(*v21, v24);
                v21[-1] = veorq_s8(v21[-1], v23);
                *v21 = v25;
                v21 += 2;
              }
              while ( v22 );
              if ( v17 == v19 )
                goto LABEL_30;
            }
            else
            {
              v19 = 0LL;
            }
          }
        }
        else
        {
          v19 = 0LL;
        }
        v26 = (char *)v5 + v19;
        v27 = (char *)&v3[4] + v19;
        v28 = v17 - v19;
        do
        {
          v29 = *v26++;
          --v28;
          *v27++ ^= v29;
        }
        while ( v28 );
      }
LABEL_30:
      v3[23].n128_u32[1] = v17;
      return 1LL;
    }
  }
  return result;
}

//----- (000000000004D0C4) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_gcm128_encrypt(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5)
{
  __int64 v5; // x19
  __int64 v6; // x8
  unsigned __int64 v7; // x23
  _BYTE *v8; // x22
  char *v9; // x20
  unsigned __int8 v10; // cf
  unsigned __int64 v11; // x8
  __int64 v12; // x21
  signed __int64 result; // x0
  char v14; // w9
  void (__fastcall *v15)(__int64, __int64); // x24
  void (__fastcall *v16)(__int64, __int64, __int64); // x26
  int v17; // w9
  unsigned int v18; // w25
  unsigned int v19; // w8
  __int64 v20; // x12
  char v21; // t1
  char v22; // w13
  unsigned __int64 v23; // x27
  int v24; // w24
  unsigned int v25; // w25
  __int64 v26; // x24
  _QWORD *v27; // x28
  char *v28; // x27
  _QWORD *v29; // x28
  unsigned __int64 v30; // x22
  unsigned __int64 v31; // x8
  int v32; // w9
  unsigned int v33; // w24
  char *v34; // x25
  __int64 v35; // x8
  __int64 v36; // x8
  __int64 v37; // x10
  char v38; // w11
  char v39; // w12
  char v40; // w11
  signed __int64 v41; // [xsp+10h] [xbp-80h]
  void (__fastcall *v42)(__int64, __int64, _BYTE *, signed __int64); // [xsp+18h] [xbp-78h]
  unsigned int v43; // [xsp+24h] [xbp-6Ch]
  int v44; // [xsp+24h] [xbp-6Ch]
  int v45; // [xsp+28h] [xbp-68h]
  signed __int64 v46; // [xsp+28h] [xbp-68h]
  signed __int64 v47; // [xsp+30h] [xbp-60h]
  unsigned __int64 v48; // [xsp+38h] [xbp-58h]
  _QWORD *v49; // [xsp+38h] [xbp-58h]

  v5 = a1;
  v6 = *(_QWORD *)(a1 + 56);
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = __CFADD__(v6, a5);
  v11 = v6 + a5;
  v12 = a2;
  result = 0LL;
  if ( v10 )
    v14 = 1;
  else
    v14 = 0;
  if ( v11 <= 0xFFFFFFFE0LL && !(v14 & 1) )
  {
    v15 = *(void (__fastcall **)(__int64, __int64))(v5 + 352);
    v16 = *(void (__fastcall **)(__int64, __int64, __int64))(v5 + 376);
    v42 = *(void (__fastcall **)(__int64, __int64, _BYTE *, signed __int64))(v5 + 360);
    v17 = *(_DWORD *)(v5 + 372);
    *(_QWORD *)(v5 + 56) = v11;
    if ( v17 )
    {
      v15(v5 + 64, v5 + 96);
      *(_DWORD *)(v5 + 372) = 0;
    }
    v18 = *(_DWORD *)(v5 + 12);
    v19 = *(_DWORD *)(v5 + 368);
    if ( v19 )
    {
      if ( !v7 )
        goto LABEL_33;
      do
      {
        v20 = v19;
        v21 = *v9++;
        v22 = *(_BYTE *)(v5 + 16 + v19);
        v23 = v7 - 1;
        v19 = (v19 + 1) & 0xF;
        *v8++ = v22 ^ v21;
        *(_BYTE *)(v5 + 64 + v20) ^= v22 ^ v21;
        if ( !v19 )
          break;
        --v7;
      }
      while ( v7 );
      if ( v19 )
      {
LABEL_33:
        result = 1LL;
        *(_DWORD *)(v5 + 368) = v19;
        return result;
      }
      v15(v5 + 64, v5 + 96);
    }
    else
    {
      v23 = v7;
    }
    v24 = bswap32(v18);
    if ( v23 < 0xC00 )
    {
      v29 = v8;
    }
    else
    {
      v25 = v24 + 1;
      do
      {
        v43 = v25;
        v45 = v24;
        v26 = 0LL;
        v48 = v23;
        do
        {
          v27 = &v8[v26];
          v28 = &v9[v26];
          v16(v5, v5 + 16, v12);
          *(_DWORD *)(v5 + 12) = bswap32(v25);
          v26 += 16LL;
          ++v25;
          *v27 = *(_QWORD *)(v5 + 16) ^ *(_QWORD *)v28;
          v27[1] = *(_QWORD *)(v5 + 24) ^ *((_QWORD *)v28 + 1);
        }
        while ( v26 != 3072 );
        v24 = v45 + 192;
        v9 += 3072;
        v42(v5 + 64, v5 + 96, v8, 3072LL);
        v29 = v8 + 3072;
        v23 = v48 - 3072;
        v25 = v43 + 192;
        v8 += 3072;
      }
      while ( v48 - 3072 > 0xBFF );
    }
    v30 = v23 & 0xFFFFFFFFFFFFFFF0LL;
    if ( v23 & 0xFFFFFFFFFFFFFFF0LL )
    {
      if ( v23 >= 0x10 )
      {
        v47 = v23 - 16;
        v31 = (v23 - 16) >> 4;
        v32 = v24 + v31;
        v46 = 16 * v31;
        v41 = 16 * v31 + 16;
        v33 = v24 + 1;
        v34 = v9;
        v44 = v32;
        v49 = (_QWORD *)((char *)v29 + v41);
        do
        {
          v16(v5, v5 + 16, v12);
          *(_DWORD *)(v5 + 12) = bswap32(v33);
          v23 -= 16LL;
          ++v33;
          *v29 = *(_QWORD *)(v5 + 16) ^ *(_QWORD *)v34;
          v35 = *((_QWORD *)v34 + 1);
          v34 += 16;
          v29[1] = *(_QWORD *)(v5 + 24) ^ v35;
          v29 += 2;
        }
        while ( v23 > 0xF );
        v29 = v49;
        v24 = v44 + 1;
        v9 += v41;
        v23 = v47 - v46;
      }
      v42(v5 + 64, v5 + 96, (_BYTE *)v29 - v30, v30);
    }
    if ( v23 )
    {
      v16(v5, v5 + 16, v12);
      v36 = 0LL;
      *(_DWORD *)(v5 + 12) = bswap32(v24 + 1);
      do
      {
        v37 = (unsigned int)v36;
        v38 = v9[(unsigned int)v36];
        v39 = *(_BYTE *)(v5 + 16 + (unsigned int)v36++);
        v40 = v39 ^ v38;
        *((_BYTE *)v29 + v37) = v40;
        *(_BYTE *)(v5 + 64 + v37) ^= v40;
      }
      while ( v23 != v36 );
      v19 = v23;
    }
    else
    {
      v19 = 0;
    }
    goto LABEL_33;
  }
  return result;
}

//----- (000000000004D3C8) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_gcm128_decrypt(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5)
{
  __int64 v5; // x19
  __int64 v6; // x8
  unsigned __int64 v7; // x23
  _BYTE *v8; // x22
  char *v9; // x20
  unsigned __int8 v10; // cf
  unsigned __int64 v11; // x8
  __int64 v12; // x21
  signed __int64 result; // x0
  char v14; // w9
  void (__fastcall *v15)(__int64, __int64); // x24
  void (__fastcall *v16)(__int64, __int64, __int64); // x26
  int v17; // w9
  unsigned int v18; // w25
  unsigned int v19; // w8
  __int64 v20; // x12
  char v21; // t1
  char v22; // w13
  unsigned __int64 v23; // x27
  int v24; // w23
  unsigned int v25; // w24
  __int64 v26; // x28
  _QWORD *v27; // x27
  char *v28; // x23
  signed __int64 v29; // x8
  signed __int64 v30; // x24
  unsigned __int64 v31; // x8
  signed __int64 v32; // x9
  _QWORD *v33; // x8
  unsigned int v34; // w28
  _QWORD *v35; // x23
  char *v36; // x25
  __int64 v37; // x8
  __int64 v38; // x8
  signed __int64 v39; // x9
  __int64 v40; // x10
  char v41; // w11
  char v42; // w12
  void (__fastcall *v43)(__int64, __int64, char *, signed __int64); // [xsp+18h] [xbp-78h]
  unsigned int v44; // [xsp+20h] [xbp-70h]
  signed __int64 v45; // [xsp+20h] [xbp-70h]
  int v46; // [xsp+28h] [xbp-68h]
  int v47; // [xsp+30h] [xbp-60h]
  signed __int64 v48; // [xsp+30h] [xbp-60h]
  unsigned __int64 v49; // [xsp+38h] [xbp-58h]
  signed __int64 v50; // [xsp+38h] [xbp-58h]

  v5 = a1;
  v6 = *(_QWORD *)(a1 + 56);
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = __CFADD__(v6, a5);
  v11 = v6 + a5;
  v12 = a2;
  result = 0LL;
  if ( v10 )
    v14 = 1;
  else
    v14 = 0;
  if ( v11 <= 0xFFFFFFFE0LL && !(v14 & 1) )
  {
    v15 = *(void (__fastcall **)(__int64, __int64))(v5 + 352);
    v16 = *(void (__fastcall **)(__int64, __int64, __int64))(v5 + 376);
    v43 = *(void (__fastcall **)(__int64, __int64, char *, signed __int64))(v5 + 360);
    v17 = *(_DWORD *)(v5 + 372);
    *(_QWORD *)(v5 + 56) = v11;
    if ( v17 )
    {
      v15(v5 + 64, v5 + 96);
      *(_DWORD *)(v5 + 372) = 0;
    }
    v18 = *(_DWORD *)(v5 + 12);
    v19 = *(_DWORD *)(v5 + 368);
    if ( v19 )
    {
      if ( !v7 )
        goto LABEL_32;
      do
      {
        v20 = v19;
        v21 = *v9++;
        v22 = *(_BYTE *)(v5 + 16 + v19);
        v23 = v7 - 1;
        v19 = (v19 + 1) & 0xF;
        *v8++ = v22 ^ v21;
        *(_BYTE *)(v5 + 64 + v20) ^= v21;
        if ( !v19 )
          break;
        --v7;
      }
      while ( v7 );
      if ( v19 )
        goto LABEL_32;
      v15(v5 + 64, v5 + 96);
    }
    else
    {
      v23 = v7;
    }
    v24 = bswap32(v18);
    if ( v23 < 0xC00 )
    {
      v29 = (signed __int64)v8;
    }
    else
    {
      v25 = v24 + 1;
      do
      {
        v47 = v24;
        v49 = v23;
        v43(v5 + 64, v5 + 96, v9, 3072LL);
        v26 = 0LL;
        v44 = v25;
        do
        {
          v27 = &v8[v26];
          v28 = &v9[v26];
          v16(v5, v5 + 16, v12);
          *(_DWORD *)(v5 + 12) = bswap32(v25);
          v26 += 16LL;
          ++v25;
          *v27 = *(_QWORD *)(v5 + 16) ^ *(_QWORD *)v28;
          v27[1] = *(_QWORD *)(v5 + 24) ^ *((_QWORD *)v28 + 1);
        }
        while ( v26 != 3072 );
        v29 = (signed __int64)(v8 + 3072);
        v23 = v49 - 3072;
        v24 = v47 + 192;
        v9 += 3072;
        v25 = v44 + 192;
        v8 += 3072;
      }
      while ( v49 - 3072 > 0xBFF );
    }
    v30 = v29;
    if ( v23 & 0xFFFFFFFFFFFFFFF0LL )
    {
      ((void (__fastcall *)(__int64, __int64, char *))v43)(v5 + 64, v5 + 96, v9);
      if ( v23 >= 0x10 )
      {
        v50 = v23 - 16;
        v31 = (v23 - 16) >> 4;
        v46 = v24 + v31;
        v48 = 16 * v31;
        v32 = 16 * v31 + 16;
        v33 = (_QWORD *)v30;
        v30 += v32;
        v34 = v24 + 1;
        v35 = v33;
        v36 = v9;
        v45 = v32;
        do
        {
          v16(v5, v5 + 16, v12);
          *(_DWORD *)(v5 + 12) = bswap32(v34);
          v23 -= 16LL;
          ++v34;
          *v35 = *(_QWORD *)(v5 + 16) ^ *(_QWORD *)v36;
          v37 = *((_QWORD *)v36 + 1);
          v36 += 16;
          v35[1] = *(_QWORD *)(v5 + 24) ^ v37;
          v35 += 2;
        }
        while ( v23 > 0xF );
        v24 = v46 + 1;
        v9 += v45;
        v23 = v50 - v48;
      }
    }
    if ( v23 )
    {
      v16(v5, v5 + 16, v12);
      v38 = 0LL;
      *(_DWORD *)(v5 + 12) = bswap32(v24 + 1);
      v39 = v5 + 64;
      do
      {
        v40 = (unsigned int)v38;
        v41 = v9[(unsigned int)v38];
        v42 = *(_BYTE *)(v39 + (unsigned int)v38++);
        *(_BYTE *)(v39 + v40) = v42 ^ v41;
        *(_BYTE *)(v30 + v40) = *(_BYTE *)(v5 + 16 + v40) ^ v41;
      }
      while ( v23 != v38 );
      v19 = v23;
    }
    else
    {
      v19 = 0;
    }
LABEL_32:
    result = 1LL;
    *(_DWORD *)(v5 + 368) = v19;
  }
  return result;
}

//----- (000000000004D6D8) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_gcm128_encrypt_ctr32(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5, void (__fastcall *a6)(char *, _BYTE *, signed __int64, __int64, __int64))
{
  __int64 v6; // x19
  __int64 v7; // x8
  unsigned __int64 v8; // x24
  void (__fastcall *v9)(char *, _BYTE *, signed __int64, __int64, __int64); // x23
  _BYTE *v10; // x20
  unsigned __int8 v11; // cf
  unsigned __int64 v12; // x8
  char *v13; // x21
  __int64 v14; // x22
  signed __int64 result; // x0
  char v16; // w9
  void (__fastcall *v17)(__int64, __int64); // x25
  void (__fastcall *v18)(__int64, __int64, _BYTE *, signed __int64); // x27
  int v19; // w9
  unsigned int v20; // w8
  __int64 v21; // x12
  char v22; // t1
  char v23; // w13
  unsigned __int64 v24; // x26
  unsigned int v25; // w28
  unsigned __int64 v26; // x24
  unsigned __int64 v27; // x3
  __int64 v28; // x8
  __int64 v29; // x10
  char v30; // w11
  char v31; // w12
  char v32; // w11

  v6 = a1;
  v7 = *(_QWORD *)(a1 + 56);
  v8 = a5;
  v9 = a6;
  v10 = a4;
  v11 = __CFADD__(v7, a5);
  v12 = v7 + a5;
  v13 = a3;
  v14 = a2;
  result = 0LL;
  if ( v11 )
    v16 = 1;
  else
    v16 = 0;
  if ( v12 <= 0xFFFFFFFE0LL && !(v16 & 1) )
  {
    v17 = *(void (__fastcall **)(__int64, __int64))(v6 + 352);
    v18 = *(void (__fastcall **)(__int64, __int64, _BYTE *, signed __int64))(v6 + 360);
    v19 = *(_DWORD *)(v6 + 372);
    *(_QWORD *)(v6 + 56) = v12;
    if ( v19 )
    {
      v17(v6 + 64, v6 + 96);
      *(_DWORD *)(v6 + 372) = 0;
    }
    v20 = *(_DWORD *)(v6 + 368);
    if ( v20 )
    {
      if ( !v8 )
        goto LABEL_24;
      do
      {
        v21 = v20;
        v22 = *v13++;
        v23 = *(_BYTE *)(v6 + 16 + v20);
        v24 = v8 - 1;
        v20 = (v20 + 1) & 0xF;
        *v10++ = v23 ^ v22;
        *(_BYTE *)(v6 + 64 + v21) ^= v23 ^ v22;
        if ( !v20 )
          break;
        --v8;
      }
      while ( v8 );
      if ( v20 )
      {
LABEL_24:
        result = 1LL;
        *(_DWORD *)(v6 + 368) = v20;
        return result;
      }
      v17(v6 + 64, v6 + 96);
    }
    else
    {
      v24 = v8;
    }
    v25 = bswap32(*(_DWORD *)(v6 + 12));
    if ( v24 >= 0xC00 )
    {
      do
      {
        v9(v13, v10, 192LL, v14, v6);
        v25 += 192;
        *(_DWORD *)(v6 + 12) = bswap32(v25);
        v18(v6 + 64, v6 + 96, v10, 3072LL);
        v10 += 3072;
        v13 += 3072;
        v24 -= 3072LL;
      }
      while ( v24 > 0xBFF );
    }
    v26 = v24 & 0xFFFFFFFFFFFFFFF0LL;
    if ( v24 & 0xFFFFFFFFFFFFFFF0LL )
    {
      v9(v13, v10, v24 >> 4, v14, v6);
      v25 += v24 >> 4;
      v27 = v24 & 0xFFFFFFFFFFFFFFF0LL;
      v13 += v26;
      v24 -= v26;
      *(_DWORD *)(v6 + 12) = bswap32(v25);
      v18(v6 + 64, v6 + 96, v10, v27);
      v10 += v26;
    }
    if ( v24 )
    {
      (*(void (__fastcall **)(__int64, __int64, __int64))(v6 + 376))(v6, v6 + 16, v14);
      v28 = 0LL;
      *(_DWORD *)(v6 + 12) = bswap32(v25 + 1);
      do
      {
        v29 = (unsigned int)v28;
        v30 = v13[(unsigned int)v28];
        v31 = *(_BYTE *)(v6 + 16 + (unsigned int)v28++);
        v32 = v31 ^ v30;
        v10[v29] = v32;
        *(_BYTE *)(v6 + 64 + v29) ^= v32;
      }
      while ( v24 != v28 );
      v20 = v24;
    }
    else
    {
      v20 = 0;
    }
    goto LABEL_24;
  }
  return result;
}

//----- (000000000004D8F4) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_gcm128_decrypt_ctr32(__int64 a1, __int64 a2, char *a3, _BYTE *a4, unsigned __int64 a5, void (__fastcall *a6)(char *, _BYTE *, signed __int64, __int64, __int64))
{
  __int64 v6; // x19
  __int64 v7; // x8
  unsigned __int64 v8; // x24
  void (__fastcall *v9)(char *, _BYTE *, signed __int64, __int64, __int64); // x23
  _BYTE *v10; // x20
  unsigned __int8 v11; // cf
  unsigned __int64 v12; // x8
  char *v13; // x21
  __int64 v14; // x22
  signed __int64 result; // x0
  char v16; // w9
  void (__fastcall *v17)(__int64, __int64); // x25
  void (__fastcall *v18)(__int64, __int64, char *, signed __int64); // x27
  int v19; // w9
  unsigned int v20; // w8
  __int64 v21; // x12
  char v22; // t1
  char v23; // w13
  unsigned __int64 v24; // x26
  unsigned int v25; // w28
  unsigned __int64 v26; // x24
  __int64 v27; // x8
  signed __int64 v28; // x9
  __int64 v29; // x10
  char v30; // w11
  char v31; // w12

  v6 = a1;
  v7 = *(_QWORD *)(a1 + 56);
  v8 = a5;
  v9 = a6;
  v10 = a4;
  v11 = __CFADD__(v7, a5);
  v12 = v7 + a5;
  v13 = a3;
  v14 = a2;
  result = 0LL;
  if ( v11 )
    v16 = 1;
  else
    v16 = 0;
  if ( v12 <= 0xFFFFFFFE0LL && !(v16 & 1) )
  {
    v17 = *(void (__fastcall **)(__int64, __int64))(v6 + 352);
    v18 = *(void (__fastcall **)(__int64, __int64, char *, signed __int64))(v6 + 360);
    v19 = *(_DWORD *)(v6 + 372);
    *(_QWORD *)(v6 + 56) = v12;
    if ( v19 )
    {
      v17(v6 + 64, v6 + 96);
      *(_DWORD *)(v6 + 372) = 0;
    }
    v20 = *(_DWORD *)(v6 + 368);
    if ( v20 )
    {
      if ( !v8 )
        goto LABEL_24;
      do
      {
        v21 = v20;
        v22 = *v13++;
        v23 = *(_BYTE *)(v6 + 16 + v20);
        v24 = v8 - 1;
        v20 = (v20 + 1) & 0xF;
        *v10++ = v23 ^ v22;
        *(_BYTE *)(v6 + 64 + v21) ^= v22;
        if ( !v20 )
          break;
        --v8;
      }
      while ( v8 );
      if ( v20 )
      {
LABEL_24:
        result = 1LL;
        *(_DWORD *)(v6 + 368) = v20;
        return result;
      }
      v17(v6 + 64, v6 + 96);
    }
    else
    {
      v24 = v8;
    }
    v25 = bswap32(*(_DWORD *)(v6 + 12));
    if ( v24 >= 0xC00 )
    {
      do
      {
        v18(v6 + 64, v6 + 96, v13, 3072LL);
        v9(v13, v10, 192LL, v14, v6);
        v25 += 192;
        v10 += 3072;
        v13 += 3072;
        v24 -= 3072LL;
        *(_DWORD *)(v6 + 12) = bswap32(v25);
      }
      while ( v24 > 0xBFF );
    }
    v26 = v24 & 0xFFFFFFFFFFFFFFF0LL;
    if ( v24 & 0xFFFFFFFFFFFFFFF0LL )
    {
      v18(v6 + 64, v6 + 96, v13, v24 & 0xFFFFFFFFFFFFFFF0LL);
      v9(v13, v10, v24 >> 4, v14, v6);
      v25 += v24 >> 4;
      v10 += v26;
      v13 += v26;
      v24 -= v26;
      *(_DWORD *)(v6 + 12) = bswap32(v25);
    }
    if ( v24 )
    {
      (*(void (__fastcall **)(__int64, __int64, __int64))(v6 + 376))(v6, v6 + 16, v14);
      v27 = 0LL;
      *(_DWORD *)(v6 + 12) = bswap32(v25 + 1);
      v28 = v6 + 64;
      do
      {
        v29 = (unsigned int)v27;
        v30 = v13[(unsigned int)v27];
        v31 = *(_BYTE *)(v28 + (unsigned int)v27++);
        *(_BYTE *)(v28 + v29) = v31 ^ v30;
        v10[v29] = *(_BYTE *)(v6 + 16 + v29) ^ v30;
      }
      while ( v24 != v27 );
      v20 = v24;
    }
    else
    {
      v20 = 0;
    }
    goto LABEL_24;
  }
  return result;
}

//----- (000000000004DB10) ----------------------------------------------------
bool __fastcall CRYPTO_gcm128_finish(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // x21
  void (__fastcall *v4)(__int64, __int64); // x23
  unsigned __int64 v5; // x19
  __int64 v6; // x20
  unsigned __int64 v7; // x25
  unsigned __int64 v8; // x24
  signed __int64 v9; // x22
  unsigned __int64 *v10; // x21
  __int64 v11; // t1
  unsigned __int64 v12; // x10
  _BOOL8 result; // x0
  unsigned __int64 v14; // x9

  v3 = a1;
  v4 = *(void (__fastcall **)(__int64, __int64))(a1 + 352);
  v5 = a3;
  v6 = a2;
  v7 = 8LL * *(_QWORD *)(a1 + 48);
  v8 = 8LL * *(_QWORD *)(a1 + 56);
  if ( *(_DWORD *)(a1 + 368) || *(_DWORD *)(a1 + 372) )
  {
    v9 = a1 + 96;
    v4(a1 + 64, a1 + 96);
  }
  else
  {
    v9 = a1 + 96;
  }
  v11 = *(_QWORD *)(v3 + 64);
  v10 = (unsigned __int64 *)(v3 + 64);
  v12 = v10[1];
  *v10 = v11 ^ bswap32(v7);
  v10[1] = v12 ^ bswap32(v8);
  v4((__int64)v10, v9);
  result = 0LL;
  v14 = v10[1] ^ *(v10 - 3);
  *v10 ^= *(v10 - 4);
  v10[1] = v14;
  if ( v6 )
  {
    if ( v5 <= 0x10 )
      result = (unsigned int)CRYPTO_memcmp((__int64)v10, v6, v5) == 0;
  }
  return result;
}

//----- (000000000004DBEC) ----------------------------------------------------
void *__fastcall CRYPTO_gcm128_tag(__int64 a1, void *a2, unsigned __int64 a3)
{
  __int64 v3; // x20
  void (__fastcall *v4)(__int64, __int64); // x23
  unsigned __int64 v5; // x21
  void *v6; // x19
  unsigned __int64 v7; // x25
  unsigned __int64 v8; // x24
  signed __int64 v9; // x22
  unsigned __int64 *v10; // x20
  __int64 v11; // t1
  unsigned __int64 v12; // x10
  void *result; // x0
  __int64 v14; // x9
  unsigned __int64 v15; // x11
  size_t v16; // x2

  v3 = a1;
  v4 = *(void (__fastcall **)(__int64, __int64))(a1 + 352);
  v5 = a3;
  v6 = a2;
  v7 = 8LL * *(_QWORD *)(a1 + 48);
  v8 = 8LL * *(_QWORD *)(a1 + 56);
  if ( *(_DWORD *)(a1 + 368) || *(_DWORD *)(a1 + 372) )
  {
    v9 = a1 + 96;
    v4(a1 + 64, a1 + 96);
  }
  else
  {
    v9 = a1 + 96;
  }
  v11 = *(_QWORD *)(v3 + 64);
  v10 = (unsigned __int64 *)(v3 + 64);
  v12 = v10[1];
  *v10 = v11 ^ bswap32(v7);
  v10[1] = v12 ^ bswap32(v8);
  result = (void *)((__int64 (__fastcall *)(unsigned __int64 *, signed __int64))v4)(v10, v9);
  v14 = *(v10 - 3);
  v15 = v10[1];
  if ( v5 <= 0x10 )
    v16 = v5;
  else
    v16 = 16LL;
  *v10 ^= *(v10 - 4);
  v10[1] = v15 ^ v14;
  if ( v16 )
    result = memcpy(v6, v10, v16);
  return result;
}

//----- (000000000004DCBC) ----------------------------------------------------
__int64 __fastcall sub_4DCBC(__int64 result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6, __int64 (__fastcall *a7)(__int64, __int64, __int64))
{
  unsigned int *v7; // x22
  __int64 (__fastcall *v8)(__int64, __int64, __int64); // x23
  __int64 v9; // x20
  __int64 v10; // ST28_8
  unsigned int v11; // w26
  __int64 v12; // x24
  unsigned __int64 v13; // x21
  _BYTE *v14; // x25
  char *i; // x19
  char v16; // t1
  char v17; // w9
  signed __int64 v18; // x28
  _BYTE *v19; // x27
  char *v20; // x22
  unsigned __int64 v21; // x8
  int v22; // w8
  __int64 v23; // x9
  char v24; // w10
  char v25; // w11
  unsigned __int64 v26; // [xsp+8h] [xbp-78h]
  unsigned __int64 v27; // [xsp+10h] [xbp-70h]
  unsigned int *v28; // [xsp+18h] [xbp-68h]

  v7 = a6;
  v8 = a7;
  v9 = a5;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = *a6;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  for ( i = (char *)result; v13 && v11; ++v14 )
  {
    v16 = *i++;
    v17 = *(_BYTE *)(a5 + v11);
    --v13;
    v11 = (v11 + 1) & 0xF;
    *v14 = v17 ^ v16;
  }
  v18 = v13 - 16;
  if ( v13 < 0x10 )
  {
    v19 = v14;
    if ( !v13 )
      goto LABEL_17;
    goto LABEL_14;
  }
  v26 = v18 & 0xFFFFFFFFFFFFFFF0LL;
  v27 = (v18 & 0xFFFFFFFFFFFFFFF0LL) + 16;
  v28 = a6;
  v19 = &v14[v27];
  v20 = i;
  do
  {
    result = v8(v9, v9, v12);
    if ( v11 <= 0xF )
    {
      v21 = v11;
      do
      {
        *(_QWORD *)&v14[v21] = *(_QWORD *)(v9 + v21) ^ *(_QWORD *)&v20[v21];
        v21 += 8LL;
      }
      while ( v21 < 0x10 );
    }
    v11 = 0;
    v13 -= 16LL;
    v14 += 16;
    v20 += 16;
  }
  while ( v13 > 0xF );
  v11 = 0;
  v13 = v18 - v26;
  v7 = v28;
  i += v27;
  if ( v18 != v26 )
  {
LABEL_14:
    result = v8(v9, v9, v12);
    v22 = v11 + v13 - 1;
    do
    {
      v23 = v11;
      v24 = i[v11];
      v25 = *(_BYTE *)(v9 + v11);
      --v13;
      ++v11;
      v19[v23] = v25 ^ v24;
    }
    while ( v13 );
    v11 = v22 + 1;
  }
LABEL_17:
  *v7 = v11;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000004DE44) ----------------------------------------------------
signed __int64 __fastcall RAND_pseudo_bytes(signed __int64 a1, size_t a2)
{
  if ( a2 )
    sub_4E1C0(a1, a2);
  return 1LL;
}

//----- (000000000004DE60) ----------------------------------------------------
signed __int64 RAND_seed()
{
  unsigned __int64 v0; // x19
  signed __int64 result; // x0
  char v2; // [xsp+4h] [xbp-1Ch]
  __int64 v3; // [xsp+8h] [xbp-18h]

  v0 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v3 = *(_QWORD *)(v0 + 40);
  result = sub_4E1C0((signed __int64)&v2, 1uLL);
  *(_QWORD *)(v0 + 40);
  return result;
}

//----- (000000000004DEAC) ----------------------------------------------------
signed __int64 __fastcall RAND_load_file(__int64 a1, signed __int64 a2)
{
  if ( a2 & 0x8000000000000000LL )
    return 1LL;
  if ( a2 >= 0x80000000LL )
    return 0x7FFFFFFFLL;
  return (unsigned int)a2;
}

//----- (000000000004DECC) ----------------------------------------------------
signed __int64 RAND_egd()
{
  return 255LL;
}

//----- (000000000004DED4) ----------------------------------------------------
__int64 (__fastcall **RAND_SSLeay())()
{
  return off_F70C8;
}
// F70C8: using guessed type __int64 (__fastcall *off_F70C8[6])();

//----- (000000000004DEE0) ----------------------------------------------------
__int64 __fastcall RAND_set_urandom_fd(int a1)
{
  int v1; // w19
  __int64 result; // x0

  v1 = dup(a1);
  if ( v1 & 0x80000000 )
    abort();
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_106FB8);
  dword_106488 = v1;
  CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_106FB8);
  result = CRYPTO_once((pthread_once_t *)&unk_106FF0, (void (*)(void))sub_4DF68);
  if ( dword_10648C == -3 )
    return close(v1);
  if ( dword_10648C != v1 )
    abort();
  return result;
}
// 106488: using guessed type int dword_106488;
// 10648C: using guessed type int dword_10648C;

//----- (000000000004DF68) ----------------------------------------------------
_DWORD *sub_4DF68()
{
  int v0; // w21
  _DWORD *result; // x0
  _DWORD *v2; // x20
  int v3; // w19
  __int64 v4; // [xsp+8h] [xbp-28h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_106FB8);
  v0 = dword_106488;
  dword_106FF8 = (unsigned __int8)byte_106FF4;
  CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_106FB8);
  result = (_DWORD *)syscall(278LL);
  if ( result == (int *)((char *)&dword_0 + 1) )
  {
    v3 = -3;
  }
  else
  {
    if ( result != (_DWORD *)-1LL )
      goto LABEL_10;
    v2 = (_DWORD *)__errno();
    if ( *v2 != 11 )
      goto LABEL_10;
    fwrite(
      "getrandom indicates that the entropy pool has not been initialized. Rather than continue with poor entropy, this p"
      "rocess will block until entropy is available.\n",
      0xA0uLL,
      1uLL,
      (FILE *)((char *)&_sF + 304));
    v3 = -3;
    while ( 1 )
    {
      result = (_DWORD *)syscall(278LL);
      if ( result != (_DWORD *)-1LL )
        break;
      if ( *v2 != 4 )
        goto LABEL_10;
    }
    if ( result != (int *)((char *)&dword_0 + 1) )
    {
LABEL_10:
      v3 = v0;
      if ( v0 == -2 )
      {
        while ( 1 )
        {
          v3 = __open_2();
          if ( v3 != -1 )
            break;
          if ( *(_DWORD *)__errno() != 4 )
            goto LABEL_13;
        }
      }
      if ( v3 & 0x80000000 )
LABEL_13:
        abort();
      if ( (unsigned int)fcntl(v3, 1) == -1 )
      {
        result = (_DWORD *)__errno();
        if ( *result != 38 )
          goto LABEL_20;
      }
      else
      {
        result = (_DWORD *)fcntl(v3, 2);
        if ( (_DWORD)result == -1 )
          abort();
      }
    }
  }
  dword_10648C = v3;
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v4 )
LABEL_20:
    abort();
  return result;
}
// 0: using guessed type int dword_0;
// 106488: using guessed type int dword_106488;
// 10648C: using guessed type int dword_10648C;
// 106FF4: using guessed type char byte_106FF4;
// 106FF8: using guessed type int dword_106FF8;

//----- (000000000004E10C) ----------------------------------------------------
__int64 __fastcall RAND_enable_fork_unsafe_buffering(int a1)
{
  int v1; // w19
  __int64 result; // x0

  if ( a1 & 0x80000000 )
  {
    v1 = -2;
  }
  else
  {
    v1 = dup(a1);
    if ( v1 & 0x80000000 )
LABEL_11:
      abort();
  }
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_106FB8);
  byte_106FF4 = 1;
  dword_106488 = v1;
  CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_106FB8);
  result = CRYPTO_once((pthread_once_t *)&unk_106FF0, (void (*)(void))sub_4DF68);
  if ( dword_106FF8 != 1 )
    goto LABEL_11;
  if ( !(v1 & 0x80000000) )
  {
    if ( dword_10648C == -3 )
    {
      result = close(v1);
    }
    else if ( dword_10648C != v1 )
    {
      abort();
    }
  }
  return result;
}
// 106488: using guessed type int dword_106488;
// 10648C: using guessed type int dword_10648C;
// 106FF4: using guessed type char byte_106FF4;
// 106FF8: using guessed type int dword_106FF8;

//----- (000000000004E1C0) ----------------------------------------------------
signed __int64 __fastcall sub_4E1C0(signed __int64 result, size_t a2)
{
  size_t v2; // x19
  char *v3; // x20
  char *v4; // x21
  __int64 v5; // x8
  size_t v6; // x23
  char *v7; // x1
  char *v8; // x22
  __int64 v9; // x8
  char *v10; // x0

  v2 = a2;
  v3 = (char *)result;
  if ( a2 )
  {
    CRYPTO_once((pthread_once_t *)&unk_106FF0, (void (*)(void))sub_4DF68);
    if ( v2 <= 0xFFF && dword_106FF8 )
    {
      v4 = (char *)CRYPTO_get_thread_local(2);
      if ( v4 )
        goto LABEL_5;
      v10 = (char *)malloc(0x1008uLL);
      v4 = v10;
      if ( v10 )
      {
        *(_QWORD *)v10 = 4096LL;
        if ( (unsigned int)CRYPTO_set_thread_local(2u, (__int64)v10, (void (__fastcall *)(__int64))&free) )
        {
LABEL_5:
          v5 = *(_QWORD *)v4;
          v6 = 4096LL - *(_QWORD *)v4;
          v7 = &v4[*(_QWORD *)v4 + 8];
          if ( v6 >= v2 )
          {
            v8 = &v4[*(_QWORD *)v4 + 8];
          }
          else
          {
            v8 = v4 + 8;
            do
            {
              if ( v6 )
              {
                memcpy(v3, v7, v6);
                v5 = *(_QWORD *)v4;
              }
              *(_QWORD *)v4 = v5 + v6;
              result = sub_4E320(v4 + 8, 0x1000uLL);
              if ( !(_BYTE)result )
                abort();
              v2 -= v6;
              v5 = 0LL;
              *(_QWORD *)v4 = 0LL;
              v7 = v4 + 8;
              v3 += v6;
              v6 = 4096LL;
            }
            while ( v2 > 0x1000 );
            if ( !v2 )
            {
              v9 = 0LL;
LABEL_15:
              *(_QWORD *)v4 = v9 + v2;
              return result;
            }
          }
          result = (signed __int64)memcpy(v3, v8, v2);
          v9 = *(_QWORD *)v4;
          goto LABEL_15;
        }
        free(v4);
      }
    }
    result = sub_4E320(v3, v2);
    if ( !(_BYTE)result )
      abort();
  }
  return result;
}
// 106FF8: using guessed type int dword_106FF8;

//----- (000000000004E320) ----------------------------------------------------
signed __int64 __fastcall sub_4E320(char *a1, size_t a2)
{
  size_t v2; // x19
  char *v3; // x20
  int v4; // w0
  __int64 v5; // x0
  __int64 v6; // x8

  v2 = a2;
  v3 = a1;
  while ( v2 )
  {
    v4 = dword_10648C;
    if ( dword_10648C == -3 )
    {
      while ( 1 )
      {
        v5 = syscall(278LL);
        if ( v5 != -1 )
          break;
        if ( *(_DWORD *)__errno() != 4 )
          return 0LL;
      }
    }
    else
    {
      while ( 1 )
      {
        v5 = read(v4, v3, v2);
        if ( v5 != -1 )
          break;
        if ( *(_DWORD *)__errno() != 4 )
          return 0LL;
        v4 = dword_10648C;
      }
    }
    if ( v5 >= 1 )
      v6 = v5;
    else
      v6 = 0LL;
    v3 += v5;
    v2 -= v6;
    if ( v5 <= 0 )
      return 0LL;
  }
  return 1LL;
}
// 10648C: using guessed type int dword_10648C;

//----- (000000000004E3DC) ----------------------------------------------------
_DWORD *__fastcall RC4(_DWORD *result, __int64 a2, char *a3, _BYTE *a4)
{
  __int64 v4; // x8
  __int64 v5; // x9
  signed __int64 v6; // x10
  int v7; // w12
  int v8; // w14
  char v9; // t1

  LODWORD(v5) = *result;
  for ( LODWORD(v4) = result[1]; a2; ++a4 )
  {
    v5 = ((_DWORD)v5 + 1) & 0xFF;
    v6 = (signed __int64)(result + 2);
    v7 = result[v5 + 2];
    --a2;
    v4 = (v7 + (_DWORD)v4) & 0xFF;
    v8 = result[v4 + 2];
    *(_DWORD *)(v6 + 4 * v5) = v8;
    *(_DWORD *)(v6 + 4 * v4) = v7;
    v9 = *a3++;
    *a4 = v9 ^ LOBYTE(result[((v8 + v7) & 0xFF) + 2]);
  }
  *result = v5;
  result[1] = v4;
  return result;
}

//----- (000000000004E438) ----------------------------------------------------
_QWORD *__fastcall RC4_set_key(_QWORD *result, int a2, __int64 a3)
{
  int32x4_t v3; // q0
  __int64 v4; // x8
  int32x4_t v5; // q1
  int32x4_t v6; // q2
  _QWORD *v7; // x9
  int32x4_t v8; // q3
  __int64 v9; // x8
  unsigned int v10; // w11
  unsigned int v11; // w9
  signed __int64 v12; // x10
  int v13; // w12
  signed __int64 v14; // x13

  v3 = (int32x4_t)xmmword_D10D0;
  v4 = 0LL;
  v5.n128_u64[0] = 17179869188LL;
  v5.n128_u64[1] = 17179869188LL;
  v6.n128_u64[0] = 34359738376LL;
  v6.n128_u64[1] = 34359738376LL;
  *result = 0LL;
  do
  {
    v7 = &result[v4];
    v8 = vaddq_s32(v3, v5);
    v4 += 4LL;
    *(int32x4_t *)(v7 + 1) = v3;
    v3 = vaddq_s32(v3, v6);
    *(int32x4_t *)(v7 + 3) = v8;
  }
  while ( v4 != 128 );
  v9 = 0LL;
  v10 = 0;
  v11 = 0;
  v12 = (signed __int64)(result + 1);
  do
  {
    v13 = *(_DWORD *)(v12 + v9);
    v10 = (v13 + v10 + *(unsigned __int8 *)(a3 + v11)) & 0xFF;
    v14 = (signed __int64)result + 4 * v10;
    if ( v11 + 1 == a2 )
      v11 = 0;
    else
      ++v11;
    *(_DWORD *)(v12 + v9) = *(_DWORD *)(v14 + 8);
    v9 += 4LL;
    *(_DWORD *)(v14 + 8) = v13;
  }
  while ( v9 != 1024 );
  return result;
}
// D10D0: using guessed type __int128 xmmword_D10D0;

//----- (000000000004E4C0) ----------------------------------------------------
signed __int64 __fastcall SHA1_Init(_DWORD *a1)
{
  _DWORD *v1; // x19

  v1 = a1;
  memset(a1, 0, 0x60uLL);
  v1[4] = -1009589776;
  *(_OWORD *)v1 = xmmword_D10C0;
  return 1LL;
}
// D10C0: using guessed type __int128 xmmword_D10C0;

//----- (000000000004E504) ----------------------------------------------------
void *__fastcall SHA1(char *a1, size_t a2, _BYTE *a3)
{
  unsigned __int64 v3; // x22
  size_t v4; // x20
  char *v5; // x21
  _BYTE *v6; // x19
  void *result; // x0
  __int128 v8; // [xsp+0h] [xbp-90h]
  int v9; // [xsp+10h] [xbp-80h]
  int v10; // [xsp+14h] [xbp-7Ch]
  __int64 v11; // [xsp+68h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a2;
  v5 = a1;
  if ( a3 )
    v6 = a3;
  else
    v6 = &unk_106FFC;
  v11 = *(_QWORD *)(v3 + 40);
  memset(&v10, 0, 0x4CuLL);
  v8 = xmmword_D10C0;
  v9 = -1009589776;
  SHA1_Update(&v8, v5, v4);
  SHA1_Final(v6, (int *)&v8);
  result = OPENSSL_cleanse(&v8, 0x60uLL);
  if ( *(_QWORD *)(v3 + 40) == v11 )
    result = v6;
  return result;
}
// D10C0: using guessed type __int128 xmmword_D10C0;

//----- (000000000004E5BC) ----------------------------------------------------
signed __int64 __fastcall SHA1_Update(_DWORD *a1, char *a2, size_t a3)
{
  size_t v3; // x19
  char *v4; // x21
  _DWORD *v5; // x20
  int v6; // w10
  int v7; // w8
  int v8; // w9
  __int64 v9; // x8
  _QWORD *v10; // x22
  signed __int64 v11; // x23
  size_t v12; // x22

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v7 = a1[5];
    v6 = a1[6];
    v8 = v7 + 8 * a3;
    if ( __CFADD__(v7, 8 * a3) )
      a1[6] = ++v6;
    v9 = (unsigned int)a1[23];
    a1[5] = v8;
    a1[6] = v6 + (a3 >> 29);
    if ( (_DWORD)v9 )
    {
      if ( ((v9 + a3) | a3) < 0x40 )
      {
        memcpy((char *)a1 + v9 + 28, a2, a3);
        v5[23] += v3;
        return 1LL;
      }
      v10 = a1 + 7;
      v11 = 64 - v9;
      if ( 64 != v9 )
        memcpy((char *)v10 + v9, a2, 64 - v9);
      ((void (__fastcall *)(_DWORD *, _DWORD *, signed __int64))loc_50840)(v5, v5 + 7, 1LL);
      v4 += v11;
      v3 -= v11;
      v5[23] = 0;
      *(_QWORD *)(v5 + 19) = 0LL;
      *(_QWORD *)(v5 + 21) = 0LL;
      *(_QWORD *)(v5 + 15) = 0LL;
      *(_QWORD *)(v5 + 17) = 0LL;
      *(_QWORD *)(v5 + 11) = 0LL;
      *(_QWORD *)(v5 + 13) = 0LL;
      *v10 = 0LL;
      *(_QWORD *)(v5 + 9) = 0LL;
    }
    v12 = v3 >> 6;
    if ( v3 >> 6 )
    {
      ((void (__fastcall *)(_DWORD *, char *, size_t))loc_50840)(v5, v4, v3 >> 6);
      v4 += 64 * v12;
      v3 -= v12 << 6;
    }
    if ( v3 )
    {
      v5[23] = v3;
      memcpy(v5 + 7, v4, v3);
    }
  }
  return 1LL;
}

//----- (000000000004E6DC) ----------------------------------------------------
signed __int64 __fastcall SHA1_Final(_BYTE *a1, int *a2)
{
  int *v2; // x20
  __int64 v3; // x9
  _QWORD *v4; // x21
  _BYTE *v5; // x19
  signed __int64 v6; // x8
  int v7; // w8
  int v8; // w9
  int v9; // w8
  signed __int64 result; // x0
  int v11; // w8
  int v12; // w8
  int v13; // w8
  int v14; // w8

  v2 = a2;
  v3 = (unsigned int)a2[23];
  v4 = a2 + 7;
  v5 = a1;
  *((_BYTE *)a2 + v3 + 28) = -128;
  v6 = v3 + 1;
  if ( (unsigned __int64)(v3 + 1) >= 0x39 )
  {
    if ( 63 != v3 )
      memset((char *)a2 + v6 + 28, 0, 63 - v3);
    ((void (__fastcall *)(int *, _QWORD *, signed __int64))loc_50840)(v2, v4, 1LL);
    v6 = 0LL;
  }
  if ( 56 != v6 )
    memset((char *)v2 + v6 + 28, 0, 56 - v6);
  v8 = v2[5];
  v7 = v2[6];
  *((_BYTE *)v2 + 84) = HIBYTE(v7);
  *((_BYTE *)v2 + 87) = v7;
  *((_BYTE *)v2 + 86) = BYTE1(v7);
  *((_BYTE *)v2 + 88) = HIBYTE(v8);
  *((_BYTE *)v2 + 89) = BYTE2(v8);
  *((_BYTE *)v2 + 85) = BYTE2(v7);
  *((_BYTE *)v2 + 90) = BYTE1(v8);
  *((_BYTE *)v2 + 91) = v8;
  ((void (__fastcall *)(int *, _QWORD *, signed __int64))loc_50840)(v2, v4, 1LL);
  v2[23] = 0;
  v4[6] = 0LL;
  v4[7] = 0LL;
  v4[4] = 0LL;
  v4[5] = 0LL;
  v4[2] = 0LL;
  v4[3] = 0LL;
  *v4 = 0LL;
  v4[1] = 0LL;
  v9 = *v2;
  result = 1LL;
  *v5 = (unsigned int)*v2 >> 24;
  v5[3] = v9;
  v5[1] = BYTE2(v9);
  v5[2] = BYTE1(v9);
  v11 = v2[1];
  v5[4] = HIBYTE(v11);
  v5[7] = v11;
  v5[5] = BYTE2(v11);
  v5[6] = BYTE1(v11);
  v12 = v2[2];
  v5[8] = HIBYTE(v12);
  v5[11] = v12;
  v5[9] = BYTE2(v12);
  v5[10] = BYTE1(v12);
  v13 = v2[3];
  v5[12] = HIBYTE(v13);
  v5[15] = v13;
  v5[13] = BYTE2(v13);
  v5[14] = BYTE1(v13);
  v14 = v2[4];
  v5[16] = HIBYTE(v14);
  v5[17] = BYTE2(v14);
  v5[18] = BYTE1(v14);
  v5[19] = v14;
  return result;
}

//----- (000000000004E870) ----------------------------------------------------
void __fastcall SHA1_Transform(__int128 *a1, _OWORD *a2)
{
  signed __int64 v2; // x2
  int v3; // w20
  int v4; // w21
  int v5; // w22
  int v6; // w23
  int v7; // w24
  unsigned __int64 v8; // t1
  unsigned __int64 v9; // x3
  unsigned __int64 v10; // x4
  unsigned __int64 v11; // t2
  int v12; // w25
  int v13; // w24
  int v14; // w21
  int v15; // w24
  unsigned __int64 v16; // x5
  int v17; // w25
  int v18; // w23
  int v19; // w20
  int v20; // w23
  unsigned __int64 v21; // x6
  int v22; // w25
  int v23; // w22
  int v24; // w24
  int v25; // w22
  unsigned __int64 v26; // x7
  int v27; // w25
  int v28; // w21
  int v29; // w23
  int v30; // w21
  unsigned __int64 v31; // x8
  int v32; // w25
  int v33; // w20
  int v34; // w22
  int v35; // w20
  unsigned __int64 v36; // x9
  int v37; // w25
  int v38; // w24
  int v39; // w21
  int v40; // w24
  unsigned __int64 v41; // x10
  int v42; // w25
  int v43; // w23
  int v44; // w20
  int v45; // w23
  unsigned __int64 v46; // x11
  int v47; // w25
  int v48; // w22
  int v49; // w24
  int v50; // w22
  unsigned __int64 v51; // x12
  int v52; // w25
  int v53; // w21
  int v54; // w23
  int v55; // w21
  unsigned __int64 v56; // x13
  int v57; // w25
  int v58; // w20
  int v59; // w22
  int v60; // w20
  unsigned __int64 v61; // x14
  int v62; // w25
  int v63; // w24
  int v64; // w21
  int v65; // w24
  unsigned __int64 v66; // x15
  int v67; // w25
  int v68; // w23
  int v69; // w20
  int v70; // w23
  unsigned __int64 v71; // x16
  int v72; // w25
  int v73; // w22
  int v74; // w24
  int v75; // w22
  unsigned __int64 v76; // x17
  int v77; // w25
  int v78; // w21
  int v79; // w23
  int v80; // w21
  unsigned __int64 v81; // x19
  int v82; // w25
  int v83; // w20
  int v84; // w22
  int v85; // w20
  int v86; // w25
  int v87; // w24
  int v88; // w21
  int v89; // w24
  int v90; // w25
  int v91; // w23
  int v92; // w20
  int v93; // w23
  int v94; // w25
  int v95; // w22
  int v96; // w24
  int v97; // w22
  int v98; // w25
  int v99; // w21
  int v100; // w23
  int v101; // w21
  int v102; // w25
  int v103; // w20
  int v104; // w22
  int v105; // w20
  int v106; // w25
  int v107; // w24
  int v108; // w21
  int v109; // w24
  int v110; // w25
  int v111; // w23
  int v112; // w20
  int v113; // w23
  int v114; // w25
  int v115; // w22
  int v116; // w24
  int v117; // w22
  int v118; // w25
  int v119; // w21
  int v120; // w23
  int v121; // w21
  int v122; // w25
  int v123; // w20
  int v124; // w22
  int v125; // w20
  int v126; // w25
  int v127; // w24
  int v128; // w21
  int v129; // w24
  int v130; // w25
  int v131; // w23
  int v132; // w20
  int v133; // w23
  int v134; // w25
  int v135; // w22
  int v136; // w24
  int v137; // w22
  int v138; // w25
  int v139; // w21
  int v140; // w23
  int v141; // w21
  int v142; // w25
  int v143; // w20
  int v144; // w22
  int v145; // w20
  int v146; // w25
  int v147; // w24
  int v148; // w21
  int v149; // w24
  int v150; // w25
  int v151; // w23
  int v152; // w20
  int v153; // w23
  int v154; // w25
  int v155; // w22
  int v156; // w24
  int v157; // w22
  int v158; // w25
  int v159; // w21
  int v160; // w23
  int v161; // w21
  int v162; // w25
  int v163; // w20
  int v164; // w22
  int v165; // w20
  int v166; // w25
  int v167; // w24
  int v168; // w21
  int v169; // w24
  int v170; // w25
  int v171; // w23
  int v172; // w20
  int v173; // w23
  int v174; // w25
  int v175; // w22
  int v176; // w24
  int v177; // w22
  int v178; // w25
  int v179; // w21
  int v180; // w23
  int v181; // w21
  int v182; // w25
  int v183; // w20
  int v184; // w22
  int v185; // w20
  int v186; // w24
  int v187; // w25
  int v188; // w21
  int v189; // w24
  int v190; // w23
  int v191; // w25
  int v192; // w20
  int v193; // w23
  int v194; // w22
  int v195; // w25
  int v196; // w24
  int v197; // w22
  int v198; // w21
  int v199; // w25
  int v200; // w23
  int v201; // w21
  int v202; // w20
  int v203; // w25
  int v204; // w22
  int v205; // w20
  int v206; // w24
  int v207; // w25
  int v208; // w21
  int v209; // w24
  int v210; // w23
  int v211; // w25
  int v212; // w20
  int v213; // w23
  int v214; // w22
  int v215; // w25
  int v216; // w24
  int v217; // w22
  int v218; // w21
  int v219; // w25
  int v220; // w23
  int v221; // w21
  int v222; // w20
  int v223; // w25
  int v224; // w22
  int v225; // w20
  int v226; // w24
  int v227; // w25
  int v228; // w21
  int v229; // w24
  int v230; // w23
  int v231; // w25
  int v232; // w20
  int v233; // w23
  int v234; // w22
  int v235; // w25
  int v236; // w24
  int v237; // w22
  int v238; // w21
  int v239; // w25
  int v240; // w23
  int v241; // w21
  int v242; // w20
  int v243; // w25
  int v244; // w22
  int v245; // w20
  int v246; // w24
  int v247; // w25
  int v248; // w21
  int v249; // w24
  int v250; // w23
  int v251; // w25
  int v252; // w20
  int v253; // w23
  int v254; // w22
  int v255; // w25
  int v256; // w24
  int v257; // w22
  int v258; // w21
  int v259; // w25
  int v260; // w23
  int v261; // w21
  int v262; // w26
  int v263; // w25
  int v264; // w20
  int v265; // w22
  int v266; // w20
  int v267; // w25
  int v268; // w24
  int v269; // w21
  int v270; // w24
  int v271; // w25
  int v272; // w23
  int v273; // w20
  int v274; // w23
  int v275; // w25
  int v276; // w22
  int v277; // w24
  int v278; // w22
  int v279; // w25
  int v280; // w21
  int v281; // w23
  int v282; // w21
  int v283; // w25
  int v284; // w20
  int v285; // w22
  int v286; // w20
  int v287; // w25
  int v288; // w24
  int v289; // w21
  int v290; // w24
  int v291; // w25
  int v292; // w23
  int v293; // w20
  int v294; // w23
  int v295; // w25
  int v296; // w22
  int v297; // w24
  int v298; // w22
  int v299; // w25
  int v300; // w21
  int v301; // w23
  int v302; // w21
  int v303; // w25
  int v304; // w20
  int v305; // w22
  int v306; // w20
  int v307; // w25
  int v308; // w24
  int v309; // w21
  int v310; // w24
  int v311; // w25
  int v312; // w23
  int v313; // w20
  int v314; // w23
  int v315; // w25
  int v316; // w22
  int v317; // w24
  int v318; // w22
  int v319; // w25
  int v320; // w21
  int v321; // w23
  int v322; // w21
  int v323; // w25
  int v324; // w20
  int v325; // w22
  int v326; // w20
  int v327; // w25
  int v328; // w24
  int v329; // w21
  int v330; // w24
  int v331; // w25
  int v332; // w23
  int v333; // w20
  int v334; // w23
  int v335; // w25
  int v336; // w22
  int v337; // w24
  int v338; // w22
  int v339; // w25
  int v340; // w21
  int v341; // w23
  int v342; // w21
  int v343; // w27
  int v344; // w25
  __int128 v345; // q0
  int v346; // s1
  __int128 v347; // q4

  v2 = 1LL;
  if ( dword_106E2C & 8 )
  {
    v345 = *a1;
    v346 = *((_DWORD *)a1 + 4);
    v347 = *a2;
    JUMPOUT(*(_QWORD *)&dword_51884);
  }
  v3 = *(_DWORD *)a1;
  v4 = *((_DWORD *)a1 + 1);
  v5 = *((_DWORD *)a1 + 2);
  v6 = *((_DWORD *)a1 + 3);
  v7 = *((_DWORD *)a1 + 4);
  do
  {
    v8 = *(_QWORD *)a2;
    a2 += 4;
    --v2;
    v9 = __rev32(v8);
    v10 = v9 >> 32;
    HIDWORD(v11) = v3;
    LODWORD(v11) = v3;
    v12 = v6 & ~v4 | v5 & v4;
    v13 = v7 + 1518500249 + v9 + (v11 >> 27);
    HIDWORD(v11) = v4;
    LODWORD(v11) = v4;
    v14 = v11 >> 2;
    v15 = v13 + v12;
    v16 = __rev32(*((_QWORD *)a2 - 7));
    HIDWORD(v11) = v15;
    LODWORD(v11) = v15;
    v17 = v5 & ~v3 | v14 & v3;
    v18 = v6 + 1518500249 + HIDWORD(v9) + (v11 >> 27);
    HIDWORD(v11) = v3;
    LODWORD(v11) = v3;
    v19 = v11 >> 2;
    v20 = v18 + v17;
    v21 = v16 >> 32;
    HIDWORD(v11) = v20;
    LODWORD(v11) = v20;
    v22 = v14 & ~v15 | v19 & v15;
    v23 = v5 + 1518500249 + v16 + (v11 >> 27);
    HIDWORD(v11) = v15;
    LODWORD(v11) = v15;
    v24 = v11 >> 2;
    v25 = v23 + v22;
    v26 = __rev32(*((_QWORD *)a2 - 6));
    HIDWORD(v11) = v25;
    LODWORD(v11) = v25;
    v27 = v19 & ~v20 | v24 & v20;
    v28 = v14 + 1518500249 + HIDWORD(v16) + (v11 >> 27);
    HIDWORD(v11) = v20;
    LODWORD(v11) = v20;
    v29 = v11 >> 2;
    v30 = v28 + v27;
    v31 = v26 >> 32;
    HIDWORD(v11) = v30;
    LODWORD(v11) = v30;
    v32 = v24 & ~v25 | v29 & v25;
    v33 = v19 + 1518500249 + v26 + (v11 >> 27);
    HIDWORD(v11) = v25;
    LODWORD(v11) = v25;
    v34 = v11 >> 2;
    v35 = v33 + v32;
    v36 = __rev32(*((_QWORD *)a2 - 5));
    HIDWORD(v11) = v35;
    LODWORD(v11) = v35;
    v37 = v29 & ~v30 | v34 & v30;
    v38 = v24 + 1518500249 + HIDWORD(v26) + (v11 >> 27);
    HIDWORD(v11) = v30;
    LODWORD(v11) = v30;
    v39 = v11 >> 2;
    v40 = v38 + v37;
    v41 = v36 >> 32;
    HIDWORD(v11) = v40;
    LODWORD(v11) = v40;
    v42 = v34 & ~v35 | v39 & v35;
    v43 = v29 + 1518500249 + v36 + (v11 >> 27);
    HIDWORD(v11) = v35;
    LODWORD(v11) = v35;
    v44 = v11 >> 2;
    v45 = v43 + v42;
    v46 = __rev32(*((_QWORD *)a2 - 4));
    HIDWORD(v11) = v45;
    LODWORD(v11) = v45;
    v47 = v39 & ~v40 | v44 & v40;
    v48 = v34 + 1518500249 + HIDWORD(v36) + (v11 >> 27);
    HIDWORD(v11) = v40;
    LODWORD(v11) = v40;
    v49 = v11 >> 2;
    v50 = v48 + v47;
    v51 = v46 >> 32;
    HIDWORD(v11) = v50;
    LODWORD(v11) = v50;
    v52 = v44 & ~v45 | v49 & v45;
    v53 = v39 + 1518500249 + v46 + (v11 >> 27);
    HIDWORD(v11) = v45;
    LODWORD(v11) = v45;
    v54 = v11 >> 2;
    v55 = v53 + v52;
    v56 = __rev32(*((_QWORD *)a2 - 3));
    HIDWORD(v11) = v55;
    LODWORD(v11) = v55;
    v57 = v49 & ~v50 | v54 & v50;
    v58 = v44 + 1518500249 + HIDWORD(v46) + (v11 >> 27);
    HIDWORD(v11) = v50;
    LODWORD(v11) = v50;
    v59 = v11 >> 2;
    v60 = v58 + v57;
    v61 = v56 >> 32;
    HIDWORD(v11) = v60;
    LODWORD(v11) = v60;
    v62 = v54 & ~v55 | v59 & v55;
    v63 = v49 + 1518500249 + v56 + (v11 >> 27);
    HIDWORD(v11) = v55;
    LODWORD(v11) = v55;
    v64 = v11 >> 2;
    v65 = v63 + v62;
    v66 = __rev32(*((_QWORD *)a2 - 2));
    HIDWORD(v11) = v65;
    LODWORD(v11) = v65;
    v67 = v59 & ~v60 | v64 & v60;
    v68 = v54 + 1518500249 + HIDWORD(v56) + (v11 >> 27);
    HIDWORD(v11) = v60;
    LODWORD(v11) = v60;
    v69 = v11 >> 2;
    v70 = v68 + v67;
    v71 = v66 >> 32;
    HIDWORD(v11) = v70;
    LODWORD(v11) = v70;
    v72 = v64 & ~v65 | v69 & v65;
    v73 = v59 + 1518500249 + v66 + (v11 >> 27);
    HIDWORD(v11) = v65;
    LODWORD(v11) = v65;
    v74 = v11 >> 2;
    v75 = v73 + v72;
    v76 = __rev32(*((_QWORD *)a2 - 1));
    HIDWORD(v11) = v75;
    LODWORD(v11) = v75;
    v77 = v69 & ~v70 | v74 & v70;
    v78 = v64 + 1518500249 + HIDWORD(v66) + (v11 >> 27);
    HIDWORD(v11) = v70;
    LODWORD(v11) = v70;
    v79 = v11 >> 2;
    v80 = v78 + v77;
    v81 = v76 >> 32;
    HIDWORD(v11) = v80;
    LODWORD(v11) = v80;
    v82 = v74 & ~v75 | v79 & v75;
    v83 = v69 + 1518500249 + v76 + (v11 >> 27);
    HIDWORD(v11) = v75;
    LODWORD(v11) = v75;
    v84 = v11 >> 2;
    v85 = v83 + v82;
    HIDWORD(v11) = v9 ^ v16 ^ v46 ^ HIDWORD(v66);
    LODWORD(v11) = v9 ^ v16 ^ v46 ^ HIDWORD(v66);
    LODWORD(v9) = v11 >> 31;
    HIDWORD(v11) = v85;
    LODWORD(v11) = v85;
    v86 = v79 & ~v80 | v84 & v80;
    v87 = v74 + 1518500249 + HIDWORD(v76) + (v11 >> 27);
    HIDWORD(v11) = v80;
    LODWORD(v11) = v80;
    v88 = v11 >> 2;
    v89 = v87 + v86;
    HIDWORD(v11) = v10 ^ HIDWORD(v16) ^ HIDWORD(v46) ^ v76;
    LODWORD(v11) = v10 ^ HIDWORD(v16) ^ HIDWORD(v46) ^ v76;
    LODWORD(v10) = v11 >> 31;
    HIDWORD(v11) = v89;
    LODWORD(v11) = v89;
    v90 = v84 & ~v85 | v88 & v85;
    v91 = v79 + 1518500249 + v9 + (v11 >> 27);
    HIDWORD(v11) = v85;
    LODWORD(v11) = v85;
    v92 = v11 >> 2;
    v93 = v91 + v90;
    HIDWORD(v11) = v16 ^ v26 ^ v56 ^ HIDWORD(v76);
    LODWORD(v11) = v16 ^ v26 ^ v56 ^ HIDWORD(v76);
    LODWORD(v16) = v11 >> 31;
    HIDWORD(v11) = v93;
    LODWORD(v11) = v93;
    v94 = v88 & ~v89 | v92 & v89;
    v95 = v84 + 1518500249 + v10 + (v11 >> 27);
    HIDWORD(v11) = v89;
    LODWORD(v11) = v89;
    v96 = v11 >> 2;
    v97 = v95 + v94;
    HIDWORD(v11) = v21 ^ HIDWORD(v26) ^ HIDWORD(v56) ^ v9;
    LODWORD(v11) = v21 ^ HIDWORD(v26) ^ HIDWORD(v56) ^ v9;
    LODWORD(v21) = v11 >> 31;
    HIDWORD(v11) = v97;
    LODWORD(v11) = v97;
    v98 = v92 & ~v93 | v96 & v93;
    v99 = v88 + 1518500249 + v16 + (v11 >> 27);
    HIDWORD(v11) = v93;
    LODWORD(v11) = v93;
    v100 = v11 >> 2;
    v101 = v99 + v98;
    HIDWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v26) = v11 >> 31;
    HIDWORD(v11) = v101;
    LODWORD(v11) = v101;
    v102 = v96 & ~v97 | v100 & v97;
    v103 = v92 + 1518500249 + v21 + (v11 >> 27);
    HIDWORD(v11) = v97;
    LODWORD(v11) = v97;
    v104 = v11 >> 2;
    v105 = v103 + v102;
    HIDWORD(v11) = v31 ^ HIDWORD(v36) ^ HIDWORD(v66) ^ v16;
    LODWORD(v11) = v31 ^ HIDWORD(v36) ^ HIDWORD(v66) ^ v16;
    LODWORD(v31) = v11 >> 31;
    v106 = v100 ^ v101;
    HIDWORD(v11) = v105;
    LODWORD(v11) = v105;
    v107 = v96 + 1859775393 + v26 + (v11 >> 27);
    HIDWORD(v11) = v101;
    LODWORD(v11) = v101;
    v108 = v11 >> 2;
    v109 = v107 + (v106 ^ v104);
    HIDWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v36) = v11 >> 31;
    v110 = v104 ^ v105;
    HIDWORD(v11) = v109;
    LODWORD(v11) = v109;
    v111 = v100 + 1859775393 + v31 + (v11 >> 27);
    HIDWORD(v11) = v105;
    LODWORD(v11) = v105;
    v112 = v11 >> 2;
    v113 = v111 + (v110 ^ v108);
    HIDWORD(v11) = v41 ^ HIDWORD(v46) ^ HIDWORD(v76) ^ v26;
    LODWORD(v11) = v41 ^ HIDWORD(v46) ^ HIDWORD(v76) ^ v26;
    LODWORD(v41) = v11 >> 31;
    v114 = v108 ^ v109;
    HIDWORD(v11) = v113;
    LODWORD(v11) = v113;
    v115 = v104 + 1859775393 + v36 + (v11 >> 27);
    HIDWORD(v11) = v109;
    LODWORD(v11) = v109;
    v116 = v11 >> 2;
    v117 = v115 + (v114 ^ v112);
    HIDWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v46) = v11 >> 31;
    v118 = v112 ^ v113;
    HIDWORD(v11) = v117;
    LODWORD(v11) = v117;
    v119 = v108 + 1859775393 + v41 + (v11 >> 27);
    HIDWORD(v11) = v113;
    LODWORD(v11) = v113;
    v120 = v11 >> 2;
    v121 = v119 + (v118 ^ v116);
    HIDWORD(v11) = v51 ^ HIDWORD(v56) ^ v10 ^ v36;
    LODWORD(v11) = v51 ^ HIDWORD(v56) ^ v10 ^ v36;
    LODWORD(v51) = v11 >> 31;
    v122 = v116 ^ v117;
    HIDWORD(v11) = v121;
    LODWORD(v11) = v121;
    v123 = v112 + 1859775393 + v46 + (v11 >> 27);
    HIDWORD(v11) = v117;
    LODWORD(v11) = v117;
    v124 = v11 >> 2;
    v125 = v123 + (v122 ^ v120);
    HIDWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v56) = v11 >> 31;
    v126 = v120 ^ v121;
    HIDWORD(v11) = v125;
    LODWORD(v11) = v125;
    v127 = v116 + 1859775393 + v51 + (v11 >> 27);
    HIDWORD(v11) = v121;
    LODWORD(v11) = v121;
    v128 = v11 >> 2;
    v129 = v127 + (v126 ^ v124);
    HIDWORD(v11) = v61 ^ HIDWORD(v66) ^ v21 ^ v46;
    LODWORD(v11) = v61 ^ HIDWORD(v66) ^ v21 ^ v46;
    LODWORD(v61) = v11 >> 31;
    v130 = v124 ^ v125;
    HIDWORD(v11) = v129;
    LODWORD(v11) = v129;
    v131 = v120 + 1859775393 + v56 + (v11 >> 27);
    HIDWORD(v11) = v125;
    LODWORD(v11) = v125;
    v132 = v11 >> 2;
    v133 = v131 + (v130 ^ v128);
    HIDWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v66) = v11 >> 31;
    v134 = v128 ^ v129;
    HIDWORD(v11) = v133;
    LODWORD(v11) = v133;
    v135 = v124 + 1859775393 + v61 + (v11 >> 27);
    HIDWORD(v11) = v129;
    LODWORD(v11) = v129;
    v136 = v11 >> 2;
    v137 = v135 + (v134 ^ v132);
    HIDWORD(v11) = v71 ^ HIDWORD(v76) ^ v31 ^ v56;
    LODWORD(v11) = v71 ^ HIDWORD(v76) ^ v31 ^ v56;
    LODWORD(v71) = v11 >> 31;
    v138 = v132 ^ v133;
    HIDWORD(v11) = v137;
    LODWORD(v11) = v137;
    v139 = v128 + 1859775393 + v66 + (v11 >> 27);
    HIDWORD(v11) = v133;
    LODWORD(v11) = v133;
    v140 = v11 >> 2;
    v141 = v139 + (v138 ^ v136);
    HIDWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v76) = v11 >> 31;
    v142 = v136 ^ v137;
    HIDWORD(v11) = v141;
    LODWORD(v11) = v141;
    v143 = v132 + 1859775393 + v71 + (v11 >> 27);
    HIDWORD(v11) = v137;
    LODWORD(v11) = v137;
    v144 = v11 >> 2;
    v145 = v143 + (v142 ^ v140);
    HIDWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v81) = v11 >> 31;
    v146 = v140 ^ v141;
    HIDWORD(v11) = v145;
    LODWORD(v11) = v145;
    v147 = v136 + 1859775393 + v76 + (v11 >> 27);
    HIDWORD(v11) = v141;
    LODWORD(v11) = v141;
    v148 = v11 >> 2;
    v149 = v147 + (v146 ^ v144);
    HIDWORD(v11) = v9 ^ v16 ^ v46 ^ v71;
    LODWORD(v11) = v9 ^ v16 ^ v46 ^ v71;
    LODWORD(v9) = v11 >> 31;
    v150 = v144 ^ v145;
    HIDWORD(v11) = v149;
    LODWORD(v11) = v149;
    v151 = v140 + 1859775393 + v81 + (v11 >> 27);
    HIDWORD(v11) = v145;
    LODWORD(v11) = v145;
    v152 = v11 >> 2;
    v153 = v151 + (v150 ^ v148);
    HIDWORD(v11) = v10 ^ v21 ^ v51 ^ v76;
    LODWORD(v11) = v10 ^ v21 ^ v51 ^ v76;
    LODWORD(v10) = v11 >> 31;
    v154 = v148 ^ v149;
    HIDWORD(v11) = v153;
    LODWORD(v11) = v153;
    v155 = v144 + 1859775393 + v9 + (v11 >> 27);
    HIDWORD(v11) = v149;
    LODWORD(v11) = v149;
    v156 = v11 >> 2;
    v157 = v155 + (v154 ^ v152);
    HIDWORD(v11) = v16 ^ v26 ^ v56 ^ v81;
    LODWORD(v11) = v16 ^ v26 ^ v56 ^ v81;
    LODWORD(v16) = v11 >> 31;
    v158 = v152 ^ v153;
    HIDWORD(v11) = v157;
    LODWORD(v11) = v157;
    v159 = v148 + 1859775393 + v10 + (v11 >> 27);
    HIDWORD(v11) = v153;
    LODWORD(v11) = v153;
    v160 = v11 >> 2;
    v161 = v159 + (v158 ^ v156);
    HIDWORD(v11) = v21 ^ v31 ^ v61 ^ v9;
    LODWORD(v11) = v21 ^ v31 ^ v61 ^ v9;
    LODWORD(v21) = v11 >> 31;
    v162 = v156 ^ v157;
    HIDWORD(v11) = v161;
    LODWORD(v11) = v161;
    v163 = v152 + 1859775393 + v16 + (v11 >> 27);
    HIDWORD(v11) = v157;
    LODWORD(v11) = v157;
    v164 = v11 >> 2;
    v165 = v163 + (v162 ^ v160);
    HIDWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v26) = v11 >> 31;
    v166 = v160 ^ v161;
    HIDWORD(v11) = v165;
    LODWORD(v11) = v165;
    v167 = v156 + 1859775393 + v21 + (v11 >> 27);
    HIDWORD(v11) = v161;
    LODWORD(v11) = v161;
    v168 = v11 >> 2;
    v169 = v167 + (v166 ^ v164);
    HIDWORD(v11) = v31 ^ v41 ^ v71 ^ v16;
    LODWORD(v11) = v31 ^ v41 ^ v71 ^ v16;
    LODWORD(v31) = v11 >> 31;
    v170 = v164 ^ v165;
    HIDWORD(v11) = v169;
    LODWORD(v11) = v169;
    v171 = v160 + 1859775393 + v26 + (v11 >> 27);
    HIDWORD(v11) = v165;
    LODWORD(v11) = v165;
    v172 = v11 >> 2;
    v173 = v171 + (v170 ^ v168);
    HIDWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v36) = v11 >> 31;
    v174 = v168 ^ v169;
    HIDWORD(v11) = v173;
    LODWORD(v11) = v173;
    v175 = v164 + 1859775393 + v31 + (v11 >> 27);
    HIDWORD(v11) = v169;
    LODWORD(v11) = v169;
    v176 = v11 >> 2;
    v177 = v175 + (v174 ^ v172);
    HIDWORD(v11) = v41 ^ v51 ^ v81 ^ v26;
    LODWORD(v11) = v41 ^ v51 ^ v81 ^ v26;
    LODWORD(v41) = v11 >> 31;
    v178 = v172 ^ v173;
    HIDWORD(v11) = v177;
    LODWORD(v11) = v177;
    v179 = v168 + 1859775393 + v36 + (v11 >> 27);
    HIDWORD(v11) = v173;
    LODWORD(v11) = v173;
    v180 = v11 >> 2;
    v181 = v179 + (v178 ^ v176);
    HIDWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v46) = v11 >> 31;
    v182 = v176 ^ v177;
    HIDWORD(v11) = v181;
    LODWORD(v11) = v181;
    v183 = v172 + 1859775393 + v41 + (v11 >> 27);
    HIDWORD(v11) = v177;
    LODWORD(v11) = v177;
    v184 = v11 >> 2;
    v185 = v183 + (v182 ^ v180);
    HIDWORD(v11) = v51 ^ v61 ^ v10 ^ v36;
    LODWORD(v11) = v51 ^ v61 ^ v10 ^ v36;
    LODWORD(v51) = v11 >> 31;
    HIDWORD(v11) = v185;
    LODWORD(v11) = v185;
    v186 = v176 - 1894007588 + v46 + (v11 >> 27);
    v187 = (v181 | v184) & v180 | v181 & v184;
    HIDWORD(v11) = v181;
    LODWORD(v11) = v181;
    v188 = v11 >> 2;
    v189 = v186 + v187;
    HIDWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v56) = v11 >> 31;
    HIDWORD(v11) = v189;
    LODWORD(v11) = v189;
    v190 = v180 - 1894007588 + v51 + (v11 >> 27);
    v191 = (v185 | v188) & v184 | v185 & v188;
    HIDWORD(v11) = v185;
    LODWORD(v11) = v185;
    v192 = v11 >> 2;
    v193 = v190 + v191;
    HIDWORD(v11) = v61 ^ v71 ^ v21 ^ v46;
    LODWORD(v11) = v61 ^ v71 ^ v21 ^ v46;
    LODWORD(v61) = v11 >> 31;
    HIDWORD(v11) = v193;
    LODWORD(v11) = v193;
    v194 = v184 - 1894007588 + v56 + (v11 >> 27);
    v195 = (v189 | v192) & v188 | v189 & v192;
    HIDWORD(v11) = v189;
    LODWORD(v11) = v189;
    v196 = v11 >> 2;
    v197 = v194 + v195;
    HIDWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v66) = v11 >> 31;
    HIDWORD(v11) = v197;
    LODWORD(v11) = v197;
    v198 = v188 - 1894007588 + v61 + (v11 >> 27);
    v199 = (v193 | v196) & v192 | v193 & v196;
    HIDWORD(v11) = v193;
    LODWORD(v11) = v193;
    v200 = v11 >> 2;
    v201 = v198 + v199;
    HIDWORD(v11) = v71 ^ v81 ^ v31 ^ v56;
    LODWORD(v11) = v71 ^ v81 ^ v31 ^ v56;
    LODWORD(v71) = v11 >> 31;
    HIDWORD(v11) = v201;
    LODWORD(v11) = v201;
    v202 = v192 - 1894007588 + v66 + (v11 >> 27);
    v203 = (v197 | v200) & v196 | v197 & v200;
    HIDWORD(v11) = v197;
    LODWORD(v11) = v197;
    v204 = v11 >> 2;
    v205 = v202 + v203;
    HIDWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v76) = v11 >> 31;
    HIDWORD(v11) = v205;
    LODWORD(v11) = v205;
    v206 = v196 - 1894007588 + v71 + (v11 >> 27);
    v207 = (v201 | v204) & v200 | v201 & v204;
    HIDWORD(v11) = v201;
    LODWORD(v11) = v201;
    v208 = v11 >> 2;
    v209 = v206 + v207;
    HIDWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v81) = v11 >> 31;
    HIDWORD(v11) = v209;
    LODWORD(v11) = v209;
    v210 = v200 - 1894007588 + v76 + (v11 >> 27);
    v211 = (v205 | v208) & v204 | v205 & v208;
    HIDWORD(v11) = v205;
    LODWORD(v11) = v205;
    v212 = v11 >> 2;
    v213 = v210 + v211;
    HIDWORD(v11) = v9 ^ v16 ^ v46 ^ v71;
    LODWORD(v11) = v9 ^ v16 ^ v46 ^ v71;
    LODWORD(v9) = v11 >> 31;
    HIDWORD(v11) = v213;
    LODWORD(v11) = v213;
    v214 = v204 - 1894007588 + v81 + (v11 >> 27);
    v215 = (v209 | v212) & v208 | v209 & v212;
    HIDWORD(v11) = v209;
    LODWORD(v11) = v209;
    v216 = v11 >> 2;
    v217 = v214 + v215;
    HIDWORD(v11) = v10 ^ v21 ^ v51 ^ v76;
    LODWORD(v11) = v10 ^ v21 ^ v51 ^ v76;
    LODWORD(v10) = v11 >> 31;
    HIDWORD(v11) = v217;
    LODWORD(v11) = v217;
    v218 = v208 - 1894007588 + v9 + (v11 >> 27);
    v219 = (v213 | v216) & v212 | v213 & v216;
    HIDWORD(v11) = v213;
    LODWORD(v11) = v213;
    v220 = v11 >> 2;
    v221 = v218 + v219;
    HIDWORD(v11) = v16 ^ v26 ^ v56 ^ v81;
    LODWORD(v11) = v16 ^ v26 ^ v56 ^ v81;
    LODWORD(v16) = v11 >> 31;
    HIDWORD(v11) = v221;
    LODWORD(v11) = v221;
    v222 = v212 - 1894007588 + v10 + (v11 >> 27);
    v223 = (v217 | v220) & v216 | v217 & v220;
    HIDWORD(v11) = v217;
    LODWORD(v11) = v217;
    v224 = v11 >> 2;
    v225 = v222 + v223;
    HIDWORD(v11) = v21 ^ v31 ^ v61 ^ v9;
    LODWORD(v11) = v21 ^ v31 ^ v61 ^ v9;
    LODWORD(v21) = v11 >> 31;
    HIDWORD(v11) = v225;
    LODWORD(v11) = v225;
    v226 = v216 - 1894007588 + v16 + (v11 >> 27);
    v227 = (v221 | v224) & v220 | v221 & v224;
    HIDWORD(v11) = v221;
    LODWORD(v11) = v221;
    v228 = v11 >> 2;
    v229 = v226 + v227;
    HIDWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v26) = v11 >> 31;
    HIDWORD(v11) = v229;
    LODWORD(v11) = v229;
    v230 = v220 - 1894007588 + v21 + (v11 >> 27);
    v231 = (v225 | v228) & v224 | v225 & v228;
    HIDWORD(v11) = v225;
    LODWORD(v11) = v225;
    v232 = v11 >> 2;
    v233 = v230 + v231;
    HIDWORD(v11) = v31 ^ v41 ^ v71 ^ v16;
    LODWORD(v11) = v31 ^ v41 ^ v71 ^ v16;
    LODWORD(v31) = v11 >> 31;
    HIDWORD(v11) = v233;
    LODWORD(v11) = v233;
    v234 = v224 - 1894007588 + v26 + (v11 >> 27);
    v235 = (v229 | v232) & v228 | v229 & v232;
    HIDWORD(v11) = v229;
    LODWORD(v11) = v229;
    v236 = v11 >> 2;
    v237 = v234 + v235;
    HIDWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v36) = v11 >> 31;
    HIDWORD(v11) = v237;
    LODWORD(v11) = v237;
    v238 = v228 - 1894007588 + v31 + (v11 >> 27);
    v239 = (v233 | v236) & v232 | v233 & v236;
    HIDWORD(v11) = v233;
    LODWORD(v11) = v233;
    v240 = v11 >> 2;
    v241 = v238 + v239;
    HIDWORD(v11) = v41 ^ v51 ^ v81 ^ v26;
    LODWORD(v11) = v41 ^ v51 ^ v81 ^ v26;
    LODWORD(v41) = v11 >> 31;
    HIDWORD(v11) = v241;
    LODWORD(v11) = v241;
    v242 = v232 - 1894007588 + v36 + (v11 >> 27);
    v243 = (v237 | v240) & v236 | v237 & v240;
    HIDWORD(v11) = v237;
    LODWORD(v11) = v237;
    v244 = v11 >> 2;
    v245 = v242 + v243;
    HIDWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v46) = v11 >> 31;
    HIDWORD(v11) = v245;
    LODWORD(v11) = v245;
    v246 = v236 - 1894007588 + v41 + (v11 >> 27);
    v247 = (v241 | v244) & v240 | v241 & v244;
    HIDWORD(v11) = v241;
    LODWORD(v11) = v241;
    v248 = v11 >> 2;
    v249 = v246 + v247;
    HIDWORD(v11) = v51 ^ v61 ^ v10 ^ v36;
    LODWORD(v11) = v51 ^ v61 ^ v10 ^ v36;
    LODWORD(v51) = v11 >> 31;
    HIDWORD(v11) = v249;
    LODWORD(v11) = v249;
    v250 = v240 - 1894007588 + v46 + (v11 >> 27);
    v251 = (v245 | v248) & v244 | v245 & v248;
    HIDWORD(v11) = v245;
    LODWORD(v11) = v245;
    v252 = v11 >> 2;
    v253 = v250 + v251;
    HIDWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v56) = v11 >> 31;
    HIDWORD(v11) = v253;
    LODWORD(v11) = v253;
    v254 = v244 - 1894007588 + v51 + (v11 >> 27);
    v255 = (v249 | v252) & v248 | v249 & v252;
    HIDWORD(v11) = v249;
    LODWORD(v11) = v249;
    v256 = v11 >> 2;
    v257 = v254 + v255;
    HIDWORD(v11) = v61 ^ v71 ^ v21 ^ v46;
    LODWORD(v11) = v61 ^ v71 ^ v21 ^ v46;
    LODWORD(v61) = v11 >> 31;
    HIDWORD(v11) = v257;
    LODWORD(v11) = v257;
    v258 = v248 - 1894007588 + v56 + (v11 >> 27);
    v259 = (v253 | v256) & v252 | v253 & v256;
    HIDWORD(v11) = v253;
    LODWORD(v11) = v253;
    v260 = v11 >> 2;
    v261 = v258 + v259;
    HIDWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v66) = v11 >> 31;
    v262 = v257 & v260;
    HIDWORD(v11) = v261;
    LODWORD(v11) = v261;
    v263 = (v257 | v260) & v256;
    v264 = v252 - 1894007588 + v61 + (v11 >> 27);
    HIDWORD(v11) = v257;
    LODWORD(v11) = v257;
    v265 = v11 >> 2;
    v266 = v264 + (v263 | v262);
    HIDWORD(v11) = v71 ^ v81 ^ v31 ^ v56;
    LODWORD(v11) = v71 ^ v81 ^ v31 ^ v56;
    LODWORD(v71) = v11 >> 31;
    v267 = v260 ^ v261;
    HIDWORD(v11) = v266;
    LODWORD(v11) = v266;
    v268 = v256 - 899497514 + v66 + (v11 >> 27);
    HIDWORD(v11) = v261;
    LODWORD(v11) = v261;
    v269 = v11 >> 2;
    v270 = v268 + (v267 ^ v265);
    HIDWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v76) = v11 >> 31;
    v271 = v265 ^ v266;
    HIDWORD(v11) = v270;
    LODWORD(v11) = v270;
    v272 = v260 - 899497514 + v71 + (v11 >> 27);
    HIDWORD(v11) = v266;
    LODWORD(v11) = v266;
    v273 = v11 >> 2;
    v274 = v272 + (v271 ^ v269);
    HIDWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v81) = v11 >> 31;
    v275 = v269 ^ v270;
    HIDWORD(v11) = v274;
    LODWORD(v11) = v274;
    v276 = v265 - 899497514 + v76 + (v11 >> 27);
    HIDWORD(v11) = v270;
    LODWORD(v11) = v270;
    v277 = v11 >> 2;
    v278 = v276 + (v275 ^ v273);
    HIDWORD(v11) = v9 ^ v16 ^ v46 ^ v71;
    LODWORD(v11) = v9 ^ v16 ^ v46 ^ v71;
    LODWORD(v9) = v11 >> 31;
    v279 = v273 ^ v274;
    HIDWORD(v11) = v278;
    LODWORD(v11) = v278;
    v280 = v269 - 899497514 + v81 + (v11 >> 27);
    HIDWORD(v11) = v274;
    LODWORD(v11) = v274;
    v281 = v11 >> 2;
    v282 = v280 + (v279 ^ v277);
    HIDWORD(v11) = v10 ^ v21 ^ v51 ^ v76;
    LODWORD(v11) = v10 ^ v21 ^ v51 ^ v76;
    LODWORD(v10) = v11 >> 31;
    v283 = v277 ^ v278;
    HIDWORD(v11) = v282;
    LODWORD(v11) = v282;
    v284 = v273 - 899497514 + v9 + (v11 >> 27);
    HIDWORD(v11) = v278;
    LODWORD(v11) = v278;
    v285 = v11 >> 2;
    v286 = v284 + (v283 ^ v281);
    HIDWORD(v11) = v16 ^ v26 ^ v56 ^ v81;
    LODWORD(v11) = v16 ^ v26 ^ v56 ^ v81;
    LODWORD(v16) = v11 >> 31;
    v287 = v281 ^ v282;
    HIDWORD(v11) = v286;
    LODWORD(v11) = v286;
    v288 = v277 - 899497514 + v10 + (v11 >> 27);
    HIDWORD(v11) = v282;
    LODWORD(v11) = v282;
    v289 = v11 >> 2;
    v290 = v288 + (v287 ^ v285);
    HIDWORD(v11) = v21 ^ v31 ^ v61 ^ v9;
    LODWORD(v11) = v21 ^ v31 ^ v61 ^ v9;
    LODWORD(v21) = v11 >> 31;
    v291 = v285 ^ v286;
    HIDWORD(v11) = v290;
    LODWORD(v11) = v290;
    v292 = v281 - 899497514 + v16 + (v11 >> 27);
    HIDWORD(v11) = v286;
    LODWORD(v11) = v286;
    v293 = v11 >> 2;
    v294 = v292 + (v291 ^ v289);
    HIDWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v11) = v26 ^ v36 ^ v66 ^ v10;
    LODWORD(v26) = v11 >> 31;
    v295 = v289 ^ v290;
    HIDWORD(v11) = v294;
    LODWORD(v11) = v294;
    v296 = v285 - 899497514 + v21 + (v11 >> 27);
    HIDWORD(v11) = v290;
    LODWORD(v11) = v290;
    v297 = v11 >> 2;
    v298 = v296 + (v295 ^ v293);
    HIDWORD(v11) = v31 ^ v41 ^ v71 ^ v16;
    LODWORD(v11) = v31 ^ v41 ^ v71 ^ v16;
    LODWORD(v31) = v11 >> 31;
    v299 = v293 ^ v294;
    HIDWORD(v11) = v298;
    LODWORD(v11) = v298;
    v300 = v289 - 899497514 + v26 + (v11 >> 27);
    HIDWORD(v11) = v294;
    LODWORD(v11) = v294;
    v301 = v11 >> 2;
    v302 = v300 + (v299 ^ v297);
    HIDWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v11) = v36 ^ v46 ^ v76 ^ v21;
    LODWORD(v36) = v11 >> 31;
    v303 = v297 ^ v298;
    HIDWORD(v11) = v302;
    LODWORD(v11) = v302;
    v304 = v293 - 899497514 + v31 + (v11 >> 27);
    HIDWORD(v11) = v298;
    LODWORD(v11) = v298;
    v305 = v11 >> 2;
    v306 = v304 + (v303 ^ v301);
    HIDWORD(v11) = v41 ^ v51 ^ v81 ^ v26;
    LODWORD(v11) = v41 ^ v51 ^ v81 ^ v26;
    LODWORD(v41) = v11 >> 31;
    v307 = v301 ^ v302;
    HIDWORD(v11) = v306;
    LODWORD(v11) = v306;
    v308 = v297 - 899497514 + v36 + (v11 >> 27);
    HIDWORD(v11) = v302;
    LODWORD(v11) = v302;
    v309 = v11 >> 2;
    v310 = v308 + (v307 ^ v305);
    HIDWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v11) = v46 ^ v56 ^ v9 ^ v31;
    LODWORD(v46) = v11 >> 31;
    v311 = v305 ^ v306;
    HIDWORD(v11) = v310;
    LODWORD(v11) = v310;
    v312 = v301 - 899497514 + v41 + (v11 >> 27);
    HIDWORD(v11) = v306;
    LODWORD(v11) = v306;
    v313 = v11 >> 2;
    v314 = v312 + (v311 ^ v309);
    HIDWORD(v11) = v51 ^ v61 ^ v10 ^ v36;
    LODWORD(v11) = v51 ^ v61 ^ v10 ^ v36;
    LODWORD(v51) = v11 >> 31;
    v315 = v309 ^ v310;
    HIDWORD(v11) = v314;
    LODWORD(v11) = v314;
    v316 = v305 - 899497514 + v46 + (v11 >> 27);
    HIDWORD(v11) = v310;
    LODWORD(v11) = v310;
    v317 = v11 >> 2;
    v318 = v316 + (v315 ^ v313);
    HIDWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v11) = v56 ^ v66 ^ v16 ^ v41;
    LODWORD(v56) = v11 >> 31;
    v319 = v313 ^ v314;
    HIDWORD(v11) = v318;
    LODWORD(v11) = v318;
    v320 = v309 - 899497514 + v51 + (v11 >> 27);
    HIDWORD(v11) = v314;
    LODWORD(v11) = v314;
    v321 = v11 >> 2;
    v322 = v320 + (v319 ^ v317);
    HIDWORD(v11) = v61 ^ v71 ^ v21 ^ v46;
    LODWORD(v11) = v61 ^ v71 ^ v21 ^ v46;
    LODWORD(v61) = v11 >> 31;
    v323 = v317 ^ v318;
    HIDWORD(v11) = v322;
    LODWORD(v11) = v322;
    v324 = v313 - 899497514 + v56 + (v11 >> 27);
    HIDWORD(v11) = v318;
    LODWORD(v11) = v318;
    v325 = v11 >> 2;
    v326 = v324 + (v323 ^ v321);
    HIDWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v11) = v66 ^ v76 ^ v26 ^ v51;
    LODWORD(v66) = v11 >> 31;
    v327 = v321 ^ v322;
    HIDWORD(v11) = v326;
    LODWORD(v11) = v326;
    v328 = v317 - 899497514 + v61 + (v11 >> 27);
    HIDWORD(v11) = v322;
    LODWORD(v11) = v322;
    v329 = v11 >> 2;
    v330 = v328 + (v327 ^ v325);
    HIDWORD(v11) = v71 ^ v81 ^ v31 ^ v56;
    LODWORD(v11) = v71 ^ v81 ^ v31 ^ v56;
    LODWORD(v71) = v11 >> 31;
    v331 = v325 ^ v326;
    HIDWORD(v11) = v330;
    LODWORD(v11) = v330;
    v332 = v321 - 899497514 + v66 + (v11 >> 27);
    HIDWORD(v11) = v326;
    LODWORD(v11) = v326;
    v333 = v11 >> 2;
    v334 = v332 + (v331 ^ v329);
    HIDWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v11) = v76 ^ v9 ^ v36 ^ v61;
    LODWORD(v76) = v11 >> 31;
    v335 = v329 ^ v330;
    HIDWORD(v11) = v334;
    LODWORD(v11) = v334;
    v336 = v325 - 899497514 + v71 + (v11 >> 27);
    HIDWORD(v11) = v330;
    LODWORD(v11) = v330;
    v337 = v11 >> 2;
    v338 = v336 + (v335 ^ v333);
    HIDWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v11) = v81 ^ v10 ^ v41 ^ v66;
    LODWORD(v81) = v11 >> 31;
    v339 = v333 ^ v334;
    HIDWORD(v11) = v338;
    LODWORD(v11) = v338;
    v340 = v329 - 899497514 + v76 + (v11 >> 27);
    HIDWORD(v11) = v334;
    LODWORD(v11) = v334;
    v341 = v11 >> 2;
    v342 = v340 + (v339 ^ v337);
    HIDWORD(v11) = v342;
    LODWORD(v11) = v342;
    v343 = v11 >> 27;
    v344 = v337 ^ v338 ^ v341;
    HIDWORD(v11) = v338;
    LODWORD(v11) = v338;
    v4 = v342 + *((_DWORD *)a1 + 1);
    v5 = (v11 >> 2) + *((_DWORD *)a1 + 2);
    v3 = v333 - 899497514 + v81 + v343 + v344 + *(_DWORD *)a1;
    v6 = v341 + *((_DWORD *)a1 + 3);
    v7 = v337 + *((_DWORD *)a1 + 4);
    *(_DWORD *)a1 = v3;
    *((_DWORD *)a1 + 1) = v4;
    *((_DWORD *)a1 + 2) = v5;
    *((_DWORD *)a1 + 3) = v6;
    *((_DWORD *)a1 + 4) = v7;
  }
  while ( v2 );
}
// 51884: using guessed type int;
// 51A40: using guessed type __int64 qword_51A40[8];
// 106E2C: using guessed type int dword_106E2C;

//----- (000000000004E878) ----------------------------------------------------
signed __int64 __fastcall SHA224_Init(_DWORD *a1)
{
  _DWORD *v1; // x19
  signed __int64 result; // x0

  v1 = a1;
  memset(a1, 0, 0x70uLL);
  v1[27] = 28;
  result = 1LL;
  *(_OWORD *)v1 = xmmword_D10E0;
  *((_OWORD *)v1 + 1) = xmmword_D10F0;
  return result;
}
// D10E0: using guessed type __int128 xmmword_D10E0;
// D10F0: using guessed type __int128 xmmword_D10F0;

//----- (000000000004E8C0) ----------------------------------------------------
signed __int64 __fastcall SHA256_Init(_DWORD *a1)
{
  _DWORD *v1; // x19
  signed __int64 result; // x0

  v1 = a1;
  memset(a1, 0, 0x70uLL);
  v1[27] = 32;
  result = 1LL;
  *(_OWORD *)v1 = xmmword_D1100;
  *((_OWORD *)v1 + 1) = xmmword_D1110;
  return result;
}
// D1100: using guessed type __int128 xmmword_D1100;
// D1110: using guessed type __int128 xmmword_D1110;

//----- (000000000004E908) ----------------------------------------------------
void *__fastcall SHA224(char *a1, size_t a2, _BYTE *a3)
{
  unsigned __int64 v3; // x22
  size_t v4; // x20
  char *v5; // x21
  _BYTE *v6; // x19
  void *result; // x0
  __int128 v8; // [xsp+0h] [xbp-A0h]
  __int128 v9; // [xsp+10h] [xbp-90h]
  __int64 v10; // [xsp+20h] [xbp-80h]
  int v11; // [xsp+6Ch] [xbp-34h]
  __int64 v12; // [xsp+78h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a2;
  v5 = a1;
  if ( a3 )
    v6 = a3;
  else
    v6 = &unk_107010;
  v12 = *(_QWORD *)(v3 + 40);
  memset(&v10, 0, 0x4CuLL);
  v8 = xmmword_D10E0;
  v9 = xmmword_D10F0;
  v11 = 28;
  SHA256_Update(&v8, v5, v4);
  SHA256_Final(v6, (int *)&v8);
  result = OPENSSL_cleanse(&v8, 0x70uLL);
  if ( *(_QWORD *)(v3 + 40) == v12 )
    result = v6;
  return result;
}
// D10E0: using guessed type __int128 xmmword_D10E0;
// D10F0: using guessed type __int128 xmmword_D10F0;

//----- (000000000004E9C4) ----------------------------------------------------
signed __int64 __fastcall SHA224_Update(_DWORD *a1, char *a2, size_t a3)
{
  SHA256_Update(a1, a2, a3);
  return 1LL;
}

//----- (000000000004E9E0) ----------------------------------------------------
void *__fastcall SHA256(char *a1, size_t a2, _BYTE *a3)
{
  unsigned __int64 v3; // x22
  size_t v4; // x20
  char *v5; // x21
  _BYTE *v6; // x19
  void *result; // x0
  __int128 v8; // [xsp+0h] [xbp-A0h]
  __int128 v9; // [xsp+10h] [xbp-90h]
  __int64 v10; // [xsp+20h] [xbp-80h]
  int v11; // [xsp+6Ch] [xbp-34h]
  __int64 v12; // [xsp+78h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a2;
  v5 = a1;
  if ( a3 )
    v6 = a3;
  else
    v6 = &unk_10702C;
  v12 = *(_QWORD *)(v3 + 40);
  memset(&v10, 0, 0x4CuLL);
  v8 = xmmword_D1100;
  v9 = xmmword_D1110;
  v11 = 32;
  SHA256_Update(&v8, v5, v4);
  SHA256_Final(v6, (int *)&v8);
  result = OPENSSL_cleanse(&v8, 0x70uLL);
  if ( *(_QWORD *)(v3 + 40) == v12 )
    result = v6;
  return result;
}
// D1100: using guessed type __int128 xmmword_D1100;
// D1110: using guessed type __int128 xmmword_D1110;

//----- (000000000004EA9C) ----------------------------------------------------
signed __int64 __fastcall SHA256_Update(_DWORD *a1, char *a2, size_t a3)
{
  size_t v3; // x19
  char *v4; // x21
  _DWORD *v5; // x20
  int v6; // w10
  int v7; // w8
  int v8; // w9
  __int64 v9; // x8
  _QWORD *v10; // x22
  signed __int64 v11; // x23
  size_t v12; // x22

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v7 = a1[8];
    v6 = a1[9];
    v8 = v7 + 8 * a3;
    if ( __CFADD__(v7, 8 * a3) )
      a1[9] = ++v6;
    v9 = (unsigned int)a1[26];
    a1[8] = v8;
    a1[9] = v6 + (a3 >> 29);
    if ( (_DWORD)v9 )
    {
      if ( ((v9 + a3) | a3) < 0x40 )
      {
        memcpy((char *)a1 + v9 + 40, a2, a3);
        v5[26] += v3;
        return 1LL;
      }
      v10 = a1 + 10;
      v11 = 64 - v9;
      if ( 64 != v9 )
        memcpy((char *)v10 + v9, a2, 64 - v9);
      ((void (__fastcall *)(_DWORD *, _DWORD *, signed __int64))loc_51B00)(v5, v5 + 10, 1LL);
      v4 += v11;
      v3 -= v11;
      v5[26] = 0;
      *((_QWORD *)v5 + 11) = 0LL;
      *((_QWORD *)v5 + 12) = 0LL;
      *((_QWORD *)v5 + 9) = 0LL;
      *((_QWORD *)v5 + 10) = 0LL;
      *((_QWORD *)v5 + 7) = 0LL;
      *((_QWORD *)v5 + 8) = 0LL;
      *v10 = 0LL;
      *((_QWORD *)v5 + 6) = 0LL;
    }
    v12 = v3 >> 6;
    if ( v3 >> 6 )
    {
      ((void (__fastcall *)(_DWORD *, char *, size_t))loc_51B00)(v5, v4, v3 >> 6);
      v4 += 64 * v12;
      v3 -= v12 << 6;
    }
    if ( v3 )
    {
      v5[26] = v3;
      memcpy(v5 + 10, v4, v3);
    }
  }
  return 1LL;
}

//----- (000000000004EBBC) ----------------------------------------------------
signed __int64 __fastcall SHA256_Final(_BYTE *a1, int *a2)
{
  int *v2; // x20
  __int64 v3; // x9
  _QWORD *v4; // x21
  _BYTE *v5; // x19
  signed __int64 v6; // x8
  int v7; // w8
  int v8; // w9
  unsigned int v9; // w8
  int v10; // w8
  int v11; // w8
  int v12; // w8
  int v13; // w8
  int v14; // w8
  int v15; // w8
  int v16; // w8
  int v17; // w8
  int v18; // w8
  int v19; // w8
  int v20; // w8
  int v21; // w8
  int v22; // w8
  int v23; // w8
  int v24; // w8
  unsigned __int64 v26; // x8
  int v27; // w9

  v2 = a2;
  v3 = (unsigned int)a2[26];
  v4 = a2 + 10;
  v5 = a1;
  *((_BYTE *)a2 + v3 + 40) = -128;
  v6 = v3 + 1;
  if ( (unsigned __int64)(v3 + 1) >= 0x39 )
  {
    if ( 63 != v3 )
      memset((char *)a2 + v6 + 40, 0, 63 - v3);
    ((void (__fastcall *)(int *, _QWORD *, signed __int64))loc_51B00)(v2, v4, 1LL);
    v6 = 0LL;
  }
  if ( 56 != v6 )
    memset((char *)v2 + v6 + 40, 0, 56 - v6);
  v8 = v2[8];
  v7 = v2[9];
  *((_BYTE *)v2 + 96) = HIBYTE(v7);
  *((_BYTE *)v2 + 99) = v7;
  *((_BYTE *)v2 + 98) = BYTE1(v7);
  *((_BYTE *)v2 + 100) = HIBYTE(v8);
  *((_BYTE *)v2 + 101) = BYTE2(v8);
  *((_BYTE *)v2 + 97) = BYTE2(v7);
  *((_BYTE *)v2 + 102) = BYTE1(v8);
  *((_BYTE *)v2 + 103) = v8;
  ((void (__fastcall *)(int *, _QWORD *, signed __int64))loc_51B00)(v2, v4, 1LL);
  v2[26] = 0;
  v4[6] = 0LL;
  v4[7] = 0LL;
  v4[4] = 0LL;
  v4[5] = 0LL;
  v4[2] = 0LL;
  v4[3] = 0LL;
  *v4 = 0LL;
  v4[1] = 0LL;
  v9 = v2[27];
  if ( v9 == 28 )
  {
    v18 = *v2;
    *v5 = (unsigned int)*v2 >> 24;
    v5[3] = v18;
    v5[1] = BYTE2(v18);
    v5[2] = BYTE1(v18);
    v19 = v2[1];
    v5[4] = HIBYTE(v19);
    v5[7] = v19;
    v5[5] = BYTE2(v19);
    v5[6] = BYTE1(v19);
    v20 = v2[2];
    v5[8] = HIBYTE(v20);
    v5[11] = v20;
    v5[9] = BYTE2(v20);
    v5[10] = BYTE1(v20);
    v21 = v2[3];
    v5[12] = HIBYTE(v21);
    v5[15] = v21;
    v5[13] = BYTE2(v21);
    v5[14] = BYTE1(v21);
    v22 = v2[4];
    v5[16] = HIBYTE(v22);
    v5[19] = v22;
    v5[17] = BYTE2(v22);
    v5[18] = BYTE1(v22);
    v23 = v2[5];
    v5[20] = HIBYTE(v23);
    v5[23] = v23;
    v5[21] = BYTE2(v23);
    v5[22] = BYTE1(v23);
    v24 = v2[6];
    v5[27] = v24;
    v5[24] = HIBYTE(v24);
    v5[25] = BYTE2(v24);
    v5[26] = BYTE1(v24);
  }
  else if ( v9 == 32 )
  {
    v10 = *v2;
    *v5 = (unsigned int)*v2 >> 24;
    v5[3] = v10;
    v5[1] = BYTE2(v10);
    v5[2] = BYTE1(v10);
    v11 = v2[1];
    v5[4] = HIBYTE(v11);
    v5[7] = v11;
    v5[5] = BYTE2(v11);
    v5[6] = BYTE1(v11);
    v12 = v2[2];
    v5[8] = HIBYTE(v12);
    v5[11] = v12;
    v5[9] = BYTE2(v12);
    v5[10] = BYTE1(v12);
    v13 = v2[3];
    v5[12] = HIBYTE(v13);
    v5[15] = v13;
    v5[13] = BYTE2(v13);
    v5[14] = BYTE1(v13);
    v14 = v2[4];
    v5[16] = HIBYTE(v14);
    v5[19] = v14;
    v5[17] = BYTE2(v14);
    v5[18] = BYTE1(v14);
    v15 = v2[5];
    v5[20] = HIBYTE(v15);
    v5[23] = v15;
    v5[21] = BYTE2(v15);
    v5[22] = BYTE1(v15);
    v16 = v2[6];
    v5[24] = HIBYTE(v16);
    v5[27] = v16;
    v5[25] = BYTE2(v16);
    v5[26] = BYTE1(v16);
    v17 = v2[7];
    v5[31] = v17;
    v5[28] = HIBYTE(v17);
    v5[29] = BYTE2(v17);
    v5[30] = BYTE1(v17);
  }
  else
  {
    if ( v9 > 0x20 )
      return 0LL;
    if ( v9 >= 4 )
    {
      v26 = 0LL;
      do
      {
        v27 = v2[v26++];
        v5[3] = v27;
        *v5 = HIBYTE(v27);
        v5[1] = BYTE2(v27);
        v5[2] = BYTE1(v27);
        v5 += 4;
      }
      while ( v26 < (unsigned int)v2[27] >> 2 );
    }
  }
  return 1LL;
}

//----- (000000000004EEFC) ----------------------------------------------------
void __fastcall SHA256_Transform(int *a1, signed __int64 a2)
{
  int v2; // w20
  int v3; // w21
  int v4; // w22
  int v5; // w23
  int v6; // w24
  int v7; // w25
  int v8; // w26
  int v9; // w27
  int *v10; // x30
  unsigned int *v11; // x1
  unsigned int v12; // w3
  unsigned int v13; // w4
  int *v14; // x30
  int v15; // t1
  unsigned int v16; // w3
  unsigned __int64 v17; // t2
  int v18; // w16
  int v19; // w27
  int v20; // w23
  int v21; // t1
  unsigned int v22; // w4
  unsigned int v23; // w5
  unsigned int v24; // w6
  int v25; // w27
  int v26; // w16
  int v27; // w26
  int v28; // w22
  int v29; // t1
  unsigned int v30; // w5
  int v31; // w26
  int v32; // w16
  int v33; // w25
  int v34; // w21
  int v35; // t1
  unsigned int v36; // w6
  unsigned int v37; // w7
  unsigned int v38; // w8
  int v39; // w25
  int v40; // w16
  int v41; // w24
  int v42; // w20
  int v43; // t1
  unsigned int v44; // w7
  int v45; // w24
  int v46; // w16
  int v47; // w23
  int v48; // w27
  int v49; // t1
  unsigned int v50; // w8
  unsigned int v51; // w9
  unsigned int v52; // w10
  int v53; // w23
  int v54; // w16
  int v55; // w22
  int v56; // w26
  int v57; // t1
  unsigned int v58; // w9
  int v59; // w22
  int v60; // w16
  int v61; // w21
  int v62; // w25
  int v63; // t1
  unsigned int v64; // w10
  unsigned int v65; // w11
  unsigned int v66; // w12
  int v67; // w21
  int v68; // w16
  int v69; // w20
  int v70; // w24
  int v71; // t1
  unsigned int v72; // w11
  int v73; // w20
  int v74; // w16
  int v75; // w27
  int v76; // w23
  int v77; // t1
  unsigned int v78; // w12
  unsigned int v79; // w13
  unsigned int v80; // w14
  int v81; // w27
  int v82; // w16
  int v83; // w26
  int v84; // w22
  int v85; // t1
  unsigned int v86; // w13
  int v87; // w26
  int v88; // w16
  int v89; // w25
  int v90; // w21
  int v91; // t1
  unsigned int v92; // w14
  unsigned int v93; // w0
  unsigned int v94; // w15
  int v95; // w25
  int v96; // w16
  int v97; // w24
  int v98; // w20
  int v99; // t1
  unsigned int v100; // w15
  int v101; // w24
  int v102; // w16
  int v103; // w23
  int v104; // w27
  int v105; // t1
  unsigned int v106; // w0
  unsigned int v107; // w2
  int v108; // w23
  int v109; // w16
  int v110; // w22
  int v111; // w26
  int v112; // t1
  unsigned int v113; // w1
  int v114; // w22
  int v115; // w16
  int v116; // w21
  int v117; // w25
  int v118; // t1
  unsigned int v119; // w2
  int v120; // w21
  int v121; // w16
  int v122; // w9
  int v123; // w8
  int v124; // w28
  int v125; // w20
  int v126; // w24
  int v127; // w19
  int *v128; // x30
  int v129; // t1
  int v130; // w20
  unsigned int v131; // w3
  unsigned int v132; // w8
  unsigned int v133; // ST00_4
  int v134; // w16
  unsigned __int64 v135; // t2
  int v136; // w10
  int v137; // w9
  int v138; // w27
  int v139; // w23
  int *v140; // x30
  int v141; // t1
  int v142; // w27
  unsigned int v143; // w4
  unsigned int v144; // w9
  unsigned int v145; // ST04_4
  int v146; // w16
  int v147; // w11
  int v148; // w10
  int v149; // w26
  int v150; // w22
  int v151; // t1
  int v152; // w26
  unsigned int v153; // w5
  unsigned int v154; // w10
  unsigned int v155; // ST08_4
  int v156; // w16
  int v157; // w12
  int v158; // w11
  int v159; // w25
  int v160; // w21
  int v161; // t1
  int v162; // w25
  unsigned int v163; // w6
  unsigned int v164; // w11
  unsigned int v165; // ST0C_4
  int v166; // w16
  int v167; // w13
  int v168; // w12
  int v169; // w24
  int v170; // w20
  int v171; // t1
  int v172; // w24
  unsigned int v173; // w7
  unsigned int v174; // w12
  unsigned int v175; // ST00_4
  int v176; // w16
  int v177; // w14
  int v178; // w13
  int v179; // w23
  int v180; // w27
  int v181; // t1
  int v182; // w23
  unsigned int v183; // w8
  unsigned int v184; // w13
  unsigned int v185; // ST04_4
  int v186; // w16
  int v187; // w15
  int v188; // w14
  int v189; // w22
  int v190; // w26
  int v191; // t1
  int v192; // w22
  unsigned int v193; // w9
  unsigned int v194; // w14
  unsigned int v195; // ST08_4
  int v196; // w16
  int v197; // w0
  int v198; // w15
  int v199; // w21
  int v200; // w25
  int v201; // t1
  int v202; // w21
  unsigned int v203; // w10
  unsigned int v204; // w15
  unsigned int v205; // ST0C_4
  int v206; // w16
  int v207; // w1
  int v208; // w0
  int v209; // w20
  int v210; // w24
  int v211; // t1
  int v212; // w20
  unsigned int v213; // w0
  unsigned int v214; // ST00_4
  int v215; // w16
  int v216; // w2
  int v217; // w1
  int v218; // w27
  int v219; // w23
  int v220; // t1
  int v221; // w27
  unsigned int v222; // w1
  unsigned int v223; // ST04_4
  int v224; // w16
  int v225; // w3
  int v226; // w2
  int v227; // w26
  int v228; // w22
  int v229; // t1
  int v230; // w26
  unsigned int v231; // w2
  unsigned int v232; // ST08_4
  int v233; // w16
  int v234; // w4
  int v235; // w3
  int v236; // w25
  int v237; // w21
  int v238; // t1
  int v239; // w25
  unsigned int v240; // w3
  unsigned int v241; // ST0C_4
  int v242; // w16
  int v243; // w5
  int v244; // w4
  int v245; // w24
  int v246; // w20
  int v247; // t1
  int v248; // w24
  unsigned int v249; // ST00_4
  int v250; // w16
  int v251; // w6
  int v252; // w5
  int v253; // w23
  int v254; // t1
  int v255; // w16
  int v256; // w7
  int v257; // w6
  int v258; // w22
  int v259; // t1
  int v260; // w16
  int v261; // w8
  int v262; // w7
  int v263; // w21
  int v264; // t1
  int v265; // w16
  int v266; // w9
  int v267; // w8
  int v268; // w20
  int v269; // t1
  int v270; // w7
  int v271; // w8
  int v272; // w9
  int v273; // w10
  __int128 v274; // q0
  __int128 v275; // q4
  unsigned int v276; // [xsp+4h] [xbp-8Ch]
  unsigned int v277; // [xsp+8h] [xbp-88h]
  unsigned int v278; // [xsp+Ch] [xbp-84h]
  int *v279; // [xsp+70h] [xbp-20h]
  signed __int64 v280; // [xsp+78h] [xbp-18h]
  unsigned int *v281; // [xsp+80h] [xbp-10h]

  if ( dword_106E2C & 0x10 )
  {
    v274 = *(_OWORD *)a1;
    v275 = *(_OWORD *)a2;
    JUMPOUT(*(_QWORD *)&dword_52AFC);
  }
  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = a1[7];
  v10 = &dword_52940;
  v279 = a1;
  v280 = a2 + 64;
  do
  {
    v12 = *(_DWORD *)a2;
    v13 = *(_DWORD *)(a2 + 4);
    v11 = (unsigned int *)(a2 + 8);
    v15 = *v10;
    v14 = v10 + 1;
    v281 = v11;
    v16 = bswap32(v12);
    HIDWORD(v17) = v6;
    LODWORD(v17) = v6;
    v18 = (v17 >> 6) ^ __ROR4__(v6 ^ __ROR4__(v6, 14), 11);
    HIDWORD(v17) = v2;
    LODWORD(v17) = v2;
    v19 = v9 + v15 + v16 + (v7 & v6 | v8 & ~v6) + v18;
    v20 = v5 + v19;
    v21 = *v14;
    ++v14;
    v22 = bswap32(v13);
    v23 = *v11;
    v24 = v11[1];
    v11 += 2;
    v25 = v19 + ((v3 ^ v4) & (v2 ^ v3) ^ v3) + ((v17 >> 2) ^ __ROR4__(v2 ^ __ROR4__(v2, 9), 13));
    HIDWORD(v17) = v20;
    LODWORD(v17) = v20;
    v26 = (v17 >> 6) ^ __ROR4__(v20 ^ __ROR4__(v20, 14), 11);
    HIDWORD(v17) = v25;
    LODWORD(v17) = v25;
    v27 = v8 + v21 + v22 + (v6 & v20 | v7 & ~v20) + v26;
    v28 = v4 + v27;
    v29 = *v14;
    ++v14;
    v30 = bswap32(v23);
    v31 = v27 + ((v2 ^ v3) & (v25 ^ v2) ^ v2) + ((v17 >> 2) ^ __ROR4__(v25 ^ __ROR4__(v25, 9), 13));
    HIDWORD(v17) = v28;
    LODWORD(v17) = v28;
    v32 = (v17 >> 6) ^ __ROR4__(v28 ^ __ROR4__(v28, 14), 11);
    HIDWORD(v17) = v31;
    LODWORD(v17) = v31;
    v33 = v7 + v29 + v30 + (v20 & v28 | v6 & ~v28) + v32;
    v34 = v3 + v33;
    v35 = *v14;
    ++v14;
    v36 = bswap32(v24);
    v37 = *v11;
    v38 = v11[1];
    v11 += 2;
    v39 = v33 + ((v25 ^ v2) & (v31 ^ v25) ^ v25) + ((v17 >> 2) ^ __ROR4__(v31 ^ __ROR4__(v31, 9), 13));
    HIDWORD(v17) = v34;
    LODWORD(v17) = v34;
    v40 = (v17 >> 6) ^ __ROR4__(v34 ^ __ROR4__(v34, 14), 11);
    HIDWORD(v17) = v39;
    LODWORD(v17) = v39;
    v41 = v6 + v35 + v36 + (v28 & v34 | v20 & ~v34) + v40;
    v42 = v2 + v41;
    v43 = *v14;
    ++v14;
    v44 = bswap32(v37);
    v45 = v41 + ((v31 ^ v25) & (v39 ^ v31) ^ v31) + ((v17 >> 2) ^ __ROR4__(v39 ^ __ROR4__(v39, 9), 13));
    HIDWORD(v17) = v42;
    LODWORD(v17) = v42;
    v46 = (v17 >> 6) ^ __ROR4__(v42 ^ __ROR4__(v42, 14), 11);
    HIDWORD(v17) = v45;
    LODWORD(v17) = v45;
    v47 = v20 + v43 + v44 + (v34 & v42 | v28 & ~v42) + v46;
    v48 = v25 + v47;
    v49 = *v14;
    ++v14;
    v50 = bswap32(v38);
    v51 = *v11;
    v52 = v11[1];
    v11 += 2;
    v53 = v47 + ((v39 ^ v31) & (v45 ^ v39) ^ v39) + ((v17 >> 2) ^ __ROR4__(v45 ^ __ROR4__(v45, 9), 13));
    HIDWORD(v17) = v48;
    LODWORD(v17) = v48;
    v54 = (v17 >> 6) ^ __ROR4__(v48 ^ __ROR4__(v48, 14), 11);
    HIDWORD(v17) = v53;
    LODWORD(v17) = v53;
    v55 = v28 + v49 + v50 + (v42 & v48 | v34 & ~v48) + v54;
    v56 = v31 + v55;
    v57 = *v14;
    ++v14;
    v58 = bswap32(v51);
    v59 = v55 + ((v45 ^ v39) & (v53 ^ v45) ^ v45) + ((v17 >> 2) ^ __ROR4__(v53 ^ __ROR4__(v53, 9), 13));
    HIDWORD(v17) = v56;
    LODWORD(v17) = v56;
    v60 = (v17 >> 6) ^ __ROR4__(v56 ^ __ROR4__(v56, 14), 11);
    HIDWORD(v17) = v59;
    LODWORD(v17) = v59;
    v61 = v34 + v57 + v58 + (v48 & v56 | v42 & ~v56) + v60;
    v62 = v39 + v61;
    v63 = *v14;
    ++v14;
    v64 = bswap32(v52);
    v65 = *v11;
    v66 = v11[1];
    v11 += 2;
    v67 = v61 + ((v53 ^ v45) & (v59 ^ v53) ^ v53) + ((v17 >> 2) ^ __ROR4__(v59 ^ __ROR4__(v59, 9), 13));
    HIDWORD(v17) = v62;
    LODWORD(v17) = v62;
    v68 = (v17 >> 6) ^ __ROR4__(v62 ^ __ROR4__(v62, 14), 11);
    HIDWORD(v17) = v67;
    LODWORD(v17) = v67;
    v69 = v42 + v63 + v64 + (v56 & v62 | v48 & ~v62) + v68;
    v70 = v45 + v69;
    v71 = *v14;
    ++v14;
    v72 = bswap32(v65);
    v73 = v69 + ((v59 ^ v53) & (v67 ^ v59) ^ v59) + ((v17 >> 2) ^ __ROR4__(v67 ^ __ROR4__(v67, 9), 13));
    HIDWORD(v17) = v70;
    LODWORD(v17) = v70;
    v74 = (v17 >> 6) ^ __ROR4__(v70 ^ __ROR4__(v70, 14), 11);
    HIDWORD(v17) = v73;
    LODWORD(v17) = v73;
    v75 = v48 + v71 + v72 + (v62 & v70 | v56 & ~v70) + v74;
    v76 = v53 + v75;
    v77 = *v14;
    ++v14;
    v78 = bswap32(v66);
    v79 = *v11;
    v80 = v11[1];
    v11 += 2;
    v81 = v75 + ((v67 ^ v59) & (v73 ^ v67) ^ v67) + ((v17 >> 2) ^ __ROR4__(v73 ^ __ROR4__(v73, 9), 13));
    HIDWORD(v17) = v76;
    LODWORD(v17) = v76;
    v82 = (v17 >> 6) ^ __ROR4__(v76 ^ __ROR4__(v76, 14), 11);
    HIDWORD(v17) = v81;
    LODWORD(v17) = v81;
    v83 = v56 + v77 + v78 + (v70 & v76 | v62 & ~v76) + v82;
    v84 = v59 + v83;
    v85 = *v14;
    ++v14;
    v86 = bswap32(v79);
    v87 = v83 + ((v73 ^ v67) & (v81 ^ v73) ^ v73) + ((v17 >> 2) ^ __ROR4__(v81 ^ __ROR4__(v81, 9), 13));
    HIDWORD(v17) = v84;
    LODWORD(v17) = v84;
    v88 = (v17 >> 6) ^ __ROR4__(v84 ^ __ROR4__(v84, 14), 11);
    HIDWORD(v17) = v87;
    LODWORD(v17) = v87;
    v89 = v62 + v85 + v86 + (v76 & v84 | v70 & ~v84) + v88;
    v90 = v67 + v89;
    v91 = *v14;
    ++v14;
    v92 = bswap32(v80);
    v94 = *v11;
    v93 = v11[1];
    v11 += 2;
    v95 = v89 + ((v81 ^ v73) & (v87 ^ v81) ^ v81) + ((v17 >> 2) ^ __ROR4__(v87 ^ __ROR4__(v87, 9), 13));
    HIDWORD(v17) = v90;
    LODWORD(v17) = v90;
    v96 = (v17 >> 6) ^ __ROR4__(v90 ^ __ROR4__(v90, 14), 11);
    HIDWORD(v17) = v95;
    LODWORD(v17) = v95;
    v97 = v70 + v91 + v92 + (v84 & v90 | v76 & ~v90) + v96;
    v98 = v73 + v97;
    v99 = *v14;
    ++v14;
    v100 = bswap32(v94);
    v101 = v97 + ((v87 ^ v81) & (v95 ^ v87) ^ v87) + ((v17 >> 2) ^ __ROR4__(v95 ^ __ROR4__(v95, 9), 13));
    HIDWORD(v17) = v98;
    LODWORD(v17) = v98;
    v102 = (v17 >> 6) ^ __ROR4__(v98 ^ __ROR4__(v98, 14), 11);
    HIDWORD(v17) = v101;
    LODWORD(v17) = v101;
    v103 = v76 + v99 + v100 + (v90 & v98 | v84 & ~v98) + v102;
    v104 = v81 + v103;
    v105 = *v14;
    ++v14;
    v106 = bswap32(v93);
    v107 = v11[1];
    v108 = v103 + ((v95 ^ v87) & (v101 ^ v95) ^ v95) + ((v17 >> 2) ^ __ROR4__(v101 ^ __ROR4__(v101, 9), 13));
    v276 = v50;
    HIDWORD(v17) = v104;
    LODWORD(v17) = v104;
    v109 = (v17 >> 6) ^ __ROR4__(v104 ^ __ROR4__(v104, 14), 11);
    HIDWORD(v17) = v108;
    LODWORD(v17) = v108;
    v110 = v84 + v105 + v106 + (v98 & v104 | v90 & ~v104) + v109;
    v111 = v87 + v110;
    v112 = *v14;
    ++v14;
    v113 = bswap32(*v11);
    v114 = v110 + ((v101 ^ v95) & (v108 ^ v101) ^ v101) + ((v17 >> 2) ^ __ROR4__(v108 ^ __ROR4__(v108, 9), 13));
    v277 = v58;
    HIDWORD(v17) = v111;
    LODWORD(v17) = v111;
    v115 = (v17 >> 6) ^ __ROR4__(v111 ^ __ROR4__(v111, 14), 11);
    HIDWORD(v17) = v114;
    LODWORD(v17) = v114;
    v116 = v90 + v112 + v113 + (v104 & v111 | v98 & ~v111) + v115;
    v117 = v95 + v116;
    v118 = *v14;
    ++v14;
    v119 = bswap32(v107);
    v120 = v116 + ((v108 ^ v101) & (v114 ^ v108) ^ v108) + ((v17 >> 2) ^ __ROR4__(v114 ^ __ROR4__(v114, 9), 13));
    v278 = v64;
    HIDWORD(v17) = v117;
    LODWORD(v17) = v117;
    v121 = v17 >> 6;
    HIDWORD(v17) = v22;
    LODWORD(v17) = v22;
    v122 = v17 >> 7;
    HIDWORD(v17) = v113;
    LODWORD(v17) = v113;
    v123 = v17 >> 17;
    HIDWORD(v17) = v120;
    LODWORD(v17) = v120;
    v124 = v120 ^ v114;
    v125 = v98 + v118 + v119 + (v111 & v117 | v104 & ~v117) + (v121 ^ __ROR4__(v117, 11) ^ __ROR4__(v117, 25));
    v126 = v101 + v125;
    v129 = *v14;
    v128 = v14 + 1;
    v127 = v129;
    v130 = v125 + ((v114 ^ v108) & (v120 ^ v114) ^ v114) + ((v17 >> 2) ^ __ROR4__(v120, 13) ^ __ROR4__(v120, 22));
    v131 = v16 + v78 + (v122 ^ __ROR4__(v22, 18) ^ (v22 >> 3)) + (v123 ^ __ROR4__(v113, 19) ^ (v113 >> 10));
    do
    {
      v132 = v276;
      v133 = v72;
      HIDWORD(v135) = v126;
      LODWORD(v135) = v126;
      v134 = v135 >> 6;
      HIDWORD(v135) = v30;
      LODWORD(v135) = v30;
      v136 = v135 >> 7;
      HIDWORD(v135) = v119;
      LODWORD(v135) = v119;
      v137 = v135 >> 17;
      HIDWORD(v135) = v130;
      LODWORD(v135) = v130;
      v138 = v104 + v127 + v131 + (v117 & v126 | v111 & ~v126) + (v134 ^ __ROR4__(v126, 11) ^ __ROR4__(v126, 25));
      v139 = v108 + v138;
      v141 = *v128;
      v140 = v128 + 1;
      v142 = v138 + (v124 & (v130 ^ v120) ^ v120) + ((v135 >> 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22));
      v143 = v22 + v86 + (v136 ^ __ROR4__(v30, 18) ^ (v30 >> 3)) + (v137 ^ __ROR4__(v119, 19) ^ (v119 >> 10));
      v144 = v277;
      v145 = v78;
      HIDWORD(v135) = v139;
      LODWORD(v135) = v139;
      v146 = v135 >> 6;
      HIDWORD(v135) = v36;
      LODWORD(v135) = v36;
      v147 = v135 >> 7;
      HIDWORD(v135) = v131;
      LODWORD(v135) = v131;
      v148 = v135 >> 17;
      HIDWORD(v135) = v142;
      LODWORD(v135) = v142;
      v149 = v111 + v141 + v143 + (v126 & v139 | v117 & ~v139) + (v146 ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25));
      v150 = v114 + v149;
      v151 = *v140;
      ++v140;
      v152 = v149 + ((v130 ^ v120) & (v142 ^ v130) ^ v130) + ((v135 >> 2) ^ __ROR4__(v142, 13) ^ __ROR4__(v142, 22));
      v153 = v30 + v92 + (v147 ^ __ROR4__(v36, 18) ^ (v36 >> 3)) + (v148 ^ __ROR4__(v131, 19) ^ (v131 >> 10));
      v154 = v278;
      v155 = v86;
      HIDWORD(v135) = v150;
      LODWORD(v135) = v150;
      v156 = v135 >> 6;
      HIDWORD(v135) = v44;
      LODWORD(v135) = v44;
      v157 = v135 >> 7;
      HIDWORD(v135) = v143;
      LODWORD(v135) = v143;
      v158 = v135 >> 17;
      HIDWORD(v135) = v152;
      LODWORD(v135) = v152;
      v159 = v117 + v151 + v153 + (v139 & v150 | v126 & ~v150) + (v156 ^ __ROR4__(v150, 11) ^ __ROR4__(v150, 25));
      v160 = v120 + v159;
      v161 = *v140;
      ++v140;
      v162 = v159 + ((v142 ^ v130) & (v152 ^ v142) ^ v142) + ((v135 >> 2) ^ __ROR4__(v152, 13) ^ __ROR4__(v152, 22));
      v163 = v36 + v100 + (v157 ^ __ROR4__(v44, 18) ^ (v44 >> 3)) + (v158 ^ __ROR4__(v143, 19) ^ (v143 >> 10));
      v164 = v133;
      v165 = v92;
      HIDWORD(v135) = v160;
      LODWORD(v135) = v160;
      v166 = v135 >> 6;
      HIDWORD(v135) = v132;
      LODWORD(v135) = v132;
      v167 = v135 >> 7;
      HIDWORD(v135) = v153;
      LODWORD(v135) = v153;
      v168 = v135 >> 17;
      HIDWORD(v135) = v162;
      LODWORD(v135) = v162;
      v169 = v126 + v161 + v163 + (v150 & v160 | v139 & ~v160) + (v166 ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25));
      v170 = v130 + v169;
      v171 = *v140;
      ++v140;
      v172 = v169 + ((v152 ^ v142) & (v162 ^ v152) ^ v152) + ((v135 >> 2) ^ __ROR4__(v162, 13) ^ __ROR4__(v162, 22));
      v173 = v44 + v106 + (v167 ^ __ROR4__(v132, 18) ^ (v132 >> 3)) + (v168 ^ __ROR4__(v153, 19) ^ (v153 >> 10));
      v174 = v145;
      v175 = v100;
      HIDWORD(v135) = v170;
      LODWORD(v135) = v170;
      v176 = v135 >> 6;
      HIDWORD(v135) = v144;
      LODWORD(v135) = v144;
      v177 = v135 >> 7;
      HIDWORD(v135) = v163;
      LODWORD(v135) = v163;
      v178 = v135 >> 17;
      HIDWORD(v135) = v172;
      LODWORD(v135) = v172;
      v179 = v139 + v171 + v173 + (v160 & v170 | v150 & ~v170) + (v176 ^ __ROR4__(v170, 11) ^ __ROR4__(v170, 25));
      v180 = v142 + v179;
      v181 = *v140;
      ++v140;
      v182 = v179 + ((v162 ^ v152) & (v172 ^ v162) ^ v162) + ((v135 >> 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22));
      v183 = v132 + v113 + (v177 ^ __ROR4__(v144, 18) ^ (v144 >> 3)) + (v178 ^ __ROR4__(v163, 19) ^ (v163 >> 10));
      v184 = v155;
      v185 = v106;
      HIDWORD(v135) = v180;
      LODWORD(v135) = v180;
      v186 = v135 >> 6;
      HIDWORD(v135) = v154;
      LODWORD(v135) = v154;
      v187 = v135 >> 7;
      HIDWORD(v135) = v173;
      LODWORD(v135) = v173;
      v188 = v135 >> 17;
      HIDWORD(v135) = v182;
      LODWORD(v135) = v182;
      v189 = v150 + v181 + v183 + (v170 & v180 | v160 & ~v180) + (v186 ^ __ROR4__(v180, 11) ^ __ROR4__(v180, 25));
      v190 = v152 + v189;
      v191 = *v140;
      ++v140;
      v192 = v189 + ((v172 ^ v162) & (v182 ^ v172) ^ v172) + ((v135 >> 2) ^ __ROR4__(v182, 13) ^ __ROR4__(v182, 22));
      v193 = v144 + v119 + (v187 ^ __ROR4__(v154, 18) ^ (v154 >> 3)) + (v188 ^ __ROR4__(v173, 19) ^ (v173 >> 10));
      v194 = v165;
      v195 = v113;
      HIDWORD(v135) = v190;
      LODWORD(v135) = v190;
      v196 = v135 >> 6;
      HIDWORD(v135) = v164;
      LODWORD(v135) = v164;
      v197 = v135 >> 7;
      HIDWORD(v135) = v183;
      LODWORD(v135) = v183;
      v198 = v135 >> 17;
      HIDWORD(v135) = v192;
      LODWORD(v135) = v192;
      v199 = v160 + v191 + v193 + (v180 & v190 | v170 & ~v190) + (v196 ^ __ROR4__(v190, 11) ^ __ROR4__(v190, 25));
      v200 = v162 + v199;
      v201 = *v140;
      ++v140;
      v202 = v199 + ((v182 ^ v172) & (v192 ^ v182) ^ v182) + ((v135 >> 2) ^ __ROR4__(v192, 13) ^ __ROR4__(v192, 22));
      v203 = v154 + v131 + (v197 ^ __ROR4__(v164, 18) ^ (v164 >> 3)) + (v198 ^ __ROR4__(v183, 19) ^ (v183 >> 10));
      v204 = v175;
      v205 = v119;
      HIDWORD(v135) = v200;
      LODWORD(v135) = v200;
      v206 = v135 >> 6;
      HIDWORD(v135) = v174;
      LODWORD(v135) = v174;
      v207 = v135 >> 7;
      HIDWORD(v135) = v193;
      LODWORD(v135) = v193;
      v208 = v135 >> 17;
      HIDWORD(v135) = v202;
      LODWORD(v135) = v202;
      v209 = v170 + v201 + v203 + (v190 & v200 | v180 & ~v200) + (v206 ^ __ROR4__(v200, 11) ^ __ROR4__(v200, 25));
      v210 = v172 + v209;
      v211 = *v140;
      ++v140;
      v212 = v209 + ((v192 ^ v182) & (v202 ^ v192) ^ v192) + ((v135 >> 2) ^ __ROR4__(v202, 13) ^ __ROR4__(v202, 22));
      v72 = v164 + v143 + (v207 ^ __ROR4__(v174, 18) ^ (v174 >> 3)) + (v208 ^ __ROR4__(v193, 19) ^ (v193 >> 10));
      v213 = v185;
      v214 = v131;
      HIDWORD(v135) = v210;
      LODWORD(v135) = v210;
      v215 = v135 >> 6;
      HIDWORD(v135) = v184;
      LODWORD(v135) = v184;
      v216 = v135 >> 7;
      HIDWORD(v135) = v203;
      LODWORD(v135) = v203;
      v217 = v135 >> 17;
      HIDWORD(v135) = v212;
      LODWORD(v135) = v212;
      v218 = v180 + v211 + v72 + (v200 & v210 | v190 & ~v210) + (v215 ^ __ROR4__(v210, 11) ^ __ROR4__(v210, 25));
      v219 = v182 + v218;
      v220 = *v140;
      ++v140;
      v221 = v218 + ((v202 ^ v192) & (v212 ^ v202) ^ v202) + ((v135 >> 2) ^ __ROR4__(v212, 13) ^ __ROR4__(v212, 22));
      v78 = v174 + v153 + (v216 ^ __ROR4__(v184, 18) ^ (v184 >> 3)) + (v217 ^ __ROR4__(v203, 19) ^ (v203 >> 10));
      v222 = v195;
      v223 = v143;
      HIDWORD(v135) = v219;
      LODWORD(v135) = v219;
      v224 = v135 >> 6;
      HIDWORD(v135) = v194;
      LODWORD(v135) = v194;
      v225 = v135 >> 7;
      HIDWORD(v135) = v72;
      LODWORD(v135) = v72;
      v226 = v135 >> 17;
      HIDWORD(v135) = v221;
      LODWORD(v135) = v221;
      v227 = v190 + v220 + v78 + (v210 & v219 | v200 & ~v219) + (v224 ^ __ROR4__(v219, 11) ^ __ROR4__(v219, 25));
      v228 = v192 + v227;
      v229 = *v140;
      ++v140;
      v230 = v227 + ((v212 ^ v202) & (v221 ^ v212) ^ v212) + ((v135 >> 2) ^ __ROR4__(v221, 13) ^ __ROR4__(v221, 22));
      v86 = v184 + v163 + (v225 ^ __ROR4__(v194, 18) ^ (v194 >> 3)) + (v226 ^ __ROR4__(v72, 19) ^ (v72 >> 10));
      v231 = v205;
      v232 = v153;
      HIDWORD(v135) = v228;
      LODWORD(v135) = v228;
      v233 = v135 >> 6;
      HIDWORD(v135) = v204;
      LODWORD(v135) = v204;
      v234 = v135 >> 7;
      HIDWORD(v135) = v78;
      LODWORD(v135) = v78;
      v235 = v135 >> 17;
      HIDWORD(v135) = v230;
      LODWORD(v135) = v230;
      v236 = v200 + v229 + v86 + (v219 & v228 | v210 & ~v228) + (v233 ^ __ROR4__(v228, 11) ^ __ROR4__(v228, 25));
      v237 = v202 + v236;
      v238 = *v140;
      ++v140;
      v239 = v236 + ((v221 ^ v212) & (v230 ^ v221) ^ v221) + ((v135 >> 2) ^ __ROR4__(v230, 13) ^ __ROR4__(v230, 22));
      v92 = v194 + v173 + (v234 ^ __ROR4__(v204, 18) ^ (v204 >> 3)) + (v235 ^ __ROR4__(v78, 19) ^ (v78 >> 10));
      v240 = v214;
      v241 = v163;
      HIDWORD(v135) = v237;
      LODWORD(v135) = v237;
      v242 = v135 >> 6;
      HIDWORD(v135) = v213;
      LODWORD(v135) = v213;
      v243 = v135 >> 7;
      HIDWORD(v135) = v86;
      LODWORD(v135) = v86;
      v244 = v135 >> 17;
      HIDWORD(v135) = v239;
      LODWORD(v135) = v239;
      v245 = v210 + v238 + v92 + (v228 & v237 | v219 & ~v237) + (v242 ^ __ROR4__(v237, 11) ^ __ROR4__(v237, 25));
      v246 = v212 + v245;
      v247 = *v140;
      ++v140;
      v248 = v245 + ((v230 ^ v221) & (v239 ^ v230) ^ v230) + ((v135 >> 2) ^ __ROR4__(v239, 13) ^ __ROR4__(v239, 22));
      v100 = v204 + v183 + (v243 ^ __ROR4__(v213, 18) ^ (v213 >> 3)) + (v244 ^ __ROR4__(v86, 19) ^ (v86 >> 10));
      v22 = v223;
      v249 = v173;
      HIDWORD(v135) = v246;
      LODWORD(v135) = v246;
      v250 = v135 >> 6;
      HIDWORD(v135) = v222;
      LODWORD(v135) = v222;
      v251 = v135 >> 7;
      HIDWORD(v135) = v92;
      LODWORD(v135) = v92;
      v252 = v135 >> 17;
      HIDWORD(v135) = v248;
      LODWORD(v135) = v248;
      v253 = v219 + v247 + v100 + (v237 & v246 | v228 & ~v246) + (v250 ^ __ROR4__(v246, 11) ^ __ROR4__(v246, 25));
      v104 = v221 + v253;
      v254 = *v140;
      ++v140;
      v108 = v253 + ((v239 ^ v230) & (v248 ^ v239) ^ v239) + ((v135 >> 2) ^ __ROR4__(v248, 13) ^ __ROR4__(v248, 22));
      v106 = v213 + v193 + (v251 ^ __ROR4__(v222, 18) ^ (v222 >> 3)) + (v252 ^ __ROR4__(v92, 19) ^ (v92 >> 10));
      v30 = v232;
      v276 = v183;
      HIDWORD(v135) = v104;
      LODWORD(v135) = v104;
      v255 = v135 >> 6;
      HIDWORD(v135) = v231;
      LODWORD(v135) = v231;
      v256 = v135 >> 7;
      HIDWORD(v135) = v100;
      LODWORD(v135) = v100;
      v257 = v135 >> 17;
      HIDWORD(v135) = v108;
      LODWORD(v135) = v108;
      v258 = v228 + v254 + v106 + (v246 & v104 | v237 & ~v104) + (v255 ^ __ROR4__(v104, 11) ^ __ROR4__(v104, 25));
      v111 = v230 + v258;
      v259 = *v140;
      ++v140;
      v114 = v258 + ((v248 ^ v239) & (v108 ^ v248) ^ v248) + ((v135 >> 2) ^ __ROR4__(v108, 13) ^ __ROR4__(v108, 22));
      v113 = v222 + v203 + (v256 ^ __ROR4__(v231, 18) ^ (v231 >> 3)) + (v257 ^ __ROR4__(v100, 19) ^ (v100 >> 10));
      v36 = v241;
      v277 = v193;
      HIDWORD(v135) = v111;
      LODWORD(v135) = v111;
      v260 = v135 >> 6;
      HIDWORD(v135) = v240;
      LODWORD(v135) = v240;
      v261 = v135 >> 7;
      HIDWORD(v135) = v106;
      LODWORD(v135) = v106;
      v262 = v135 >> 17;
      HIDWORD(v135) = v114;
      LODWORD(v135) = v114;
      v263 = v237 + v259 + v113 + (v104 & v111 | v246 & ~v111) + (v260 ^ __ROR4__(v111, 11) ^ __ROR4__(v111, 25));
      v117 = v239 + v263;
      v264 = *v140;
      ++v140;
      v120 = v263 + ((v108 ^ v248) & (v114 ^ v108) ^ v108) + ((v135 >> 2) ^ __ROR4__(v114, 13) ^ __ROR4__(v114, 22));
      v119 = v231 + v72 + (v261 ^ __ROR4__(v240, 18) ^ (v240 >> 3)) + (v262 ^ __ROR4__(v106, 19) ^ (v106 >> 10));
      v44 = v249;
      v278 = v203;
      HIDWORD(v135) = v117;
      LODWORD(v135) = v117;
      v265 = v135 >> 6;
      HIDWORD(v135) = v22;
      LODWORD(v135) = v22;
      v266 = v135 >> 7;
      HIDWORD(v135) = v113;
      LODWORD(v135) = v113;
      v267 = v135 >> 17;
      HIDWORD(v135) = v120;
      LODWORD(v135) = v120;
      v124 = v120 ^ v114;
      v268 = v246 + v264 + v119 + (v111 & v117 | v104 & ~v117) + (v265 ^ __ROR4__(v117, 11) ^ __ROR4__(v117, 25));
      v126 = v248 + v268;
      v269 = *v140;
      v128 = v140 + 1;
      v127 = v269;
      v130 = v268 + ((v114 ^ v108) & (v120 ^ v114) ^ v114) + ((v135 >> 2) ^ __ROR4__(v120, 13) ^ __ROR4__(v120, 22));
      v131 = v240 + v78 + (v266 ^ __ROR4__(v22, 18) ^ (v22 >> 3)) + (v267 ^ __ROR4__(v113, 19) ^ (v113 >> 10));
    }
    while ( v269 );
    v10 = v128 - 65;
    a2 = (signed __int64)(v281 + 14);
    v270 = v279[4];
    v271 = v279[5];
    v2 = v130 + *v279;
    v272 = v279[6];
    v273 = v279[7];
    v3 = v120 + v279[1];
    v4 = v114 + v279[2];
    v5 = v108 + v279[3];
    *v279 = v2;
    v279[1] = v3;
    v6 = v126 + v270;
    v7 = v117 + v271;
    v279[2] = v4;
    v279[3] = v5;
    v8 = v111 + v272;
    v9 = v104 + v273;
    v279[4] = v6;
    v279[5] = v7;
    v279[6] = v8;
    v279[7] = v9;
  }
  while ( v281 + 14 != (unsigned int *)v280 );
}
// 52940: using guessed type int dword_52940;
// 52948: using guessed type __int64[32];
// 52AFC: using guessed type int;
// 106E2C: using guessed type int dword_106E2C;

//----- (000000000004EF04) ----------------------------------------------------
signed __int64 __fastcall SHA384_Init(_QWORD *a1)
{
  _QWORD *v1; // x8
  signed __int64 result; // x0

  v1 = a1;
  *a1 = -3766243637369397544LL;
  a1[1] = 7105036623409894663LL;
  a1[4] = 7436329637833083697LL;
  a1[5] = -8163818279084223215LL;
  a1[6] = -2662702644619276377LL;
  a1[7] = 5167115440072839076LL;
  result = 1LL;
  v1[2] = -7973340178411365097LL;
  v1[3] = 1526699215303891257LL;
  *((_DWORD *)v1 + 52) = 0;
  *((_DWORD *)v1 + 53) = 48;
  v1[8] = 0LL;
  v1[9] = 0LL;
  return result;
}

//----- (000000000004EFAC) ----------------------------------------------------
signed __int64 __fastcall SHA512_Init(_QWORD *a1)
{
  _QWORD *v1; // x8
  signed __int64 result; // x0

  v1 = a1;
  *a1 = 7640891576956012808LL;
  a1[1] = -4942790177534073029LL;
  a1[4] = 5840696475078001361LL;
  a1[5] = -7276294671716946913LL;
  a1[6] = 2270897969802886507LL;
  a1[7] = 6620516959819538809LL;
  result = 1LL;
  v1[2] = 4354685564936845355LL;
  v1[3] = -6534734903238641935LL;
  *((_DWORD *)v1 + 52) = 0;
  *((_DWORD *)v1 + 53) = 64;
  v1[8] = 0LL;
  v1[9] = 0LL;
  return result;
}

//----- (000000000004F054) ----------------------------------------------------
void *__fastcall SHA384(unsigned __int64 *a1, size_t a2, _BYTE *a3)
{
  unsigned __int64 v3; // x20
  _BYTE *v4; // x19
  void *result; // x0
  __int64 v6; // [xsp+0h] [xbp-100h]
  __int64 v7; // [xsp+8h] [xbp-F8h]
  __int64 v8; // [xsp+10h] [xbp-F0h]
  __int64 v9; // [xsp+18h] [xbp-E8h]
  __int64 v10; // [xsp+20h] [xbp-E0h]
  __int64 v11; // [xsp+28h] [xbp-D8h]
  __int64 v12; // [xsp+30h] [xbp-D0h]
  __int64 v13; // [xsp+38h] [xbp-C8h]
  __int64 v14; // [xsp+40h] [xbp-C0h]
  __int64 v15; // [xsp+48h] [xbp-B8h]
  int v16; // [xsp+D0h] [xbp-30h]
  int v17; // [xsp+D4h] [xbp-2Ch]
  __int64 v18; // [xsp+D8h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a3 )
    v4 = a3;
  else
    v4 = &unk_10704C;
  v18 = *(_QWORD *)(v3 + 40);
  v6 = -3766243637369397544LL;
  v7 = 7105036623409894663LL;
  v8 = -7973340178411365097LL;
  v9 = 1526699215303891257LL;
  v10 = 7436329637833083697LL;
  v11 = -8163818279084223215LL;
  v12 = -2662702644619276377LL;
  v13 = 5167115440072839076LL;
  v16 = 0;
  v17 = 48;
  v14 = 0LL;
  v15 = 0LL;
  SHA512_Update((__int64)&v6, a1, a2);
  SHA512_Final(v4, (__int64)&v6);
  result = OPENSSL_cleanse(&v6, 0xD8uLL);
  if ( *(_QWORD *)(v3 + 40) == v18 )
    result = v4;
  return result;
}

//----- (000000000004F17C) ----------------------------------------------------
signed __int64 __fastcall SHA384_Update(__int64 a1, unsigned __int64 *a2, size_t a3)
{
  SHA512_Update(a1, a2, a3);
  return 1LL;
}

//----- (000000000004F198) ----------------------------------------------------
void *__fastcall SHA512(unsigned __int64 *a1, size_t a2, _BYTE *a3)
{
  unsigned __int64 v3; // x20
  _BYTE *v4; // x19
  void *result; // x0
  __int64 v6; // [xsp+0h] [xbp-100h]
  __int64 v7; // [xsp+8h] [xbp-F8h]
  __int64 v8; // [xsp+10h] [xbp-F0h]
  __int64 v9; // [xsp+18h] [xbp-E8h]
  __int64 v10; // [xsp+20h] [xbp-E0h]
  __int64 v11; // [xsp+28h] [xbp-D8h]
  __int64 v12; // [xsp+30h] [xbp-D0h]
  __int64 v13; // [xsp+38h] [xbp-C8h]
  __int64 v14; // [xsp+40h] [xbp-C0h]
  __int64 v15; // [xsp+48h] [xbp-B8h]
  int v16; // [xsp+D0h] [xbp-30h]
  int v17; // [xsp+D4h] [xbp-2Ch]
  __int64 v18; // [xsp+D8h] [xbp-28h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a3 )
    v4 = a3;
  else
    v4 = &unk_10707C;
  v18 = *(_QWORD *)(v3 + 40);
  v6 = 7640891576956012808LL;
  v7 = -4942790177534073029LL;
  v8 = 4354685564936845355LL;
  v9 = -6534734903238641935LL;
  v10 = 5840696475078001361LL;
  v11 = -7276294671716946913LL;
  v12 = 2270897969802886507LL;
  v13 = 6620516959819538809LL;
  v16 = 0;
  v17 = 64;
  v14 = 0LL;
  v15 = 0LL;
  SHA512_Update((__int64)&v6, a1, a2);
  SHA512_Final(v4, (__int64)&v6);
  result = OPENSSL_cleanse(&v6, 0xD8uLL);
  if ( *(_QWORD *)(v3 + 40) == v18 )
    result = v4;
  return result;
}

//----- (000000000004F2C0) ----------------------------------------------------
signed __int64 __fastcall SHA512_Update(__int64 a1, unsigned __int64 *a2, size_t a3)
{
  size_t v3; // x19
  unsigned __int64 *v4; // x21
  __int64 v5; // x20
  __int64 v6; // x9
  __int64 v7; // x8
  unsigned __int8 v8; // cf
  signed __int64 v9; // x8
  __int64 v10; // x10
  signed __int64 v11; // x23
  void *v12; // x0
  char *v13; // x8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v7 = *(_QWORD *)(a1 + 64);
    v6 = *(_QWORD *)(a1 + 72);
    v8 = __CFADD__(v7, 8 * a3);
    v9 = v7 + 8 * a3;
    if ( v8 )
      *(_QWORD *)(a1 + 72) = ++v6;
    v10 = *(unsigned int *)(a1 + 208);
    *(_QWORD *)(a1 + 64) = v9;
    *(_QWORD *)(a1 + 72) = v6 + (a3 >> 61);
    if ( (_DWORD)v10 )
    {
      v11 = 128 - v10;
      v12 = (void *)(a1 + 80 + v10);
      if ( 128 - v10 > a3 )
      {
        memcpy(v12, a2, a3);
        *(_DWORD *)(v5 + 208) += v3;
        return 1LL;
      }
      if ( 128 != v10 )
        memcpy(v12, a2, 128 - v10);
      *(_DWORD *)(v5 + 208) = 0;
      v3 -= v11;
      v4 = (unsigned __int64 *)((char *)v4 + v11);
      sub_52CC0((unsigned __int64 *)v5, (unsigned __int64 *)(v5 + 80), 1LL);
    }
    if ( v3 >= 0x80 )
    {
      sub_52CC0((unsigned __int64 *)v5, v4, v3 >> 7);
      v13 = (char *)v4 + v3;
      v3 &= 0x7Fu;
      v4 = (unsigned __int64 *)&v13[-v3];
    }
    if ( v3 )
    {
      memcpy((void *)(v5 + 80), v4, v3);
      *(_DWORD *)(v5 + 208) = v3;
    }
  }
  return 1LL;
}

//----- (000000000004F3BC) ----------------------------------------------------
signed __int64 __fastcall SHA512_Final(_BYTE *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x9
  unsigned __int64 *v4; // x21
  _BYTE *v5; // x19
  signed __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x9
  int v9; // w8
  unsigned __int64 v10; // x8
  __int64 v11; // x8
  __int64 v12; // x8
  __int64 v13; // x8
  __int64 v14; // x8
  __int64 v15; // x8
  __int64 v16; // x8
  __int64 v17; // x8
  unsigned __int64 v19; // x8
  __int64 v20; // x8
  __int64 v21; // x8
  __int64 v22; // x8
  __int64 v23; // x8
  __int64 v24; // x8

  v2 = a2;
  v3 = *(unsigned int *)(a2 + 208);
  v4 = (unsigned __int64 *)(a2 + 80);
  v5 = a1;
  *(_BYTE *)(a2 + 80 + v3) = -128;
  v6 = v3 + 1;
  if ( (unsigned __int64)(v3 + 1) >= 0x71 )
  {
    if ( 127 != v3 )
      memset((char *)v4 + v6, 0, 127 - v3);
    sub_52CC0((unsigned __int64 *)v2, v4, 1LL);
    v6 = 0LL;
  }
  if ( 112 != v6 )
    memset((char *)v4 + v6, 0, 112 - v6);
  v7 = *(_QWORD *)(v2 + 64);
  v8 = *(_QWORD *)(v2 + 72);
  *(_BYTE *)(v2 + 206) = BYTE1(v7);
  *(_BYTE *)(v2 + 205) = BYTE2(v7);
  *(_BYTE *)(v2 + 204) = BYTE3(v7);
  *(_BYTE *)(v2 + 203) = BYTE4(v7);
  *(_BYTE *)(v2 + 202) = BYTE5(v7);
  *(_BYTE *)(v2 + 207) = v7;
  *(_BYTE *)(v2 + 200) = HIBYTE(v7);
  *(_BYTE *)(v2 + 198) = BYTE1(v8);
  *(_BYTE *)(v2 + 197) = BYTE2(v8);
  *(_BYTE *)(v2 + 196) = BYTE3(v8);
  *(_BYTE *)(v2 + 195) = BYTE4(v8);
  *(_BYTE *)(v2 + 199) = v8;
  *(_BYTE *)(v2 + 194) = BYTE5(v8);
  *(_BYTE *)(v2 + 201) = BYTE6(v7);
  *(_BYTE *)(v2 + 193) = BYTE6(v8);
  *(_BYTE *)(v2 + 192) = HIBYTE(v8);
  sub_52CC0((unsigned __int64 *)v2, v4, 1LL);
  if ( !v5 )
    return 0LL;
  v9 = *(_DWORD *)(v2 + 212);
  if ( v9 == 48 )
  {
    v19 = *(_QWORD *)v2;
    *v5 = *(_QWORD *)v2 >> 56;
    v5[1] = BYTE6(v19);
    v5[2] = BYTE5(v19);
    v5[3] = BYTE4(v19);
    v5[4] = BYTE3(v19);
    v5[7] = v19;
    v5[5] = BYTE2(v19);
    v5[6] = BYTE1(v19);
    v20 = *(_QWORD *)(v2 + 8);
    v5[8] = HIBYTE(v20);
    v5[9] = BYTE6(v20);
    v5[10] = BYTE5(v20);
    v5[11] = BYTE4(v20);
    v5[12] = BYTE3(v20);
    v5[15] = v20;
    v5[13] = BYTE2(v20);
    v5[14] = BYTE1(v20);
    v21 = *(_QWORD *)(v2 + 16);
    v5[16] = HIBYTE(v21);
    v5[17] = BYTE6(v21);
    v5[18] = BYTE5(v21);
    v5[19] = BYTE4(v21);
    v5[20] = BYTE3(v21);
    v5[23] = v21;
    v5[21] = BYTE2(v21);
    v5[22] = BYTE1(v21);
    v22 = *(_QWORD *)(v2 + 24);
    v5[24] = HIBYTE(v22);
    v5[25] = BYTE6(v22);
    v5[26] = BYTE5(v22);
    v5[27] = BYTE4(v22);
    v5[28] = BYTE3(v22);
    v5[31] = v22;
    v5[29] = BYTE2(v22);
    v5[30] = BYTE1(v22);
    v23 = *(_QWORD *)(v2 + 32);
    v5[32] = HIBYTE(v23);
    v5[33] = BYTE6(v23);
    v5[34] = BYTE5(v23);
    v5[35] = BYTE4(v23);
    v5[36] = BYTE3(v23);
    v5[39] = v23;
    v5[37] = BYTE2(v23);
    v5[38] = BYTE1(v23);
    v24 = *(_QWORD *)(v2 + 40);
    v5[40] = HIBYTE(v24);
    v5[41] = BYTE6(v24);
    v5[42] = BYTE5(v24);
    v5[43] = BYTE4(v24);
    v5[47] = v24;
    v5[44] = BYTE3(v24);
    v5[45] = BYTE2(v24);
    v5[46] = BYTE1(v24);
    return 1LL;
  }
  if ( v9 != 64 )
    return 0LL;
  v10 = *(_QWORD *)v2;
  *v5 = *(_QWORD *)v2 >> 56;
  v5[1] = BYTE6(v10);
  v5[2] = BYTE5(v10);
  v5[3] = BYTE4(v10);
  v5[4] = BYTE3(v10);
  v5[7] = v10;
  v5[5] = BYTE2(v10);
  v5[6] = BYTE1(v10);
  v11 = *(_QWORD *)(v2 + 8);
  v5[8] = HIBYTE(v11);
  v5[9] = BYTE6(v11);
  v5[10] = BYTE5(v11);
  v5[11] = BYTE4(v11);
  v5[12] = BYTE3(v11);
  v5[15] = v11;
  v5[13] = BYTE2(v11);
  v5[14] = BYTE1(v11);
  v12 = *(_QWORD *)(v2 + 16);
  v5[16] = HIBYTE(v12);
  v5[17] = BYTE6(v12);
  v5[18] = BYTE5(v12);
  v5[19] = BYTE4(v12);
  v5[20] = BYTE3(v12);
  v5[23] = v12;
  v5[21] = BYTE2(v12);
  v5[22] = BYTE1(v12);
  v13 = *(_QWORD *)(v2 + 24);
  v5[24] = HIBYTE(v13);
  v5[25] = BYTE6(v13);
  v5[26] = BYTE5(v13);
  v5[27] = BYTE4(v13);
  v5[28] = BYTE3(v13);
  v5[31] = v13;
  v5[29] = BYTE2(v13);
  v5[30] = BYTE1(v13);
  v14 = *(_QWORD *)(v2 + 32);
  v5[32] = HIBYTE(v14);
  v5[33] = BYTE6(v14);
  v5[34] = BYTE5(v14);
  v5[35] = BYTE4(v14);
  v5[36] = BYTE3(v14);
  v5[39] = v14;
  v5[37] = BYTE2(v14);
  v5[38] = BYTE1(v14);
  v15 = *(_QWORD *)(v2 + 40);
  v5[40] = HIBYTE(v15);
  v5[41] = BYTE6(v15);
  v5[42] = BYTE5(v15);
  v5[43] = BYTE4(v15);
  v5[44] = BYTE3(v15);
  v5[47] = v15;
  v5[45] = BYTE2(v15);
  v5[46] = BYTE1(v15);
  v16 = *(_QWORD *)(v2 + 48);
  v5[48] = HIBYTE(v16);
  v5[49] = BYTE6(v16);
  v5[50] = BYTE5(v16);
  v5[51] = BYTE4(v16);
  v5[52] = BYTE3(v16);
  v5[55] = v16;
  v5[53] = BYTE2(v16);
  v5[54] = BYTE1(v16);
  v17 = *(_QWORD *)(v2 + 56);
  v5[56] = HIBYTE(v17);
  v5[57] = BYTE6(v17);
  v5[58] = BYTE5(v17);
  v5[59] = BYTE4(v17);
  v5[63] = v17;
  v5[60] = BYTE3(v17);
  v5[61] = BYTE2(v17);
  v5[62] = BYTE1(v17);
  return 1LL;
}

//----- (000000000004F878) ----------------------------------------------------
unsigned __int64 *__fastcall SHA512_Transform(unsigned __int64 *a1, unsigned __int64 *a2)
{
  return sub_52CC0(a1, a2, 1LL);
}

//----- (000000000004F880) ----------------------------------------------------
__int64 __fastcall CRYPTO_MUTEX_init(pthread_rwlock_t *a1)
{
  __int64 result; // x0

  result = pthread_rwlock_init(a1, 0LL);
  if ( (_DWORD)result )
    abort();
  return result;
}

//----- (000000000004F8A0) ----------------------------------------------------
__int64 __fastcall CRYPTO_STATIC_MUTEX_lock_read(pthread_rwlock_t *a1)
{
  __int64 result; // x0

  result = pthread_rwlock_rdlock(a1);
  if ( (_DWORD)result )
    abort();
  return result;
}

//----- (000000000004F8BC) ----------------------------------------------------
__int64 __fastcall CRYPTO_STATIC_MUTEX_lock_write(pthread_rwlock_t *a1)
{
  __int64 result; // x0

  result = pthread_rwlock_wrlock(a1);
  if ( (_DWORD)result )
    abort();
  return result;
}

//----- (000000000004F8D8) ----------------------------------------------------
__int64 __fastcall CRYPTO_STATIC_MUTEX_unlock_write(pthread_rwlock_t *a1)
{
  __int64 result; // x0

  result = pthread_rwlock_unlock(a1);
  if ( (_DWORD)result )
    abort();
  return result;
}

//----- (000000000004F8F8) ----------------------------------------------------
__int64 __fastcall CRYPTO_once(pthread_once_t *a1, void (*a2)(void))
{
  __int64 result; // x0

  result = pthread_once(a1, a2);
  if ( (_DWORD)result )
    abort();
  return result;
}

//----- (000000000004F914) ----------------------------------------------------
_QWORD *__fastcall CRYPTO_get_thread_local(int a1)
{
  int v1; // w19
  _QWORD *result; // x0

  v1 = a1;
  if ( (unsigned int)pthread_once((pthread_once_t *)&unk_1070BC, (void (*)(void))sub_4F974) )
    abort();
  if ( dword_1070C0 )
    return 0LL;
  result = pthread_getspecific(dword_1070C4);
  if ( result )
    result = (_QWORD *)result[v1];
  return result;
}
// 1070C0: using guessed type int dword_1070C0;
// 1070C4: using guessed type int dword_1070C4;

//----- (000000000004F974) ----------------------------------------------------
__int64 sub_4F974()
{
  __int64 result; // x0

  result = pthread_key_create((pthread_key_t *)&dword_1070C4, (void (*)(void *))sub_4FA90);
  dword_1070C0 = result != 0;
  return result;
}
// 1070C0: using guessed type int dword_1070C0;
// 1070C4: using guessed type int dword_1070C4;

//----- (000000000004F9A8) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_set_thread_local(unsigned int a1, __int64 a2, void (__fastcall *a3)(__int64))
{
  __int64 v3; // x19
  unsigned int v4; // w21
  void (__fastcall *v5)(__int64); // x20
  _QWORD *v6; // x22
  signed __int64 v7; // x21
  signed __int64 result; // x0
  pthread_key_t v9; // w0

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( (unsigned int)pthread_once((pthread_once_t *)&unk_1070BC, (void (*)(void))sub_4F974) )
    abort();
  if ( dword_1070C0 )
    goto LABEL_9;
  v6 = pthread_getspecific(dword_1070C4);
  if ( !v6 )
  {
    v6 = malloc(0x20uLL);
    if ( !v6 )
      goto LABEL_9;
    v9 = dword_1070C4;
    v6[2] = 0LL;
    v6[3] = 0LL;
    *v6 = 0LL;
    v6[1] = 0LL;
    if ( (unsigned int)pthread_setspecific(v9, v6) )
    {
      free(v6);
      goto LABEL_9;
    }
  }
  if ( !(unsigned int)pthread_mutex_lock((pthread_mutex_t *)&unk_1070C8) )
  {
    v7 = v4;
    *(_QWORD *)((char *)&unk_1070F0 + v7 * 8) = v5;
    pthread_mutex_unlock((pthread_mutex_t *)&unk_1070C8);
    result = 1LL;
    v6[v7] = v3;
    return result;
  }
LABEL_9:
  v5(v3);
  return 0LL;
}
// 1070C0: using guessed type int dword_1070C0;
// 1070C4: using guessed type int dword_1070C4;

//----- (000000000004FA90) ----------------------------------------------------
void __fastcall sub_4FA90(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 v2; // ST28_8
  __int128 v3; // [xsp+0h] [xbp-40h]
  __int128 v4; // [xsp+10h] [xbp-30h]

  v1 = a1;
  v2 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 && !(unsigned int)pthread_mutex_lock((pthread_mutex_t *)&unk_1070C8) )
  {
    v3 = unk_1070F0;
    v4 = unk_107100;
    pthread_mutex_unlock((pthread_mutex_t *)&unk_1070C8);
    if ( (_QWORD)v3 )
      ((void (__fastcall *)(_QWORD))v3)(*v1);
    if ( *((_QWORD *)&v3 + 1) )
      (*((void (__fastcall **)(_QWORD))&v3 + 1))(v1[1]);
    if ( (_QWORD)v4 )
      ((void (__fastcall *)(_QWORD))v4)(v1[2]);
    if ( *((_QWORD *)&v4 + 1) )
      (*((void (__fastcall **)(_QWORD))&v4 + 1))(v1[3]);
    free(v1);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000050590) ----------------------------------------------------
uint64x2_t __fastcall sub_50590(int8x16_t *a1, int8x16_t *a2)
{
  int64x2_t v2; // q19
  int8x16_t v3; // q19
  int64x2_t v4; // q3
  int8x16_t v5; // q16
  int8x16_t v6; // q18
  int8x16_t v7; // q20
  signed __int64 v8; // x0
  int8x16_t v9; // q0
  int8x16_t v10; // q16
  int8x16_t v11; // q2
  int8x16_t v12; // q1
  int8x16_t v13; // q0
  int8x16_t v14; // q18
  uint64x2_t result; // q0
  int8x16_t v16; // q22

  v2.n128_u64[0] = -2170205185142300191LL;
  v2.n128_u64[1] = -2170205185142300191LL;
  v3 = vshlq_n_s64(v2, 0x39uLL);
  v4 = vextq_s8(*a2, *a2, 8uLL);
  v5 = vextq_s8(vshrq_n_u64(v3, 0x3FuLL), v3, 8uLL);
  v6 = vandq_s8(vshrq_n_u64(v4, 0x3FuLL), v5);
  v7 = veorq_s8(
         vorrq_s8(vshlq_n_s64(v4, 1uLL), vextq_s8(v6, v6, 8uLL)),
         vandq_s8(v5, vshrq_n_s32(vdupq_lane_s32((int32x2_t)*(_OWORD *)a2, 1), 0x1FuLL)));
  *a1 = v7;
  v8 = (signed __int64)&a1[1];
  v9 = vmull_p64(v7.n128_u64[0], v7.n128_u64[0]);
  v10 = veorq_s8(vextq_s8(v7, v7, 8uLL), v7);
  v11 = vmull_high_p64(v7, v7);
  v12 = veorq_s8(veorq_s8(vmull_p64(v10.n128_u64[0], v10.n128_u64[0]), vextq_s8(v9, v11, 8uLL)), veorq_s8(v9, v11));
  v11.n128_u64[0] = v12.n128_u64[1];
  v12.n128_u64[1] = v9.n128_u64[0];
  v13 = veorq_s8(v12, vmull_p64(v9.n128_u64[0], v3.n128_u64[0]));
  v14 = vextq_s8(v13, v13, 8uLL);
  result = vmull_p64(v13.n128_u64[0], v3.n128_u64[0]);
  v16 = veorq_s8(result, veorq_s8(v14, v11));
  *(int8x16_t *)v8 = vextq_s8(v10, veorq_s8(vextq_s8(v16, v16, 8uLL), v16), 8uLL);
  *(int8x16_t *)(v8 + 16) = v16;
  return result;
}

//----- (0000000000050630) ----------------------------------------------------
int8x16_t __fastcall sub_50630(int8x16_t *a1, __int64 a2)
{
  int64x2_t v2; // q19
  int8x16_t v3; // q17
  int8x16_t v4; // q3
  int8x16_t v5; // q0
  int8x16_t v6; // q2
  int8x16_t v7; // q1
  int8x16_t v8; // q0
  int8x16_t v9; // q0
  int8x16_t result; // q0

  v2.n128_u64[0] = -2170205185142300191LL;
  v2.n128_u64[1] = -2170205185142300191LL;
  v2.n128_u64[0] = (unsigned __int128)vshlq_n_s64(v2, 0x39uLL);
  v3 = vrev64q_s8(*a1);
  v4 = vextq_s8(v3, v3, 8uLL);
  v5 = vmull_p64(*(_OWORD *)a2, v4.n128_u64[0]);
  v6 = vmull_high_p64(*(uint64x2_t *)a2, v4);
  v7 = veorq_s8(
         veorq_s8(vmull_p64(*(_OWORD *)(a2 + 16), *(_OWORD *)&veorq_s8(v3, v4)), vextq_s8(v5, v6, 8uLL)),
         veorq_s8(v5, v6));
  v6.n128_u64[0] = v7.n128_u64[1];
  v7.n128_u64[1] = v5.n128_u64[0];
  v8 = veorq_s8(v7, vmull_p64(v5.n128_u64[0], v2.n128_u64[0]));
  v9 = vrev64q_s8(veorq_s8(vmull_p64(v8.n128_u64[0], v2.n128_u64[0]), veorq_s8(vextq_s8(v8, v8, 8uLL), v6)));
  result = vextq_s8(v9, v9, 8uLL);
  *a1 = result;
  return result;
}

//----- (00000000000506A0) ----------------------------------------------------
int8x16_t __fastcall sub_506A0(int8x16_t *a1, uint64x2_t *a2, int8x16_t *a3, unsigned __int64 a4)
{
  bool v4; // cf
  unsigned __int64 v5; // x3
  signed __int64 v6; // x12
  uint64x2_t v7; // q20
  uint64x2_t v8; // q21
  int64x2_t v9; // q19
  uint64x2_t v10; // q22
  int8x16_t *v11; // x2
  int8x16_t v12; // q16
  unsigned __int64 v13; // d19
  int8x16_t v14; // q16
  int8x16_t v15; // q0
  int8x16_t v16; // q3
  int8x16_t *v17; // x2
  int8x16_t v18; // q17
  int8x16_t v19; // q17
  int8x16_t v20; // q7
  int8x16_t v21; // q3
  int8x16_t v22; // q4
  unsigned __int64 v23; // d17
  int8x16_t v24; // q6
  int8x16_t v25; // q18
  bool v26; // cf
  int8x16_t v27; // q0
  int8x16_t v28; // q5
  int8x16_t v29; // q0
  int8x16_t v30; // q1
  int8x16_t *v31; // x2
  int8x16_t v32; // q16
  int8x16_t v33; // q2
  int8x16_t v34; // q17
  int8x16_t v35; // q1
  int8x16_t v36; // q17
  int8x16_t v37; // q7
  int8x16_t v38; // q0
  int8x16_t v39; // q18
  int8x16_t v40; // q0
  int8x16_t v41; // q3
  int8x16_t v42; // q17
  int8x16_t v43; // q0
  int8x16_t v44; // q2
  int8x16_t v45; // q1
  int8x16_t v46; // q0
  int8x16_t v47; // q0
  int8x16_t result; // q0

  v4 = a4 >= 0x20;
  v5 = a4 - 32;
  v6 = 1LL;
  v7 = *a2;
  v8 = a2[1];
  v9.n128_u64[0] = -2170205185142300191LL;
  v9.n128_u64[1] = -2170205185142300191LL;
  v10 = a2[2];
  if ( !v5 )
    v6 = 0LL;
  v12 = *a3;
  v11 = a3 + 1;
  v13 = (unsigned __int128)vshlq_n_s64(v9, 0x39uLL);
  v14 = vrev64q_s8(v12);
  v15 = vrev64q_s8(vextq_s8(*a1, *a1, 8uLL));
  v16 = vextq_s8(v14, v14, 8uLL);
  if ( !v4 )
    goto LABEL_16;
  v18 = *v11;
  v17 = &v11[v6];
  v19 = vrev64q_s8(v18);
  v20 = vextq_s8(v19, v19, 8uLL);
  v21 = veorq_s8(v16, v15);
  v22 = vmull_p64(v7.n128_u64[0], v20.n128_u64[0]);
  v23 = (unsigned __int128)veorq_s8(v19, v20);
  v24 = vmull_high_p64(v7, v20);
  do
  {
    v25 = vextq_s8(v21, v21, 8uLL);
    v26 = v5 >= 0x20;
    v5 -= 32LL;
    v27 = vmull_p64(v10.n128_u64[0], v21.n128_u64[0]);
    if ( !v26 )
      v6 = 0LL;
    v28 = vmull_p64(v8.n128_u64[0], v23);
    v29 = veorq_s8(v27, v22);
    v30 = vmull_high_p64(v8, veorq_s8(v25, v21));
    v32 = *v17;
    v31 = &v17[v6];
    v33 = veorq_s8(vmull_high_p64(v10, v21), v24);
    if ( !v5 )
      v6 = 0LL;
    v34 = *v31;
    v17 = &v31[v6];
    v14 = vrev64q_s8(v32);
    v35 = veorq_s8(veorq_s8(veorq_s8(v30, v28), vextq_s8(v29, v33, 8uLL)), veorq_s8(v29, v33));
    v36 = vrev64q_s8(v34);
    v33.n128_u64[0] = v35.n128_u64[1];
    v35.n128_u64[1] = v29.n128_u64[0];
    v37 = vextq_s8(v36, v36, 8uLL);
    v38 = veorq_s8(v35, vmull_p64(v29.n128_u64[0], v13));
    v22 = vmull_p64(v7.n128_u64[0], v37.n128_u64[0]);
    v39 = vextq_s8(v38, v38, 8uLL);
    v40 = vmull_p64(v38.n128_u64[0], v13);
    v23 = (unsigned __int128)veorq_s8(v36, v37);
    v21 = veorq_s8(veorq_s8(veorq_s8(vextq_s8(v14, v14, 8uLL), v33), v39), v40);
    v24 = vmull_high_p64(v7, v37);
  }
  while ( v26 );
  v16 = vextq_s8(v14, v14, 8uLL);
  v15 = veorq_s8(v40, veorq_s8(v33, v39));
  if ( v5 != -32LL )
  {
LABEL_16:
    v41 = veorq_s8(v16, v15);
    v42 = veorq_s8(v14, vextq_s8(v15, v15, 8uLL));
    v43 = vmull_p64(v7.n128_u64[0], v41.n128_u64[0]);
    v44 = vmull_high_p64(v7, v41);
    v45 = veorq_s8(
            veorq_s8(vmull_p64(v8.n128_u64[0], *(_OWORD *)&veorq_s8(v42, v41)), vextq_s8(v43, v44, 8uLL)),
            veorq_s8(v43, v44));
    v44.n128_u64[0] = v45.n128_u64[1];
    v45.n128_u64[1] = v43.n128_u64[0];
    v46 = veorq_s8(v45, vmull_p64(v43.n128_u64[0], v13));
    v15 = veorq_s8(vmull_p64(v46.n128_u64[0], v13), veorq_s8(vextq_s8(v46, v46, 8uLL), v44));
  }
  v47 = vrev64q_s8(v15);
  result = vextq_s8(v47, v47, 8uLL);
  *a1 = result;
  return result;
}

//----- (0000000000052CC0) ----------------------------------------------------
unsigned __int64 *__fastcall sub_52CC0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 v3; // x20
  unsigned __int64 v4; // x21
  unsigned __int64 v5; // x22
  unsigned __int64 v6; // x23
  unsigned __int64 v7; // x24
  unsigned __int64 v8; // x25
  unsigned __int64 v9; // x26
  unsigned __int64 v10; // x27
  __int64 *v11; // x30
  unsigned __int64 *v12; // x1
  unsigned __int64 v13; // x3
  unsigned __int64 v14; // x4
  __int64 *v15; // x30
  __int64 v16; // t1
  unsigned __int64 v17; // x3
  unsigned __int64 v18; // x27
  unsigned __int64 v19; // x23
  __int64 v20; // t1
  unsigned __int64 v21; // x4
  unsigned __int64 v22; // x5
  unsigned __int64 v23; // x6
  unsigned __int64 v24; // x27
  unsigned __int64 v25; // x26
  unsigned __int64 v26; // x22
  __int64 v27; // t1
  unsigned __int64 v28; // x5
  unsigned __int64 v29; // x26
  unsigned __int64 v30; // x25
  unsigned __int64 v31; // x21
  __int64 v32; // t1
  unsigned __int64 v33; // x6
  unsigned __int64 v34; // x7
  unsigned __int64 v35; // x8
  unsigned __int64 v36; // x25
  unsigned __int64 v37; // x24
  unsigned __int64 v38; // x20
  __int64 v39; // t1
  unsigned __int64 v40; // x7
  unsigned __int64 v41; // x24
  unsigned __int64 v42; // x23
  unsigned __int64 v43; // x27
  __int64 v44; // t1
  unsigned __int64 v45; // x8
  unsigned __int64 v46; // x9
  unsigned __int64 v47; // x10
  unsigned __int64 v48; // x23
  unsigned __int64 v49; // x22
  unsigned __int64 v50; // x26
  __int64 v51; // t1
  unsigned __int64 v52; // x9
  unsigned __int64 v53; // x22
  unsigned __int64 v54; // x21
  unsigned __int64 v55; // x25
  __int64 v56; // t1
  unsigned __int64 v57; // x10
  unsigned __int64 v58; // x11
  unsigned __int64 v59; // x12
  unsigned __int64 v60; // x21
  unsigned __int64 v61; // x20
  unsigned __int64 v62; // x24
  __int64 v63; // t1
  unsigned __int64 v64; // x11
  unsigned __int64 v65; // x20
  unsigned __int64 v66; // x27
  unsigned __int64 v67; // x23
  __int64 v68; // t1
  unsigned __int64 v69; // x12
  unsigned __int64 v70; // x13
  unsigned __int64 v71; // x14
  unsigned __int64 v72; // x27
  unsigned __int64 v73; // x26
  unsigned __int64 v74; // x22
  __int64 v75; // t1
  unsigned __int64 v76; // x13
  unsigned __int64 v77; // x26
  unsigned __int64 v78; // x25
  unsigned __int64 v79; // x21
  __int64 v80; // t1
  unsigned __int64 v81; // x14
  unsigned __int64 v82; // x0
  unsigned __int64 v83; // x15
  unsigned __int64 v84; // x25
  unsigned __int64 v85; // x24
  unsigned __int64 v86; // x20
  __int64 v87; // t1
  unsigned __int64 v88; // x15
  unsigned __int64 v89; // x24
  unsigned __int64 v90; // x23
  unsigned __int64 v91; // x27
  __int64 v92; // t1
  unsigned __int64 v93; // x0
  unsigned __int64 *v94; // t2
  unsigned __int64 v95; // x23
  unsigned __int64 v96; // x22
  unsigned __int64 v97; // x26
  __int64 v98; // t1
  unsigned __int64 v99; // x1
  unsigned __int64 v100; // x22
  unsigned __int64 v101; // x21
  unsigned __int64 v102; // x25
  __int64 v103; // t1
  unsigned __int64 v104; // x2
  unsigned __int64 v105; // x21
  unsigned __int64 v106; // x28
  unsigned __int64 v107; // x20
  unsigned __int64 v108; // x24
  __int64 v109; // x19
  __int64 *v110; // x30
  __int64 v111; // t1
  unsigned __int64 v112; // x20
  unsigned __int64 v113; // x3
  unsigned __int64 v114; // x27
  unsigned __int64 v115; // x23
  __int64 *v116; // x30
  __int64 v117; // t1
  unsigned __int64 v118; // x27
  unsigned __int64 v119; // x26
  unsigned __int64 v120; // x22
  __int64 v121; // t1
  unsigned __int64 v122; // x26
  unsigned __int64 v123; // x25
  unsigned __int64 v124; // x21
  __int64 v125; // t1
  unsigned __int64 v126; // x25
  unsigned __int64 v127; // x24
  unsigned __int64 v128; // x20
  __int64 v129; // t1
  unsigned __int64 v130; // x24
  unsigned __int64 v131; // x23
  unsigned __int64 v132; // x27
  __int64 v133; // t1
  unsigned __int64 v134; // x23
  unsigned __int64 v135; // x8
  unsigned __int64 v136; // x22
  unsigned __int64 v137; // x26
  __int64 v138; // t1
  unsigned __int64 v139; // x22
  unsigned __int64 v140; // x9
  unsigned __int64 v141; // x21
  unsigned __int64 v142; // x25
  __int64 v143; // t1
  unsigned __int64 v144; // x21
  unsigned __int64 v145; // x10
  unsigned __int64 v146; // x20
  unsigned __int64 v147; // x24
  __int64 v148; // t1
  unsigned __int64 v149; // x20
  unsigned __int64 v150; // x27
  unsigned __int64 v151; // x23
  __int64 v152; // t1
  unsigned __int64 v153; // x27
  unsigned __int64 v154; // x26
  unsigned __int64 v155; // x22
  __int64 v156; // t1
  unsigned __int64 v157; // x26
  unsigned __int64 v158; // x25
  unsigned __int64 v159; // x21
  __int64 v160; // t1
  unsigned __int64 v161; // x25
  unsigned __int64 v162; // x24
  unsigned __int64 v163; // x20
  __int64 v164; // t1
  unsigned __int64 v165; // x24
  unsigned __int64 v166; // x23
  __int64 v167; // t1
  unsigned __int64 v168; // x22
  __int64 v169; // t1
  unsigned __int64 v170; // x21
  __int64 v171; // t1
  unsigned __int64 v172; // x20
  __int64 v173; // t1
  unsigned __int64 *result; // x0
  unsigned __int64 v175; // x7
  unsigned __int64 v176; // x8
  unsigned __int64 v177; // x9
  unsigned __int64 v178; // x10
  unsigned __int64 v179; // [xsp+8h] [xbp-18h]
  unsigned __int64 v180; // [xsp+10h] [xbp-10h]
  unsigned __int64 v181; // [xsp+18h] [xbp-8h]
  unsigned __int64 *v182; // [xsp+80h] [xbp+60h]
  unsigned __int64 *v183; // [xsp+88h] [xbp+68h]
  unsigned __int64 *v184; // [xsp+90h] [xbp+70h]

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  v6 = a1[3];
  v7 = a1[4];
  v8 = a1[5];
  v9 = a1[6];
  v10 = a1[7];
  v11 = &qword_53B00;
  v182 = a1;
  v183 = &a2[16 * a3];
  do
  {
    v13 = *a2;
    v14 = a2[1];
    v12 = a2 + 2;
    v16 = *v11;
    v15 = v11 + 1;
    v184 = v12;
    v17 = bswap32(v13);
    v18 = v10 + v16 + v17 + (v8 & v7 | v9 & ~v7) + (__ROR8__(v7, 14) ^ __ROR8__(v7 ^ __ROR8__(v7, 23), 18));
    v19 = v6 + v18;
    v20 = *v15;
    ++v15;
    v21 = bswap32(v14);
    v22 = *v12;
    v23 = v12[1];
    v12 += 2;
    v24 = v18 + ((v4 ^ v5) & (v3 ^ v4) ^ v4) + (__ROR8__(v3, 28) ^ __ROR8__(v3 ^ __ROR8__(v3, 5), 34));
    v25 = v9 + v20 + v21 + (v7 & v19 | v8 & ~v19) + (__ROR8__(v19, 14) ^ __ROR8__(v19 ^ __ROR8__(v19, 23), 18));
    v26 = v5 + v25;
    v27 = *v15;
    ++v15;
    v28 = bswap32(v22);
    v29 = v25 + ((v3 ^ v4) & (v24 ^ v3) ^ v3) + (__ROR8__(v24, 28) ^ __ROR8__(v24 ^ __ROR8__(v24, 5), 34));
    v30 = v8 + v27 + v28 + (v19 & v26 | v7 & ~v26) + (__ROR8__(v26, 14) ^ __ROR8__(v26 ^ __ROR8__(v26, 23), 18));
    v31 = v4 + v30;
    v32 = *v15;
    ++v15;
    v33 = bswap32(v23);
    v34 = *v12;
    v35 = v12[1];
    v12 += 2;
    v36 = v30 + ((v24 ^ v3) & (v29 ^ v24) ^ v24) + (__ROR8__(v29, 28) ^ __ROR8__(v29 ^ __ROR8__(v29, 5), 34));
    v37 = v7 + v32 + v33 + (v26 & v31 | v19 & ~v31) + (__ROR8__(v31, 14) ^ __ROR8__(v31 ^ __ROR8__(v31, 23), 18));
    v38 = v3 + v37;
    v39 = *v15;
    ++v15;
    v40 = bswap32(v34);
    v41 = v37 + ((v29 ^ v24) & (v36 ^ v29) ^ v29) + (__ROR8__(v36, 28) ^ __ROR8__(v36 ^ __ROR8__(v36, 5), 34));
    v42 = v19 + v39 + v40 + (v31 & v38 | v26 & ~v38) + (__ROR8__(v38, 14) ^ __ROR8__(v38 ^ __ROR8__(v38, 23), 18));
    v43 = v24 + v42;
    v44 = *v15;
    ++v15;
    v45 = bswap32(v35);
    v46 = *v12;
    v47 = v12[1];
    v12 += 2;
    v48 = v42 + ((v36 ^ v29) & (v41 ^ v36) ^ v36) + (__ROR8__(v41, 28) ^ __ROR8__(v41 ^ __ROR8__(v41, 5), 34));
    v49 = v26 + v44 + v45 + (v38 & v43 | v31 & ~v43) + (__ROR8__(v43, 14) ^ __ROR8__(v43 ^ __ROR8__(v43, 23), 18));
    v50 = v29 + v49;
    v51 = *v15;
    ++v15;
    v52 = bswap32(v46);
    v53 = v49 + ((v41 ^ v36) & (v48 ^ v41) ^ v41) + (__ROR8__(v48, 28) ^ __ROR8__(v48 ^ __ROR8__(v48, 5), 34));
    v54 = v31 + v51 + v52 + (v43 & v50 | v38 & ~v50) + (__ROR8__(v50, 14) ^ __ROR8__(v50 ^ __ROR8__(v50, 23), 18));
    v55 = v36 + v54;
    v56 = *v15;
    ++v15;
    v57 = bswap32(v47);
    v58 = *v12;
    v59 = v12[1];
    v12 += 2;
    v60 = v54 + ((v48 ^ v41) & (v53 ^ v48) ^ v48) + (__ROR8__(v53, 28) ^ __ROR8__(v53 ^ __ROR8__(v53, 5), 34));
    v61 = v38 + v56 + v57 + (v50 & v55 | v43 & ~v55) + (__ROR8__(v55, 14) ^ __ROR8__(v55 ^ __ROR8__(v55, 23), 18));
    v62 = v41 + v61;
    v63 = *v15;
    ++v15;
    v64 = bswap32(v58);
    v65 = v61 + ((v53 ^ v48) & (v60 ^ v53) ^ v53) + (__ROR8__(v60, 28) ^ __ROR8__(v60 ^ __ROR8__(v60, 5), 34));
    v66 = v43 + v63 + v64 + (v55 & v62 | v50 & ~v62) + (__ROR8__(v62, 14) ^ __ROR8__(v62 ^ __ROR8__(v62, 23), 18));
    v67 = v48 + v66;
    v68 = *v15;
    ++v15;
    v69 = bswap32(v59);
    v70 = *v12;
    v71 = v12[1];
    v12 += 2;
    v72 = v66 + ((v60 ^ v53) & (v65 ^ v60) ^ v60) + (__ROR8__(v65, 28) ^ __ROR8__(v65 ^ __ROR8__(v65, 5), 34));
    v73 = v50 + v68 + v69 + (v62 & v67 | v55 & ~v67) + (__ROR8__(v67, 14) ^ __ROR8__(v67 ^ __ROR8__(v67, 23), 18));
    v74 = v53 + v73;
    v75 = *v15;
    ++v15;
    v76 = bswap32(v70);
    v77 = v73 + ((v65 ^ v60) & (v72 ^ v65) ^ v65) + (__ROR8__(v72, 28) ^ __ROR8__(v72 ^ __ROR8__(v72, 5), 34));
    v78 = v55 + v75 + v76 + (v67 & v74 | v62 & ~v74) + (__ROR8__(v74, 14) ^ __ROR8__(v74 ^ __ROR8__(v74, 23), 18));
    v79 = v60 + v78;
    v80 = *v15;
    ++v15;
    v81 = bswap32(v71);
    v83 = *v12;
    v82 = v12[1];
    v12 += 2;
    v84 = v78 + ((v72 ^ v65) & (v77 ^ v72) ^ v72) + (__ROR8__(v77, 28) ^ __ROR8__(v77 ^ __ROR8__(v77, 5), 34));
    v85 = v62 + v80 + v81 + (v74 & v79 | v67 & ~v79) + (__ROR8__(v79, 14) ^ __ROR8__(v79 ^ __ROR8__(v79, 23), 18));
    v86 = v65 + v85;
    v87 = *v15;
    ++v15;
    v88 = bswap32(v83);
    v89 = v85 + ((v77 ^ v72) & (v84 ^ v77) ^ v77) + (__ROR8__(v84, 28) ^ __ROR8__(v84 ^ __ROR8__(v84, 5), 34));
    v90 = v67 + v87 + v88 + (v79 & v86 | v74 & ~v86) + (__ROR8__(v86, 14) ^ __ROR8__(v86 ^ __ROR8__(v86, 23), 18));
    v91 = v72 + v90;
    v92 = *v15;
    ++v15;
    v93 = bswap32(v82);
    v94 = v12;
    v95 = v90 + ((v84 ^ v77) & (v89 ^ v84) ^ v84) + (__ROR8__(v89, 28) ^ __ROR8__(v89 ^ __ROR8__(v89, 5), 34));
    v179 = v45;
    v96 = v74 + v92 + v93 + (v86 & v91 | v79 & ~v91) + (__ROR8__(v91, 14) ^ __ROR8__(v91 ^ __ROR8__(v91, 23), 18));
    v97 = v77 + v96;
    v98 = *v15;
    ++v15;
    v99 = bswap32(*v12);
    v100 = v96 + ((v89 ^ v84) & (v95 ^ v89) ^ v89) + (__ROR8__(v95, 28) ^ __ROR8__(v95 ^ __ROR8__(v95, 5), 34));
    v180 = v52;
    v101 = v79 + v98 + v99 + (v91 & v97 | v86 & ~v97) + (__ROR8__(v97, 14) ^ __ROR8__(v97 ^ __ROR8__(v97, 23), 18));
    v102 = v84 + v101;
    v103 = *v15;
    ++v15;
    v104 = bswap32(v94[1]);
    v105 = v101 + ((v95 ^ v89) & (v100 ^ v95) ^ v95) + (__ROR8__(v100, 28) ^ __ROR8__(v100 ^ __ROR8__(v100, 5), 34));
    v181 = v57;
    v106 = v105 ^ v100;
    v107 = v86
         + v103
         + v104
         + (v97 & v102 | v91 & ~v102)
         + (__ROR8__(v102, 14) ^ __ROR8__(v102, 18) ^ __ROR8__(v102, 41));
    v108 = v89 + v107;
    v111 = *v15;
    v110 = v15 + 1;
    v109 = v111;
    v112 = v107 + ((v100 ^ v95) & (v105 ^ v100) ^ v100) + (__ROR8__(v105, 28) ^ __ROR8__(v105, 34) ^ __ROR8__(v105, 39));
    v113 = v17
         + v69
         + (__ROR8__(v21, 1) ^ __ROR8__(v21, 8) ^ (v21 >> 7))
         + (__ROR8__(v99, 19) ^ __ROR8__(v99, 61) ^ (v99 >> 6));
    do
    {
      v114 = v91
           + v109
           + v113
           + (v102 & v108 | v97 & ~v108)
           + (__ROR8__(v108, 14) ^ __ROR8__(v108, 18) ^ __ROR8__(v108, 41));
      v115 = v95 + v114;
      v117 = *v110;
      v116 = v110 + 1;
      v118 = v114 + (v106 & (v112 ^ v105) ^ v105) + (__ROR8__(v112, 28) ^ __ROR8__(v112, 34) ^ __ROR8__(v112, 39));
      v21 += v76
           + (__ROR8__(v28, 1) ^ __ROR8__(v28, 8) ^ (v28 >> 7))
           + (__ROR8__(v104, 19) ^ __ROR8__(v104, 61) ^ (v104 >> 6));
      v119 = v97
           + v117
           + v21
           + (v108 & v115 | v102 & ~v115)
           + (__ROR8__(v115, 14) ^ __ROR8__(v115, 18) ^ __ROR8__(v115, 41));
      v120 = v100 + v119;
      v121 = *v116;
      ++v116;
      v122 = v119
           + ((v112 ^ v105) & (v118 ^ v112) ^ v112)
           + (__ROR8__(v118, 28) ^ __ROR8__(v118, 34) ^ __ROR8__(v118, 39));
      v28 += v81
           + (__ROR8__(v33, 1) ^ __ROR8__(v33, 8) ^ (v33 >> 7))
           + (__ROR8__(v113, 19) ^ __ROR8__(v113, 61) ^ (v113 >> 6));
      v123 = v102
           + v121
           + v28
           + (v115 & v120 | v108 & ~v120)
           + (__ROR8__(v120, 14) ^ __ROR8__(v120, 18) ^ __ROR8__(v120, 41));
      v124 = v105 + v123;
      v125 = *v116;
      ++v116;
      v126 = v123
           + ((v118 ^ v112) & (v122 ^ v118) ^ v118)
           + (__ROR8__(v122, 28) ^ __ROR8__(v122, 34) ^ __ROR8__(v122, 39));
      v33 += v88
           + (__ROR8__(v40, 1) ^ __ROR8__(v40, 8) ^ (v40 >> 7))
           + (__ROR8__(v21, 19) ^ __ROR8__(v21, 61) ^ (v21 >> 6));
      v127 = v108
           + v125
           + v33
           + (v120 & v124 | v115 & ~v124)
           + (__ROR8__(v124, 14) ^ __ROR8__(v124, 18) ^ __ROR8__(v124, 41));
      v128 = v112 + v127;
      v129 = *v116;
      ++v116;
      v130 = v127
           + ((v122 ^ v118) & (v126 ^ v122) ^ v122)
           + (__ROR8__(v126, 28) ^ __ROR8__(v126, 34) ^ __ROR8__(v126, 39));
      v40 += v93
           + (__ROR8__(v179, 1) ^ __ROR8__(v179, 8) ^ (v179 >> 7))
           + (__ROR8__(v28, 19) ^ __ROR8__(v28, 61) ^ (v28 >> 6));
      v131 = v115
           + v129
           + v40
           + (v124 & v128 | v120 & ~v128)
           + (__ROR8__(v128, 14) ^ __ROR8__(v128, 18) ^ __ROR8__(v128, 41));
      v132 = v118 + v131;
      v133 = *v116;
      ++v116;
      v134 = v131
           + ((v126 ^ v122) & (v130 ^ v126) ^ v126)
           + (__ROR8__(v130, 28) ^ __ROR8__(v130, 34) ^ __ROR8__(v130, 39));
      v135 = v179
           + v99
           + (__ROR8__(v180, 1) ^ __ROR8__(v180, 8) ^ (v180 >> 7))
           + (__ROR8__(v33, 19) ^ __ROR8__(v33, 61) ^ (v33 >> 6));
      v136 = v120
           + v133
           + v135
           + (v128 & v132 | v124 & ~v132)
           + (__ROR8__(v132, 14) ^ __ROR8__(v132, 18) ^ __ROR8__(v132, 41));
      v137 = v122 + v136;
      v138 = *v116;
      ++v116;
      v139 = v136
           + ((v130 ^ v126) & (v134 ^ v130) ^ v130)
           + (__ROR8__(v134, 28) ^ __ROR8__(v134, 34) ^ __ROR8__(v134, 39));
      v140 = v180
           + v104
           + (__ROR8__(v181, 1) ^ __ROR8__(v181, 8) ^ (v181 >> 7))
           + (__ROR8__(v40, 19) ^ __ROR8__(v40, 61) ^ (v40 >> 6));
      v141 = v124
           + v138
           + v140
           + (v132 & v137 | v128 & ~v137)
           + (__ROR8__(v137, 14) ^ __ROR8__(v137, 18) ^ __ROR8__(v137, 41));
      v142 = v126 + v141;
      v143 = *v116;
      ++v116;
      v144 = v141
           + ((v134 ^ v130) & (v139 ^ v134) ^ v134)
           + (__ROR8__(v139, 28) ^ __ROR8__(v139, 34) ^ __ROR8__(v139, 39));
      v145 = v181
           + v113
           + (__ROR8__(v64, 1) ^ __ROR8__(v64, 8) ^ (v64 >> 7))
           + (__ROR8__(v135, 19) ^ __ROR8__(v135, 61) ^ (v135 >> 6));
      v146 = v128
           + v143
           + v145
           + (v137 & v142 | v132 & ~v142)
           + (__ROR8__(v142, 14) ^ __ROR8__(v142, 18) ^ __ROR8__(v142, 41));
      v147 = v130 + v146;
      v148 = *v116;
      ++v116;
      v149 = v146
           + ((v139 ^ v134) & (v144 ^ v139) ^ v139)
           + (__ROR8__(v144, 28) ^ __ROR8__(v144, 34) ^ __ROR8__(v144, 39));
      v64 += v21
           + (__ROR8__(v69, 1) ^ __ROR8__(v69, 8) ^ (v69 >> 7))
           + (__ROR8__(v140, 19) ^ __ROR8__(v140, 61) ^ (v140 >> 6));
      v150 = v132
           + v148
           + v64
           + (v142 & v147 | v137 & ~v147)
           + (__ROR8__(v147, 14) ^ __ROR8__(v147, 18) ^ __ROR8__(v147, 41));
      v151 = v134 + v150;
      v152 = *v116;
      ++v116;
      v153 = v150
           + ((v144 ^ v139) & (v149 ^ v144) ^ v144)
           + (__ROR8__(v149, 28) ^ __ROR8__(v149, 34) ^ __ROR8__(v149, 39));
      v69 += v28
           + (__ROR8__(v76, 1) ^ __ROR8__(v76, 8) ^ (v76 >> 7))
           + (__ROR8__(v145, 19) ^ __ROR8__(v145, 61) ^ (v145 >> 6));
      v154 = v137
           + v152
           + v69
           + (v147 & v151 | v142 & ~v151)
           + (__ROR8__(v151, 14) ^ __ROR8__(v151, 18) ^ __ROR8__(v151, 41));
      v155 = v139 + v154;
      v156 = *v116;
      ++v116;
      v157 = v154
           + ((v149 ^ v144) & (v153 ^ v149) ^ v149)
           + (__ROR8__(v153, 28) ^ __ROR8__(v153, 34) ^ __ROR8__(v153, 39));
      v76 += v33
           + (__ROR8__(v81, 1) ^ __ROR8__(v81, 8) ^ (v81 >> 7))
           + (__ROR8__(v64, 19) ^ __ROR8__(v64, 61) ^ (v64 >> 6));
      v158 = v142
           + v156
           + v76
           + (v151 & v155 | v147 & ~v155)
           + (__ROR8__(v155, 14) ^ __ROR8__(v155, 18) ^ __ROR8__(v155, 41));
      v159 = v144 + v158;
      v160 = *v116;
      ++v116;
      v161 = v158
           + ((v153 ^ v149) & (v157 ^ v153) ^ v153)
           + (__ROR8__(v157, 28) ^ __ROR8__(v157, 34) ^ __ROR8__(v157, 39));
      v81 += v40
           + (__ROR8__(v88, 1) ^ __ROR8__(v88, 8) ^ (v88 >> 7))
           + (__ROR8__(v69, 19) ^ __ROR8__(v69, 61) ^ (v69 >> 6));
      v162 = v147
           + v160
           + v81
           + (v155 & v159 | v151 & ~v159)
           + (__ROR8__(v159, 14) ^ __ROR8__(v159, 18) ^ __ROR8__(v159, 41));
      v163 = v149 + v162;
      v164 = *v116;
      ++v116;
      v165 = v162
           + ((v157 ^ v153) & (v161 ^ v157) ^ v157)
           + (__ROR8__(v161, 28) ^ __ROR8__(v161, 34) ^ __ROR8__(v161, 39));
      v88 += v135
           + (__ROR8__(v93, 1) ^ __ROR8__(v93, 8) ^ (v93 >> 7))
           + (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6));
      v166 = v151
           + v164
           + v88
           + (v159 & v163 | v155 & ~v163)
           + (__ROR8__(v163, 14) ^ __ROR8__(v163, 18) ^ __ROR8__(v163, 41));
      v91 = v153 + v166;
      v167 = *v116;
      ++v116;
      v95 = v166
          + ((v161 ^ v157) & (v165 ^ v161) ^ v161)
          + (__ROR8__(v165, 28) ^ __ROR8__(v165, 34) ^ __ROR8__(v165, 39));
      v93 += v140
           + (__ROR8__(v99, 1) ^ __ROR8__(v99, 8) ^ (v99 >> 7))
           + (__ROR8__(v81, 19) ^ __ROR8__(v81, 61) ^ (v81 >> 6));
      v179 += v99
            + (__ROR8__(v180, 1) ^ __ROR8__(v180, 8) ^ (v180 >> 7))
            + (__ROR8__(v33, 19) ^ __ROR8__(v33, 61) ^ (v33 >> 6));
      v168 = v155
           + v167
           + v93
           + (v163 & v91 | v159 & ~v91)
           + (__ROR8__(v91, 14) ^ __ROR8__(v91, 18) ^ __ROR8__(v91, 41));
      v97 = v157 + v168;
      v169 = *v116;
      ++v116;
      v100 = v168 + ((v165 ^ v161) & (v95 ^ v165) ^ v165) + (__ROR8__(v95, 28) ^ __ROR8__(v95, 34) ^ __ROR8__(v95, 39));
      v99 += v145
           + (__ROR8__(v104, 1) ^ __ROR8__(v104, 8) ^ (v104 >> 7))
           + (__ROR8__(v88, 19) ^ __ROR8__(v88, 61) ^ (v88 >> 6));
      v180 += v104
            + (__ROR8__(v181, 1) ^ __ROR8__(v181, 8) ^ (v181 >> 7))
            + (__ROR8__(v40, 19) ^ __ROR8__(v40, 61) ^ (v40 >> 6));
      v170 = v159 + v169 + v99 + (v91 & v97 | v163 & ~v97) + (__ROR8__(v97, 14) ^ __ROR8__(v97, 18) ^ __ROR8__(v97, 41));
      v102 = v161 + v170;
      v171 = *v116;
      ++v116;
      v105 = v170 + ((v95 ^ v165) & (v100 ^ v95) ^ v95) + (__ROR8__(v100, 28) ^ __ROR8__(v100, 34) ^ __ROR8__(v100, 39));
      v104 += v64
            + (__ROR8__(v113, 1) ^ __ROR8__(v113, 8) ^ (v113 >> 7))
            + (__ROR8__(v93, 19) ^ __ROR8__(v93, 61) ^ (v93 >> 6));
      v181 = v145;
      v106 = v105 ^ v100;
      v172 = v163
           + v171
           + v104
           + (v97 & v102 | v91 & ~v102)
           + (__ROR8__(v102, 14) ^ __ROR8__(v102, 18) ^ __ROR8__(v102, 41));
      v108 = v165 + v172;
      v173 = *v116;
      v110 = v116 + 1;
      v109 = v173;
      v112 = v172
           + ((v100 ^ v95) & (v105 ^ v100) ^ v100)
           + (__ROR8__(v105, 28) ^ __ROR8__(v105, 34) ^ __ROR8__(v105, 39));
      v113 += v69
            + (__ROR8__(v21, 1) ^ __ROR8__(v21, 8) ^ (v21 >> 7))
            + (__ROR8__(v99, 19) ^ __ROR8__(v99, 61) ^ (v99 >> 6));
    }
    while ( v173 );
    result = v182;
    v11 = v110 - 81;
    a2 = v184 + 14;
    v175 = v182[4];
    v176 = v182[5];
    v3 = v112 + *v182;
    v177 = v182[6];
    v178 = v182[7];
    v4 = v105 + v182[1];
    v5 = v100 + v182[2];
    v6 = v95 + v182[3];
    *v182 = v3;
    v182[1] = v4;
    v7 = v108 + v175;
    v8 = v102 + v176;
    v182[2] = v5;
    v182[3] = v6;
    v9 = v97 + v177;
    v10 = v91 + v178;
    v182[4] = v7;
    v182[5] = v8;
    v182[6] = v9;
    v182[7] = v10;
  }
  while ( v184 + 14 != v183 );
  return result;
}
// 53B00: using guessed type __int64 qword_53B00;

//----- (0000000000053DD4) ----------------------------------------------------
__int64 __fastcall sub_53DD4(__int64 result, signed __int64 a2, _BYTE *a3, __int64 a4, char *a5, __int64 a6)
{
  __int64 v6; // x21
  char *v7; // x19
  unsigned int v8; // w22
  _BYTE *v9; // x23
  signed __int64 v10; // x24
  unsigned __int64 v11; // x25
  unsigned int v12; // w20
  _QWORD *v13; // x22
  unsigned __int64 v14; // x21
  __int64 v15; // [xsp+0h] [xbp-70h]
  _QWORD *v16; // [xsp+8h] [xbp-68h]
  unsigned int v17; // [xsp+14h] [xbp-5Ch]
  __int64 v18; // [xsp+18h] [xbp-58h]
  __int64 v19; // [xsp+20h] [xbp-50h]
  __int64 v20; // [xsp+28h] [xbp-48h]

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = result;
  v12 = -22;
  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v15 = 0LL;
  v16 = 0LL;
  if ( result && a2 && a3 && a4 && a5 && a6 )
  {
    std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf();
    v12 = sub_564EC(&v15, 0LL, 0LL, 512);
    if ( !v12 )
    {
      v12 = sub_57618(v15, v11, v10, v9, v8, &v16);
      if ( !v12 )
      {
        v13 = v16;
        v18 = 0LL;
        v19 = 0LL;
        v17 = 0;
        v12 = sub_57540((__int64)v16, &v19);
        if ( !v12 )
        {
          if ( *(_DWORD *)(v19 + 4) != 37 || *(_DWORD *)(v19 + 8) != 2 )
          {
            v12 = -1016;
          }
          else
          {
            v12 = sub_5757C((__int64)v13, &v17);
            if ( !v12 )
            {
              if ( v17 == v6 )
              {
                if ( v17 )
                {
                  v14 = 0LL;
                  do
                  {
                    v12 = sub_5759C((__int64)v13, v14, &v18);
                    if ( v12 )
                      break;
                    if ( (unsigned int)memcmp(v7, *(const void **)(v18 + 8), 0x20uLL) )
                      goto LABEL_24;
                    v12 = 0;
                    ++v14;
                    v7 += 32;
                  }
                  while ( v14 < v17 );
                }
                else
                {
                  v12 = 0;
                }
              }
              else
              {
LABEL_24:
                v12 = -1025;
              }
            }
          }
        }
      }
    }
    sub_57508(v16);
    sub_566B8(v15);
    result = std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf();
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v20 )
    result = v12;
  return result;
}
// 564E8: using guessed type __int64 std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(void);

//----- (0000000000053F88) ----------------------------------------------------
signed __int64 __fastcall AES_set_encrypt_key(unsigned __int8 *a1, int a2, unsigned int *a3)
{
  unsigned int v3; // w8
  signed int v4; // w8
  unsigned int v5; // w8
  __int64 v6; // x9
  unsigned int *v7; // x10
  unsigned int v8; // w16
  int v9; // w18
  int v10; // w17
  int v11; // w17
  __int64 v12; // x9
  unsigned int *i; // x10
  int v14; // w17
  unsigned int v15; // w16
  int v16; // w18
  int v17; // w17
  int v18; // w0
  __int64 v20; // x9
  unsigned int *j; // x10
  unsigned int v22; // w17
  int v23; // w18
  int v24; // w0
  unsigned int v25; // w16
  int v26; // w18
  int v27; // w17
  int v28; // w0
  unsigned int v29; // w17

  v3 = -1;
  if ( a1 && a3 )
  {
    switch ( a2 )
    {
      case 128:
        v4 = 10;
        break;
      case 256:
        v4 = 14;
        break;
      case 192:
        v4 = 12;
        break;
      default:
        return 4294967294LL;
    }
    a3[60] = v4;
    v5 = ((*a1 << 24) & 0xFF00FFFF | (a1[1] << 16)) & 0xFFFF00FF | (a1[2] << 8) | a1[3];
    *a3 = v5;
    a3[1] = ((a1[4] << 24) & 0xFF00FFFF | (a1[5] << 16)) & 0xFFFF00FF | (a1[6] << 8) | a1[7];
    a3[2] = ((a1[8] << 24) & 0xFF00FFFF | (a1[9] << 16)) & 0xFFFF00FF | (a1[10] << 8) | a1[11];
    a3[3] = ((a1[12] << 24) & 0xFF00FFFF | (a1[13] << 16)) & 0xFFFF00FF | (a1[14] << 8) | a1[15];
    if ( a2 == 128 )
    {
      v6 = 0LL;
      v7 = a3 + 4;
      do
      {
        v8 = *(v7 - 1);
        v5 ^= dword_D4E4C[(v8 >> 16) & 0xFF] & 0xFF000000 ^ dword_D524C[(unsigned __int16)v8 >> 8] & 0xFF0000 ^ dword_D564C[(unsigned __int8)v8] & 0xFF00 ^ byte_D5A4C[4 * (v8 >> 24)] ^ *(_DWORD *)((char *)&unk_D5E4C + v6);
        v9 = *(v7 - 2);
        v6 += 4LL;
        v10 = *(v7 - 3) ^ v5;
        *v7 = v5;
        v7[1] = v10;
        v11 = v9 ^ v10;
        v7[2] = v11;
        v7[3] = v11 ^ v8;
        v7 += 4;
      }
      while ( v6 != 40 );
    }
    else
    {
      a3[4] = ((a1[16] << 24) & 0xFF00FFFF | (a1[17] << 16)) & 0xFFFF00FF | (a1[18] << 8) | a1[19];
      a3[5] = ((a1[20] << 24) & 0xFF00FFFF | (a1[21] << 16)) & 0xFFFF00FF | (a1[22] << 8) | a1[23];
      if ( a2 == 192 )
      {
        v12 = 0LL;
        for ( i = a3 + 6; ; i += 6 )
        {
          v15 = *(i - 1);
          v5 ^= dword_D4E4C[(v15 >> 16) & 0xFF] & 0xFF000000 ^ dword_D524C[(unsigned __int16)v15 >> 8] & 0xFF0000 ^ dword_D564C[(unsigned __int8)v15] & 0xFF00 ^ byte_D5A4C[4 * (v15 >> 24)] ^ *(_DWORD *)((char *)&unk_D5E4C + v12);
          v16 = *(i - 3);
          v17 = *(i - 5) ^ v5;
          v18 = *(i - 4) ^ v17;
          *i = v5;
          i[1] = v17;
          i[2] = v18;
          i[3] = v16 ^ v18;
          if ( v12 == 28 )
            break;
          v12 += 4LL;
          v14 = *(i - 2) ^ v16 ^ v18;
          i[4] = v14;
          i[5] = v14 ^ v15;
        }
      }
      else
      {
        a3[6] = ((a1[24] << 24) & 0xFF00FFFF | (a1[25] << 16)) & 0xFFFF00FF | (a1[26] << 8) | a1[27];
        a3[7] = ((a1[28] << 24) & 0xFF00FFFF | (a1[29] << 16)) & 0xFFFF00FF | (a1[30] << 8) | a1[31];
        if ( a2 == 256 )
        {
          v20 = 0LL;
          for ( j = a3 + 8; ; j += 8 )
          {
            v25 = *(j - 1);
            v5 ^= dword_D4E4C[(v25 >> 16) & 0xFF] & 0xFF000000 ^ dword_D524C[(unsigned __int16)v25 >> 8] & 0xFF0000 ^ dword_D564C[(unsigned __int8)v25] & 0xFF00 ^ byte_D5A4C[4 * (v25 >> 24)] ^ *(_DWORD *)((char *)&unk_D5E4C + v20);
            v26 = *(j - 5);
            v27 = *(j - 7) ^ v5;
            v28 = *(j - 6) ^ v27;
            *j = v5;
            j[1] = v27;
            j[2] = v28;
            j[3] = v26 ^ v28;
            if ( v20 == 24 )
              break;
            v29 = v26 ^ v28;
            v22 = dword_D4E4C[v29 >> 24] & 0xFF000000 ^ *(j - 4) ^ dword_D524C[(v29 >> 16) & 0xFF] & 0xFF0000 ^ dword_D564C[(unsigned __int16)v29 >> 8] & 0xFF00 ^ byte_D5A4C[4 * (unsigned __int8)v29];
            v23 = *(j - 2);
            v24 = *(j - 3) ^ v22;
            j[4] = v22;
            j[5] = v24;
            v20 += 4LL;
            j[6] = v23 ^ v24;
            j[7] = v23 ^ v24 ^ v25;
          }
        }
      }
    }
    v3 = 0;
  }
  return v3;
}

//----- (0000000000054384) ----------------------------------------------------
signed __int64 __fastcall AES_set_decrypt_key(unsigned __int8 *a1, int a2, unsigned int *a3)
{
  unsigned int *v3; // x19
  signed __int64 result; // x0
  signed int v5; // w8
  int v6; // w9
  __int64 v7; // x8
  signed __int64 v8; // x11
  unsigned int *v9; // x9
  unsigned int *v10; // x10
  unsigned int v11; // w13
  bool v12; // nf
  unsigned __int8 v13; // vf
  unsigned int v14; // w13
  unsigned int v15; // w13
  unsigned int v16; // w13
  int *v17; // x8
  signed int v18; // w9
  unsigned int v19; // w15
  unsigned int v20; // w16
  unsigned int v21; // w17
  int v22; // w16
  int v23; // w17
  int v24; // w18

  v3 = a3;
  result = AES_set_encrypt_key(a1, a2, a3);
  if ( !(result & 0x80000000) )
  {
    v5 = v3[60];
    v6 = 4 * v5;
    if ( 4 * v5 >= 1 )
    {
      v7 = 0LL;
      v8 = v6 - 4LL;
      v9 = &v3[v6 + 2];
      v10 = v3 + 2;
      do
      {
        v11 = *(v10 - 2);
        v7 += 4LL;
        v13 = __OFSUB__(v7, v8);
        v12 = v7 - v8 < 0;
        *(v10 - 2) = *(v9 - 2);
        *(v9 - 2) = v11;
        v14 = *(v10 - 1);
        v8 -= 4LL;
        *(v10 - 1) = *(v9 - 1);
        *(v9 - 1) = v14;
        v15 = *v10;
        *v10 = *v9;
        *v9 = v15;
        v16 = v10[1];
        v10[1] = v9[1];
        v9[1] = v16;
        v9 -= 4;
        v10 += 4;
      }
      while ( v12 ^ v13 );
      v5 = v3[60];
    }
    if ( v5 > 1 )
    {
      v17 = (int *)(v3 + 7);
      v18 = 1;
      do
      {
        v19 = *(v17 - 3);
        v20 = *(v17 - 2);
        v21 = *(v17 - 1);
        ++v18;
        v22 = dword_D6274[byte_D5A4C[4 * ((v20 >> 16) & 0xFF)]] ^ dword_D5E74[byte_D5A4C[4 * (v20 >> 24)]] ^ dword_D6674[byte_D5A4C[4 * ((unsigned __int16)v20 >> 8)]] ^ dword_D6A74[byte_D5A4C[4 * (unsigned __int8)v20]];
        v23 = dword_D6274[byte_D5A4C[4 * ((v21 >> 16) & 0xFF)]] ^ dword_D5E74[byte_D5A4C[4 * (v21 >> 24)]] ^ dword_D6674[byte_D5A4C[4 * ((unsigned __int16)v21 >> 8)]] ^ dword_D6A74[byte_D5A4C[4 * (unsigned __int8)v21]];
        v24 = dword_D6274[byte_D5A4C[4 * (((unsigned int)*v17 >> 16) & 0xFF)]] ^ dword_D5E74[byte_D5A4C[4 * ((unsigned int)*v17 >> 24)]] ^ dword_D6674[byte_D5A4C[4 * ((unsigned __int16)*v17 >> 8)]] ^ dword_D6A74[byte_D5A4C[4 * (*v17 & 0xFFLL)]];
        *(v17 - 3) = dword_D6274[byte_D5A4C[4 * ((v19 >> 16) & 0xFF)]] ^ dword_D5E74[byte_D5A4C[4 * (v19 >> 24)]] ^ dword_D6674[byte_D5A4C[4 * ((unsigned __int16)v19 >> 8)]] ^ dword_D6A74[byte_D5A4C[4 * (unsigned __int8)v19]];
        *(v17 - 2) = v22;
        *(v17 - 1) = v23;
        *v17 = v24;
        v17 += 4;
      }
      while ( v18 < (signed int)v3[60] );
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000545BC) ----------------------------------------------------
__int64 __fastcall AES_encrypt(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3)
{
  unsigned int v3; // w3
  unsigned int v4; // w17
  unsigned int v5; // w16
  int v6; // w13
  unsigned int v7; // w15
  signed __int64 v8; // x14
  _DWORD *v9; // x12
  unsigned int v10; // w18
  int v11; // w26
  int v12; // w18
  int v13; // w5
  int v14; // w19
  int v15; // w20
  int v16; // w24
  int v17; // w25
  unsigned int v18; // w23
  int v19; // w26
  int v20; // w0
  int v21; // w17
  int v22; // w18
  int v23; // w6
  int v24; // w15
  int v25; // w4
  unsigned int v26; // w18
  unsigned int v27; // w17
  unsigned int v28; // w16
  unsigned int v29; // w0
  __int64 v30; // x24
  __int64 v31; // x4
  __int64 v32; // x22
  __int64 v33; // x19
  __int64 v34; // x20
  __int64 v35; // x7
  __int64 v36; // x23
  __int64 v37; // x25
  __int64 v38; // x3
  __int64 v39; // x6
  __int64 v40; // x21
  __int64 v41; // x5
  __int64 v42; // x0
  _DWORD *v43; // x12
  int v44; // w20
  int v45; // w4
  int v46; // w11
  __int64 result; // x0
  int v48; // w21
  int v49; // w7
  int v50; // w3
  int v51; // w8
  int v52; // w19
  int v53; // w6
  int v54; // w5
  int v55; // w10
  int v56; // w9
  int v57; // w13
  unsigned int v58; // w13
  int v59; // w5
  int v60; // w13
  unsigned int v61; // w8

  v3 = a3[60];
  v4 = (((*a1 << 24) & 0xFF00FFFF | (a1[1] << 16)) & 0xFFFF00FF | (a1[2] << 8) | a1[3]) ^ *a3;
  v5 = (((a1[4] << 24) & 0xFF00FFFF | (a1[5] << 16)) & 0xFFFF00FF | (a1[6] << 8) | a1[7]) ^ a3[1];
  v6 = 1 - (v3 >> 1);
  v7 = (((a1[8] << 24) & 0xFF00FFFF | (a1[9] << 16)) & 0xFFFF00FF | (a1[10] << 8) | a1[11]) ^ a3[2];
  v8 = 8LL * ((v3 >> 1) - 1);
  v9 = a3 + 6;
  v10 = (((a1[12] << 24) & 0xFF00FFFF | (a1[13] << 16)) & 0xFFFF00FF | (a1[14] << 8) | a1[15]) ^ a3[3];
  while ( 1 )
  {
    v13 = (unsigned __int8)v10;
    v14 = (unsigned __int16)v10 >> 8;
    v15 = (unsigned __int8)v4;
    v16 = (v10 >> 16) & 0xFF;
    v17 = (unsigned __int16)v4 >> 8;
    v18 = v7 >> 24;
    v19 = (unsigned __int8)v7;
    v20 = *(_DWORD *)&byte_D5A4C[4 * ((v5 >> 16) & 0xFF)] ^ dword_D564C[v4 >> 24];
    v21 = *(_DWORD *)&byte_D5A4C[4 * ((v4 >> 16) & 0xFF)] ^ dword_D564C[v10 >> 24];
    v22 = dword_D4E4C[(unsigned __int16)v7 >> 8];
    v23 = *(_DWORD *)&byte_D5A4C[4 * ((v7 >> 16) & 0xFF)] ^ dword_D564C[v5 >> 24];
    v24 = v9[2];
    v25 = v21 ^ dword_D4E4C[(unsigned __int16)v5 >> 8] ^ dword_D524C[v19];
    v26 = v20 ^ v22 ^ dword_D524C[v13] ^ *(v9 - 2);
    v27 = v23 ^ dword_D4E4C[v14] ^ dword_D524C[v15] ^ *(v9 - 1);
    v28 = *(_DWORD *)&byte_D5A4C[4 * v16] ^ dword_D564C[v18] ^ dword_D4E4C[v17] ^ dword_D524C[(unsigned __int8)v5] ^ *v9;
    v29 = v25 ^ v9[1];
    v30 = v26 >> 24;
    v31 = v28 >> 24;
    v32 = (unsigned __int8)v29;
    v33 = (unsigned __int16)v29 >> 8;
    v34 = v27 >> 24;
    v35 = (unsigned __int8)v26;
    v36 = (unsigned __int16)v28 >> 8;
    v37 = (v27 >> 16) & 0xFF;
    v38 = (unsigned __int8)v27;
    v39 = (v29 >> 16) & 0xFF;
    v40 = (v28 >> 16) & 0xFF;
    v41 = (unsigned __int16)v26 >> 8;
    v42 = v29 >> 24;
    if ( !v6 )
      break;
    v11 = dword_D524C[(unsigned __int8)v28];
    v12 = *(_DWORD *)&byte_D5A4C[4 * ((v26 >> 16) & 0xFF)] ^ dword_D564C[v42] ^ dword_D4E4C[(unsigned __int16)v27 >> 8];
    ++v6;
    v4 = dword_D564C[v30] ^ v24 ^ *(_DWORD *)&byte_D5A4C[4 * v37] ^ dword_D4E4C[v36] ^ dword_D524C[v32];
    v5 = *(_DWORD *)&byte_D5A4C[4 * v40] ^ dword_D564C[v34] ^ dword_D4E4C[v33] ^ dword_D524C[v35] ^ v9[3];
    v7 = *(_DWORD *)&byte_D5A4C[4 * v39] ^ dword_D564C[v31] ^ dword_D4E4C[v41] ^ dword_D524C[v38] ^ v9[4];
    v10 = v12 ^ v11 ^ v9[5];
    v9 += 8;
  }
  v43 = &a3[v8];
  v44 = dword_D4E4C[v34];
  v45 = dword_D4E4C[v31];
  v46 = dword_D4E4C[v42];
  result = byte_D5A4C[4 * v32];
  v48 = dword_D524C[v40];
  v49 = byte_D5A4C[4 * (unsigned __int8)v26];
  v50 = byte_D5A4C[4 * (unsigned __int8)v27];
  v51 = byte_D5A4C[4 * (unsigned __int8)v28];
  v52 = dword_D564C[v33];
  v53 = dword_D524C[v39];
  v54 = dword_D564C[v41];
  v55 = dword_D524C[(v26 >> 16) & 0xFF];
  v56 = dword_D564C[(unsigned __int16)v27 >> 8];
  v57 = (dword_D524C[v37] & 0xFF0000 | dword_D4E4C[v30] & 0xFF000000 | dword_D564C[v36] & 0xFF00 | result) ^ v24;
  a2[3] = result ^ v24;
  *a2 = HIBYTE(v57);
  a2[1] = BYTE2(v57);
  a2[2] = BYTE1(v57);
  v58 = (v48 & 0xFF0000 | v44 & 0xFF000000 | v52 & 0xFF00 | v49) ^ v43[9];
  a2[7] = v49 ^ *((_BYTE *)v43 + 36);
  a2[4] = HIBYTE(v58);
  a2[5] = BYTE2(v58);
  a2[6] = BYTE1(v58);
  v45 &= 0xFF000000;
  v53 &= 0xFF0000u;
  v59 = v54 & 0xFF00;
  v60 = (v53 | v45 | v59 | v50) ^ v43[10];
  a2[11] = (v53 | v45 | v59 | v50) ^ *((_BYTE *)v43 + 40);
  a2[8] = HIBYTE(v60);
  a2[9] = BYTE2(v60);
  a2[10] = BYTE1(v60);
  v61 = (v55 & 0xFF0000 | v46 & 0xFF000000 | v56 & 0xFF00 | v51) ^ v43[11];
  a2[12] = HIBYTE(v61);
  a2[13] = BYTE2(v61);
  a2[14] = BYTE1(v61);
  a2[15] = v61;
  return result;
}

//----- (00000000000549A4) ----------------------------------------------------
__int64 __fastcall AES_decrypt(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3)
{
  unsigned int v3; // w3
  unsigned int v4; // w16
  unsigned int v5; // w15
  unsigned int v6; // w17
  int v7; // w12
  _DWORD *v8; // x8
  signed __int64 v9; // x13
  unsigned int v10; // w18
  int v11; // w26
  int v12; // w18
  int v13; // w0
  unsigned int v14; // w4
  unsigned int v15; // w19
  int v16; // w20
  int v17; // w0
  int v18; // w3
  unsigned int v19; // w25
  int v20; // w26
  int v21; // w6
  int v22; // w7
  int v23; // w23
  int v24; // w17
  int v25; // w18
  int v26; // w4
  int v27; // w15
  int v28; // w18
  int v29; // w0
  int v30; // w16
  int v31; // w17
  int v32; // w4
  unsigned int v33; // w16
  unsigned int v34; // w17
  unsigned int v35; // w3
  unsigned int v36; // w6
  __int64 v37; // x23
  __int64 v38; // x0
  __int64 v39; // x20
  __int64 v40; // x7
  __int64 v41; // x22
  __int64 v42; // x19
  __int64 v43; // x4
  __int64 v44; // x18
  __int64 v45; // x21
  __int64 v46; // x24
  __int64 v47; // x25
  __int64 v48; // x5
  _DWORD *v49; // x8
  unsigned int v50; // w10
  unsigned int v51; // w11
  int v52; // w2
  int v53; // w3
  unsigned __int8 v54; // w6
  unsigned __int8 v55; // w19
  int v56; // w7
  int v57; // w4
  __int64 result; // x0
  unsigned __int8 v59; // w5
  int v60; // w18
  int v61; // w10
  int v62; // w12
  int v63; // w9
  unsigned int v64; // w13
  unsigned int v65; // w13
  unsigned int v66; // w13

  v3 = a3[60];
  v4 = (((a1[4] << 24) & 0xFF00FFFF | (a1[5] << 16)) & 0xFFFF00FF | (a1[6] << 8) | a1[7]) ^ a3[1];
  v5 = (((*a1 << 24) & 0xFF00FFFF | (a1[1] << 16)) & 0xFFFF00FF | (a1[2] << 8) | a1[3]) ^ *a3;
  v6 = (((a1[8] << 24) & 0xFF00FFFF | (a1[9] << 16)) & 0xFFFF00FF | (a1[10] << 8) | a1[11]) ^ a3[2];
  v7 = 1 - (v3 >> 1);
  v8 = a3 + 6;
  v9 = 8LL * ((v3 >> 1) - 1);
  v10 = (((a1[12] << 24) & 0xFF00FFFF | (a1[13] << 16)) & 0xFFFF00FF | (a1[14] << 8) | a1[15]) ^ a3[3];
  while ( 1 )
  {
    v14 = (unsigned __int16)v6 >> 8;
    v15 = (unsigned __int16)v10 >> 8;
    v16 = (unsigned __int8)v6;
    v17 = dword_D6274[(v10 >> 16) & 0xFF] ^ dword_D5E74[v5 >> 24];
    v18 = (unsigned __int8)v10;
    v19 = (unsigned __int16)v5 >> 8;
    v20 = (unsigned __int8)v5;
    v21 = dword_D6274[(v5 >> 16) & 0xFF];
    v22 = dword_D5E74[v6 >> 24];
    v23 = dword_D6274[(v4 >> 16) & 0xFF];
    v24 = dword_D6274[(v6 >> 16) & 0xFF] ^ dword_D5E74[v10 >> 24];
    v25 = dword_D6674[v14];
    v26 = dword_D6A74[(unsigned __int8)v4];
    v27 = v8[2];
    v28 = v17 ^ v25;
    v29 = v21 ^ dword_D5E74[v4 >> 24] ^ dword_D6674[v15];
    v30 = v24 ^ dword_D6674[(unsigned __int16)v4 >> 8];
    v31 = v28 ^ v26;
    v32 = v30 ^ dword_D6A74[v20];
    v33 = v31 ^ *(v8 - 2);
    v34 = v29 ^ dword_D6A74[v16] ^ *(v8 - 1);
    v35 = v23 ^ v22 ^ dword_D6674[v19] ^ dword_D6A74[v18] ^ *v8;
    v36 = v32 ^ v8[1];
    v37 = v33 >> 24;
    v38 = (v34 >> 16) & 0xFF;
    v39 = v34 >> 24;
    v40 = (unsigned __int8)v35;
    v41 = (unsigned __int8)v34;
    v42 = (unsigned __int16)(v32 ^ *((_WORD *)v8 + 2)) >> 8;
    v43 = v35 >> 24;
    v44 = (unsigned __int8)v36;
    v45 = (v33 >> 16) & 0xFF;
    v46 = (v36 >> 16) & 0xFF;
    v47 = (unsigned __int16)v35 >> 8;
    v48 = (unsigned __int16)v33 >> 8;
    if ( !v7 )
      break;
    v11 = dword_D6A74[(unsigned __int8)v33];
    v12 = dword_D6274[v38] ^ dword_D5E74[v43] ^ dword_D6674[v48] ^ dword_D6A74[(unsigned __int8)v36];
    v13 = dword_D6274[(v35 >> 16) & 0xFF] ^ dword_D5E74[v36 >> 24] ^ dword_D6674[(unsigned __int16)v34 >> 8];
    v6 = v12 ^ v8[4];
    ++v7;
    v5 = dword_D5E74[v37] ^ v27 ^ dword_D6274[v46] ^ dword_D6674[v47] ^ dword_D6A74[v41];
    v4 = dword_D6274[v45] ^ dword_D5E74[v39] ^ dword_D6674[v42] ^ dword_D6A74[(unsigned __int8)v35] ^ v8[3];
    v10 = v13 ^ v11 ^ v8[5];
    v8 += 8;
  }
  v49 = &a3[v9];
  v50 = v36 >> 24;
  v51 = (v35 >> 16) & 0xFF;
  v52 = byte_D6E74[(unsigned __int8)v34];
  v53 = byte_D6E74[v39];
  v54 = byte_D6E74[v45];
  v55 = byte_D6E74[v42];
  v56 = byte_D6E74[v40];
  v57 = byte_D6E74[v43];
  result = byte_D6E74[v38];
  v59 = byte_D6E74[v48];
  v60 = byte_D6E74[v44];
  v61 = byte_D6E74[v50];
  LOBYTE(v51) = byte_D6E74[v51];
  v62 = byte_D6E74[(unsigned __int16)v34 >> 8];
  v63 = byte_D6E74[(unsigned __int8)v33];
  v64 = (((byte_D6E74[v37] << 24) & 0xFF00FFFF | (byte_D6E74[v46] << 16)) & 0xFFFF00FF | (byte_D6E74[v47] << 8) | v52) ^ v27;
  byte_D6E74[v46];
  byte_D6E74[v47];
  a2[3] = v52 ^ v27;
  *a2 = HIBYTE(v64);
  a2[1] = BYTE2(v64);
  a2[2] = BYTE1(v64);
  v65 = (((v53 << 24) & 0xFF00FFFF | (v54 << 16)) & 0xFFFF00FF | (v55 << 8) | v56) ^ v49[9];
  a2[7] = v56 ^ *((_BYTE *)v49 + 36);
  a2[4] = HIBYTE(v65);
  a2[5] = BYTE2(v65);
  a2[6] = BYTE1(v65);
  v66 = (((v57 << 24) & 0xFF00FFFF | ((unsigned __int8)result << 16)) & 0xFFFF00FF | (v59 << 8) | v60) ^ v49[10];
  a2[11] = v60 ^ *((_BYTE *)v49 + 40);
  a2[8] = HIBYTE(v66);
  a2[9] = BYTE2(v66);
  a2[10] = BYTE1(v66);
  LODWORD(v49) = (((v61 << 24) & 0xFF00FFFF | ((unsigned __int8)v51 << 16)) & 0xFFFF00FF | ((unsigned __int8)v62 << 8) | v63) ^ v49[11];
  a2[12] = BYTE3(v49);
  a2[13] = BYTE2(v49);
  a2[14] = BYTE1(v49);
  a2[15] = (_BYTE)v49;
  return result;
}

//----- (0000000000054D68) ----------------------------------------------------
char *__fastcall AES_ctr128_encrypt(char *a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, _BYTE *a5, _QWORD *a6, unsigned int *a7)
{
  return sub_4C3D8(a1, a2, a3, a4, a5, a6, a7, (void (__fastcall *)(_BYTE *, _QWORD *, __int64))AES_encrypt);
}

//----- (0000000000054D74) ----------------------------------------------------
__int64 __fastcall AES_ecb_encrypt(unsigned __int8 *a1, _BYTE *a2, _DWORD *a3, int a4)
{
  __int64 result; // x0

  if ( a4 == 1 )
    result = AES_encrypt(a1, a2, a3);
  else
    result = AES_decrypt(a1, a2, a3);
  return result;
}

//----- (0000000000054D84) ----------------------------------------------------
void __fastcall AES_cbc_encrypt(_QWORD *a1, long double *a2, unsigned __int64 a3, __int64 a4, _OWORD *a5, int a6)
{
  if ( a6 )
    sub_4BDC0(a1, a2, a3, a4, a5, (void (__fastcall *)(long double *, long double *, __int64))AES_encrypt);
  else
    sub_4BFD4(
      (unsigned __int64)a1,
      (unsigned __int64)a2,
      a3,
      a4,
      a5,
      (__int64 (__fastcall *)(_QWORD *, __int64 *, __int64))AES_decrypt);
}

//----- (0000000000054DA0) ----------------------------------------------------
__int64 __fastcall AES_ofb128_encrypt(__int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, int *a6)
{
  unsigned __int64 v6; // x20
  int *v7; // x19
  __int64 result; // x0
  int v9; // [xsp+4h] [xbp-1Ch]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v6 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v7 = a6;
  v10 = *(_QWORD *)(v6 + 40);
  v9 = *a6;
  result = sub_4DCBC(
             a1,
             a2,
             a3,
             a4,
             a5,
             (unsigned int *)&v9,
             (__int64 (__fastcall *)(__int64, __int64, __int64))AES_encrypt);
  *v7 = v9;
  *(_QWORD *)(v6 + 40);
  return result;
}

//----- (0000000000054E04) ----------------------------------------------------
__int64 __fastcall AES_cfb128_encrypt(__int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, int *a6, int a7)
{
  unsigned __int64 v7; // x20
  int *v8; // x19
  __int64 result; // x0
  int v10; // [xsp+4h] [xbp-1Ch]
  __int64 v11; // [xsp+8h] [xbp-18h]

  v7 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v8 = a6;
  v11 = *(_QWORD *)(v7 + 40);
  v10 = *a6;
  result = sub_56234(
             a1,
             a2,
             a3,
             a4,
             a5,
             (unsigned int *)&v10,
             a7,
             (__int64 (__fastcall *)(__int64, __int64, __int64))AES_encrypt);
  *v8 = v10;
  *(_QWORD *)(v7 + 40);
  return result;
}

//----- (0000000000054E68) ----------------------------------------------------
_QWORD *__fastcall CBS_init(_QWORD *result, __int64 a2, __int64 a3)
{
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (0000000000054E70) ----------------------------------------------------
signed __int64 __fastcall CBS_skip(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  __int64 v4; // x8
  __int64 v6; // x9

  v2 = a1[1];
  v3 = v2 >= a2;
  v4 = v2 - a2;
  if ( !v3 )
    return 0LL;
  v6 = *a1;
  a1[1] = v4;
  *a1 = v6 + a2;
  return 1LL;
}

//----- (0000000000054E9C) ----------------------------------------------------
void *__fastcall CBS_stow(__int64 a1, void **a2, _QWORD *a3)
{
  void **v3; // x21
  __int64 v4; // x20
  _QWORD *v5; // x19
  size_t v6; // x1
  void *result; // x0

  v3 = a2;
  v4 = a1;
  v5 = a3;
  free(*a2);
  *v3 = 0LL;
  *v5 = 0LL;
  v6 = *(_QWORD *)(v4 + 8);
  if ( v6 )
  {
    result = BUF_memdup(*(const void **)v4, v6);
    *v3 = result;
    if ( !result )
      return result;
    *v5 = *(_QWORD *)(v4 + 8);
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (0000000000054F00) ----------------------------------------------------
bool __fastcall CBS_strdup(__int64 a1, void **a2)
{
  void **v2; // x19
  __int64 v3; // x20
  _BYTE *v4; // x0

  v2 = a2;
  v3 = a1;
  if ( *a2 )
    free(*a2);
  v4 = BUF_strndup(*(const void **)v3, *(_QWORD *)(v3 + 8));
  *v2 = v4;
  return v4 != 0LL;
}

//----- (0000000000054F48) ----------------------------------------------------
bool __fastcall CBS_contains_zero_byte(__int64 a1)
{
  size_t v1; // x2
  _BOOL8 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
    result = memchr(*(const void **)a1, 0, v1) != 0LL;
  else
    result = 0LL;
  return result;
}

//----- (0000000000054F7C) ----------------------------------------------------
bool __fastcall CBS_mem_equal(__int64 *a1, __int64 a2, __int64 a3)
{
  _BOOL8 result; // x0

  if ( a1[1] == a3 )
    result = (unsigned int)CRYPTO_memcmp(*a1, a2, a3) == 0;
  else
    result = 0LL;
  return result;
}

//----- (0000000000054FB0) ----------------------------------------------------
signed __int64 __fastcall CBS_get_u8(__int64 a1, _BYTE *a2)
{
  __int64 v2; // x8
  _BYTE *v3; // x9
  signed __int64 result; // x0

  v2 = *(_QWORD *)(a1 + 8);
  if ( !v2 )
    return 0LL;
  v3 = *(_BYTE **)a1;
  *(_QWORD *)(a1 + 8) = v2 - 1;
  *(_QWORD *)a1 = v3 + 1;
  result = 1LL;
  *a2 = *v3;
  return result;
}

//----- (0000000000054FE4) ----------------------------------------------------
signed __int64 __fastcall CBS_get_u16(__int64 a1, _WORD *a2)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  signed __int64 v4; // x8
  signed __int64 result; // x0
  unsigned __int16 *v6; // x9

  v2 = *(_QWORD *)(a1 + 8);
  v3 = v2 >= 2;
  v4 = v2 - 2;
  if ( !v3 )
    return 0LL;
  v6 = *(unsigned __int16 **)a1;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)a1 = v6 + 1;
  result = 1LL;
  *a2 = _byteswap_ushort(*v6);
  return result;
}

//----- (0000000000055020) ----------------------------------------------------
signed __int64 __fastcall CBS_get_u24(__int64 *a1, int *a2)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  signed __int64 v4; // x8
  signed __int64 result; // x0
  __int64 v6; // x9

  v2 = a1[1];
  v3 = v2 >= 3;
  v4 = v2 - 3;
  if ( !v3 )
    return 0LL;
  v6 = *a1;
  a1[1] = v4;
  *a1 = v6 + 3;
  result = 1LL;
  *a2 = *(unsigned __int8 *)(v6 + 2) | (_byteswap_ushort(*(_WORD *)v6) << 8);
  return result;
}

//----- (0000000000055064) ----------------------------------------------------
signed __int64 __fastcall CBS_get_u32(__int64 a1, int *a2)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  signed __int64 v4; // x8
  signed __int64 result; // x0
  unsigned __int8 *v6; // x9

  v2 = *(_QWORD *)(a1 + 8);
  v3 = v2 >= 4;
  v4 = v2 - 4;
  if ( !v3 )
    return 0LL;
  v6 = *(unsigned __int8 **)a1;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)a1 = v6 + 4;
  result = 1LL;
  *a2 = v6[3] | ((v6[2] | ((v6[1] | (*v6 << 8)) << 8)) << 8);
  return result;
}

//----- (00000000000550B0) ----------------------------------------------------
signed __int64 __fastcall CBS_get_last_u8(_QWORD *a1, _BYTE *a2)
{
  __int64 v2; // x8

  v2 = a1[1];
  if ( !v2 )
    return 0LL;
  *a2 = *(_BYTE *)(*a1 + v2 - 1);
  --a1[1];
  return 1LL;
}

//----- (00000000000550E4) ----------------------------------------------------
signed __int64 __fastcall CBS_get_bytes(__int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  bool v4; // cf
  __int64 v5; // x8
  signed __int64 result; // x0
  __int64 v7; // x9

  v3 = a1[1];
  v4 = v3 >= a3;
  v5 = v3 - a3;
  if ( !v4 )
    return 0LL;
  v7 = *a1;
  a1[1] = v5;
  *a1 = v7 + a3;
  result = 1LL;
  *a2 = v7;
  a2[1] = a3;
  return result;
}

//----- (0000000000055114) ----------------------------------------------------
signed __int64 __fastcall CBS_copy_bytes(__int64 a1, void *a2, size_t a3)
{
  unsigned __int64 v3; // x8
  size_t v4; // x9
  const void *v6; // x8

  v3 = *(_QWORD *)(a1 + 8);
  v4 = v3 - a3;
  if ( v3 < a3 )
    return 0LL;
  v6 = *(const void **)a1;
  *(_QWORD *)a1 += a3;
  *(_QWORD *)(a1 + 8) = v4;
  if ( a3 )
    memcpy(a2, v6, a3);
  return 1LL;
}

//----- (0000000000055160) ----------------------------------------------------
signed __int64 __fastcall CBS_get_u8_length_prefixed(signed __int64 *a1, signed __int64 *a2)
{
  unsigned __int8 *v2; // x8
  unsigned __int8 *v3; // x9
  unsigned __int64 v4; // x10
  signed __int64 v5; // x8
  unsigned __int64 v6; // x9
  bool v7; // cf
  unsigned __int64 v8; // x10
  signed __int64 result; // x0

  v2 = (unsigned __int8 *)a1[1];
  if ( !v2 )
    return 0LL;
  v3 = (unsigned __int8 *)*a1;
  v4 = (unsigned __int64)(v2 - 1);
  v5 = *a1 + 1;
  *a1 = v5;
  a1[1] = v4;
  v6 = *v3;
  v7 = v4 >= v6;
  v8 = v4 - v6;
  if ( !v7 )
    return 0LL;
  *a1 = v5 + v6;
  a1[1] = v8;
  result = 1LL;
  *a2 = v5;
  a2[1] = v6;
  return result;
}

//----- (00000000000551A8) ----------------------------------------------------
signed __int64 __fastcall CBS_get_u16_length_prefixed(signed __int64 *a1, signed __int64 *a2)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x9
  signed __int64 result; // x0
  unsigned __int8 *v5; // x10
  signed __int64 v6; // x8
  unsigned __int64 v7; // x10
  bool v8; // cf
  unsigned __int64 v9; // x9

  v2 = a1[1];
  v3 = v2 - 2;
  if ( v2 < 2 )
    return 0LL;
  v5 = (unsigned __int8 *)*a1;
  v6 = *a1 + 2;
  *a1 = v6;
  a1[1] = v3;
  v7 = v5[1] | ((unsigned __int64)*v5 << 8);
  v8 = v3 >= v7;
  v9 = v3 - v7;
  if ( !v8 )
    return 0LL;
  *a1 = v6 + v7;
  a1[1] = v9;
  result = 1LL;
  *a2 = v6;
  a2[1] = v7;
  return result;
}

//----- (00000000000551F8) ----------------------------------------------------
signed __int64 __fastcall CBS_get_u24_length_prefixed(signed __int64 *a1, signed __int64 *a2)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x9
  signed __int64 result; // x0
  signed __int64 v5; // x10
  signed __int64 v6; // x8
  unsigned __int64 v7; // x10
  bool v8; // cf
  unsigned __int64 v9; // x9

  v2 = a1[1];
  v3 = v2 - 3;
  if ( v2 < 3 )
    return 0LL;
  v5 = *a1;
  v6 = *a1 + 3;
  *a1 = v6;
  a1[1] = v3;
  v7 = *(unsigned __int8 *)(v5 + 2) | ((unsigned __int64)_byteswap_ushort(*(_WORD *)v5) << 8);
  v8 = v3 >= v7;
  v9 = v3 - v7;
  if ( !v8 )
    return 0LL;
  *a1 = v6 + v7;
  a1[1] = v9;
  result = 1LL;
  *a2 = v6;
  a2[1] = v7;
  return result;
}

//----- (0000000000055250) ----------------------------------------------------
unsigned __int8 **__fastcall CBS_get_any_asn1(unsigned __int8 **a1, char *a2, _DWORD *a3)
{
  char *v3; // x19
  unsigned __int8 **result; // x0
  unsigned __int64 v5; // x9
  bool v6; // cf
  __int64 v7; // x9
  unsigned __int64 v8; // [xsp+0h] [xbp-20h]
  __int64 v9; // [xsp+8h] [xbp-18h]

  v3 = a2;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = sub_552D8(a1, a2, a3, (signed __int64 *)&v8, 0);
  if ( (_DWORD)result )
  {
    v5 = *((_QWORD *)v3 + 1);
    v6 = v5 >= v8;
    v7 = v5 - v8;
    if ( v6 )
    {
      result = (unsigned __int8 **)(&dword_0 + 1);
      *(_QWORD *)v3 += v8;
      *((_QWORD *)v3 + 1) = v7;
    }
    else
    {
      result = 0LL;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000552D0) ----------------------------------------------------
unsigned __int8 **__fastcall CBS_get_any_asn1_element(unsigned __int8 **a1, char *a2, _DWORD *a3, signed __int64 *a4)
{
  return sub_552D8(a1, a2, a3, a4, 0);
}

//----- (00000000000552D8) ----------------------------------------------------
unsigned __int8 **__fastcall sub_552D8(unsigned __int8 **result, char *a2, _DWORD *a3, signed __int64 *a4, int a5)
{
  unsigned __int8 *v5; // x11
  char *v6; // x9
  unsigned int v7; // w8
  __int64 v8; // x12
  int v9; // w8
  __int64 v10; // x10
  unsigned __int64 v11; // x8
  signed __int64 v12; // x10
  unsigned __int8 *v13; // x10
  bool v14; // cf
  unsigned __int8 *v15; // x10
  unsigned __int64 v16; // x10
  unsigned __int64 v17; // x8
  signed __int64 v18; // x8
  int v19; // w13
  unsigned __int8 *v20; // x8
  unsigned __int64 v21; // x12
  unsigned __int8 v22; // t1
  unsigned int v23; // w11
  __int64 v24; // x11
  __int64 v25; // x10
  char v26; // [xsp+8h] [xbp-18h]
  __int64 v27; // [xsp+18h] [xbp-8h]

  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = result[1];
  if ( a2 )
    v6 = a2;
  else
    v6 = &v26;
  if ( !v5 || v5 == (_BYTE *)&dword_0 + 1 )
  {
    v7 = 0;
    goto LABEL_7;
  }
  v8 = (__int64)*result;
  v9 = **result;
  if ( (v9 & 0x1F) == 31 )
  {
    v7 = 0;
    goto LABEL_7;
  }
  v10 = *(unsigned __int8 *)(v8 + 1);
  if ( a3 )
    *a3 = v9;
  if ( !(v10 & 0x80) )
  {
    v11 = v10 + 2;
    if ( !a4 )
    {
LABEL_17:
      v13 = result[1];
      v14 = (unsigned __int64)v13 >= v11;
      v15 = &v13[-v11];
      if ( !v14 )
      {
        v7 = 0;
        goto LABEL_7;
      }
      v24 = (__int64)*result;
      result[1] = v15;
      *result = (unsigned __int8 *)(v24 + v11);
      *(_QWORD *)v6 = v24;
LABEL_38:
      *((_QWORD *)v6 + 1) = v11;
      v7 = 1;
      goto LABEL_7;
    }
    v12 = 2LL;
LABEL_16:
    *a4 = v12;
    goto LABEL_17;
  }
  v16 = v10 & 0x7F;
  if ( a5 && v9 & 0x20 && !(_DWORD)v16 )
  {
    if ( a4 )
      *a4 = 2LL;
    v17 = (unsigned __int64)result[1];
    v14 = v17 >= 2;
    v18 = v17 - 2;
    if ( !v14 )
    {
      v7 = 0;
      goto LABEL_7;
    }
    v25 = (__int64)*result;
    result[1] = (unsigned __int8 *)v18;
    v11 = 2LL;
    *result = (unsigned __int8 *)(v25 + 2);
    *(_QWORD *)v6 = v25;
    goto LABEL_38;
  }
  v7 = 0;
  if ( !(_DWORD)v16 || (unsigned int)(v16 - 1) > 3 || (unsigned __int64)(v5 - 2) < v16 )
    goto LABEL_7;
  v19 = 0;
  v20 = (unsigned __int8 *)(v8 + 2);
  v21 = v16;
  do
  {
    v22 = *v20++;
    --v21;
    v23 = v22 | (v19 << 8);
    v19 = v22 | (v19 << 8);
  }
  while ( v21 );
  if ( v23 < 0x80 )
  {
    v7 = 0;
    goto LABEL_7;
  }
  v7 = v23 >> (8 * v16 - 8);
  if ( v7 )
  {
    v12 = v16 + 2;
    v11 = v12 + v23;
    if ( !a4 )
      goto LABEL_17;
    goto LABEL_16;
  }
LABEL_7:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v27 )
    result = (unsigned __int8 **)v7;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000055464) ----------------------------------------------------
unsigned __int8 **__fastcall CBS_get_any_ber_asn1_element(unsigned __int8 **a1, char *a2, _DWORD *a3, signed __int64 *a4)
{
  return sub_552D8(a1, a2, a3, a4, 1);
}

//----- (000000000005546C) ----------------------------------------------------
signed __int64 __fastcall CBS_get_asn1(unsigned __int8 **a1, char *a2, int a3)
{
  __int64 v3; // x8
  int v4; // w20
  char *v5; // x19
  int v6; // w8
  signed __int64 result; // x0
  unsigned __int64 v8; // x9
  bool v9; // cf
  __int64 v10; // x9
  char v11; // [xsp+8h] [xbp-38h]
  int v12; // [xsp+1Ch] [xbp-24h]
  unsigned __int64 v13; // [xsp+20h] [xbp-20h]
  __int64 v14; // [xsp+28h] [xbp-18h]

  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = a3;
  if ( a2 )
    v5 = a2;
  else
    v5 = &v11;
  v14 = v3;
  v6 = (unsigned __int64)sub_552D8(a1, v5, &v12, (signed __int64 *)&v13, 0);
  result = 0LL;
  if ( v6 && v12 == v4 )
  {
    v8 = *((_QWORD *)v5 + 1);
    v9 = v8 >= v13;
    v10 = v8 - v13;
    if ( v9 )
    {
      result = 1LL;
      *(_QWORD *)v5 += v13;
      *((_QWORD *)v5 + 1) = v10;
    }
    else
    {
      result = 0LL;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000055514) ----------------------------------------------------
unsigned __int8 **__fastcall CBS_get_asn1_element(unsigned __int8 **a1, char *a2, int a3)
{
  unsigned __int64 v3; // x20
  int v4; // w19
  unsigned __int8 **result; // x0
  char v6; // [xsp+8h] [xbp-38h]
  int v7; // [xsp+1Ch] [xbp-24h]
  char v8; // [xsp+20h] [xbp-20h]
  __int64 v9; // [xsp+28h] [xbp-18h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a3;
  if ( !a2 )
    a2 = &v6;
  v9 = *(_QWORD *)(v3 + 40);
  result = sub_552D8(a1, a2, &v7, (signed __int64 *)&v8, 0);
  if ( *(_QWORD *)(v3 + 40) == v9 )
    result = (unsigned __int8 **)(((_DWORD)result != 0) & (unsigned __int8)(v7 == v4));
  return result;
}

//----- (000000000005558C) ----------------------------------------------------
bool __fastcall CBS_peek_asn1_tag(unsigned __int8 **a1, int a2)
{
  _BOOL8 result; // x0

  if ( a1[1] )
    result = **a1 == a2;
  else
    result = 0LL;
  return result;
}

//----- (00000000000555B0) ----------------------------------------------------
signed __int64 __fastcall CBS_get_asn1_uint64(unsigned __int8 **a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 v3; // x8
  char *v4; // x9
  unsigned __int64 v5; // x11
  unsigned __int64 v6; // x10
  unsigned __int8 v7; // w12
  signed __int64 result; // x0
  __int64 v9; // [xsp+8h] [xbp-38h]
  unsigned __int64 v10; // [xsp+10h] [xbp-30h]
  int v11; // [xsp+1Ch] [xbp-24h]
  unsigned __int64 v12; // [xsp+20h] [xbp-20h]
  __int64 v13; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)sub_552D8(a1, (char *)&v9, &v11, (signed __int64 *)&v12, 0) )
  {
    if ( v11 == 2 )
    {
      v3 = v10 - v12;
      if ( v10 >= v12 )
      {
        v4 = (char *)(v9 + v12);
        v9 += v12;
        v10 -= v12;
        *v2 = 0LL;
        if ( v3 )
        {
          if ( !(*v4 & 0x80000000) && (v3 < 2 || *v4 || v4[1] & 0x80000000) )
          {
            v5 = 0LL;
            v6 = 0LL;
            while ( !(v5 >> 56) )
            {
              *v2 = v5 << 8;
              v7 = v4[v6++];
              v5 = v7 | (v5 << 8);
              *v2 = v5;
              if ( v6 >= v3 )
              {
                result = 1LL;
                goto LABEL_14;
              }
            }
          }
        }
      }
    }
  }
  result = 0LL;
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005569C) ----------------------------------------------------
signed __int64 __fastcall CBS_get_optional_asn1(unsigned __int8 **a1, char *a2, _DWORD *a3, int a4)
{
  int v4; // w20
  _DWORD *v5; // x19
  unsigned __int8 *v6; // x8
  char *v7; // x21
  unsigned __int64 v8; // x9
  bool v9; // cf
  __int64 v10; // x9
  signed __int64 result; // x0
  char v12; // [xsp+8h] [xbp-48h]
  int v13; // [xsp+1Ch] [xbp-34h]
  unsigned __int64 v14; // [xsp+20h] [xbp-30h]
  __int64 v15; // [xsp+28h] [xbp-28h]

  v4 = a4;
  v5 = a3;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = a1[1];
  if ( !v6 )
  {
LABEL_11:
    if ( !a3 )
    {
LABEL_13:
      result = 1LL;
      goto LABEL_14;
    }
LABEL_12:
    *v5 = (_DWORD)v6;
    goto LABEL_13;
  }
  if ( **a1 != a4 )
  {
    LODWORD(v6) = 0;
    goto LABEL_11;
  }
  if ( a2 )
    v7 = a2;
  else
    v7 = &v12;
  if ( (unsigned int)sub_552D8(a1, v7, &v13, (signed __int64 *)&v14, 0) )
  {
    if ( v13 == v4 )
    {
      v8 = *((_QWORD *)v7 + 1);
      v9 = v8 >= v14;
      v10 = v8 - v14;
      if ( v9 )
      {
        *(_QWORD *)v7 += v14;
        *((_QWORD *)v7 + 1) = v10;
        LODWORD(v6) = 1;
        if ( !v5 )
          goto LABEL_13;
        goto LABEL_12;
      }
    }
  }
  result = 0LL;
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v15;
  return result;
}

//----- (0000000000055778) ----------------------------------------------------
signed __int64 __fastcall CBS_get_optional_asn1_octet_string(unsigned __int8 **a1, char *a2, signed int *a3, int a4)
{
  int v4; // w21
  signed int *v5; // x19
  char *v6; // x20
  unsigned __int64 v7; // x9
  bool v8; // cf
  __int64 v9; // x9
  signed __int64 result; // x0
  signed int v11; // w8
  __int64 v12; // [xsp+8h] [xbp-58h]
  unsigned __int64 v13; // [xsp+10h] [xbp-50h]
  signed __int64 v14[2]; // [xsp+18h] [xbp-48h]
  int v15; // [xsp+2Ch] [xbp-34h]
  unsigned __int64 v16; // [xsp+30h] [xbp-30h]
  __int64 v17; // [xsp+38h] [xbp-28h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1[1] || **a1 != a4 )
  {
    v11 = 0;
    *(_QWORD *)a2 = 0LL;
    *((_QWORD *)a2 + 1) = 0LL;
    if ( !a3 )
    {
LABEL_16:
      result = 1LL;
      goto LABEL_17;
    }
LABEL_15:
    *v5 = v11;
    goto LABEL_16;
  }
  if ( (unsigned int)sub_552D8(a1, (char *)&v12, &v16, v14, 0) && (_DWORD)v16 == v4 && v13 >= v14[0] )
  {
    if ( !v6 )
      v6 = (char *)v14;
    v12 += v14[0];
    v13 -= v14[0];
    if ( (unsigned int)sub_552D8((unsigned __int8 **)&v12, v6, &v15, (signed __int64 *)&v16, 0) )
    {
      if ( v15 == 4 )
      {
        v7 = *((_QWORD *)v6 + 1);
        v8 = v7 >= v16;
        v9 = v7 - v16;
        if ( v8 )
        {
          *(_QWORD *)v6 += v16;
          *((_QWORD *)v6 + 1) = v9;
          if ( !v13 )
          {
            v11 = 1;
            if ( !v5 )
              goto LABEL_16;
            goto LABEL_15;
          }
        }
      }
    }
  }
  result = 0LL;
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v17;
  return result;
}

//----- (00000000000558A4) ----------------------------------------------------
signed __int64 __fastcall CBS_get_optional_asn1_uint64(unsigned __int8 **a1, unsigned __int64 *a2, int a3, unsigned __int64 a4)
{
  int v4; // w20
  unsigned __int64 *v5; // x19
  signed __int64 result; // x0
  int v7; // w8
  __int64 v8; // [xsp+8h] [xbp-38h]
  unsigned __int64 v9; // [xsp+10h] [xbp-30h]
  int v10; // [xsp+1Ch] [xbp-24h]
  unsigned __int64 v11; // [xsp+20h] [xbp-20h]
  __int64 v12; // [xsp+28h] [xbp-18h]

  v4 = a3;
  v5 = a2;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1[1] || **a1 != a3 )
  {
    *a2 = a4;
    goto LABEL_8;
  }
  if ( !(unsigned int)sub_552D8(a1, (char *)&v8, &v10, (signed __int64 *)&v11, 0) || v10 != v4 || v9 < v11 )
  {
    result = 0LL;
    goto LABEL_9;
  }
  v8 += v11;
  v9 -= v11;
  v7 = CBS_get_asn1_uint64((unsigned __int8 **)&v8, v5);
  result = 0LL;
  if ( v7 && !v9 )
LABEL_8:
    result = 1LL;
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v12;
  return result;
}

//----- (000000000005597C) ----------------------------------------------------
signed __int64 __fastcall CBS_get_optional_asn1_bool(unsigned __int8 **a1, _DWORD *a2, int a3, int a4)
{
  int v4; // w20
  _DWORD *v5; // x19
  signed __int64 result; // x0
  __int64 v7; // x9
  unsigned __int8 *v8; // x8
  int v9; // w8
  unsigned __int64 v10; // [xsp+8h] [xbp-48h]
  unsigned __int64 v11; // [xsp+10h] [xbp-40h]
  __int64 v12; // [xsp+18h] [xbp-38h]
  unsigned __int64 v13; // [xsp+20h] [xbp-30h]
  int v14; // [xsp+2Ch] [xbp-24h]
  unsigned __int64 v15; // [xsp+30h] [xbp-20h]
  __int64 v16; // [xsp+38h] [xbp-18h]

  v4 = a3;
  v5 = a2;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1[1] || **a1 != a3 )
  {
    *a2 = a4;
LABEL_8:
    result = 1LL;
    goto LABEL_9;
  }
  if ( !(unsigned int)sub_552D8(a1, (char *)&v12, &v15, (signed __int64 *)&v10, 0) || (_DWORD)v15 != v4 || v13 < v10 )
  {
    result = 0LL;
    goto LABEL_9;
  }
  v12 += v10;
  v13 -= v10;
  if ( !(unsigned int)sub_552D8((unsigned __int8 **)&v12, (char *)&v10, &v14, (signed __int64 *)&v15, 0)
    || v14 != 1
    || (v7 = v11 - v15, v11 < v15) )
  {
    result = 0LL;
    goto LABEL_9;
  }
  result = 0LL;
  v8 = (unsigned __int8 *)(v10 + v15);
  v10 += v15;
  v11 -= v15;
  if ( v7 == 1 && !v13 )
  {
    v9 = *v8;
    result = 0LL;
    if ( v9 )
    {
      if ( v9 != 255 )
        goto LABEL_9;
      LODWORD(result) = 1;
    }
    *v5 = result;
    goto LABEL_8;
  }
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v16;
  return result;
}

//----- (0000000000055AB0) ----------------------------------------------------
bool __fastcall CBS_is_valid_asn1_bitstring(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // x8
  unsigned int v2; // w10

  v1 = a1[1];
  if ( !v1 )
    return 0LL;
  v2 = **a1;
  if ( v2 > 7 )
    return 0LL;
  if ( !**a1 )
    return 1LL;
  if ( v1 == (_BYTE *)&dword_0 + 1 )
    return 0LL;
  return (v1[(_QWORD)(*a1 + 1) - 2] & ((1 << v2) - 1)) == 0;
}
// 0: using guessed type int dword_0;

//----- (0000000000055B14) ----------------------------------------------------
bool __fastcall CBS_asn1_bitstring_has_bit(unsigned __int8 **a1, unsigned int a2)
{
  unsigned __int8 *v2; // x9
  unsigned int v3; // w10
  _BOOL8 result; // x0
  unsigned __int64 v5; // x10

  v2 = a1[1];
  if ( !v2 )
    return 0LL;
  v3 = **a1;
  if ( v3 > 7 )
    return 0LL;
  if ( !**a1 )
    goto LABEL_15;
  if ( v2 == (_BYTE *)&dword_0 + 1 )
    return 0LL;
  if ( v2[(_QWORD)(*a1 + 1) - 2] & ((1 << v3) - 1) )
    return 0LL;
LABEL_15:
  v5 = (a2 >> 3) + 1LL;
  if ( v5 >= (unsigned __int64)v2 )
    result = 0LL;
  else
    result = ((*a1)[v5] & (1 << (~(_BYTE)a2 & 7))) != 0;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000055BB0) ----------------------------------------------------
unsigned __int64 sub_55BB0()
{
  unsigned __int64 result; // x0
  int v1; // w9
  signed __int64 v2; // x10

  result = getauxval(0x10uLL);
  if ( result & 2 )
  {
    v1 = ((unsigned int)result >> 1) & 4 | dword_106E2C | 2 * result & 0x20 | 1;
    v2 = (result >> 2) & 8;
    dword_106E2C = v2 | v1;
    if ( result & 0x40 )
      dword_106E2C = v2 | v1 | 0x10;
  }
  return result;
}
// 106E2C: using guessed type int dword_106E2C;

//----- (0000000000055C14) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_get_depth(__int64 a1)
{
  return *(unsigned int *)(a1 + 40);
}

//----- (0000000000055C1C) ----------------------------------------------------
_QWORD *__fastcall EVP_MD_CTX_init(_QWORD *result)
{
  result[2] = 0LL;
  result[3] = 0LL;
  *result = 0LL;
  result[1] = 0LL;
  return result;
}

//----- (0000000000055C28) ----------------------------------------------------
_QWORD *EVP_MD_CTX_create()
{
  _QWORD *result; // x0

  result = malloc(0x20uLL);
  if ( result )
  {
    result[2] = 0LL;
    result[3] = 0LL;
    *result = 0LL;
    result[1] = 0LL;
  }
  return result;
}

//----- (0000000000055C4C) ----------------------------------------------------
signed __int64 __fastcall EVP_MD_CTX_cleanup(_QWORD *a1)
{
  _QWORD *v1; // x19
  size_t v2; // x1
  void *v3; // x0
  void (__fastcall **v4)(_QWORD); // x8

  v1 = a1;
  if ( *a1 )
  {
    v2 = *(unsigned int *)(*a1 + 44LL);
    if ( (_DWORD)v2 )
    {
      v3 = (void *)a1[1];
      if ( v3 )
      {
        OPENSSL_cleanse(v3, v2);
        free((void *)v1[1]);
      }
    }
  }
  v4 = (void (__fastcall **)(_QWORD))v1[3];
  if ( v4 )
    (*v4)(v1[2]);
  v1[2] = 0LL;
  v1[3] = 0LL;
  *v1 = 0LL;
  v1[1] = 0LL;
  return 1LL;
}

//----- (0000000000055CAC) ----------------------------------------------------
void __fastcall EVP_MD_CTX_destroy(void **a1)
{
  void **v1; // x19
  size_t v2; // x1
  void *v3; // x0
  void (__fastcall **v4)(void *); // x8

  v1 = a1;
  if ( a1 )
  {
    if ( *a1 )
    {
      v2 = *((unsigned int *)*a1 + 11);
      if ( (_DWORD)v2 )
      {
        v3 = a1[1];
        if ( v3 )
        {
          OPENSSL_cleanse(v3, v2);
          free(v1[1]);
        }
      }
    }
    v4 = (void (__fastcall **)(void *))v1[3];
    if ( v4 )
      (*v4)(v1[2]);
    v1[2] = 0LL;
    v1[3] = 0LL;
    *v1 = 0LL;
    v1[1] = 0LL;
    free(v1);
  }
}

//----- (0000000000055D1C) ----------------------------------------------------
signed __int64 __fastcall EVP_MD_CTX_copy_ex(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  _QWORD *v3; // x19
  __int64 v4; // x8
  void *v5; // x21
  int v6; // w2
  __int16 v7; // w4
  signed __int64 result; // x0
  size_t v9; // x1
  void *v10; // x0
  void (__fastcall **v11)(_QWORD); // x8
  size_t v12; // x0
  size_t v13; // x2
  __int64 v14; // x8
  __int64 v15; // x0
  size_t v16; // x1
  void *v17; // x0
  void (__fastcall **v18)(_QWORD); // x8

  v2 = a2;
  v3 = a1;
  if ( !a2 || !*a2 )
  {
    v6 = 100;
    v7 = 121;
LABEL_7:
    ERR_put_error(29, 0LL, v6, (__int64)"external/boringssl/src/crypto/digest/digest.c", v7);
    return 0LL;
  }
  v4 = *a1;
  if ( *a1 == *a2 )
  {
    v5 = (void *)a1[1];
    a1[1] = 0LL;
    if ( !v4 )
      goto LABEL_12;
  }
  else
  {
    v5 = 0LL;
    if ( !v4 )
      goto LABEL_12;
  }
  v9 = *(unsigned int *)(v4 + 44);
  if ( (_DWORD)v9 )
  {
    v10 = (void *)a1[1];
    if ( v10 )
    {
      OPENSSL_cleanse(v10, v9);
      free((void *)v3[1]);
    }
  }
LABEL_12:
  v11 = (void (__fastcall **)(_QWORD))v3[3];
  if ( v11 )
    (*v11)(v3[2]);
  v3[2] = 0LL;
  v3[3] = 0LL;
  *v3 = 0LL;
  v3[1] = 0LL;
  *v3 = *v2;
  if ( !v2[1] )
    goto LABEL_21;
  v12 = *(unsigned int *)(*v2 + 44LL);
  if ( !(_DWORD)v12 )
    goto LABEL_21;
  if ( v5 )
  {
    v3[1] = v5;
    goto LABEL_19;
  }
  v5 = malloc(v12);
  v3[1] = v5;
  if ( !v5 )
  {
    v6 = 65;
    v7 = 142;
    goto LABEL_7;
  }
LABEL_19:
  v13 = *(unsigned int *)(*v2 + 44LL);
  if ( (_DWORD)v13 )
    memcpy(v5, (const void *)v2[1], v13);
LABEL_21:
  v3[3] = v2[3];
  if ( !v2[2] )
    return 1LL;
  v14 = v2[3];
  if ( !v14 )
    return 1LL;
  v15 = (*(__int64 (**)(void))(v14 + 8))();
  v3[2] = v15;
  if ( v15 )
    return 1LL;
  if ( *v3 )
  {
    v16 = *(unsigned int *)(*v3 + 44LL);
    if ( (_DWORD)v16 )
    {
      v17 = (void *)v3[1];
      if ( v17 )
      {
        OPENSSL_cleanse(v17, v16);
        free((void *)v3[1]);
      }
    }
  }
  v18 = (void (__fastcall **)(_QWORD))v3[3];
  if ( v18 )
    (*v18)(v3[2]);
  result = 0LL;
  v3[2] = 0LL;
  v3[3] = 0LL;
  *v3 = 0LL;
  v3[1] = 0LL;
  return result;
}

//----- (0000000000055EAC) ----------------------------------------------------
signed __int64 __fastcall EVP_MD_CTX_copy(_QWORD *a1, _QWORD *a2)
{
  a1[2] = 0LL;
  a1[3] = 0LL;
  *a1 = 0LL;
  a1[1] = 0LL;
  return EVP_MD_CTX_copy_ex(a1, a2);
}

//----- (0000000000055EB8) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestInit_ex(__int64 *a1, __int64 a2)
{
  _QWORD *v2; // x19
  __int64 v3; // x8
  __int64 v4; // x20
  size_t v5; // x0
  void *v6; // x0
  signed __int64 result; // x0

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  if ( *a1 == a2 )
    goto LABEL_12;
  if ( v3 && *(_DWORD *)(v3 + 44) )
  {
    free((void *)a1[1]);
    v2[1] = 0LL;
  }
  *v2 = v4;
  v5 = *(unsigned int *)(v4 + 44);
  if ( (_DWORD)v5 && (v6 = malloc(v5), (v2[1] = v6) == 0LL) )
  {
    ERR_put_error(29, 0LL, 65, (__int64)"external/boringssl/src/crypto/digest/digest.c", 177);
    result = 0LL;
  }
  else
  {
LABEL_12:
    (*(void (__fastcall **)(_QWORD *))(v4 + 16))(v2);
    result = 1LL;
  }
  return result;
}

//----- (0000000000055F48) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestInit(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x20
  _QWORD *v3; // x19
  size_t v4; // x0
  void *v5; // x0
  signed __int64 result; // x0

  v2 = a2;
  v3 = a1;
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  if ( a2 && (*a1 = a2, v4 = *(unsigned int *)(a2 + 44), (_DWORD)v4) && (v5 = malloc(v4), (v3[1] = v5) == 0LL) )
  {
    ERR_put_error(29, 0LL, 65, (__int64)"external/boringssl/src/crypto/digest/digest.c", 177);
    result = 0LL;
  }
  else
  {
    (*(void (__fastcall **)(_QWORD *))(v2 + 16))(v3);
    result = 1LL;
  }
  return result;
}
// 28: using guessed type __int64 qword_28;

//----- (0000000000055FE0) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestUpdate(__int64 a1)
{
  (*(void (**)(void))(*(_QWORD *)a1 + 24LL))();
  return 1LL;
}

//----- (0000000000056000) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestFinal_ex(void **a1, __int64 a2, _DWORD *a3)
{
  void **v3; // x19
  _DWORD *v4; // x20

  v3 = a1;
  v4 = a3;
  (*((void (**)(void))*a1 + 4))();
  if ( v4 )
    *v4 = *((_DWORD *)*v3 + 1);
  OPENSSL_cleanse(v3[1], *((unsigned int *)*v3 + 11));
  return 1LL;
}

//----- (000000000005604C) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestFinal(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // x19
  _DWORD *v4; // x20
  size_t v5; // x1
  void *v6; // x0
  void (__fastcall **v7)(_QWORD); // x8

  v3 = a1;
  v4 = a3;
  (*(void (**)(void))(*(_QWORD *)a1 + 32LL))();
  if ( v4 )
    *v4 = *(_DWORD *)(*(_QWORD *)v3 + 4LL);
  OPENSSL_cleanse(*(void **)(v3 + 8), *(unsigned int *)(*(_QWORD *)v3 + 44LL));
  if ( *(_QWORD *)v3 )
  {
    v5 = *(unsigned int *)(*(_QWORD *)v3 + 44LL);
    if ( (_DWORD)v5 )
    {
      v6 = *(void **)(v3 + 8);
      if ( v6 )
      {
        OPENSSL_cleanse(v6, v5);
        free(*(void **)(v3 + 8));
      }
    }
  }
  v7 = *(void (__fastcall ***)(_QWORD))(v3 + 24);
  if ( v7 )
    (*v7)(*(_QWORD *)(v3 + 16));
  *(_QWORD *)(v3 + 16) = 0LL;
  *(_QWORD *)(v3 + 24) = 0LL;
  *(_QWORD *)v3 = 0LL;
  *(_QWORD *)(v3 + 8) = 0LL;
  return 1LL;
}

//----- (00000000000560D8) ----------------------------------------------------
void __fastcall EVP_Digest(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, __int64 a5)
{
  __int64 v5; // x19
  _DWORD *v6; // x20
  __int64 v7; // x21
  __int64 v8; // x22
  __int64 v9; // x23
  size_t v10; // x0
  __int64 v11; // x8
  size_t v12; // x1
  __int64 v13; // [xsp+8h] [xbp-58h]
  void *v14; // [xsp+10h] [xbp-50h]
  __int64 v15; // [xsp+18h] [xbp-48h]
  void (__fastcall **v16)(__int64); // [xsp+20h] [xbp-40h]
  __int64 v17; // [xsp+28h] [xbp-38h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v15 = 0LL;
  v16 = 0LL;
  v13 = 0LL;
  v14 = 0LL;
  if ( a5 )
  {
    v13 = a5;
    v10 = *(unsigned int *)(a5 + 44);
    if ( (_DWORD)v10 )
    {
      v14 = malloc(v10);
      if ( !v14 )
      {
        ERR_put_error(29, 0LL, 65, (__int64)"external/boringssl/src/crypto/digest/digest.c", 177);
LABEL_9:
        v12 = *(unsigned int *)(v5 + 44);
        if ( (_DWORD)v12 && v14 )
        {
          OPENSSL_cleanse(v14, v12);
          free(v14);
        }
        goto LABEL_12;
      }
    }
  }
  (*(void (__fastcall **)(__int64 *))(v5 + 16))(&v13);
  (*(void (__fastcall **)(__int64 *, __int64, __int64))(v13 + 24))(&v13, v9, v8);
  (*(void (__fastcall **)(__int64 *, __int64))(v13 + 32))(&v13, v7);
  v11 = v13;
  if ( v6 )
    *v6 = *(_DWORD *)(v13 + 4);
  OPENSSL_cleanse(v14, *(unsigned int *)(v11 + 44));
  v5 = v13;
  if ( v13 )
    goto LABEL_9;
LABEL_12:
  if ( v16 )
    (*v16)(v15);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005621C) ----------------------------------------------------
_QWORD *__fastcall sk_num(_QWORD *result)
{
  if ( result )
    result = (_QWORD *)*result;
  return result;
}

//----- (0000000000056228) ----------------------------------------------------
__int64 __fastcall EVP_MD_CTX_block_size(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 40LL);
}

//----- (0000000000056234) ----------------------------------------------------
__int64 __fastcall sub_56234(__int64 result, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int64 a5, unsigned int *a6, int a7, __int64 (__fastcall *a8)(__int64, __int64, __int64))
{
  unsigned int *v8; // x21
  unsigned int v9; // w25
  __int64 (__fastcall *v10)(__int64, __int64, __int64); // x22
  __int64 v11; // x20
  __int64 v12; // x23
  _BYTE *v13; // x24
  char *v14; // x28
  __int64 v15; // x9
  char v16; // t1
  char v17; // w10
  unsigned __int64 v18; // x26
  __int64 v19; // x8
  char v20; // w9
  char v21; // t1
  unsigned __int64 v22; // x26
  signed __int64 v23; // x19
  _BYTE *v24; // x27
  char *v25; // x21
  unsigned __int64 v26; // x8
  __int64 v27; // x9
  int v28; // w8
  __int64 v29; // x9
  char v30; // w10
  char v31; // w11
  char v32; // w10
  signed __int64 v33; // x21
  unsigned __int64 v34; // x27
  char *v35; // x19
  unsigned __int64 v36; // x8
  __int64 v37; // x9
  __int64 v38; // x9
  char v39; // w10
  char v40; // w11
  unsigned __int64 v41; // [xsp+8h] [xbp-68h]
  unsigned __int64 v42; // [xsp+10h] [xbp-60h]
  unsigned int *v43; // [xsp+18h] [xbp-58h]
  unsigned int *v44; // [xsp+18h] [xbp-58h]

  v8 = a6;
  v9 = *a6;
  v10 = a8;
  v11 = a5;
  v12 = a4;
  v13 = a2;
  v14 = (char *)result;
  if ( a7 )
  {
    if ( *a6 != 0 && a3 != 0 )
    {
      do
      {
        v15 = v9;
        v16 = *v14++;
        v17 = *(_BYTE *)(a5 + v9);
        v18 = a3 - 1;
        v9 = (v9 + 1) & 0xF;
        *(_BYTE *)(a5 + v15) = v17 ^ v16;
        *v13++ = v17 ^ v16;
        if ( !v9 )
          break;
        --a3;
      }
      while ( a3 );
    }
    else
    {
      v18 = a3;
    }
    v23 = v18 - 16;
    if ( v18 < 0x10 )
    {
      v24 = v13;
      if ( !v18 )
        goto LABEL_36;
    }
    else
    {
      v41 = v23 & 0xFFFFFFFFFFFFFFF0LL;
      v42 = (v23 & 0xFFFFFFFFFFFFFFF0LL) + 16;
      v43 = a6;
      v24 = &v13[v42];
      v25 = v14;
      do
      {
        result = v10(v11, v11, v12);
        if ( v9 <= 0xF )
        {
          v26 = v9;
          do
          {
            v27 = *(_QWORD *)(v11 + v26) ^ *(_QWORD *)&v25[v26];
            *(_QWORD *)(v11 + v26) = v27;
            *(_QWORD *)&v13[v26] = v27;
            v26 += 8LL;
          }
          while ( v26 < 0x10 );
        }
        v9 = 0;
        v18 -= 16LL;
        v13 += 16;
        v25 += 16;
      }
      while ( v18 > 0xF );
      v9 = 0;
      v18 = v23 - v41;
      v8 = v43;
      v14 += v42;
      if ( v23 == v41 )
        goto LABEL_36;
    }
    result = v10(v11, v11, v12);
    v28 = v9 + v18 - 1;
    do
    {
      v29 = v9;
      v30 = v14[v9];
      v31 = *(_BYTE *)(v11 + v9);
      --v18;
      ++v9;
      v32 = v31 ^ v30;
      *(_BYTE *)(v11 + v29) = v32;
      v24[v29] = v32;
    }
    while ( v18 );
LABEL_35:
    v9 = v28 + 1;
    goto LABEL_36;
  }
  if ( *a6 != 0 && a3 != 0 )
  {
    do
    {
      v19 = v9;
      v20 = *(_BYTE *)(a5 + v9);
      v21 = *v14++;
      v22 = a3 - 1;
      v9 = (v9 + 1) & 0xF;
      *v13++ = v21 ^ v20;
      *(_BYTE *)(a5 + v19) = v21;
      if ( !v9 )
        break;
      --a3;
    }
    while ( a3 );
  }
  else
  {
    v22 = a3;
  }
  v44 = a6;
  v33 = v22 - 16;
  if ( v22 < 0x10 )
  {
    v34 = (unsigned __int64)v13;
    v8 = a6;
    if ( !v22 )
      goto LABEL_36;
    goto LABEL_33;
  }
  v34 = (unsigned __int64)&v13[(v33 & 0xFFFFFFFFFFFFFFF0LL) + 16];
  v35 = v14;
  do
  {
    result = v10(v11, v11, v12);
    if ( v9 <= 0xF )
    {
      v36 = v9;
      do
      {
        v37 = *(_QWORD *)&v35[v36];
        *(_QWORD *)&v13[v36] = *(_QWORD *)(v11 + v36) ^ v37;
        *(_QWORD *)(v11 + v36) = v37;
        v36 += 8LL;
      }
      while ( v36 < 0x10 );
    }
    v9 = 0;
    v22 -= 16LL;
    v13 += 16;
    v35 += 16;
  }
  while ( v22 > 0xF );
  v9 = 0;
  v22 = v33 - (v33 & 0xFFFFFFFFFFFFFFF0LL);
  v14 += (v33 & 0xFFFFFFFFFFFFFFF0LL) + 16;
  v8 = v44;
  if ( v22 )
  {
LABEL_33:
    result = v10(v11, v11, v12);
    v28 = v9 + v22 - 1;
    do
    {
      v38 = v9;
      v39 = *(_BYTE *)(v11 + v9);
      v40 = v14[v9];
      --v22;
      ++v9;
      *(_BYTE *)(v34 + v38) = v40 ^ v39;
      *(_BYTE *)(v11 + v38) = v40;
    }
    while ( v22 );
    goto LABEL_35;
  }
LABEL_36:
  *v8 = v9;
  return result;
}

//----- (00000000000564EC) ----------------------------------------------------
__int64 __fastcall sub_564EC(__int64 *a1, const void *a2, size_t a3, signed int a4)
{
  signed int v4; // w22
  size_t v5; // x20
  const void *v6; // x21
  __int64 *v7; // x19
  __int64 v8; // x23
  unsigned int v9; // w24
  signed int v10; // w8
  int v11; // w10
  char **v12; // x25
  _QWORD *v14; // x0
  void *v15; // x0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = 0LL;
  v9 = -22;
  if ( !a1 || !a4 )
    goto def_56588;
  if ( a2 && !a3 )
  {
LABEL_12:
    v8 = 0LL;
    v9 = -22;
    goto def_56588;
  }
  v10 = 0;
  do
  {
    v11 = (1 << v10) & a4;
    if ( v11 == a4 )
      break;
    if ( v11 )
      goto LABEL_12;
    ++v10;
  }
  while ( v10 <= 31 );
  v8 = 0LL;
  v9 = -22;
  if ( a4 > 127 )
  {
    if ( a4 > 511 )
    {
      if ( a4 == 512 )
      {
LABEL_22:
        v12 = off_106538;
      }
      else
      {
        if ( a4 != 1024 )
          goto def_56588;
        v12 = off_1065B0;
      }
    }
    else if ( a4 == 128 )
    {
LABEL_21:
      v12 = off_106578;
    }
    else
    {
      if ( a4 != 256 )
        goto def_56588;
      v12 = off_106590;
    }
LABEL_26:
    v14 = malloc(0xA0uLL);
    v8 = (__int64)v14;
    if ( v14 )
    {
      *v14 = v5;
      v14[1] = 0LL;
      *((_DWORD *)v14 + 4) = v4;
      *((_BYTE *)v14 + 20) = 0;
      *((_DWORD *)v14 + 6) = 0;
      *((_DWORD *)v14 + 22) = 0;
      v14[9] = 0LL;
      v14[10] = 0LL;
      v14[7] = 0LL;
      v14[8] = 0LL;
      v14[5] = 0LL;
      v14[6] = 0LL;
      v14[4] = v12;
      v14[18] = 0LL;
      v14[19] = 0LL;
      v14[16] = 0LL;
      v14[17] = 0LL;
      v14[14] = 0LL;
      v14[15] = 0LL;
      v14[12] = 0LL;
      v14[13] = 0LL;
      if ( !v6 )
      {
LABEL_30:
        v9 = 0;
        *v7 = v8;
        v8 = 0LL;
        goto def_56588;
      }
      v15 = malloc(v5);
      *(_QWORD *)(v8 + 8) = v15;
      if ( v15 )
      {
        memcpy(v15, v6, v5);
        goto LABEL_30;
      }
    }
    v9 = -12;
    goto def_56588;
  }
  v12 = off_1064B8;
  switch ( a4 )
  {
    case 1:
      goto LABEL_26;
    case 2:
      v12 = off_1064D8;
      goto LABEL_26;
    case 4:
      v12 = off_1064F8;
      goto LABEL_26;
    case 8:
      v12 = off_106518;
      goto LABEL_26;
    case 16:
      goto LABEL_22;
    case 32:
      v12 = off_106558;
      goto LABEL_26;
    case 64:
      goto LABEL_21;
    default:
      break;
  }
def_56588:
  sub_566B8(v8);
  return v9;
}
// 1064B8: using guessed type char *off_1064B8[3];
// 1064D8: using guessed type char *off_1064D8[3];
// 1064F8: using guessed type char *off_1064F8[3];
// 106518: using guessed type char *off_106518[3];
// 106538: using guessed type char *off_106538[3];
// 106558: using guessed type char *off_106558[3];
// 106578: using guessed type char *off_106578[2];
// 106590: using guessed type char *off_106590[3];
// 1065B0: using guessed type char *off_1065B0[3];

//----- (00000000000566B8) ----------------------------------------------------
void __fastcall sub_566B8(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  if ( a1 )
  {
    sub_616F0(*(_QWORD **)(a1 + 152));
    sub_616F0(*(_QWORD **)(v1 + 144));
    free(*(void **)(v1 + 112));
    free(*(void **)(v1 + 96));
    free(*(void **)(v1 + 72));
    free(*(void **)(v1 + 56));
    free(*(void **)(v1 + 40));
    free(*(void **)(v1 + 8));
    free((void *)v1);
  }
}

//----- (0000000000056728) ----------------------------------------------------
void __fastcall sub_56728(__int64 a1)
{
  __int64 v1; // x19
  signed int v2; // w8
  size_t v3; // x20
  const void *v4; // x20
  char *v5; // x21
  size_t v6; // x0
  const void *v7; // x3
  size_t v8; // x2
  signed int v9; // w20
  _QWORD *v10; // x22
  _QWORD *v11; // x21
  int v12; // w8
  __int64 v13; // x20
  char *v14; // x21
  const void *v15; // x20
  size_t v16; // x0
  __int64 v17; // x20
  char *v18; // x21
  const void *v19; // x20
  size_t v20; // x0
  int v21; // w8
  __int64 v22; // x20
  char *v23; // x21
  const void *v24; // x20
  size_t v25; // x0
  __int64 v26; // x21
  char *v27; // x20
  const void *v28; // x19
  size_t v29; // x0
  int v30; // w8
  __int64 v31; // x8
  unsigned __int64 v32; // x9
  unsigned __int64 v33; // x12
  signed int v34; // w14
  char v35; // w11
  signed int v36; // w20
  int v37; // w15
  unsigned int v38; // w10
  const void *v39; // x21
  size_t v40; // x22
  signed int v41; // w0
  signed int v42; // w0
  int v43; // w11
  char v44; // w13
  int v45; // w12
  signed int v46; // w14
  int v47; // w11
  signed int v48; // w20
  _QWORD *v49; // [xsp+8h] [xbp-38h]
  char v50; // [xsp+14h] [xbp-2Ch]
  __int64 v51; // [xsp+18h] [xbp-28h]

  v1 = a1;
  v51 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
    goto LABEL_25;
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 > 255 )
  {
    if ( v2 == 256 )
      goto LABEL_15;
    if ( v2 != 1024 && v2 != 512 )
      goto LABEL_25;
  }
  else if ( (unsigned int)(v2 - 1) >= 2 )
  {
    if ( v2 != 64 )
      goto LABEL_25;
LABEL_15:
    v49 = 0LL;
    v7 = *(const void **)(a1 + 72);
    if ( v7 && (v8 = *(_QWORD *)(a1 + 80)) != 0 )
    {
      v9 = sub_6179C(&v49, (__int64)&unk_F7460, v8, v7, *(_QWORD *)(a1 + 32));
      if ( v9 )
      {
LABEL_18:
        v10 = 0LL;
LABEL_19:
        v11 = 0LL;
        goto LABEL_23;
      }
      if ( *(_DWORD *)(v1 + 16) == 64 )
      {
        v10 = sub_61654();
        if ( !v10 )
        {
          v11 = 0LL;
          v9 = -12;
          goto LABEL_23;
        }
      }
      else
      {
        v10 = 0LL;
      }
      v9 = sub_618A4(v49, (__int64)v10);
      if ( v9 & 0x80000000 )
        goto LABEL_19;
      if ( v9 )
      {
        v30 = *(_DWORD *)(v1 + 16);
        *(_QWORD *)(v1 + 144) = v10;
        if ( v30 != 256 )
        {
LABEL_69:
          v39 = *(const void **)(v1 + 72);
          v40 = *(_QWORD *)(v1 + 80);
          sub_570E4(v1, *(const void **)(v1 + 72), *(_QWORD *)(v1 + 80), (__int64)&off_1065D0, &v50);
          v9 = v41;
          if ( !v41 && !v50 )
          {
            sub_570E4(v1, v39, v40, (__int64)&off_1065E0, &v50);
            v9 = v42;
          }
          goto LABEL_18;
        }
        v11 = sub_6162C();
        if ( v11 )
        {
          v9 = sub_6179C(
                 &v49,
                 (__int64)&unk_F7460,
                 *(_QWORD *)(v1 + 80),
                 *(const void **)(v1 + 72),
                 (__int64)&off_1065F0);
          if ( v9 )
          {
            v10 = 0LL;
            goto LABEL_23;
          }
          v9 = sub_618A4(v49, (__int64)v11);
          if ( !(v9 & 0x80000000) )
          {
            if ( v9 )
            {
              *(_QWORD *)(v1 + 152) = v11;
              goto LABEL_69;
            }
            v10 = 0LL;
LABEL_22:
            v9 = -22;
            goto LABEL_23;
          }
          v10 = 0LL;
        }
        else
        {
          v10 = 0LL;
          v9 = -12;
        }
LABEL_23:
        sub_616F0(v10);
        sub_616F0(v11);
        sub_61844(v49);
        if ( !(v9 & 0x80000000) )
          sub_56C98((_QWORD *)v1);
        goto LABEL_25;
      }
    }
    else
    {
      v10 = 0LL;
    }
    v11 = 0LL;
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(a1 + 104);
  if ( v3 >= strlen(off_106490[0])
    && (v4 = *(const void **)(v1 + 96)) != 0LL
    && (v5 = off_106490[0], v6 = strlen(off_106490[0]), !(unsigned int)memcmp(v4, v5, v6)) )
  {
    if ( !*(_QWORD *)(v1 + 112) )
      goto LABEL_25;
    v12 = *(_DWORD *)(v1 + 16);
    if ( v12 == 1 )
    {
      v13 = *(_QWORD *)(v1 + 120);
      if ( v13 == strlen(off_106498[0]) )
      {
        v14 = off_106498[0];
        v15 = *(const void **)(v1 + 112);
        v16 = strlen(off_106498[0]);
        if ( !(unsigned int)memcmp(v15, v14, v16) )
          goto LABEL_25;
      }
      v12 = *(_DWORD *)(v1 + 16);
    }
    if ( v12 != 2
      || (v17 = *(_QWORD *)(v1 + 120), v17 != strlen(off_1064A0[0]))
      || (v18 = off_1064A0[0],
          v19 = *(const void **)(v1 + 112),
          v20 = strlen(off_1064A0[0]),
          (unsigned int)memcmp(v19, v18, v20)) )
    {
      v21 = *(_DWORD *)(v1 + 16);
      if ( v21 == 1024 )
      {
        v22 = *(_QWORD *)(v1 + 120);
        if ( v22 == strlen(off_1064A8[0]) )
        {
          v23 = off_1064A8[0];
          v24 = *(const void **)(v1 + 112);
          v25 = strlen(off_1064A8[0]);
          if ( !(unsigned int)memcmp(v24, v23, v25) )
            goto LABEL_25;
        }
        v21 = *(_DWORD *)(v1 + 16);
      }
      if ( v21 == 512 )
      {
        v26 = *(_QWORD *)(v1 + 120);
        if ( v26 == strlen(off_1064B0[0]) )
        {
          v27 = off_1064B0[0];
          v28 = *(const void **)(v1 + 112);
          v29 = strlen(off_1064B0[0]);
          !(unsigned int)memcmp(v28, v27, v29);
        }
      }
    }
    else
    {
      v31 = *(_QWORD *)(v1 + 128);
      if ( !v31 )
      {
        *(_BYTE *)(v1 + 20);
        goto LABEL_25;
      }
      v32 = *(_QWORD *)(v1 + 136);
      if ( v32 )
      {
        v33 = 0LL;
        v34 = 2;
        v35 = 1;
        v36 = -1009;
        while ( 1 )
        {
          v37 = *(unsigned __int8 *)(v31 + v33);
          v38 = v34;
          LODWORD(v33) = v34 - 1;
          if ( v37 == 32 )
            break;
          if ( (unsigned int)(v37 - 48) >= 0xA
            && ((unsigned int)(v37 - 65) > 0x25 || !((1LL << ((unsigned __int8)v37 - 65)) & 0x3F0000003FLL)) )
          {
            goto LABEL_76;
          }
          v35 = 0;
          v33 = (unsigned int)v33;
          ++v34;
          if ( (unsigned int)v33 >= v32 )
            goto LABEL_79;
        }
        v36 = 0;
LABEL_76:
        if ( v35 & 1 || v36 )
          goto LABEL_25;
        v33 = (unsigned int)v33;
LABEL_79:
        if ( v33 >= v32 )
          goto LABEL_25;
        v43 = 0;
        v44 = 1;
        while ( 1 )
        {
          v45 = *(unsigned __int8 *)(v31 + v33);
          if ( v45 == 32 )
          {
            v48 = 0;
            if ( v44 & 1 )
              break;
            goto LABEL_97;
          }
          if ( (unsigned int)(v45 - 48) > 9 )
          {
            if ( (unsigned int)(v45 - 97) >= 6 )
            {
              if ( (unsigned int)(v45 - 65) >= 6 )
              {
                v48 = -1009;
                if ( v44 & 1 )
                  break;
LABEL_97:
                if ( v48 )
                  break;
                v33 = v38;
LABEL_89:
                if ( v32 - v33 == 4 && *(_DWORD *)(v31 + v33) == 1145655375 )
                  *(_BYTE *)(v1 + 20);
                break;
              }
              v46 = -55;
            }
            else
            {
              v46 = -87;
            }
          }
          else
          {
            v46 = -48;
          }
          v47 = v45 + 16 * v43;
          v44 = 0;
          v33 = v38++;
          v43 = v47 + v46;
          if ( v33 >= v32 )
            goto LABEL_89;
        }
      }
    }
LABEL_25:
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v51;
  }
  else
  {
    sub_56C98((_QWORD *)v1);
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v51;
  }
}
// 106490: using guessed type char *off_106490[8];
// 106498: using guessed type char *off_106498[7];
// 1064A0: using guessed type char *off_1064A0[6];
// 1064A8: using guessed type char *off_1064A8[5];
// 1064B0: using guessed type char *off_1064B0[4];
// 1065D0: using guessed type char *off_1065D0;
// 1065E0: using guessed type char *off_1065E0;
// 1065F0: using guessed type char *off_1065F0;

//----- (0000000000056C98) ----------------------------------------------------
void __fastcall sub_56C98(_QWORD *a1)
{
  __int64 v1; // x19
  const void *v2; // x3
  size_t v3; // x2
  __int64 v4; // x0
  __int64 v5; // x0
  const char *v6; // x21
  signed int v7; // w22
  _QWORD *v8; // x20
  const void *v9; // x20
  size_t v10; // x21
  int v11; // w0
  const char *v12; // x22
  size_t v13; // x0
  const char *v14; // x22
  size_t v15; // x0
  _QWORD *v16; // [xsp+0h] [xbp-30h]
  __int64 v17; // [xsp+8h] [xbp-28h]

  v1 = (__int64)a1;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = (const void *)a1[5];
  if ( !v2 )
    goto LABEL_13;
  v3 = a1[6];
  if ( !v3 )
    goto LABEL_13;
  v4 = a1[18];
  if ( v4 )
  {
    v5 = sub_616A0(v4);
    v2 = *(const void **)(v1 + 40);
    v3 = *(_QWORD *)(v1 + 48);
    v6 = (const char *)v5;
  }
  else
  {
    v6 = 0LL;
  }
  v16 = 0LL;
  v7 = sub_6179C(&v16, (__int64)&unk_F7348, v3, v2, *(_QWORD *)(v1 + 32));
  if ( !v7 )
  {
    if ( *(_DWORD *)(v1 + 16) == 64 )
    {
      v8 = sub_61654();
      if ( !v8 )
      {
        v7 = -12;
        goto LABEL_9;
      }
    }
    else
    {
      v8 = 0LL;
    }
    v7 = sub_618A4(v16, (__int64)v8);
    if ( v7 )
    {
      if ( !(v7 & 0x80000000) )
      {
        if ( !v6 )
          goto LABEL_24;
        if ( v8 )
        {
          v12 = (const char *)sub_616A0((__int64)v8);
          v13 = strlen(v6);
          if ( (unsigned int)strncmp(v12, v6, v13) )
          {
            while ( 1 )
            {
              do
              {
LABEL_24:
                v7 = sub_618A4(v16, (__int64)v8);
                if ( !v7 )
                {
                  v7 = -1017;
                  goto LABEL_9;
                }
                if ( v7 & 0x80000000 )
                  goto LABEL_9;
              }
              while ( !v6 );
              if ( !v8 )
                break;
              v14 = (const char *)sub_616A0((__int64)v8);
              v15 = strlen(v6);
              if ( !(unsigned int)strncmp(v14, v6, v15) )
              {
                v7 = 0;
                goto LABEL_9;
              }
            }
            v7 = -22;
          }
          else
          {
            v7 = 0;
          }
        }
        else
        {
          v7 = -22;
        }
      }
    }
    else
    {
      v7 = -22;
    }
    goto LABEL_9;
  }
  v8 = 0LL;
LABEL_9:
  sub_616F0(v8);
  sub_61844(v16);
  if ( !v7 )
  {
    v9 = *(const void **)(v1 + 72);
    v10 = *(_QWORD *)(v1 + 80);
    sub_570E4(v1, *(const void **)(v1 + 72), *(_QWORD *)(v1 + 80), (__int64)&off_1065D0, &v16);
    if ( !v11 && !(_BYTE)v16 )
      sub_570E4(v1, v9, v10, (__int64)&off_1065E0, &v16);
  }
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v17;
}
// 1065D0: using guessed type char *off_1065D0;
// 1065E0: using guessed type char *off_1065E0;

//----- (0000000000056E8C) ----------------------------------------------------
void __fastcall sub_56E8C(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x20
  _QWORD *v3; // x19
  const void *v4; // x21
  void *v5; // x0
  void *v6; // x0
  _QWORD *v7; // [xsp+0h] [xbp-30h]
  __int64 v8; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = 0LL;
  if ( a1 && a2 && *(_QWORD *)(a2 + 16) == 13LL )
  {
    v4 = *(const void **)(a2 + 8);
    if ( (unsigned int)memcmp(*(const void **)(a2 + 8), &unk_D7074, 0xDuLL) )
    {
      if ( !(unsigned int)memcmp(v4, &unk_D7081, 0xDuLL)
        && !v3[7]
        && !(unsigned int)sub_6179C(&v7, (__int64)&unk_F73C0, *(_QWORD *)(v2 + 32), *(const void **)(v2 + 24), 0LL)
        && !(sub_618A4(v7, 0LL) & 0x80000000) )
      {
        v6 = malloc(*(_QWORD *)(v2 + 32));
        v3[7] = v6;
        if ( v6 )
        {
          memcpy(v6, *(const void **)(v2 + 24), *(_QWORD *)(v2 + 32));
          v3[8] = *(_QWORD *)(v2 + 32);
        }
      }
    }
    else if ( !v3[5]
           && !(unsigned int)sub_6179C(&v7, (__int64)&unk_F7348, *(_QWORD *)(v2 + 32), *(const void **)(v2 + 24), 0LL)
           && !(sub_618A4(v7, 0LL) & 0x80000000) )
    {
      v5 = malloc(*(_QWORD *)(v2 + 32));
      v3[5] = v5;
      if ( v5 )
      {
        memcpy(v5, *(const void **)(v2 + 24), *(_QWORD *)(v2 + 32));
        v3[6] = *(_QWORD *)(v2 + 32);
      }
    }
  }
  sub_61844(v7);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v8;
}

//----- (0000000000057020) ----------------------------------------------------
signed __int64 __fastcall sub_57020(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  signed __int64 result; // x0
  void *v5; // x0
  void *v6; // x0
  void *v7; // x0

  v2 = a2;
  v3 = a1;
  result = 4294967274LL;
  if ( v3 && a2 )
  {
    if ( *(_DWORD *)a2 )
    {
      if ( *(_DWORD *)(v3 + 88) >= *(_DWORD *)a2 )
        return 0LL;
      v5 = *(void **)(v3 + 96);
      if ( v5 )
      {
        free(v5);
        *(_QWORD *)(v3 + 96) = 0LL;
      }
      v6 = malloc(*(_QWORD *)(v2 + 16));
      *(_QWORD *)(v3 + 96) = v6;
      if ( v6 )
      {
        memcpy(v6, *(const void **)(v2 + 8), *(_QWORD *)(v2 + 16));
        result = 0LL;
        *(_QWORD *)(v3 + 104) = *(_QWORD *)(v2 + 16);
        *(_DWORD *)(v3 + 88) = *(_DWORD *)v2;
        return result;
      }
    }
    else
    {
      if ( *(_QWORD *)(v3 + 112) )
        return 4294966278LL;
      v7 = malloc(*(_QWORD *)(a2 + 16));
      *(_QWORD *)(v3 + 112) = v7;
      if ( v7 )
      {
        memcpy(v7, *(const void **)(v2 + 8), *(_QWORD *)(v2 + 16));
        result = 0LL;
        *(_QWORD *)(v3 + 120) = *(_QWORD *)(v2 + 16);
        return result;
      }
    }
    result = 4294967284LL;
  }
  return result;
}

//----- (00000000000570E4) ----------------------------------------------------
void __fastcall sub_570E4(__int64 a1, const void *a2, size_t a3, __int64 a4, _BYTE *a5)
{
  _BYTE *v5; // x22
  __int64 v6; // x20
  _QWORD *v7; // x19
  __int64 v8; // x8
  const void *v9; // [xsp+8h] [xbp-38h]
  _QWORD *v10; // [xsp+10h] [xbp-30h]
  __int64 v11; // [xsp+18h] [xbp-28h]

  v5 = a5;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = 0LL;
  v10 = 0LL;
  *a5 = 0;
  v6 = a1;
  if ( (unsigned int)sub_6179C(&v10, (__int64)&unk_F7460, a3, a2, a4) )
  {
    v7 = 0LL;
  }
  else
  {
    v7 = sub_61678();
    if ( v7 )
    {
      if ( (signed int)sub_618A4(v10, (__int64)v7) >= 1 )
      {
        if ( *(_QWORD *)(v6 + 8) )
        {
          *v5 = 1;
          v8 = sub_616BC((__int64)v7, &v9);
          if ( *(_QWORD *)v6 == v8 )
            !(unsigned int)memcmp(*(const void **)(v6 + 8), v9, v8);
        }
      }
    }
  }
  sub_616F0(v7);
  sub_61844(v10);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v11;
}

//----- (0000000000057204) ----------------------------------------------------
__int64 __fastcall sub_57204(_QWORD *a1, _BYTE *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x23
  _BYTE *v4; // x21
  _QWORD *v5; // x19
  unsigned int v6; // w22
  unsigned __int64 v7; // x22
  _DWORD *v9; // x0
  _QWORD *v10; // x20
  unsigned int v11; // w9
  int v12; // w10
  int v13; // w8
  void *v14; // x0
  signed __int64 v15; // x25
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x24
  void *v18; // x0
  __int64 v19; // x9
  unsigned __int64 v20; // x10
  unsigned int v21; // w8
  __int64 v22; // x8
  _BYTE *v23; // x13
  __int64 v24; // x12
  unsigned __int64 v25; // x9
  unsigned __int8 *v26; // x10
  unsigned int v27; // w8
  int v28; // w11
  unsigned __int64 v29; // x9
  unsigned int v30; // w10

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = -22;
  if ( a1 && a2 && a3 >= 0x1C )
  {
    if ( *a2 != 3 )
    {
      v6 = -1011;
      goto LABEL_10;
    }
    v7 = a3 - 1;
    if ( a3 - 1 < 3 )
    {
      v6 = 0;
      goto LABEL_10;
    }
    if ( (unsigned int)memcmp(a2 + 1, "SIN", 3uLL) )
    {
      v6 = -1012;
LABEL_10:
      *v5 = 0LL;
      return v6;
    }
    v9 = malloc(0x40uLL);
    v10 = v9;
    if ( !v9 )
      return (unsigned int)-12;
    *((_QWORD *)v9 + 3) = 0LL;
    *((_QWORD *)v9 + 6) = v4;
    if ( v7 >= 7 )
    {
      v11 = (_byteswap_ushort(*((_WORD *)v4 + 3)) | ((unsigned __int8)v4[5] << 16)) & 0xFFFFFF | ((unsigned __int8)v4[4] << 24);
      *v9 = v11;
      if ( v7 >= 0xB )
      {
        v12 = (_byteswap_ushort(*((_WORD *)v4 + 5)) | ((unsigned __int8)v4[9] << 16)) & 0xFFFFFF | ((unsigned __int8)v4[8] << 24);
        v9[1] = v12;
        if ( v7 >= 0xF )
        {
          v13 = (_byteswap_ushort(*((_WORD *)v4 + 7)) | ((unsigned __int8)v4[13] << 16)) & 0xFFFFFF | ((unsigned __int8)v4[12] << 24);
          v9[2] = v13;
          if ( v11 > v3 )
            goto LABEL_17;
          if ( (unsigned int)(v12 - 32) > 0xA )
          {
            v6 = -22;
            v14 = (void *)*((_QWORD *)v9 + 3);
            if ( !v14 )
              goto LABEL_43;
            goto LABEL_42;
          }
          if ( (unsigned int)(v13 - 1) > 1 )
          {
            v6 = -1014;
            v14 = (void *)*((_QWORD *)v9 + 3);
            if ( !v14 )
              goto LABEL_43;
            goto LABEL_42;
          }
          if ( v7 >= 0x17 )
          {
            if ( v13 == 1 )
              v15 = 20LL;
            else
              v15 = 32LL * (v13 == 2);
            v16 = (_byteswap_ushort(*((_WORD *)v4 + 11)) | ((unsigned __int8)v4[21] << 16)) & 0xFFFFFF | ((unsigned int)(unsigned __int8)v4[20] << 24);
            v17 = v16 / (v15 + 4);
            v9[3] = v16;
            v18 = malloc(16 * v17);
            v10[3] = v18;
            if ( !v18 )
            {
              v6 = -12;
              goto LABEL_43;
            }
            if ( (_DWORD)v17 )
            {
              v19 = 0LL;
              v20 = 0LL;
              v21 = 24;
              while ( v21 + 3 <= v7 )
              {
                *(_DWORD *)(v10[3] + v19) = (_byteswap_ushort(*(_WORD *)&v4[v21 + 2]) | ((unsigned __int8)v4[v21 + 1] << 16)) & 0xFFFFFF | ((unsigned __int8)v4[v21] << 24);
                if ( ((unsigned int)v15 | 3) + v21 > v7 )
                  break;
                v22 = v21 + 4;
                ++v20;
                v23 = &v4[v22];
                v21 = v22 + v15;
                v24 = v10[3] + v19;
                v19 += 16LL;
                *(_QWORD *)(v24 + 8) = v23;
                if ( v20 >= v17 )
                  goto LABEL_39;
              }
            }
            else
            {
              v21 = 24;
LABEL_39:
              v25 = v21 + 3;
              *((_DWORD *)v10 + 4) = v17;
              if ( v25 <= v7 )
              {
                v26 = &v4[v21];
                v27 = v21 + 4;
                v28 = (_byteswap_ushort(*((_WORD *)v26 + 1)) | (v26[1] << 16)) & 0xFFFFFF | (*v26 << 24);
                *((_DWORD *)v10 + 14) = v27;
                *((_DWORD *)v10 + 8) = v28;
                if ( (unsigned int)(v25 + v28) <= v7 )
                {
                  v29 = *((unsigned int *)v10 + 3);
                  v30 = *(_DWORD *)v10;
                  v10[5] = &v4[v27];
                  if ( (unsigned int)v29 < v30 && v29 == v29 / (v15 + 4) * (v15 + 4) )
                  {
                    v6 = 0;
                    *v5 = v10;
                    return v6;
                  }
LABEL_17:
                  v6 = -1013;
                  v14 = (void *)v10[3];
                  if ( !v14 )
                    goto LABEL_43;
                  goto LABEL_42;
                }
              }
            }
          }
        }
      }
    }
    v6 = 0;
    v14 = (void *)v10[3];
    if ( v14 )
LABEL_42:
      free(v14);
LABEL_43:
    free(v10);
    goto LABEL_10;
  }
  return v6;
}

//----- (0000000000057508) ----------------------------------------------------
__int64 __fastcall sub_57508(_QWORD *a1)
{
  void *v1; // x19
  void *v2; // x0

  v1 = a1;
  if ( a1 )
  {
    v2 = (void *)a1[3];
    if ( v2 )
      free(v2);
    free(v1);
  }
  return 0LL;
}

//----- (0000000000057540) ----------------------------------------------------
signed __int64 __fastcall sub_57540(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x8
  signed __int64 result; // x0

  v2 = a1;
  result = 4294967274LL;
  if ( v2 )
  {
    if ( a2 )
    {
      result = 0LL;
      *a2 = v2;
    }
  }
  return result;
}

//----- (000000000005755C) ----------------------------------------------------
signed __int64 __fastcall sub_5755C(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x8
  signed __int64 result; // x0

  v2 = a1;
  result = 4294967274LL;
  if ( v2 )
  {
    if ( a2 )
    {
      result = 0LL;
      *a2 = v2 + 32;
    }
  }
  return result;
}

//----- (000000000005757C) ----------------------------------------------------
signed __int64 __fastcall sub_5757C(__int64 a1, _DWORD *a2)
{
  __int64 v2; // x8
  signed __int64 result; // x0

  v2 = a1;
  result = 4294967274LL;
  if ( v2 )
  {
    if ( a2 )
    {
      result = 0LL;
      *a2 = *(_DWORD *)(v2 + 16);
    }
  }
  return result;
}

//----- (000000000005759C) ----------------------------------------------------
signed __int64 __fastcall sub_5759C(__int64 a1, unsigned int a2, _QWORD *a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0
  __int64 v5; // x9

  v3 = a1;
  result = 4294967274LL;
  if ( v3 && a3 )
  {
    v5 = *(_QWORD *)(v3 + 24);
    if ( v5 )
    {
      if ( *(_DWORD *)(v3 + 16) <= a2 )
      {
        result = 4294967274LL;
      }
      else
      {
        result = 0LL;
        *a3 = v5 + 16LL * a2;
      }
    }
    else
    {
      result = 4294967274LL;
    }
  }
  return result;
}

//----- (00000000000575E0) ----------------------------------------------------
signed __int64 __fastcall sub_575E0(__int64 a1, int a2, _QWORD *a3, _DWORD *a4)
{
  __int64 v4; // x8
  signed __int64 result; // x0

  v4 = a1;
  result = 4294967274LL;
  if ( v4 && a3 && a4 )
  {
    if ( a2 )
    {
      result = 4294966281LL;
    }
    else
    {
      result = 0LL;
      *a3 = *(_QWORD *)(v4 + 48);
      *a4 = *(_DWORD *)(v4 + 56);
    }
  }
  return result;
}

//----- (0000000000057618) ----------------------------------------------------
__int64 __fastcall sub_57618(__int64 a1, unsigned __int64 a2, signed __int64 a3, _BYTE *a4, unsigned int a5, _QWORD *a6)
{
  _QWORD *v6; // x19
  signed __int64 v7; // x20
  unsigned __int64 v8; // x21
  __int64 v9; // x22
  unsigned int v10; // w23
  unsigned int v11; // w24
  int v12; // w25
  __int64 result; // x0
  unsigned int v14; // w0
  int v15; // [xsp+Ch] [xbp-84h]
  __int64 v16; // [xsp+10h] [xbp-80h]
  __int64 v17; // [xsp+18h] [xbp-78h]
  int v18; // [xsp+24h] [xbp-6Ch]
  __int64 v19; // [xsp+28h] [xbp-68h]
  __int64 v20; // [xsp+30h] [xbp-60h]
  unsigned __int8 **v21; // [xsp+38h] [xbp-58h]
  _QWORD *v22; // [xsp+40h] [xbp-50h]
  __int64 v23; // [xsp+48h] [xbp-48h]

  v6 = a6;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = -22;
  v23 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v16 = 0LL;
  v17 = 0LL;
  v15 = 0;
  v22 = 0LL;
  if ( !a1 || !a2 || !a3 || !a4 || !a5 || !a6 )
    goto LABEL_19;
  if ( (unsigned int)sub_57204(&v22, a4, a5) || (unsigned int)sub_57540((__int64)v22, &v20) || *(_DWORD *)(v20 + 8) != 2 )
    goto LABEL_18;
  v10 = sub_61B40((void ****)&v17);
  if ( v10 )
    goto LABEL_19;
  v11 = X509V3_add_standard_extensions();
  if ( v11 )
  {
    v12 = 0;
    while ( !(unsigned int)sub_575E0((__int64)v22, v12, &v19, &v18) )
    {
      v10 = sub_61C54(v17, v19, v18);
      if ( v10 )
        goto LABEL_19;
      if ( ++v12 >= v11 )
        goto LABEL_16;
    }
LABEL_18:
    v10 = -1016;
    goto LABEL_19;
  }
LABEL_16:
  v10 = sub_61C90(v17, &v16, &v15);
  if ( v10 )
    goto LABEL_19;
  if ( (unsigned int)sub_5755C((__int64)v22, &v21) )
    goto LABEL_18;
  sub_61098(v9, v8, v7, v21[1], *(unsigned int *)v21, v16, v15);
  v10 = v14;
  if ( !v14 )
  {
    *v6 = v22;
    v22 = 0LL;
  }
LABEL_19:
  sub_61C14(v17);
  result = sub_57508(v22);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v23 )
    result = v10;
  return result;
}

//----- (00000000000577B8) ----------------------------------------------------
_QWORD *BUF_MEM_new()
{
  _QWORD *result; // x0

  result = malloc(0x18uLL);
  if ( result )
  {
    result[1] = 0LL;
    result[2] = 0LL;
    *result = 0LL;
  }
  else
  {
    ERR_put_error(7, 0LL, 65, (__int64)"external/boringssl/src/crypto/buf/buf.c", 72);
    result = 0LL;
  }
  return result;
}

//----- (0000000000057804) ----------------------------------------------------
void __fastcall BUF_MEM_free(__int64 a1)
{
  __int64 v1; // x19
  void *v2; // x0

  v1 = a1;
  if ( a1 )
  {
    v2 = *(void **)(a1 + 8);
    if ( v2 )
    {
      OPENSSL_cleanse(v2, *(_QWORD *)(v1 + 16));
      free(*(void **)(v1 + 8));
    }
    free((void *)v1);
  }
}

//----- (000000000005784C) ----------------------------------------------------
signed __int64 __fastcall BUF_MEM_reserve(__int64 a1, unsigned __int64 a2)
{
  return sub_57854(a1, a2, 0);
}

//----- (0000000000057854) ----------------------------------------------------
signed __int64 __fastcall sub_57854(__int64 a1, unsigned __int64 a2, int a3)
{
  __int64 v3; // x19
  size_t v4; // x8
  __int16 v5; // w4
  unsigned __int64 v6; // x9
  void *v7; // x0
  signed __int64 v8; // x20
  void *v9; // x0

  v3 = a1;
  v4 = *(_QWORD *)(a1 + 16);
  if ( v4 >= a2 )
    return 1LL;
  if ( a2 < 0xFFFFFFFFFFFFFFFDLL )
  {
    v6 = (unsigned __int64)((a2 + 3) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL >> 64) >> 1;
    if ( (v6 & 0x3FFFFFFFFFFFFFFFLL) != v6 )
    {
      v5 = 108;
      goto LABEL_16;
    }
    v7 = *(void **)(a1 + 8);
    v8 = 4 * v6;
    if ( v7 )
    {
      if ( a3 )
      {
        v9 = sub_4BAEC(v7, v4, 4 * v6);
        if ( !v9 )
          goto LABEL_15;
      }
      else
      {
        v9 = realloc(v7, 4 * v6);
        if ( !v9 )
        {
LABEL_15:
          v5 = 124;
          goto LABEL_16;
        }
      }
    }
    else
    {
      v9 = malloc(4 * v6);
      if ( !v9 )
        goto LABEL_15;
    }
    *(_QWORD *)(v3 + 8) = v9;
    *(_QWORD *)(v3 + 16) = v8;
    return 1LL;
  }
  v5 = 101;
LABEL_16:
  ERR_put_error(7, 0LL, 65, (__int64)"external/boringssl/src/crypto/buf/buf.c", v5);
  return 0LL;
}

//----- (0000000000057940) ----------------------------------------------------
unsigned __int64 __fastcall BUF_MEM_grow(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x19
  unsigned __int64 *v3; // x20
  unsigned __int64 v4; // x8

  v2 = a2;
  v3 = (unsigned __int64 *)a1;
  if ( !(unsigned int)sub_57854(a1, a2, 0) )
    return 0LL;
  v4 = *v3;
  if ( *v3 < v2 && v2 != v4 )
    memset((void *)(v3[1] + v4), 0, v2 - v4);
  *v3 = v2;
  return v2;
}

//----- (00000000000579A0) ----------------------------------------------------
unsigned __int64 __fastcall BUF_MEM_grow_clean(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x19
  unsigned __int64 *v3; // x20
  unsigned __int64 v4; // x8

  v2 = a2;
  v3 = (unsigned __int64 *)a1;
  if ( !(unsigned int)sub_57854(a1, a2, 1) )
    return 0LL;
  v4 = *v3;
  if ( *v3 < v2 && v2 != v4 )
    memset((void *)(v3[1] + v4), 0, v2 - v4);
  *v3 = v2;
  return v2;
}

//----- (0000000000057A00) ----------------------------------------------------
_BYTE *__fastcall BUF_strdup(const char *a1)
{
  const char *v1; // x19
  size_t v2; // x1

  v1 = a1;
  if ( !a1 )
    return 0LL;
  v2 = strlen(a1);
  return BUF_strndup(v1, v2);
}

//----- (0000000000057A40) ----------------------------------------------------
_BYTE *__fastcall BUF_strndup(const void *a1, size_t a2)
{
  const void *v2; // x19
  size_t v3; // x20
  _BYTE *v4; // x0
  _BYTE *v5; // x21

  v2 = a1;
  if ( !a1 )
    return 0LL;
  v3 = 0LL;
  if ( a2 )
  {
    while ( *((_BYTE *)a1 + v3) )
    {
      if ( ++v3 >= a2 )
      {
        if ( v3 != -1LL )
          break;
        ERR_put_error(7, 0LL, 65, (__int64)"external/boringssl/src/crypto/buf/buf.c", 189);
        return 0LL;
      }
    }
  }
  v4 = malloc(v3 + 1);
  v5 = v4;
  if ( v4 )
  {
    if ( v3 )
      memcpy(v4, v2, v3);
    v5[v3] = 0;
  }
  else
  {
    ERR_put_error(7, 0LL, 65, (__int64)"external/boringssl/src/crypto/buf/buf.c", 194);
  }
  return v5;
}

//----- (0000000000057AFC) ----------------------------------------------------
unsigned __int64 __fastcall BUF_strnlen(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 result; // x0

  v2 = a1;
  result = 0LL;
  if ( a2 )
  {
    do
    {
      if ( !*(_BYTE *)(v2 + result) )
        break;
      ++result;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (0000000000057B20) ----------------------------------------------------
size_t __fastcall BUF_strlcpy(_BYTE *a1, const char *a2, unsigned __int64 a3)
{
  __int64 v3; // x19

  if ( a3 < 2 )
  {
    v3 = 0LL;
    if ( a3 )
LABEL_10:
      *a1 = 0;
  }
  else
  {
    v3 = 0LL;
    do
    {
      if ( !a2[v3] )
      {
        a2 += v3;
        a1 += v3;
        goto LABEL_10;
      }
      a1[v3] = a2[v3];
      ++v3;
      --a3;
    }
    while ( a3 > 1 );
    a2 += v3;
    a1 += v3;
    if ( a3 )
      goto LABEL_10;
  }
  return strlen(a2) + v3;
}

//----- (0000000000057B94) ----------------------------------------------------
size_t __fastcall BUF_strlcat(_BYTE *a1, const char *a2, __int64 a3)
{
  __int64 v3; // x8
  __int64 v4; // x20
  __int64 v5; // x19
  unsigned __int64 v6; // x9

  if ( a3 )
  {
    v3 = 0LL;
    while ( *a1 )
    {
      ++a1;
      if ( !(a3 + --v3) )
      {
        v4 = 0LL;
        v5 = -v3;
        return v4 + v5 + strlen(a2);
      }
    }
    v4 = 0LL;
    v6 = a3 + v3;
    v5 = -v3;
    if ( (unsigned __int64)(a3 + v3) >= 2 )
    {
      v4 = 0LL;
      do
      {
        if ( !a2[v4] )
        {
          a2 += v4;
          goto LABEL_14;
        }
        a1[v4] = a2[v4];
        ++v4;
        --v6;
      }
      while ( v6 > 1 );
      a2 += v4;
      if ( a3 + v3 == v4 )
        return v4 + v5 + strlen(a2);
LABEL_14:
      a1 += v4;
    }
    *a1 = 0;
  }
  else
  {
    v5 = 0LL;
    v4 = 0LL;
  }
  return v4 + v5 + strlen(a2);
}

//----- (0000000000057C48) ----------------------------------------------------
void *__fastcall BUF_memdup(const void *a1, size_t a2)
{
  size_t v2; // x20
  const void *v3; // x21
  void *v4; // x0
  void *v5; // x19

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    return 0LL;
  v4 = malloc(a2);
  v5 = v4;
  if ( v4 )
    memcpy(v4, v3, v2);
  else
    ERR_put_error(7, 0LL, 65, (__int64)"external/boringssl/src/crypto/buf/buf.c", 235);
  return v5;
}

//----- (0000000000057CC0) ----------------------------------------------------
char *EVP_PKEY_new()
{
  char *result; // x0

  result = (char *)malloc(0x18uLL);
  if ( result )
  {
    *((_DWORD *)result + 5) = 0;
    *(_QWORD *)(result + 12) = 0LL;
    *(_QWORD *)(result + 4) = 0LL;
    *(_DWORD *)result = 1;
  }
  else
  {
    ERR_put_error(6, 0LL, 65, (__int64)"external/boringssl/src/crypto/evp/evp.c", 79);
    result = 0LL;
  }
  return result;
}

//----- (0000000000057D18) ----------------------------------------------------
void __fastcall EVP_PKEY_free(int *a1)
{
  int *v1; // x19
  __int64 v2; // x8
  void (__fastcall *v3)(int *); // x8

  v1 = a1;
  if ( a1 && (unsigned int)CRYPTO_refcount_dec_and_test_zero(a1) )
  {
    v2 = *((_QWORD *)v1 + 2);
    if ( v2 )
    {
      v3 = *(void (__fastcall **)(int *))(v2 + 112);
      if ( v3 )
        v3(v1);
    }
    free(v1);
  }
}

//----- (0000000000057D6C) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_up_ref(_DWORD *a1)
{
  CRYPTO_refcount_inc(a1);
  return 1LL;
}

//----- (0000000000057D84) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_is_opaque(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x1
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 && (v2 = *(__int64 (**)(void))(v1 + 56)) != 0LL )
    result = v2();
  else
    result = 0LL;
  return result;
}

//----- (0000000000057DA0) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_supports_digest(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x2
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 && (v2 = *(__int64 (**)(void))(v1 + 64)) != 0LL )
    result = v2();
  else
    result = 1LL;
  return result;
}

//----- (0000000000057DBC) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_cmp(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  __int64 (*v5)(void); // x9
  __int64 result; // x0
  __int64 (__fastcall *v7)(__int64, __int64); // x2

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4) )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 16);
  if ( !v4 )
    goto LABEL_12;
  v5 = *(__int64 (**)(void))(v4 + 104);
  if ( v5 )
  {
    result = v5();
    if ( (signed int)result < 1 )
      return result;
    v4 = *(_QWORD *)(v3 + 16);
  }
  v7 = *(__int64 (__fastcall **)(__int64, __int64))(v4 + 32);
  if ( v7 )
    result = v7(v3, v2);
  else
LABEL_12:
    result = 4294967294LL;
  return result;
}

//----- (0000000000057E3C) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_copy_parameters(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  unsigned int (__fastcall *v5)(__int64); // x9
  int v6; // w2
  __int16 v7; // w4
  __int64 (__fastcall *v9)(__int64, __int64); // x2

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4) )
  {
    v6 = 103;
    v7 = 155;
    goto LABEL_7;
  }
  v4 = *(_QWORD *)(a2 + 16);
  if ( !v4 )
    return 0LL;
  v5 = *(unsigned int (__fastcall **)(__int64))(v4 + 88);
  if ( v5 )
  {
    if ( v5(a2) )
    {
      v6 = 118;
      v7 = 160;
LABEL_7:
      ERR_put_error(6, 0LL, v6, (__int64)"external/boringssl/src/crypto/evp/evp.c", v7);
      return 0LL;
    }
    v4 = *(_QWORD *)(v2 + 16);
    if ( !v4 )
      return 0LL;
  }
  v9 = *(__int64 (__fastcall **)(__int64, __int64))(v4 + 96);
  if ( !v9 )
    return 0LL;
  return v9(v3, v2);
}

//----- (0000000000057EE4) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_missing_parameters(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x1
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 16);
  if ( v1 && (v2 = *(__int64 (**)(void))(v1 + 88)) != 0LL )
    result = v2();
  else
    result = 0LL;
  return result;
}

//----- (0000000000057F00) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_size(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x1
  __int64 result; // x0

  if ( a1 && (v1 = *(_QWORD *)(a1 + 16)) != 0 && (v2 = *(__int64 (**)(void))(v1 + 72)) != 0LL )
    result = v2();
  else
    result = 0LL;
  return result;
}

//----- (0000000000057F20) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_bits(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x1
  __int64 result; // x0

  if ( a1 && (v1 = *(_QWORD *)(a1 + 16)) != 0 && (v2 = *(__int64 (**)(void))(v1 + 80)) != 0LL )
    result = v2();
  else
    result = 0LL;
  return result;
}

//----- (0000000000057F40) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_type(int a1)
{
  switch ( a1 )
  {
    case 6:
      return 6LL;
    case 116:
      return 116LL;
    case 408:
      return 408LL;
  }
  return 0LL;
}

//----- (0000000000057F90) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_set1_RSA(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  void (*v5)(void); // x8

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = *(_QWORD *)(a1 + 16);
      if ( v4 )
      {
        v5 = *(void (**)(void))(v4 + 112);
        if ( v5 )
        {
          v5();
          *(_QWORD *)(v3 + 8) = 0LL;
          *(_DWORD *)(v3 + 4) = 0;
        }
      }
    }
    *(_QWORD *)(v3 + 16) = &dword_F72A8;
    *(_DWORD *)(v3 + 4) = 6;
  }
  *(_QWORD *)(v3 + 8) = v2;
  if ( !v2 )
    return 0LL;
  RSA_up_ref(v2);
  return 1LL;
}
// F72A8: using guessed type int dword_F72A8;

//----- (000000000005800C) ----------------------------------------------------
bool __fastcall EVP_PKEY_assign_RSA(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  void (*v5)(void); // x8

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = *(_QWORD *)(a1 + 16);
      if ( v4 )
      {
        v5 = *(void (**)(void))(v4 + 112);
        if ( v5 )
        {
          v5();
          *(_QWORD *)(v3 + 8) = 0LL;
          *(_DWORD *)(v3 + 4) = 0;
        }
      }
    }
    *(_QWORD *)(v3 + 16) = &dword_F72A8;
    *(_DWORD *)(v3 + 4) = 6;
  }
  *(_QWORD *)(v3 + 8) = v2;
  return v2 != 0;
}
// F72A8: using guessed type int dword_F72A8;

//----- (0000000000058078) ----------------------------------------------------
bool __fastcall EVP_PKEY_assign(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // x19
  unsigned int v4; // w21
  __int64 v5; // x20
  __int64 v6; // x8
  void (*v7)(void); // x8
  int *v8; // x8
  int v9; // w9
  _BOOL8 result; // x0
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v6 = *(_QWORD *)(a1 + 16);
      if ( v6 )
      {
        v7 = *(void (**)(void))(v6 + 112);
        if ( v7 )
        {
          v7();
          *(_QWORD *)(v5 + 8) = 0LL;
          *(_DWORD *)(v5 + 4) = 0;
        }
      }
    }
  }
  switch ( v4 )
  {
    case 6u:
      v8 = &dword_F72A8;
      if ( !v5 )
        goto LABEL_15;
      goto LABEL_14;
    case 0x74u:
      v8 = &dword_F70F8;
      if ( !v5 )
      {
LABEL_15:
        result = v3 != 0;
        *(_QWORD *)(v5 + 8) = v3;
        return result;
      }
LABEL_14:
      v9 = *v8;
      *(_QWORD *)(v5 + 16) = v8;
      *(_DWORD *)(v5 + 4) = v9;
      goto LABEL_15;
    case 0x198u:
      v8 = &dword_F71D0;
      if ( !v5 )
        goto LABEL_15;
      goto LABEL_14;
  }
  ERR_put_error(6, 0LL, 128, (__int64)"external/boringssl/src/crypto/evp/evp.c", 324);
  ERR_add_error_dataf((__int64)"algorithm %d", v11, v12, v13, v14, v15, v16, v17, v18, v4);
  return 0LL;
}
// F70F8: using guessed type int dword_F70F8;
// F71D0: using guessed type int dword_F71D0;
// F72A8: using guessed type int dword_F72A8;

//----- (0000000000058160) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_get0_RSA(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 4) == 6 )
    return *(_QWORD *)(a1 + 8);
  ERR_put_error(6, 0LL, 107, (__int64)"external/boringssl/src/crypto/evp/evp.c", 235);
  return 0LL;
}

//----- (00000000000581A4) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_get1_RSA(__int64 a1)
{
  __int64 v1; // x19

  if ( *(_DWORD *)(a1 + 4) == 6 )
  {
    v1 = *(_QWORD *)(a1 + 8);
    if ( v1 )
      RSA_up_ref(*(_QWORD *)(a1 + 8));
  }
  else
  {
    ERR_put_error(6, 0LL, 107, (__int64)"external/boringssl/src/crypto/evp/evp.c", 235);
    v1 = 0LL;
  }
  return v1;
}

//----- (0000000000058200) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_set1_DSA(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  void (*v5)(void); // x8

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = *(_QWORD *)(a1 + 16);
      if ( v4 )
      {
        v5 = *(void (**)(void))(v4 + 112);
        if ( v5 )
        {
          v5();
          *(_QWORD *)(v3 + 8) = 0LL;
          *(_DWORD *)(v3 + 4) = 0;
        }
      }
    }
    *(_QWORD *)(v3 + 16) = &dword_F70F8;
    *(_DWORD *)(v3 + 4) = 116;
  }
  *(_QWORD *)(v3 + 8) = v2;
  if ( !v2 )
    return 0LL;
  DSA_up_ref(v2);
  return 1LL;
}
// F70F8: using guessed type int dword_F70F8;

//----- (000000000005827C) ----------------------------------------------------
bool __fastcall EVP_PKEY_assign_DSA(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  void (*v5)(void); // x8

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = *(_QWORD *)(a1 + 16);
      if ( v4 )
      {
        v5 = *(void (**)(void))(v4 + 112);
        if ( v5 )
        {
          v5();
          *(_QWORD *)(v3 + 8) = 0LL;
          *(_DWORD *)(v3 + 4) = 0;
        }
      }
    }
    *(_QWORD *)(v3 + 16) = &dword_F70F8;
    *(_DWORD *)(v3 + 4) = 116;
  }
  *(_QWORD *)(v3 + 8) = v2;
  return v2 != 0;
}
// F70F8: using guessed type int dword_F70F8;

//----- (00000000000582E8) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_get0_DSA(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 4) == 116 )
    return *(_QWORD *)(a1 + 8);
  ERR_put_error(6, 0LL, 108, (__int64)"external/boringssl/src/crypto/evp/evp.c", 263);
  return 0LL;
}

//----- (000000000005832C) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_get1_DSA(__int64 a1)
{
  __int64 v1; // x19

  if ( *(_DWORD *)(a1 + 4) == 116 )
  {
    v1 = *(_QWORD *)(a1 + 8);
    if ( v1 )
      DSA_up_ref(*(_QWORD *)(a1 + 8));
  }
  else
  {
    ERR_put_error(6, 0LL, 108, (__int64)"external/boringssl/src/crypto/evp/evp.c", 263);
    v1 = 0LL;
  }
  return v1;
}

//----- (0000000000058388) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_set1_EC_KEY(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  void (*v5)(void); // x8

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = *(_QWORD *)(a1 + 16);
      if ( v4 )
      {
        v5 = *(void (**)(void))(v4 + 112);
        if ( v5 )
        {
          v5();
          *(_QWORD *)(v3 + 8) = 0LL;
          *(_DWORD *)(v3 + 4) = 0;
        }
      }
    }
    *(_QWORD *)(v3 + 16) = &dword_F71D0;
    *(_DWORD *)(v3 + 4) = 408;
  }
  *(_QWORD *)(v3 + 8) = v2;
  if ( !v2 )
    return 0LL;
  EC_KEY_up_ref(v2);
  return 1LL;
}
// F71D0: using guessed type int dword_F71D0;

//----- (0000000000058404) ----------------------------------------------------
bool __fastcall EVP_PKEY_assign_EC_KEY(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  void (*v5)(void); // x8

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = *(_QWORD *)(a1 + 16);
      if ( v4 )
      {
        v5 = *(void (**)(void))(v4 + 112);
        if ( v5 )
        {
          v5();
          *(_QWORD *)(v3 + 8) = 0LL;
          *(_DWORD *)(v3 + 4) = 0;
        }
      }
    }
    *(_QWORD *)(v3 + 16) = &dword_F71D0;
    *(_DWORD *)(v3 + 4) = 408;
  }
  *(_QWORD *)(v3 + 8) = v2;
  return v2 != 0;
}
// F71D0: using guessed type int dword_F71D0;

//----- (0000000000058470) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_get0_EC_KEY(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 4) == 408 )
    return *(_QWORD *)(a1 + 8);
  ERR_put_error(6, 0LL, 106, (__int64)"external/boringssl/src/crypto/evp/evp.c", 291);
  return 0LL;
}

//----- (00000000000584B4) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_get1_EC_KEY(__int64 a1)
{
  __int64 v1; // x19

  if ( *(_DWORD *)(a1 + 4) == 408 )
  {
    v1 = *(_QWORD *)(a1 + 8);
    if ( v1 )
      EC_KEY_up_ref(*(_QWORD *)(a1 + 8));
  }
  else
  {
    ERR_put_error(6, 0LL, 106, (__int64)"external/boringssl/src/crypto/evp/evp.c", 291);
    v1 = 0LL;
  }
  return v1;
}

//----- (0000000000058510) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_set_type(__int64 a1, unsigned int a2)
{
  unsigned int v2; // w20
  __int64 v3; // x19
  __int64 v4; // x8
  void (*v5)(void); // x8
  int *v6; // x8
  int v7; // w9
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      v4 = *(_QWORD *)(a1 + 16);
      if ( v4 )
      {
        v5 = *(void (**)(void))(v4 + 112);
        if ( v5 )
        {
          v5();
          *(_QWORD *)(v3 + 8) = 0LL;
          *(_DWORD *)(v3 + 4) = 0;
        }
      }
    }
  }
  switch ( v2 )
  {
    case 6u:
      v6 = &dword_F72A8;
      if ( !v3 )
        return 1LL;
      goto LABEL_14;
    case 0x74u:
      v6 = &dword_F70F8;
      if ( !v3 )
        return 1LL;
LABEL_14:
      v7 = *v6;
      *(_QWORD *)(v3 + 16) = v6;
      *(_DWORD *)(v3 + 4) = v7;
      return 1LL;
    case 0x198u:
      v6 = &dword_F71D0;
      if ( !v3 )
        return 1LL;
      goto LABEL_14;
  }
  ERR_put_error(6, 0LL, 128, (__int64)"external/boringssl/src/crypto/evp/evp.c", 324);
  ERR_add_error_dataf((__int64)"algorithm %d", v9, v10, v11, v12, v13, v14, v15, v16, v2);
  return 0LL;
}
// F70F8: using guessed type int dword_F70F8;
// F71D0: using guessed type int dword_F71D0;
// F72A8: using guessed type int dword_F72A8;

//----- (00000000000585E4) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_cmp_parameters(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 (*v3)(void); // x2
  __int64 result; // x0

  if ( *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4) )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 16);
  if ( v2 && (v3 = *(__int64 (**)(void))(v2 + 104)) != 0LL )
    result = v3();
  else
    result = 4294967294LL;
  return result;
}

//----- (0000000000058618) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set_signature_md(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, -1, 56);
}

//----- (0000000000058634) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_get_signature_md(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, -1, 56);
}

//----- (0000000000058650) ----------------------------------------------------
int **__fastcall EVP_PKEY_CTX_new(__int64 a1, int *a2)
{
  int *v2; // x21
  int *v3; // x19
  int *v4; // x22
  int **v5; // x0
  int **v6; // x20
  signed int (__fastcall *v7)(int **); // x8
  unsigned int *v8; // x8
  unsigned int v9; // w20
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7

  v2 = a2;
  v3 = (int *)a1;
  if ( !a1 )
    return 0LL;
  v8 = *(unsigned int **)(a1 + 16);
  if ( !v8 )
    return 0LL;
  v9 = *v8;
  v4 = &dword_F7248;
  if ( v9 != 6 )
  {
    v4 = &dword_F7170;
    if ( v9 != 408 )
    {
      ERR_put_error(6, 0LL, 128, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 99);
      ERR_add_error_dataf((__int64)"algorithm %d", v10, v11, v12, v13, v14, v15, v16, v17, v9);
      return 0LL;
    }
  }
  v5 = (int **)malloc(0x30uLL);
  v6 = v5;
  if ( v5 )
  {
    v5[4] = 0LL;
    v5[5] = 0LL;
    v5[2] = 0LL;
    v5[3] = 0LL;
    *v5 = v4;
    v5[1] = v2;
    *((_DWORD *)v5 + 8) = 0;
    if ( v3 )
    {
      EVP_PKEY_up_ref(v3);
      v6[2] = v3;
    }
    v7 = (signed int (__fastcall *)(int **))*((_QWORD *)v4 + 1);
    if ( v7 && v7(v6) <= 0 )
    {
      EVP_PKEY_free(v6[2]);
      free(v6);
      return 0LL;
    }
  }
  else
  {
    ERR_put_error(6, 0LL, 65, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 106);
  }
  return v6;
}
// F7170: using guessed type int dword_F7170;
// F7248: using guessed type int dword_F7248;

//----- (0000000000058778) ----------------------------------------------------
void EVP_PKEY_CTX_new_id()
{
  JUMPOUT(&loc_58658);
}

//----- (0000000000058788) ----------------------------------------------------
void __fastcall EVP_PKEY_CTX_free(int **a1)
{
  int **v1; // x19
  void (*v2)(void); // x8

  v1 = a1;
  if ( a1 )
  {
    if ( *a1 )
    {
      v2 = (void (*)(void))*((_QWORD *)*a1 + 3);
      if ( v2 )
        v2();
    }
    EVP_PKEY_free(v1[2]);
    EVP_PKEY_free(v1[3]);
    free(v1);
  }
}

//----- (00000000000587E0) ----------------------------------------------------
void *__fastcall EVP_PKEY_CTX_dup(_QWORD *a1)
{
  _QWORD *v1; // x20
  __int64 v2; // x21
  _QWORD *v3; // x0
  void *v4; // x19
  _DWORD *v5; // x0
  _DWORD *v6; // x0
  int *v7; // x0

  v1 = a1;
  v2 = *a1;
  if ( !*a1 || !*(_QWORD *)(v2 + 16) )
    return 0LL;
  v3 = malloc(0x30uLL);
  v4 = v3;
  if ( v3 )
  {
    v3[4] = 0LL;
    v3[5] = 0LL;
    v3[2] = 0LL;
    v3[3] = 0LL;
    *v3 = v2;
    v3[1] = v1[1];
    *((_DWORD *)v3 + 8) = *((_DWORD *)v1 + 8);
    v5 = (_DWORD *)v1[2];
    if ( v5 )
    {
      EVP_PKEY_up_ref(v5);
      *((_QWORD *)v4 + 2) = v1[2];
    }
    v6 = (_DWORD *)v1[3];
    if ( v6 )
    {
      EVP_PKEY_up_ref(v6);
      *((_QWORD *)v4 + 3) = v1[3];
    }
    if ( (*(signed int (__fastcall **)(void *, _QWORD *))(*v1 + 16LL))(v4, v1) <= 0 )
    {
      v7 = (int *)*((_QWORD *)v4 + 2);
      *(_QWORD *)v4 = 0LL;
      EVP_PKEY_free(v7);
      EVP_PKEY_free(*((int **)v4 + 3));
      free(v4);
      ERR_put_error(6, 0LL, 6, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 180);
      return 0LL;
    }
  }
  return v4;
}

//----- (00000000000588C4) ----------------------------------------------------
__int64 __fastcall X509_TRUST_get0_name(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (00000000000588CC) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_ctrl(__int64 *a1, int a2, int a3)
{
  __int64 v3; // x8
  __int64 (*v4)(void); // x6
  int v5; // w8
  int v6; // w2
  __int16 v7; // w4

  if ( !a1 || (v3 = *a1) == 0 || (v4 = *(__int64 (**)(void))(v3 + 88)) == 0LL )
  {
    v6 = 101;
    v7 = 192;
    goto LABEL_11;
  }
  if ( a2 != -1 && *(_DWORD *)v3 != a2 )
  {
    v6 = 125;
    v7 = 196;
    goto LABEL_11;
  }
  v5 = *((_DWORD *)a1 + 8);
  if ( !v5 )
  {
    v6 = 123;
    v7 = 201;
    goto LABEL_11;
  }
  if ( a3 != -1 && !(v5 & a3) )
  {
    v6 = 114;
    v7 = 206;
LABEL_11:
    ERR_put_error(6, 0LL, v6, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v7);
    return 0LL;
  }
  return v4();
}

//----- (0000000000058998) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_sign_init(_DWORD *a1)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 40LL) )
  {
    a1[8] = 8;
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 125, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 215);
    result = 0LL;
  }
  return result;
}

//----- (00000000000589EC) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_sign(_DWORD *a1)
{
  __int64 (*v1)(void); // x5
  int v3; // w2
  __int16 v4; // w4

  if ( a1 && *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 40LL)) != 0LL )
  {
    if ( a1[8] == 8 )
      return v1();
    v3 = 126;
    v4 = 230;
  }
  else
  {
    v3 = 125;
    v4 = 226;
  }
  ERR_put_error(6, 0LL, v3, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

//----- (0000000000058A5C) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_verify_init(_DWORD *a1)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 48LL) )
  {
    a1[8] = 16;
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 125, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 238);
    result = 0LL;
  }
  return result;
}

//----- (0000000000058AB0) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_verify(_DWORD *a1)
{
  __int64 (*v1)(void); // x5
  int v3; // w2
  __int16 v4; // w4

  if ( a1 && *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 48LL)) != 0LL )
  {
    if ( a1[8] == 16 )
      return v1();
    v3 = 126;
    v4 = 252;
  }
  else
  {
    v3 = 125;
    v4 = 248;
  }
  ERR_put_error(6, 0LL, v3, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

//----- (0000000000058B20) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_encrypt_init(_DWORD *a1)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 64LL) )
  {
    a1[8] = 64;
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 125, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 260);
    result = 0LL;
  }
  return result;
}

//----- (0000000000058B74) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_encrypt(_DWORD *a1)
{
  __int64 (*v1)(void); // x5
  int v3; // w2
  __int16 v4; // w4

  if ( a1 && *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 64LL)) != 0LL )
  {
    if ( a1[8] == 64 )
      return v1();
    v3 = 126;
    v4 = 274;
  }
  else
  {
    v3 = 125;
    v4 = 270;
  }
  ERR_put_error(6, 0LL, v3, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

//----- (0000000000058BE4) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_decrypt_init(_DWORD *a1)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 72LL) )
  {
    a1[8] = 128;
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 125, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 282);
    result = 0LL;
  }
  return result;
}

//----- (0000000000058C38) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_decrypt(_DWORD *a1)
{
  __int64 (*v1)(void); // x5
  int v3; // w2
  __int16 v4; // w4

  if ( a1 && *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 72LL)) != 0LL )
  {
    if ( a1[8] == 128 )
      return v1();
    v3 = 126;
    v4 = 296;
  }
  else
  {
    v3 = 125;
    v4 = 292;
  }
  ERR_put_error(6, 0LL, v3, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

//----- (0000000000058CA8) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_verify_recover_init(_DWORD *a1)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 56LL) )
  {
    a1[8] = 32;
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 125, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 304);
    result = 0LL;
  }
  return result;
}

//----- (0000000000058CFC) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_verify_recover(_DWORD *a1)
{
  __int64 (*v1)(void); // x5
  int v3; // w2
  __int16 v4; // w4

  if ( a1 && *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 56LL)) != 0LL )
  {
    if ( a1[8] == 32 )
      return v1();
    v3 = 126;
    v4 = 318;
  }
  else
  {
    v3 = 125;
    v4 = 314;
  }
  ERR_put_error(6, 0LL, v3, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

//----- (0000000000058D6C) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_derive_init(_DWORD *a1)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 80LL) )
  {
    a1[8] = 256;
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 125, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 326);
    result = 0LL;
  }
  return result;
}

//----- (0000000000058DC0) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_derive_set_peer(__int64 *a1, _DWORD *a2)
{
  _DWORD *v2; // x19
  __int64 *v3; // x20
  _QWORD *v4; // x8
  __int64 (*v5)(void); // x8
  int v6; // w9
  signed int v7; // w0
  signed __int64 result; // x0
  int v9; // w2
  __int16 v10; // w4
  __int64 v11; // x8
  __int64 v12; // x8

  v2 = a2;
  v3 = a1;
  if ( !a1 || (v4 = (_QWORD *)*a1) == 0LL || !v4[10] && !v4[8] && !v4[9] || (v5 = (__int64 (*)(void))v4[11]) == 0LL )
  {
    v9 = 125;
    v10 = 338;
LABEL_14:
    ERR_put_error(6, 0LL, v9, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v10);
    return 0LL;
  }
  v6 = *((_DWORD *)a1 + 8);
  if ( v6 != 64 && v6 != 128 && v6 != 256 )
  {
    v9 = 126;
    v10 = 344;
    goto LABEL_14;
  }
  v7 = v5();
  if ( v7 < 1 )
    return 0LL;
  if ( v7 == 2 )
    return 1LL;
  v11 = v3[2];
  if ( !v11 )
  {
    v9 = 120;
    v10 = 359;
    goto LABEL_14;
  }
  if ( *(_DWORD *)(v11 + 4) != v2[1] )
  {
    v9 = 103;
    v10 = 364;
    goto LABEL_14;
  }
  if ( !(unsigned int)EVP_PKEY_missing_parameters((__int64)v2)
    && !(unsigned int)EVP_PKEY_cmp_parameters(v3[2], (__int64)v2) )
  {
    v9 = 104;
    v10 = 375;
    goto LABEL_14;
  }
  EVP_PKEY_free((int *)v3[3]);
  v12 = *v3;
  v3[3] = (__int64)v2;
  if ( (*(signed int (__fastcall **)(__int64 *, signed __int64, signed __int64, _DWORD *))(v12 + 88))(v3, 3LL, 1LL, v2) > 0 )
  {
    EVP_PKEY_up_ref(v2);
    return 1LL;
  }
  result = 0LL;
  v3[3] = 0LL;
  return result;
}

//----- (0000000000058F50) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_derive(_DWORD *a1)
{
  __int64 (*v1)(void); // x3
  int v3; // w2
  __int16 v4; // w4

  if ( a1 && *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 80LL)) != 0LL )
  {
    if ( a1[8] == 256 )
      return v1();
    v3 = 126;
    v4 = 399;
  }
  else
  {
    v3 = 125;
    v4 = 395;
  }
  ERR_put_error(6, 0LL, v3, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v4);
  return 0LL;
}

//----- (0000000000058FC0) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_keygen_init(_DWORD *a1)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 && *(_QWORD *)(*(_QWORD *)a1 + 32LL) )
  {
    a1[8] = 4;
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 125, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", 407);
    result = 0LL;
  }
  return result;
}

//----- (0000000000059014) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_keygen(_DWORD *a1, int **a2)
{
  int **v2; // x19
  _DWORD *v3; // x20
  unsigned int (__fastcall *v4)(_DWORD *); // x8
  char *v5; // x1
  signed __int64 result; // x0
  int v7; // w2
  __int16 v8; // w4

  v2 = a2;
  v3 = a1;
  if ( !a1 || !*(_QWORD *)a1 || (v4 = *(unsigned int (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 32LL)) == 0LL )
  {
    v7 = 125;
    v8 = 416;
LABEL_12:
    ERR_put_error(6, 0LL, v7, (__int64)"external/boringssl/src/crypto/evp/evp_ctx.c", v8);
    return 0LL;
  }
  if ( a1[8] != 4 )
  {
    v7 = 126;
    v8 = 420;
    goto LABEL_12;
  }
  if ( !a2 )
    return 0LL;
  if ( *a2 )
    goto LABEL_9;
  v5 = EVP_PKEY_new();
  *v2 = (int *)v5;
  if ( !v5 )
  {
    v7 = 6;
    v8 = 431;
    goto LABEL_12;
  }
  v4 = *(unsigned int (__fastcall **)(_DWORD *))(*(_QWORD *)v3 + 32LL);
LABEL_9:
  if ( v4(v3) )
    return 1LL;
  EVP_PKEY_free(*v2);
  result = 0LL;
  *v2 = 0LL;
  return result;
}

//----- (00000000000590F0) ----------------------------------------------------
signed __int64 __fastcall sub_590F0(__int64 a1, __int64 a2, unsigned __int8 **a3)
{
  unsigned __int8 **v3; // x22
  __int64 v4; // x20
  unsigned __int8 **v5; // x21
  char *v6; // x0
  char *v7; // x19
  __int16 v8; // w4
  _QWORD *v9; // x8

  v3 = (unsigned __int8 **)a2;
  v4 = a1;
  v5 = a3;
  if ( EVP_CIPHER_CTX_get_app_data(a2) )
  {
    DSA_parse_parameters(v3);
    v7 = v6;
    if ( !v6 || EVP_CIPHER_CTX_get_app_data((__int64)v3) )
    {
      v8 = 80;
LABEL_10:
      ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_dsa_asn1.c", v8);
      goto LABEL_11;
    }
  }
  else
  {
    v7 = DSA_new();
    if ( !v7 )
      return 0LL;
  }
  v9 = BN_new();
  *((_QWORD *)v7 + 4) = v9;
  if ( !v9 )
  {
LABEL_11:
    DSA_free((__int64)v7);
    return 0LL;
  }
  if ( !BN_parse_asn1_unsigned(v5, (__int64)v9) || EVP_CIPHER_CTX_get_app_data((__int64)v5) )
  {
    v8 = 92;
    goto LABEL_10;
  }
  EVP_PKEY_assign_DSA(v4, (__int64)v7);
  return 1LL;
}

//----- (00000000000591D0) ----------------------------------------------------
signed __int64 __fastcall sub_591D0(__int64 *a1, __int64 a2)
{
  __int64 *v2; // x19
  _QWORD *v3; // x20
  _BOOL4 v4; // w21
  signed __int64 result; // x0
  char v6; // [xsp+8h] [xbp-A8h]
  char **v7[4]; // [xsp+28h] [xbp-88h]
  char v8; // [xsp+48h] [xbp-68h]
  char v9; // [xsp+68h] [xbp-48h]
  __int64 v10; // [xsp+88h] [xbp-28h]

  v2 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *(_QWORD **)(a2 + 8);
  if ( v3[1] && v3[2] )
    v4 = v3[3] != 0LL;
  else
    v4 = 0;
  if ( (unsigned int)CBB_add_asn1(a1, (__int64 *)&v9, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)&v8, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v8, (__int64 *)v7, 6u)
    && (unsigned int)CBB_add_bytes(v7, &unk_F70FC, 7uLL)
    && (!v4 || (unsigned int)DSA_marshal_parameters((__int64 *)&v8, v3))
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)&v6, 3u)
    && (unsigned int)CBB_add_u8((__int64 *)&v6, 0)
    && (unsigned int)BN_marshal_asn1((__int64 *)&v6, v3[4])
    && (unsigned int)CBB_flush(v2) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 105, (__int64)"external/boringssl/src/crypto/evp/p_dsa_asn1.c", 120);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005931C) ----------------------------------------------------
bool __fastcall sub_5931C(__int64 a1, __int64 a2)
{
  return (unsigned int)BN_cmp(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 32LL), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL)) == 0;
}

//----- (0000000000059348) ----------------------------------------------------
signed __int64 __fastcall sub_59348(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3)
{
  __int64 v3; // x22
  __int64 v4; // x20
  unsigned __int8 **v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x19
  __int16 v8; // w4
  _DWORD *v9; // x22
  _QWORD *v11; // x0
  __int64 v12; // x1
  int v13; // w0

  v3 = (__int64)a2;
  v4 = a1;
  v5 = a3;
  DSA_parse_parameters(a2);
  v7 = v6;
  if ( !v6 || EVP_CIPHER_CTX_get_app_data(v3) )
  {
    v8 = 134;
LABEL_4:
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_dsa_asn1.c", v8);
    v9 = 0LL;
LABEL_5:
    BN_CTX_free((__int64)v9);
    DSA_free((__int64)v7);
    return 0LL;
  }
  v7[5] = (__int64)BN_new();
  v11 = BN_new();
  v9 = 0LL;
  v7[4] = (__int64)v11;
  if ( !v11 )
    goto LABEL_5;
  v12 = v7[5];
  if ( !v12 )
    goto LABEL_5;
  if ( !BN_parse_asn1_unsigned(v5, v12) || EVP_CIPHER_CTX_get_app_data((__int64)v5) )
  {
    v8 = 147;
    goto LABEL_4;
  }
  v9 = BN_CTX_new();
  if ( !v9 )
    goto LABEL_5;
  BN_mod_exp_mont(v7[4], v7[3], v7[5], v7[1], (__int64)v9, 0LL);
  if ( !v13 )
    goto LABEL_5;
  BN_CTX_free((__int64)v9);
  EVP_PKEY_assign_DSA(v4, (__int64)v7);
  return 1LL;
}

//----- (0000000000059458) ----------------------------------------------------
signed __int64 __fastcall sub_59458(__int64 *a1, __int64 a2)
{
  __int64 *v2; // x19
  _QWORD *v3; // x20
  signed __int64 result; // x0
  int v5; // w2
  __int16 v6; // w4
  char v7; // [xsp+8h] [xbp-98h]
  char **v8[4]; // [xsp+28h] [xbp-78h]
  char v9; // [xsp+48h] [xbp-58h]
  char v10; // [xsp+68h] [xbp-38h]
  __int64 v11; // [xsp+88h] [xbp-18h]

  v2 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *(_QWORD **)(a2 + 8);
  if ( !v3 || !v3[5] )
  {
    v5 = 118;
    v6 = 172;
LABEL_15:
    ERR_put_error(6, 0LL, v5, (__int64)"external/boringssl/src/crypto/evp/p_dsa_asn1.c", v6);
    result = 0LL;
    goto LABEL_16;
  }
  if ( !(unsigned int)CBB_add_asn1(a1, (__int64 *)&v10, 0x30u)
    || !(unsigned int)CBB_add_asn1_uint64((__int64 *)&v10, 0LL)
    || !(unsigned int)CBB_add_asn1((__int64 *)&v10, (__int64 *)&v9, 0x30u)
    || !(unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)v8, 6u)
    || !(unsigned int)CBB_add_bytes(v8, &unk_F70FC, 7uLL)
    || !(unsigned int)DSA_marshal_parameters((__int64 *)&v9, v3)
    || !(unsigned int)CBB_add_asn1((__int64 *)&v10, (__int64 *)&v7, 4u)
    || !(unsigned int)BN_marshal_asn1((__int64 *)&v7, v3[5])
    || !(unsigned int)CBB_flush(v2) )
  {
    v5 = 105;
    v6 = 187;
    goto LABEL_15;
  }
  result = 1LL;
LABEL_16:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000059598) ----------------------------------------------------
__int64 __fastcall sub_59598(__int64 a1)
{
  return DSA_size(*(_QWORD *)(a1 + 8));
}

//----- (00000000000595A0) ----------------------------------------------------
__int64 __fastcall sub_595A0(__int64 a1)
{
  return BN_num_bits(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL));
}

//----- (00000000000595AC) ----------------------------------------------------
bool __fastcall sub_595AC(__int64 a1)
{
  _QWORD *v1; // x8
  _BOOL8 result; // x0

  v1 = *(_QWORD **)(a1 + 8);
  if ( v1[1] && v1[2] )
    result = v1[3] == 0LL;
  else
    result = 1LL;
  return result;
}

//----- (00000000000595D8) ----------------------------------------------------
signed __int64 __fastcall sub_595D8(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x22
  signed int *v5; // x21
  __int64 v6; // x22
  signed int *v7; // x21
  __int64 v8; // x20
  signed int *v9; // x19
  signed __int64 result; // x0

  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = BN_dup(*(signed int **)(*(_QWORD *)(a2 + 8) + 8LL));
  if ( !v5 )
    return 0LL;
  BN_free(*(_DWORD **)(v4 + 8));
  *(_QWORD *)(v4 + 8) = v5;
  v6 = *(_QWORD *)(v3 + 8);
  v7 = BN_dup(*(signed int **)(*(_QWORD *)(v2 + 8) + 16LL));
  if ( !v7 )
    return 0LL;
  BN_free(*(_DWORD **)(v6 + 16));
  *(_QWORD *)(v6 + 16) = v7;
  v8 = *(_QWORD *)(v3 + 8);
  v9 = BN_dup(*(signed int **)(*(_QWORD *)(v2 + 8) + 24LL));
  if ( !v9 )
    return 0LL;
  BN_free(*(_DWORD **)(v8 + 24));
  result = 1LL;
  *(_QWORD *)(v8 + 24) = v9;
  return result;
}

//----- (0000000000059678) ----------------------------------------------------
bool __fastcall sub_59678(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20

  v2 = a2;
  v3 = a1;
  if ( (unsigned int)BN_cmp(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL), *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8LL)) )
    return 0LL;
  if ( (unsigned int)BN_cmp(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 16LL), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 16LL)) )
    return 0LL;
  return (unsigned int)BN_cmp(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 24LL), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 24LL)) == 0;
}

//----- (00000000000596F4) ----------------------------------------------------
void __fastcall sub_596F4(__int64 a1)
{
  DSA_free(*(_QWORD *)(a1 + 8));
}

//----- (00000000000596FC) ----------------------------------------------------
_QWORD *__fastcall sub_596FC(__int64 a1)
{
  __int64 v1; // x19
  _QWORD *result; // x0

  v1 = a1;
  result = malloc(8uLL);
  if ( result )
  {
    *result = 0LL;
    *(_QWORD *)(v1 + 40) = result;
    result = (_QWORD *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000059730) ----------------------------------------------------
_QWORD *__fastcall sub_59730(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  _QWORD *result; // x0

  v2 = a1;
  v3 = a2;
  result = malloc(8uLL);
  if ( result )
  {
    *result = 0LL;
    *(_QWORD *)(v2 + 40) = result;
    *result = **(_QWORD **)(v3 + 40);
    result = (_QWORD *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000059774) ----------------------------------------------------
void __fastcall sub_59774(__int64 a1)
{
  void *v1; // x0

  v1 = *(void **)(a1 + 40);
  if ( v1 )
    free(v1);
}

//----- (0000000000059784) ----------------------------------------------------
signed __int64 __fastcall sub_59784(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v3; // x19
  __int64 *v4; // x20
  _QWORD **v5; // x0

  v2 = a1;
  v3 = a2;
  if ( *(_QWORD *)(a1 + 16) )
  {
    v4 = EC_KEY_new();
    if ( v4 )
    {
      v5 = (_QWORD **)lh_num_items(*(_QWORD *)(*(_QWORD *)(v2 + 16) + 8LL));
      if ( (unsigned int)EC_KEY_set_group(v4, v5) )
      {
        if ( (unsigned int)EC_KEY_generate_key(v4) )
        {
          EVP_PKEY_assign_EC_KEY(v3, (__int64)v4);
          return 1LL;
        }
      }
    }
    EC_KEY_free((__int64)v4);
  }
  else
  {
    ERR_put_error(6, 0LL, 124, (__int64)"external/boringssl/src/crypto/evp/p_ec.c", 210);
  }
  return 0LL;
}

//----- (0000000000059828) ----------------------------------------------------
void __fastcall sub_59828(__int64 a1, __int64 a2, __int64 *a3, unsigned __int8 *a4, size_t a5)
{
  size_t v5; // x20
  unsigned __int8 *v6; // x21
  __int64 *v7; // x19
  __int64 v8; // x8
  __int64 v9; // x23
  __int64 v10; // x22
  unsigned __int64 v11; // x24
  int v12; // w0
  unsigned int v13; // [xsp+4h] [xbp-3Ch]
  __int64 v14; // [xsp+8h] [xbp-38h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *(_QWORD *)(a1 + 16);
  v9 = a2;
  v10 = *(_QWORD *)(v8 + 8);
  if ( a2 )
  {
    v11 = *a3;
    if ( v11 >= ECDSA_size(*(_QWORD *)(v8 + 8)) )
    {
      ECDSA_sign(0LL, v6, v5, v9, (int *)&v13, v10);
      if ( v12 )
        *v7 = v13;
    }
    else
    {
      ERR_put_error(6, 0LL, 100, (__int64)"external/boringssl/src/crypto/evp/p_ec.c", 126);
    }
  }
  else
  {
    *a3 = ECDSA_size(*(_QWORD *)(v8 + 8));
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005990C) ----------------------------------------------------
void __fastcall sub_5990C(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4, __int64 a5)
{
  ECDSA_verify(0LL, a4, a5, a2, a3, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8LL));
}

//----- (0000000000059934) ----------------------------------------------------
signed __int64 __fastcall sub_59934(__int64 a1, void *a2, unsigned __int64 *a3)
{
  __int64 v3; // x9
  unsigned __int64 *v4; // x19
  void *v5; // x20
  __int64 v6; // x8
  __int64 v7; // x21
  _QWORD *v8; // x0
  int v9; // w0
  unsigned __int64 v10; // x8
  signed __int64 result; // x0
  __int64 v12; // x0

  v3 = *(_QWORD *)(a1 + 16);
  v4 = a3;
  v5 = a2;
  if ( !v3 || (v6 = *(_QWORD *)(a1 + 24)) == 0 )
  {
    ERR_put_error(6, 0LL, 117, (__int64)"external/boringssl/src/crypto/evp/p_ec.c", 150);
    return 0LL;
  }
  v7 = *(_QWORD *)(v3 + 8);
  if ( !a2 )
  {
    v12 = lh_num_items(*(_QWORD *)(v3 + 8));
    v10 = ((unsigned int)EC_GROUP_get_degree(v12) + 7) >> 3;
    goto LABEL_9;
  }
  v8 = (_QWORD *)EVP_CIPHER_CTX_get_app_data(*(_QWORD *)(v6 + 8));
  ECDH_compute_key(v5, *v4, v8, v7, 0LL);
  if ( v9 & 0x80000000 )
    return 0LL;
  v10 = v9;
LABEL_9:
  result = 1LL;
  *v4 = v10;
  return result;
}
// 73338: using guessed type __int64 __fastcall EC_GROUP_get_degree(_QWORD);

//----- (00000000000599E0) ----------------------------------------------------
signed __int64 __fastcall sub_599E0(__int64 a1, int a2, __int64 a3, unsigned int *a4)
{
  unsigned int *v4; // x19
  unsigned int **v5; // x20
  signed __int64 result; // x0
  int v7; // w2
  __int16 v8; // w4

  v4 = a4;
  if ( a2 == 3 )
    return 1LL;
  v5 = *(unsigned int ***)(a1 + 40);
  if ( a2 == 2 )
  {
    result = 1LL;
    *(_QWORD *)a4 = *v5;
  }
  else
  {
    if ( a2 == 1 )
    {
      if ( (unsigned int)X509_TRUST_get_trust(a4) == 64
        || (unsigned int)X509_TRUST_get_trust(v4) == 416
        || (unsigned int)X509_TRUST_get_trust(v4) == 675
        || (unsigned int)X509_TRUST_get_trust(v4) == 672
        || (unsigned int)X509_TRUST_get_trust(v4) == 673
        || (unsigned int)X509_TRUST_get_trust(v4) == 674 )
      {
        *v5 = v4;
        return 1LL;
      }
      v7 = 111;
      v8 = 188;
    }
    else
    {
      v7 = 101;
      v8 = 203;
    }
    ERR_put_error(6, 0LL, v7, (__int64)"external/boringssl/src/crypto/evp/p_ec.c", v8);
    result = 0LL;
  }
  return result;
}

//----- (0000000000059ACC) ----------------------------------------------------
signed __int64 __fastcall sub_59ACC(__int64 a1, unsigned __int8 **a2, __int64 a3)
{
  __int64 v3; // x20
  __int64 v4; // x21
  __int64 v5; // x23
  _QWORD *v6; // x19
  _QWORD *v7; // x22
  __int64 v8; // x20
  __int64 *v10; // x0
  unsigned __int8 *v11; // x24
  __int64 v12; // x0

  v3 = (__int64)a2;
  v4 = a1;
  v5 = a3;
  v6 = EC_KEY_parse_curve_name(a2);
  if ( !v6 || EVP_CIPHER_CTX_get_app_data(v3) )
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_ec_asn1.c", 100);
    v7 = 0LL;
    v8 = 0LL;
LABEL_4:
    EC_GROUP_free((__int64)v6);
    EC_POINT_free((__int64)v7);
    EC_KEY_free(v8);
    return 0LL;
  }
  v10 = EC_KEY_new();
  v8 = (__int64)v10;
  if ( !v10 || !(unsigned int)EC_KEY_set_group(v10, (_QWORD **)v6) )
  {
    v7 = 0LL;
    goto LABEL_4;
  }
  v7 = EC_POINT_new(v6);
  if ( !v7 )
    goto LABEL_4;
  v11 = (unsigned __int8 *)lh_num_items(v5);
  v12 = EVP_CIPHER_CTX_get_app_data(v5);
  if ( !(unsigned int)EC_POINT_oct2point(v6, v7, v11, v12, 0LL) || !EC_KEY_set_public_key(v8, v7) )
    goto LABEL_4;
  EC_GROUP_free((__int64)v6);
  EC_POINT_free((__int64)v7);
  EVP_PKEY_assign_EC_KEY(v4, v8);
  return 1LL;
}

//----- (0000000000059BF4) ----------------------------------------------------
signed __int64 __fastcall sub_59BF4(__int64 *a1, __int64 a2)
{
  __int64 *v2; // x19
  __int64 v3; // x21
  _QWORD *v4; // x20
  _QWORD *v5; // x21
  signed __int64 result; // x0
  char v7; // [xsp+8h] [xbp-A8h]
  char **v8[4]; // [xsp+28h] [xbp-88h]
  char v9; // [xsp+48h] [xbp-68h]
  char v10; // [xsp+68h] [xbp-48h]
  __int64 v11; // [xsp+88h] [xbp-28h]

  v2 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = (_QWORD *)lh_num_items(*(_QWORD *)(a2 + 8));
  v5 = (_QWORD *)EVP_CIPHER_CTX_get_app_data(v3);
  if ( (unsigned int)CBB_add_asn1(v2, (__int64 *)&v10, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v10, (__int64 *)&v9, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)v8, 6u)
    && (unsigned int)CBB_add_bytes(v8, &unk_F71D4, 7uLL)
    && (unsigned int)EC_KEY_marshal_curve_name((__int64 *)&v9, (__int64)v4)
    && (unsigned int)CBB_add_asn1((__int64 *)&v10, (__int64 *)&v7, 3u)
    && (unsigned int)CBB_add_u8((__int64 *)&v7, 0)
    && (unsigned int)EC_POINT_point2cbb((__int64 *)&v7, v4, v5, 4, 0LL)
    && (unsigned int)CBB_flush(v2) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 105, (__int64)"external/boringssl/src/crypto/evp/p_ec_asn1.c", 85);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000059D3C) ----------------------------------------------------
signed __int64 __fastcall sub_59D3C(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x0
  __int64 v5; // x8
  _QWORD *v6; // x20
  __int64 v7; // x0
  __int64 v8; // x8
  _QWORD *v9; // x19
  _QWORD *v10; // x0
  int v11; // w0
  unsigned int v12; // w8
  signed __int64 result; // x0

  v2 = a2;
  v3 = a1;
  v4 = lh_num_items(*(_QWORD *)(a2 + 8));
  v5 = *(_QWORD *)(v3 + 8);
  v6 = (_QWORD *)v4;
  v7 = EVP_CIPHER_CTX_get_app_data(v5);
  v8 = *(_QWORD *)(v2 + 8);
  v9 = (_QWORD *)v7;
  v10 = (_QWORD *)EVP_CIPHER_CTX_get_app_data(v8);
  v11 = EC_POINT_cmp(v6, v9, v10, 0LL);
  if ( v11 == 1 )
    v12 = 0;
  else
    v12 = -2;
  if ( v11 )
    result = v12;
  else
    result = 1LL;
  return result;
}

//----- (0000000000059DB0) ----------------------------------------------------
signed __int64 __fastcall sub_59DB0(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3)
{
  __int64 v3; // x22
  __int64 v4; // x19
  unsigned __int8 **v5; // x21
  _QWORD *v6; // x20
  __int64 v8; // x0
  __int64 v9; // x22

  v3 = (__int64)a2;
  v4 = a1;
  v5 = a3;
  v6 = EC_KEY_parse_parameters(a2);
  if ( !v6 || EVP_CIPHER_CTX_get_app_data(v3) )
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_ec_asn1.c", 147);
    EC_GROUP_free((__int64)v6);
    return 0LL;
  }
  EC_KEY_parse_private_key(v5, (__int64)v6);
  v9 = v8;
  EC_GROUP_free((__int64)v6);
  if ( !v9 || EVP_CIPHER_CTX_get_app_data((__int64)v5) )
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_ec_asn1.c", 155);
    EC_KEY_free(v9);
    return 0LL;
  }
  EVP_PKEY_assign_EC_KEY(v4, v9);
  return 1LL;
}

//----- (0000000000059E84) ----------------------------------------------------
signed __int64 __fastcall sub_59E84(__int64 *a1, __int64 a2)
{
  __int64 *v2; // x19
  _QWORD *v3; // x20
  char v4; // w21
  __int64 v5; // x0
  signed __int64 result; // x0
  char v7; // [xsp+8h] [xbp-A8h]
  char **v8[4]; // [xsp+28h] [xbp-88h]
  char v9; // [xsp+48h] [xbp-68h]
  char v10; // [xsp+68h] [xbp-48h]
  __int64 v11; // [xsp+88h] [xbp-28h]

  v2 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *(_QWORD **)(a2 + 8);
  v4 = EVP_CIPHER_CTX_key_length(*(_QWORD *)(a2 + 8));
  if ( (unsigned int)CBB_add_asn1(v2, (__int64 *)&v10, 0x30u)
    && (unsigned int)CBB_add_asn1_uint64((__int64 *)&v10, 0LL)
    && (unsigned int)CBB_add_asn1((__int64 *)&v10, (__int64 *)&v9, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)v8, 6u)
    && (unsigned int)CBB_add_bytes(v8, &unk_F71D4, 7uLL)
    && (v5 = lh_num_items((__int64)v3), (unsigned int)EC_KEY_marshal_curve_name((__int64 *)&v9, v5))
    && (unsigned int)CBB_add_asn1((__int64 *)&v10, (__int64 *)&v7, 4u)
    && (unsigned int)EC_KEY_marshal_private_key((__int64 *)&v7, v3, v4 | 1u)
    && (unsigned int)CBB_flush(v2) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 105, (__int64)"external/boringssl/src/crypto/evp/p_ec_asn1.c", 184);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000059FC0) ----------------------------------------------------
__int64 __fastcall sub_59FC0(__int64 a1)
{
  return EC_KEY_is_opaque(*(_QWORD *)(a1 + 8));
}

//----- (0000000000059FC8) ----------------------------------------------------
__int64 __fastcall sub_59FC8(__int64 a1)
{
  return ECDSA_size(*(_QWORD *)(a1 + 8));
}

//----- (0000000000059FE0) ----------------------------------------------------
__int64 __fastcall sub_59FE0(__int64 a1)
{
  __int64 v1; // x0
  __int64 v2; // x0
  __int64 result; // x0

  v1 = lh_num_items(*(_QWORD *)(a1 + 8));
  if ( v1 )
  {
    v2 = EC_GROUP_get0_order(v1);
    result = BN_num_bits(v2);
  }
  else
  {
    ERR_clear_error();
    result = 0LL;
  }
  return result;
}

//----- (000000000005A010) ----------------------------------------------------
bool __fastcall sub_5A010(__int64 a1)
{
  return lh_num_items(*(_QWORD *)(a1 + 8)) == 0;
}

//----- (000000000005A030) ----------------------------------------------------
__int64 __fastcall sub_5A030(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  _QWORD **v3; // x0
  _QWORD *v4; // x19
  __int64 result; // x0

  v2 = a1;
  v3 = (_QWORD **)lh_num_items(*(_QWORD *)(a2 + 8));
  v4 = EC_GROUP_dup(v3);
  if ( !v4 )
    return 0LL;
  result = EC_KEY_set_group(*(__int64 **)(v2 + 8), (_QWORD **)v4);
  if ( (_DWORD)result )
  {
    EC_GROUP_free((__int64)v4);
    result = 1LL;
  }
  return result;
}

//----- (000000000005A088) ----------------------------------------------------
bool __fastcall sub_5A088(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x0
  __int64 v4; // x8
  __int64 v5; // x19
  __int64 v6; // x0

  v2 = a2;
  v3 = lh_num_items(*(_QWORD *)(a1 + 8));
  v4 = *(_QWORD *)(v2 + 8);
  v5 = v3;
  v6 = lh_num_items(v4);
  return (unsigned int)EC_GROUP_cmp(v5, v6) == 0;
}

//----- (000000000005A0D4) ----------------------------------------------------
void __fastcall sub_5A0D4(__int64 a1)
{
  EC_KEY_free(*(_QWORD *)(a1 + 8));
}

//----- (000000000005A0DC) ----------------------------------------------------
signed __int64 __fastcall sub_5A0DC(__int64 a1)
{
  __int64 v1; // x19
  _DWORD *v2; // x0
  _DWORD *v3; // x20
  signed __int64 result; // x0

  v1 = a1;
  v2 = malloc(0x48uLL);
  v3 = v2;
  if ( !v2 )
    return 0LL;
  memset(v2 + 1, 0, 0x44uLL);
  result = 1LL;
  *v3 = 2048;
  v3[4] = 1;
  v3[10] = -2;
  *(_QWORD *)(v1 + 40) = v3;
  return result;
}

//----- (000000000005A13C) ----------------------------------------------------
void *__fastcall sub_5A13C(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v3; // x20
  char *v4; // x0
  char *v5; // x19
  __int64 v6; // x20
  signed int *v7; // x0
  void *result; // x0

  v2 = a1;
  v3 = a2;
  v4 = (char *)malloc(0x48uLL);
  v5 = v4;
  if ( !v4 )
    return 0LL;
  memset(v4 + 4, 0, 0x44uLL);
  *(_DWORD *)v5 = 2048;
  *((_DWORD *)v5 + 4) = 1;
  *((_DWORD *)v5 + 10) = -2;
  *(_QWORD *)(v2 + 40) = v5;
  v6 = *(_QWORD *)(v3 + 40);
  *(_DWORD *)v5 = *(_DWORD *)v6;
  v7 = *(signed int **)(v6 + 8);
  if ( !v7 || (result = BN_dup(v7), (*((_QWORD *)v5 + 1) = result) != 0LL) )
  {
    *((_DWORD *)v5 + 4) = *(_DWORD *)(v6 + 16);
    *((_QWORD *)v5 + 3) = *(_QWORD *)(v6 + 24);
    *((_QWORD *)v5 + 4) = *(_QWORD *)(v6 + 32);
    if ( *(_QWORD *)(v6 + 56) )
    {
      free(*((void **)v5 + 7));
      result = BUF_memdup(*(const void **)(v6 + 56), *(_QWORD *)(v6 + 64));
      *((_QWORD *)v5 + 7) = result;
      if ( !result )
        return result;
      *((_QWORD *)v5 + 8) = *(_QWORD *)(v6 + 64);
    }
    result = &dword_0 + 1;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000005A20C) ----------------------------------------------------
void __fastcall sub_5A20C(__int64 a1)
{
  __int64 v1; // x19

  v1 = *(_QWORD *)(a1 + 40);
  if ( v1 )
  {
    BN_free(*(_DWORD **)(v1 + 8));
    free(*(void **)(v1 + 48));
    free(*(void **)(v1 + 56));
    free((void *)v1);
  }
}

//----- (000000000005A254) ----------------------------------------------------
signed __int64 __fastcall sub_5A254(__int64 a1, __int64 a2)
{
  unsigned int *v2; // x21
  __int64 v3; // x19
  int *v4; // x0
  int *v5; // x20
  __int64 v6; // x1
  __int64 v7; // x2
  signed __int64 result; // x0

  v2 = *(unsigned int **)(a1 + 40);
  v3 = a2;
  if ( *((_QWORD *)v2 + 1)
    || (result = (signed __int64)BN_new(), (*((_QWORD *)v2 + 1) = result) != 0LL)
    && (result = BN_set_word(result, 65537LL), (_DWORD)result) )
  {
    v4 = (int *)RSA_new();
    v5 = v4;
    if ( v4 )
    {
      v6 = *v2;
      v7 = *((_QWORD *)v2 + 1);
      if ( (unsigned int)RSA_generate_key_ex((__int64)v4) )
      {
        EVP_PKEY_assign_RSA(v3, (__int64)v5);
        return 1LL;
      }
      RSA_free(v5);
    }
    result = 0LL;
  }
  return result;
}

//----- (000000000005A2E4) ----------------------------------------------------
void __fastcall sub_5A2E4(__int64 a1, _BYTE *a2, size_t *a3, const void *a4, size_t a5)
{
  __int64 v5; // x25
  size_t v6; // x24
  const void *v7; // x22
  __int64 v8; // x0
  __int64 v9; // x26
  size_t *v10; // x19
  _BYTE *v11; // x20
  __int64 v12; // x21
  int v13; // w0
  size_t v14; // x23
  int v15; // w2
  __int16 v16; // w4
  __int64 v17; // x0
  int v18; // w8
  unsigned int v19; // w0
  int v20; // w0
  char *v21; // x1
  int v22; // w0
  int v23; // w0
  _BOOL8 v24; // x0
  unsigned int v25; // [xsp+4h] [xbp-4Ch]
  __int64 v26; // [xsp+8h] [xbp-48h]

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(v5 + 40);
  v10 = a3;
  v11 = a2;
  v12 = *(_QWORD *)(v8 + 8);
  v13 = EVP_PKEY_size(v8);
  v14 = v13;
  if ( v11 )
  {
    if ( *v10 < v13 )
    {
      v15 = 100;
      v16 = 178;
LABEL_11:
      ERR_put_error(6, 0LL, v15, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", v16);
      goto LABEL_12;
    }
    v17 = *(_QWORD *)(v9 + 24);
    if ( v17 )
    {
      if ( X509_TRUST_get_flags(v17) != v6 )
      {
        v15 = 110;
        v16 = 186;
        goto LABEL_11;
      }
      if ( (unsigned int)X509_TRUST_get_trust(*(unsigned int **)(v9 + 24)) == 95 )
      {
        v15 = 121;
        v16 = 191;
        goto LABEL_11;
      }
      v18 = *(_DWORD *)(v9 + 16);
      if ( v18 == 6 )
      {
        v21 = *(char **)(v9 + 48);
        if ( v21
          || (v22 = EVP_PKEY_size(*(_QWORD *)(v5 + 16)), v21 = (char *)malloc(v22), (*(_QWORD *)(v9 + 48) = v21) != 0LL) )
        {
          RSA_padding_add_PKCS1_PSS_mgf1(
            v12,
            v21,
            (__int64)v7,
            *(_QWORD *)(v9 + 24),
            *(_QWORD *)(v9 + 32),
            *(_DWORD *)(v9 + 40));
          if ( v23 )
            v24 = (unsigned int)RSA_sign_raw(v12, v10, v11, *v10, *(const void **)(v9 + 48), v14, 3) != 0;
        }
      }
      else if ( v18 == 1 )
      {
        v19 = X509_TRUST_get_trust(*(unsigned int **)(v9 + 24));
        RSA_sign(v19, v7, v6, v11, &v25, v12);
        if ( v20 )
          *v10 = v25;
      }
    }
    else
    {
      RSA_sign_raw(v12, v10, v11, *v10, v7, v6, *(_DWORD *)(v9 + 16));
    }
  }
  else
  {
    *v10 = v13;
  }
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v26;
}

//----- (000000000005A4C8) ----------------------------------------------------
void __fastcall sub_5A4C8(__int64 a1, unsigned __int8 *a2, size_t a3, const void *a4, size_t a5)
{
  __int64 v5; // x25
  size_t v6; // x23
  const void *v7; // x19
  __int64 v8; // x0
  __int64 v9; // x26
  size_t v10; // x20
  unsigned __int8 *v11; // x22
  _QWORD *v12; // x21
  unsigned __int64 v13; // x24
  int v14; // w9
  signed int v15; // w0
  _BYTE *v16; // x2
  int v17; // w0
  _BOOL8 v18; // x0
  _BYTE *v19; // x2
  int v20; // w0
  _BOOL8 v21; // x0
  __int64 v22; // [xsp+0h] [xbp-50h]
  __int64 v23; // [xsp+8h] [xbp-48h]

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v23 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(v5 + 40);
  v10 = a3;
  v11 = a2;
  v12 = *(_QWORD **)(v8 + 8);
  v13 = (signed int)EVP_PKEY_size(v8);
  if ( *(_QWORD *)(v9 + 24) )
  {
    v14 = *(_DWORD *)(v9 + 16);
    if ( v14 == 6 )
    {
      if ( X509_TRUST_get_flags(*(_QWORD *)(v9 + 24)) == v6 )
      {
        v19 = *(_BYTE **)(v9 + 48);
        if ( v19 || (v20 = EVP_PKEY_size(*(_QWORD *)(v5 + 16)), v19 = malloc(v20), (*(_QWORD *)(v9 + 48) = v19) != 0LL) )
        {
          if ( (unsigned int)RSA_verify_raw((__int64)v12, &v22, v19, v13, v11, v10, 3) )
            v21 = (unsigned int)RSA_verify_PKCS1_PSS_mgf1(
                                  (__int64)v12,
                                  (__int64)v7,
                                  *(_QWORD *)(v9 + 24),
                                  *(_QWORD *)(v9 + 32),
                                  *(unsigned __int8 **)(v9 + 48),
                                  *(_DWORD *)(v9 + 40)) != 0;
        }
      }
      else
      {
        ERR_put_error(6, 0LL, 110, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", 236);
      }
    }
    else if ( v14 == 1 )
    {
      v15 = X509_TRUST_get_trust(*(unsigned int **)(v9 + 24));
      RSA_verify(v15, v7, v6, v11, v10, v12);
    }
  }
  else
  {
    v16 = *(_BYTE **)(v9 + 48);
    if ( v16 || (v17 = EVP_PKEY_size(*(_QWORD *)(v5 + 16)), v16 = malloc(v17), (*(_QWORD *)(v9 + 48) = v16) != 0LL) )
    {
      if ( (unsigned int)RSA_verify_raw((__int64)v12, &v22, v16, v13, v11, v10, *(_DWORD *)(v9 + 16)) && v22 == v6 )
        v18 = (unsigned int)CRYPTO_memcmp((__int64)v7, *(_QWORD *)(v9 + 48), v6) == 0;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005A698) ----------------------------------------------------
signed __int64 __fastcall sub_5A698(__int64 a1, void *a2, size_t *a3, unsigned __int8 *a4, size_t a5)
{
  __int64 v5; // x25
  size_t v6; // x21
  unsigned __int8 *v7; // x22
  __int64 v8; // x0
  __int64 v9; // x26
  size_t *v10; // x19
  void *v11; // x20
  __int64 v12; // x23
  int v13; // w0
  unsigned __int64 v14; // x24
  signed __int64 result; // x0
  _BYTE *v16; // x8
  int v17; // w0
  unsigned int *v18; // x0
  int v19; // w4
  signed int v20; // w0
  signed int v21; // w21
  size_t v22; // x21
  int v23; // w0
  unsigned __int64 v24; // [xsp+8h] [xbp-68h]
  int v25; // [xsp+14h] [xbp-5Ch]
  unsigned __int64 v26; // [xsp+18h] [xbp-58h]
  void *v27; // [xsp+20h] [xbp-50h]
  __int64 v28; // [xsp+28h] [xbp-48h]

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(v5 + 40);
  v10 = a3;
  v11 = a2;
  v12 = *(_QWORD *)(v8 + 8);
  v13 = EVP_PKEY_size(v8);
  v14 = v13;
  if ( !v11 )
  {
    *v10 = v13;
LABEL_5:
    result = 1LL;
    goto LABEL_25;
  }
  if ( *v10 >= v13 )
  {
    v16 = *(_BYTE **)(v9 + 48);
    if ( !v16 )
    {
      v17 = EVP_PKEY_size(*(_QWORD *)(v5 + 16));
      v16 = malloc(v17);
      *(_QWORD *)(v9 + 48) = v16;
      if ( !v16 )
        goto LABEL_24;
    }
    v18 = *(unsigned int **)(v9 + 24);
    v19 = *(_DWORD *)(v9 + 16);
    if ( !v18 )
    {
      v23 = RSA_public_decrypt(v6, v7, v16, *(_QWORD *)(*(_QWORD *)(v5 + 16) + 8LL), v19);
      if ( !(v23 & 0x80000000) )
      {
        *v10 = v23;
        if ( v23 )
          memcpy(v11, *(const void **)(v9 + 48), v23);
        goto LABEL_5;
      }
      goto LABEL_24;
    }
    if ( v19 != 1 )
      goto LABEL_24;
    v20 = X509_TRUST_get_trust(v18);
    result = RSA_add_pkcs1_prefix(&v27, &v26, &v25, v20, 0LL, 0LL);
    if ( !(_DWORD)result )
      goto LABEL_25;
    if ( (unsigned int)RSA_verify_raw(v12, &v24, *(_BYTE **)(v9 + 48), v14, v7, v6, 1)
      && v24 >= v26
      && !(unsigned int)CRYPTO_memcmp(*(_QWORD *)(v9 + 48), (__int64)v27, v26) )
    {
      v21 = 1;
      if ( !v25 )
        goto LABEL_16;
    }
    else
    {
      v21 = 0;
      if ( !v25 )
      {
LABEL_16:
        if ( v21 )
        {
          v22 = v24 - v26;
          if ( v22 == X509_TRUST_get_flags(*(_QWORD *)(v9 + 24)) )
          {
            if ( v22 )
              memcpy(v11, (const void *)(*(_QWORD *)(v9 + 48) + v26), v22);
            *v10 = v22;
            goto LABEL_5;
          }
        }
LABEL_24:
        result = 0LL;
        goto LABEL_25;
      }
    }
    free(v27);
    goto LABEL_16;
  }
  ERR_put_error(6, 0LL, 100, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", 278);
  result = 0LL;
LABEL_25:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v28;
  return result;
}

//----- (000000000005A8A0) ----------------------------------------------------
void __fastcall sub_5A8A0(__int64 a1, _BYTE *a2, size_t *a3, const void *a4, size_t a5)
{
  __int64 v5; // x25
  __int64 v6; // x0
  __int64 v7; // x26
  size_t v8; // x23
  const void *v9; // x24
  __int64 v10; // x21
  size_t *v11; // x19
  _BYTE *v12; // x20
  int v13; // w0
  unsigned __int64 v14; // x22
  int v15; // w6
  _BYTE *v16; // x0
  int v17; // w0
  int v18; // w0
  _BOOL8 v19; // x0

  v5 = a1;
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(v5 + 40);
  v8 = a5;
  v9 = a4;
  v10 = *(_QWORD *)(v6 + 8);
  v11 = a3;
  v12 = a2;
  v13 = EVP_PKEY_size(v6);
  v14 = v13;
  if ( v12 )
  {
    if ( *v11 >= v13 )
    {
      v15 = *(_DWORD *)(v7 + 16);
      if ( v15 == 4 )
      {
        v16 = *(_BYTE **)(v7 + 48);
        if ( v16 || (v17 = EVP_PKEY_size(*(_QWORD *)(v5 + 16)), v16 = malloc(v17), (*(_QWORD *)(v7 + 48) = v16) != 0LL) )
        {
          RSA_padding_add_PKCS1_OAEP_mgf1(
            v16,
            v14,
            v9,
            v8,
            *(_QWORD *)(v7 + 56),
            *(_QWORD *)(v7 + 64),
            *(void **)(v7 + 24),
            *(_QWORD *)(v7 + 32));
          if ( v18 )
            v19 = (unsigned int)RSA_encrypt(v10, v11, v12, *v11, *(const void **)(v7 + 48), v14, 3) != 0;
        }
      }
      else
      {
        RSA_encrypt(v10, v11, v12, *v11, v9, v8, v15);
      }
    }
    else
    {
      ERR_put_error(6, 0LL, 100, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", 352);
    }
  }
  else
  {
    *v11 = v13;
  }
}

//----- (000000000005A9D4) ----------------------------------------------------
__int64 __fastcall sub_5A9D4(__int64 a1, unsigned __int8 *a2, _QWORD *a3, unsigned __int8 *a4, size_t a5)
{
  __int64 v5; // x25
  size_t v6; // x20
  unsigned __int8 *v7; // x22
  __int64 v8; // x0
  __int64 v9; // x26
  _QWORD *v10; // x19
  unsigned __int8 *v11; // x21
  __int64 v12; // x24
  int v13; // w0
  unsigned __int64 v14; // x23
  __int64 result; // x0
  int v16; // w6
  unsigned __int8 *v17; // x2
  int v18; // w0
  int v19; // w0
  unsigned int v20; // [xsp+0h] [xbp-50h]
  __int64 v21; // [xsp+8h] [xbp-48h]

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(v5 + 40);
  v10 = a3;
  v11 = a2;
  v12 = *(_QWORD *)(v8 + 8);
  v13 = EVP_PKEY_size(v8);
  v14 = v13;
  if ( v11 )
  {
    if ( *v10 >= (unsigned __int64)v13 )
    {
      v16 = *(_DWORD *)(v9 + 16);
      if ( v16 != 4 )
      {
        result = RSA_decrypt(v12, v10, v11, v13, v7, v6, v16);
        goto LABEL_13;
      }
      v17 = *(unsigned __int8 **)(v9 + 48);
      if ( v17
        || (v18 = EVP_PKEY_size(*(_QWORD *)(v5 + 16)),
            v17 = (unsigned __int8 *)malloc(v18),
            (*(_QWORD *)(v9 + 48) = v17) != 0LL) )
      {
        result = RSA_decrypt(v12, &v20, v17, v14, v7, v6, 3);
        if ( !(_DWORD)result )
          goto LABEL_13;
        sub_5BF08(
          v11,
          v14,
          *(unsigned __int8 **)(v9 + 48),
          v20,
          *(_QWORD *)(v9 + 56),
          *(_DWORD *)(v9 + 64),
          *(void **)(v9 + 24),
          *(_QWORD *)(v9 + 32));
        if ( !(v19 & 0x80000000) )
        {
          *v10 = v19;
          result = 1LL;
          goto LABEL_13;
        }
      }
    }
    else
    {
      ERR_put_error(6, 0LL, 100, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", 384);
    }
    result = 0LL;
  }
  else
  {
    *v10 = v13;
    result = 1LL;
  }
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005AB34) ----------------------------------------------------
signed __int64 __fastcall sub_5AB34(__int64 a1, int a2, signed int a3, _QWORD *a4)
{
  __int64 v4; // x21
  _QWORD *v5; // x19
  signed int v6; // w20
  int v7; // w2
  __int16 v8; // w4
  __int64 v9; // x8
  __int64 v10; // x8

  v4 = *(_QWORD *)(a1 + 40);
  v5 = a4;
  v6 = a3;
  switch ( a2 )
  {
    case 4097:
      if ( (unsigned int)(a3 - 1) > 5 || a3 == 2 || a3 == 5 )
        goto LABEL_22;
      v10 = *(_QWORD *)(v4 + 24);
      if ( a3 == 3 && v10 )
      {
        ERR_put_error(6, 0LL, 115, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", 417);
LABEL_22:
        v7 = 109;
        v8 = 445;
        goto LABEL_47;
      }
      if ( a3 == 4 )
      {
        if ( !(*(_BYTE *)(a1 + 32) & 0xC0) )
          goto LABEL_22;
      }
      else if ( a3 == 6 )
      {
        if ( !(*(_BYTE *)(a1 + 32) & 0x18) )
          goto LABEL_22;
      }
      else if ( (a3 | 2) != 6 )
      {
        goto LABEL_59;
      }
      if ( !v10 )
        *(_QWORD *)(v4 + 24) = EVP_sha1();
LABEL_59:
      *(_DWORD *)(v4 + 16) = v6;
      return 1LL;
    case 4098:
      *(_DWORD *)a4 = *(_DWORD *)(v4 + 16);
      return 1LL;
    case 4099:
    case 4100:
      if ( *(_DWORD *)(v4 + 16) != 6 )
      {
        v7 = 116;
        v8 = 462;
        goto LABEL_47;
      }
      if ( a2 == 4100 )
      {
        *(_DWORD *)a4 = *(_DWORD *)(v4 + 40);
        return 1LL;
      }
      if ( (a3 + 2 < 0) ^ __OFADD__(a3, 2) )
        return 0LL;
      *(_DWORD *)(v4 + 40) = a3;
      return 1LL;
    case 4101:
      if ( a3 <= 255 )
      {
        v7 = 112;
        v8 = 477;
        goto LABEL_47;
      }
      *(_DWORD *)v4 = a3;
      return 1LL;
    case 4102:
      if ( !a4 )
        return 0LL;
      BN_free(*(_DWORD **)(v4 + 8));
      *(_QWORD *)(v4 + 8) = v5;
      return 1LL;
    case 4103:
    case 4104:
      if ( *(_DWORD *)(v4 + 16) != 4 )
      {
        v7 = 115;
        v8 = 494;
        goto LABEL_47;
      }
      if ( a2 == 4104 )
        goto LABEL_14;
      goto LABEL_39;
    case 4105:
    case 4106:
      if ( (*(_DWORD *)(v4 + 16) | 2) != 6 )
      {
        v7 = 113;
        v8 = 519;
        goto LABEL_47;
      }
      if ( a2 != 4106 )
      {
        *(_QWORD *)(v4 + 32) = a4;
        return 1LL;
      }
      v9 = *(_QWORD *)(v4 + 32);
      if ( v9 )
        goto LABEL_15;
      goto LABEL_14;
    case 4107:
      if ( *(_DWORD *)(v4 + 16) != 4 )
      {
        v7 = 115;
        v8 = 535;
        goto LABEL_47;
      }
      free(*(void **)(v4 + 56));
      if ( v6 >= 1 && v5 )
      {
        *(_QWORD *)(v4 + 56) = v5;
        *(_QWORD *)(v4 + 64) = v6;
      }
      else
      {
        *(_QWORD *)(v4 + 56) = 0LL;
        *(_QWORD *)(v4 + 64) = 0LL;
      }
      return 1LL;
    case 4108:
      if ( *(_DWORD *)(v4 + 16) == 4 )
      {
        CBS_init(a4, *(_QWORD *)(v4 + 56), *(_QWORD *)(v4 + 64));
        return 1LL;
      }
      v7 = 115;
      v8 = 550;
      goto LABEL_47;
    default:
      if ( a2 == 1 )
      {
        if ( !a4 || *(_DWORD *)(v4 + 16) != 3 )
        {
LABEL_39:
          *(_QWORD *)(v4 + 24) = a4;
          return 1LL;
        }
        v7 = 115;
        v8 = 417;
        goto LABEL_47;
      }
      if ( a2 != 2 )
      {
        v7 = 101;
        v8 = 557;
LABEL_47:
        ERR_put_error(6, 0LL, v7, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", v8);
        return 0LL;
      }
LABEL_14:
      v9 = *(_QWORD *)(v4 + 24);
LABEL_15:
      *a4 = v9;
      return 1LL;
  }
}

//----- (000000000005AE34) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set_rsa_padding(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, -1);
}

//----- (000000000005AE50) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_get_rsa_padding(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, -1);
}

//----- (000000000005AE6C) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set_rsa_pss_saltlen(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 24);
}

//----- (000000000005AE88) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_get_rsa_pss_saltlen(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 24);
}

//----- (000000000005AEA4) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set_rsa_keygen_bits(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 4);
}

//----- (000000000005AEC0) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set_rsa_keygen_pubexp(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 4);
}

//----- (000000000005AEDC) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set_rsa_oaep_md(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 192);
}

//----- (000000000005AEF8) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_get_rsa_oaep_md(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 192);
}

//----- (000000000005AF14) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set_rsa_mgf1_md(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 248);
}

//----- (000000000005AF30) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_get_rsa_mgf1_md(__int64 *a1)
{
  return EVP_PKEY_CTX_ctrl(a1, 6, 248);
}

//----- (000000000005AF4C) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_set0_rsa_oaep_label(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 result; // x0

  if ( a3 >> 31 )
    result = 0LL;
  else
    result = EVP_PKEY_CTX_ctrl(a1, 6, 192);
  return result;
}

//----- (000000000005AF7C) ----------------------------------------------------
__int64 __fastcall EVP_PKEY_CTX_get0_rsa_oaep_label(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // x19
  __int64 result; // x0
  char v4; // [xsp+8h] [xbp-28h]
  __int64 v5; // [xsp+18h] [xbp-18h]

  v2 = a2;
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)EVP_PKEY_CTX_ctrl(a1, 6, 192) )
  {
    if ( !((unsigned __int64)EVP_CIPHER_CTX_get_app_data((__int64)&v4) >> 31) )
    {
      *v2 = lh_num_items((__int64)&v4);
      result = EVP_CIPHER_CTX_get_app_data((__int64)&v4);
      goto LABEL_6;
    }
    ERR_put_error(6, 0LL, 69, (__int64)"external/boringssl/src/crypto/evp/p_rsa.c", 674);
  }
  result = 0xFFFFFFFFLL;
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005B028) ----------------------------------------------------
signed __int64 __fastcall sub_5B028(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3)
{
  __int64 v3; // x21
  unsigned __int8 **v4; // x20
  __int64 v5; // x19
  signed __int64 result; // x0
  int *v7; // x0
  int *v8; // x21
  char v9; // [xsp+8h] [xbp-38h]
  __int64 v10; // [xsp+18h] [xbp-28h]

  v3 = (__int64)a2;
  v4 = a3;
  v5 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBS_get_asn1(a2, &v9, 5)
    || EVP_CIPHER_CTX_get_app_data((__int64)&v9)
    || EVP_CIPHER_CTX_get_app_data(v3) )
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_rsa_asn1.c", 96);
  }
  else
  {
    RSA_parse_public_key_buggy(v4);
    v8 = v7;
    if ( v7 && !EVP_CIPHER_CTX_get_app_data((__int64)v4) )
    {
      EVP_PKEY_assign_RSA(v5, (__int64)v8);
      result = 1LL;
      goto LABEL_6;
    }
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_rsa_asn1.c", 108);
    RSA_free(v8);
  }
  result = 0LL;
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v10;
  return result;
}

//----- (000000000005B124) ----------------------------------------------------
signed __int64 __fastcall sub_5B124(__int64 *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x19
  signed __int64 result; // x0
  char v5; // [xsp+8h] [xbp-B8h]
  char v6; // [xsp+28h] [xbp-98h]
  char **v7[4]; // [xsp+48h] [xbp-78h]
  char v8; // [xsp+68h] [xbp-58h]
  char v9; // [xsp+88h] [xbp-38h]
  __int64 v10; // [xsp+A8h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_add_asn1(a1, (__int64 *)&v9, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)&v8, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v8, (__int64 *)v7, 6u)
    && (unsigned int)CBB_add_bytes(v7, &unk_F72AC, 9uLL)
    && (unsigned int)CBB_add_asn1((__int64 *)&v8, (__int64 *)&v6, 5u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)&v5, 3u)
    && (unsigned int)CBB_add_u8((__int64 *)&v5, 0)
    && (unsigned int)RSA_marshal_public_key((__int64 *)&v5, *(_QWORD *)(v2 + 8))
    && (unsigned int)CBB_flush(v3) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 105, (__int64)"external/boringssl/src/crypto/evp/p_rsa_asn1.c", 81);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005B240) ----------------------------------------------------
bool __fastcall sub_5B240(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  _BOOL8 result; // x0

  v2 = a2;
  v3 = a1;
  if ( (unsigned int)BN_cmp(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 8LL), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL)) )
    result = 0LL;
  else
    result = (unsigned int)BN_cmp(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 16LL), *(_QWORD *)(*(_QWORD *)(v3 + 8) + 16LL)) == 0;
  return result;
}

//----- (000000000005B29C) ----------------------------------------------------
signed __int64 __fastcall sub_5B29C(__int64 a1, unsigned __int8 **a2, unsigned __int8 **a3)
{
  __int64 v3; // x21
  unsigned __int8 **v4; // x20
  __int64 v5; // x19
  signed __int64 result; // x0
  int *v7; // x21
  char v8; // [xsp+8h] [xbp-38h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v3 = (__int64)a2;
  v4 = a3;
  v5 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBS_get_asn1(a2, &v8, 5)
    || EVP_CIPHER_CTX_get_app_data((__int64)&v8)
    || EVP_CIPHER_CTX_get_app_data(v3) )
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_rsa_asn1.c", 146);
  }
  else
  {
    v7 = RSA_parse_private_key(v4);
    if ( v7 && !EVP_CIPHER_CTX_get_app_data((__int64)v4) )
    {
      EVP_PKEY_assign_RSA(v5, (__int64)v7);
      result = 1LL;
      goto LABEL_6;
    }
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/p_rsa_asn1.c", 152);
    RSA_free(v7);
  }
  result = 0LL;
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
  return result;
}

//----- (000000000005B398) ----------------------------------------------------
signed __int64 __fastcall sub_5B398(__int64 *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x19
  signed __int64 result; // x0
  char v5; // [xsp+8h] [xbp-B8h]
  char v6; // [xsp+28h] [xbp-98h]
  char **v7[4]; // [xsp+48h] [xbp-78h]
  char v8; // [xsp+68h] [xbp-58h]
  char v9; // [xsp+88h] [xbp-38h]
  __int64 v10; // [xsp+A8h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_add_asn1(a1, (__int64 *)&v9, 0x30u)
    && (unsigned int)CBB_add_asn1_uint64((__int64 *)&v9, 0LL)
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)&v8, 0x30u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v8, (__int64 *)v7, 6u)
    && (unsigned int)CBB_add_bytes(v7, &unk_F72AC, 9uLL)
    && (unsigned int)CBB_add_asn1((__int64 *)&v8, (__int64 *)&v6, 5u)
    && (unsigned int)CBB_add_asn1((__int64 *)&v9, (__int64 *)&v5, 4u)
    && (unsigned int)RSA_marshal_private_key((__int64 *)&v5, *(_QWORD *)(v2 + 8))
    && (unsigned int)CBB_flush(v3) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(6, 0LL, 105, (__int64)"external/boringssl/src/crypto/evp/p_rsa_asn1.c", 133);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005B4B4) ----------------------------------------------------
__int64 __fastcall sub_5B4B4(__int64 a1)
{
  __int64 v1; // x0
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( *(_QWORD *)v1 )
    result = *(_BYTE *)(*(_QWORD *)v1 + 112LL) & 1;
  else
    result = 0LL;
  return result;
}

//----- (000000000005B4BC) ----------------------------------------------------
__int64 __fastcall sub_5B4BC(__int64 a1)
{
  return RSA_supports_digest(*(_QWORD *)(a1 + 8));
}

//----- (000000000005B4C4) ----------------------------------------------------
__int64 __fastcall sub_5B4C4(__int64 a1)
{
  return RSA_size(*(_QWORD *)(a1 + 8));
}

//----- (000000000005B4CC) ----------------------------------------------------
void __fastcall sub_5B4CC(__int64 a1)
{
  RSA_free(*(int **)(a1 + 8));
}

//----- (000000000005B4D4) ----------------------------------------------------
__int64 __fastcall CRYPTO_refcount_inc(_DWORD *a1)
{
  _DWORD *v1; // x19

  v1 = a1;
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_107110);
  if ( *v1 != -1 )
    ++*v1;
  return CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107110);
}

//----- (000000000005B518) ----------------------------------------------------
__int64 __fastcall CRYPTO_refcount_dec_and_test_zero(int *a1)
{
  int *v1; // x19
  int v2; // w8
  int v3; // w8
  _BOOL4 v4; // w19

  v1 = a1;
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_107110);
  v2 = *v1;
  if ( *v1 == -1 )
  {
    v4 = 0;
  }
  else
  {
    if ( !v2 )
      abort();
    v3 = v2 - 1;
    *v1 = v3;
    v4 = v3 == 0;
  }
  CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107110);
  return (unsigned int)v4;
}

//----- (000000000005B578) ----------------------------------------------------
signed __int64 __fastcall sub_5B578(_WORD *a1, unsigned __int64 a2, const void *a3, unsigned __int64 a4)
{
  size_t v4; // x19
  const void *v5; // x20
  unsigned __int64 v6; // x21
  _WORD *v7; // x22
  int v8; // w2
  __int16 v9; // w4
  void *v11; // x0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a2 <= 0xA )
  {
    v8 = 126;
    v9 = 78;
LABEL_5:
    ERR_put_error(4, 0LL, v8, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v9);
    return 0LL;
  }
  if ( a2 - 11 < a4 )
  {
    v8 = 114;
    v9 = 83;
    goto LABEL_5;
  }
  *a1 = 256;
  v11 = a1 + 1;
  if ( a2 - 3 != a4 )
    memset(v11, 255, a2 - 3 - a4);
  *((_BYTE *)v7 + v6 - 1 - v4) = 0;
  if ( v4 )
    memcpy((char *)v7 + v6 - v4, v5, v4);
  return 1LL;
}

//----- (000000000005B644) ----------------------------------------------------
__int64 __fastcall sub_5B644(void *a1, unsigned int a2, _BYTE *a3, unsigned int a4)
{
  int v4; // w2
  __int16 v5; // w4
  unsigned int v6; // w10
  __int64 v7; // x9
  _BYTE *v8; // x8
  unsigned int v9; // w19

  if ( a4 <= 1 )
  {
    v4 = 116;
    v5 = 101;
LABEL_12:
    ERR_put_error(4, 0LL, v4, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v5);
    return (unsigned int)-1;
  }
  if ( *a3 || a3[1] != 1 )
  {
    v4 = 107;
    v5 = 107;
    goto LABEL_12;
  }
  v6 = a4 - 2;
  if ( a4 != 2 )
  {
    v7 = 0LL;
    while ( (unsigned __int8)a3[v7 + 2] == 255 )
    {
      if ( (unsigned int)++v7 >= v6 )
      {
        v8 = &a3[v7 + 2];
        if ( (_DWORD)v7 == v6 )
          goto LABEL_18;
        goto LABEL_19;
      }
    }
    if ( a3[v7 + 2] )
    {
      v4 = 102;
      v5 = 120;
      goto LABEL_12;
    }
    v8 = &a3[v7 + 3];
    if ( (_DWORD)v7 != v6 )
      goto LABEL_19;
    goto LABEL_18;
  }
  LODWORD(v7) = 0;
  v8 = a3 + 2;
  if ( a4 == 2 )
  {
LABEL_18:
    v4 = 131;
    v5 = 128;
    goto LABEL_12;
  }
LABEL_19:
  if ( (unsigned int)v7 <= 7 )
  {
    v4 = 103;
    v5 = 133;
    goto LABEL_12;
  }
  v9 = a4 - 3 - v7;
  if ( v9 > a2 )
  {
    v4 = 113;
    v5 = 139;
    goto LABEL_12;
  }
  if ( a4 - 3 != (_DWORD)v7 )
    memcpy(a1, v8, v9);
  return v9;
}

//----- (000000000005B7A4) ----------------------------------------------------
signed __int64 __fastcall sub_5B7A4(_WORD *a1, unsigned __int64 a2, const void *a3, unsigned __int64 a4)
{
  size_t v4; // x19
  const void *v5; // x20
  unsigned __int64 v6; // x21
  _WORD *v7; // x22
  int v8; // w2
  __int16 v9; // w4
  signed __int64 result; // x0
  size_t v11; // x24
  size_t v12; // x26

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a2 <= 0xA )
  {
    v8 = 126;
    v9 = 167;
LABEL_5:
    ERR_put_error(4, 0LL, v8, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v9);
    return 0LL;
  }
  if ( a2 - 11 < a4 )
  {
    v8 = 114;
    v9 = 172;
    goto LABEL_5;
  }
  *a1 = 512;
  v11 = a2 - 3 - a4;
  result = RAND_pseudo_bytes((signed __int64)(a1 + 1), v11);
  if ( (_DWORD)result )
  {
    if ( v6 - 3 != v4 )
    {
      v12 = 0LL;
      do
      {
        while ( !*((_BYTE *)v7 + v12 + 2) )
        {
          result = RAND_pseudo_bytes((signed __int64)v7 + v12 + 2, 1uLL);
          if ( !(_DWORD)result )
            return result;
        }
        ++v12;
      }
      while ( v12 < v11 );
    }
    *((_BYTE *)v7 + v11 + 2) = 0;
    if ( v4 )
      memcpy((char *)v7 + v6 - v4, v5, v4);
    result = 1LL;
  }
  return result;
}

//----- (000000000005B8B4) ----------------------------------------------------
__int64 __fastcall sub_5B8B4(void *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v4; // w2
  __int16 v5; // w4
  int v6; // w8
  signed int v7; // w13
  signed __int64 v8; // x12
  signed int v9; // w14
  int v10; // w15
  int v11; // w16
  int v12; // w17
  unsigned int v13; // w19

  if ( !a4 )
  {
    v4 = 120;
    v5 = 192;
    goto LABEL_15;
  }
  if ( a4 <= 0xA )
  {
    v4 = 126;
    v5 = 201;
LABEL_15:
    ERR_put_error(4, 0LL, v4, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v5);
    return (unsigned int)-1;
  }
  v6 = 0;
  v7 = -1;
  v8 = 2LL;
  do
  {
    v9 = v7;
    v10 = (a3[v8] - 1) >> 31;
    v11 = v10 & v7;
    v12 = v10 & v7 & v8;
    v7 &= ~v10;
    ++v8;
    v6 = v6 & ~v11 | v12;
  }
  while ( a4 != v8 );
  if ( !((v10 | ~v9) & (((((a3[1] ^ 2) & 0xFF) - 1) & (*a3 - 1)) >> 31) & ~(((v6 - 10) & ~v6) >> 31)) )
  {
    v4 = 137;
    v5 = 234;
    goto LABEL_15;
  }
  v13 = a4 - (v6 + 1);
  if ( v13 > a2 )
  {
    v4 = 137;
    v5 = 242;
    goto LABEL_15;
  }
  if ( v13 & 0x80000000 )
  {
    v4 = 69;
    v5 = 247;
    goto LABEL_15;
  }
  if ( a4 != v6 + 1 )
    memcpy(a1, &a3[v6 + 1], v13);
  return v13;
}

//----- (000000000005B9FC) ----------------------------------------------------
signed __int64 __fastcall sub_5B9FC(void *a1, size_t a2, const void *a3, size_t a4)
{
  int v4; // w2
  __int16 v5; // w4

  if ( a4 > a2 )
  {
    v4 = 114;
    v5 = 258;
LABEL_5:
    ERR_put_error(4, 0LL, v4, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v5);
    return 0LL;
  }
  if ( a4 < a2 )
  {
    v4 = 117;
    v5 = 263;
    goto LABEL_5;
  }
  if ( a4 )
    memcpy(a1, a3, a4);
  return 1LL;
}

//----- (000000000005BA6C) ----------------------------------------------------
void __fastcall RSA_padding_add_PKCS1_OAEP_mgf1(_BYTE *a1, unsigned __int64 a2, const void *a3, size_t a4, __int64 a5, __int64 a6, void *a7, __int64 a8)
{
  __int64 v8; // x20
  void *v9; // x27
  __int64 v10; // x26
  __int64 v11; // x28
  size_t v12; // x21
  const void *v13; // x24
  unsigned __int64 v14; // x23
  _BYTE *v15; // x25
  __int64 v16; // x22
  unsigned __int64 v17; // x20
  signed __int64 v18; // x19
  int v19; // w2
  __int16 v20; // w4
  unsigned __int64 v21; // x23
  __int64 v22; // x0
  __int64 v23; // x28
  __int64 v24; // x2
  __int64 v25; // x25
  int v26; // w0
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x24
  char *v29; // x0
  int8x16_t *v30; // x21
  unsigned __int64 v31; // x8
  int8x16_t *v32; // x9
  int8x16_t *v33; // x10
  unsigned __int64 v34; // x11
  int8x16_t v35; // q0
  int8x16_t v36; // q1
  int8x16_t v37; // q1
  char *v38; // x9
  _BYTE *v39; // x10
  unsigned __int64 v40; // x8
  char v41; // t1
  unsigned __int64 v42; // x8
  int8x16_t *v43; // x9
  int8x16_t *v44; // x10
  unsigned __int64 v45; // x11
  int8x16_t v46; // q0
  int8x16_t v47; // q1
  int8x16_t v48; // q1
  char *v49; // x9
  _BYTE *v50; // x10
  unsigned __int64 v51; // x8
  char v52; // t1
  _BYTE *v53; // [xsp+0h] [xbp-A0h]
  char v54[64]; // [xsp+8h] [xbp-98h]
  char v55[64]; // [xsp+18h] [xbp-88h]
  __int64 v56; // [xsp+48h] [xbp-58h]

  v8 = a8;
  v9 = a7;
  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  v15 = a1;
  v56 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a7 )
    v9 = EVP_sha1();
  if ( v8 )
    v16 = v8;
  else
    v16 = (__int64)v9;
  v17 = X509_TRUST_get_flags((__int64)v9);
  v18 = 2 * v17;
  if ( 2 * v17 + 2 > v14 )
  {
    v19 = 126;
    v20 = 328;
LABEL_12:
    ERR_put_error(4, 0LL, v19, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v20);
    goto LABEL_13;
  }
  if ( v14 - 2 - v18 < v12 )
  {
    v19 = 114;
    v20 = 334;
    goto LABEL_12;
  }
  v21 = v14 - 1;
  if ( v21 < (v18 | 1uLL) )
  {
    v19 = 126;
    v20 = 339;
    goto LABEL_12;
  }
  v53 = v15;
  v22 = v11;
  v23 = (__int64)&v15[v17 + 1];
  v24 = (__int64)&v15[v17 + 1];
  *v15 = 0;
  v25 = (__int64)(v15 + 1);
  EVP_Digest(v22, v10, v24, 0LL, (__int64)v9);
  if ( v26 )
  {
    v27 = v21 - v12 - v18;
    if ( v27 != 1 )
      memset((void *)(v23 + v17), 0, v27 - 1);
    *(_BYTE *)(v23 + v21 - v12 - 1 - v17) = 1;
    if ( v12 )
      memcpy((void *)(v23 + v21 - v12 - v17), v13, v12);
    if ( (unsigned int)RAND_pseudo_bytes(v25, v17) )
    {
      v28 = v21 - v17;
      v29 = (char *)malloc(v21 - v17);
      v30 = (int8x16_t *)v29;
      if ( !v29 )
      {
        v19 = 65;
        v20 = 359;
        goto LABEL_12;
      }
      if ( !(unsigned int)sub_5BDB8(v29, v21 - v17, v25, v17, v16) )
        goto LABEL_45;
      if ( v21 != v17 )
      {
        if ( v28 > 0x1F )
        {
          v31 = v28 & 0xFFFFFFFFFFFFFFE0LL;
          if ( v28 & 0xFFFFFFFFFFFFFFE0LL )
          {
            v32 = v30 + 1;
            v33 = (int8x16_t *)&v53[v17 + 17];
            v34 = v28 & 0xFFFFFFFFFFFFFFE0LL;
            do
            {
              v35 = v32[-1];
              v36 = *v32;
              v32 += 2;
              v34 -= 32LL;
              v37 = veorq_s8(*v33, v36);
              v33[-1] = veorq_s8(v33[-1], v35);
              *v33 = v37;
              v33 += 2;
            }
            while ( v34 );
            if ( v28 == v31 )
              goto LABEL_34;
          }
        }
        else
        {
          v31 = 0LL;
        }
        v38 = (char *)v30 + v31;
        v39 = &v53[v17 + 1 + v31];
        v40 = v28 - v31;
        do
        {
          v41 = *v38++;
          --v40;
          *v39++ ^= v41;
        }
        while ( v40 );
      }
LABEL_34:
      if ( !(unsigned int)sub_5BDB8(v54, v17, v23, v21 - v17, v16) || !v17 )
        goto LABEL_45;
      if ( v17 > 0x1F )
      {
        v42 = v17 & 0xFFFFFFFFFFFFFFE0LL;
        if ( v17 & 0xFFFFFFFFFFFFFFE0LL )
        {
          v43 = (int8x16_t *)v55;
          v44 = (int8x16_t *)(v53 + 17);
          v45 = v17 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v46 = v43[-1];
            v47 = *v43;
            v43 += 2;
            v45 -= 32LL;
            v48 = veorq_s8(*v44, v47);
            v44[-1] = veorq_s8(v44[-1], v46);
            *v44 = v48;
            v44 += 2;
          }
          while ( v45 );
          if ( v17 == v42 )
            goto LABEL_45;
        }
      }
      else
      {
        v42 = 0LL;
      }
      v49 = &v54[v42];
      v50 = &v53[v42 + 1];
      v51 = v17 - v42;
      do
      {
        v52 = *v49++;
        --v51;
        *v50++ ^= v52;
      }
      while ( v51 );
LABEL_45:
      free(v30);
      goto LABEL_13;
    }
  }
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v56;
}
// 5BA6C: using guessed type char var_98[64];

//----- (000000000005BDB8) ----------------------------------------------------
signed __int64 __fastcall sub_5BDB8(char *a1, size_t a2, __int64 a3, __int64 a4, __int64 a5)
{
  char *v5; // x19
  __int64 v6; // x20
  size_t v7; // x23
  unsigned __int64 v8; // x24
  int v9; // w25
  size_t v10; // x26
  unsigned int v11; // w19
  signed __int64 result; // x0
  __int64 v13; // [xsp+0h] [xbp-B0h]
  char v14; // [xsp+24h] [xbp-8Ch]
  char v15; // [xsp+25h] [xbp-8Bh]
  char v16; // [xsp+26h] [xbp-8Ah]
  char v17; // [xsp+27h] [xbp-89h]
  char v18; // [xsp+28h] [xbp-88h]
  __int64 v19; // [xsp+68h] [xbp-48h]

  v5 = a1;
  v6 = a5;
  v7 = a2;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(&v13);
  v8 = X509_TRUST_get_flags(v6);
  if ( v7 )
  {
    v9 = 0;
    while ( 1 )
    {
      v14 = HIBYTE(v9);
      v15 = BYTE2(v9);
      v16 = BYTE1(v9);
      v17 = v9;
      if ( !(unsigned int)EVP_DigestInit_ex(&v13, v6)
        || !(unsigned int)EVP_DigestUpdate((__int64)&v13)
        || !(unsigned int)EVP_DigestUpdate((__int64)&v13) )
      {
        break;
      }
      v10 = v7 - v8;
      if ( v7 < v8 )
      {
        if ( (unsigned int)EVP_DigestFinal_ex((void **)&v13, (__int64)&v18, 0LL) )
        {
          memcpy(v5, &v18, v7);
          v11 = 1;
          goto LABEL_13;
        }
        break;
      }
      if ( !(unsigned int)EVP_DigestFinal_ex((void **)&v13, (__int64)v5, 0LL) )
        break;
      v5 += v8;
      ++v9;
      v7 -= v8;
      if ( !v10 )
        goto LABEL_9;
    }
    v11 = 0;
  }
  else
  {
LABEL_9:
    v11 = 1;
  }
LABEL_13:
  result = EVP_MD_CTX_cleanup(&v13);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v19 )
    result = v11;
  return result;
}

//----- (000000000005BF08) ----------------------------------------------------
void __fastcall sub_5BF08(void *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4, __int64 a5, unsigned int a6, void *a7, __int64 a8)
{
  __int64 v8; // x20
  void *v9; // x26
  unsigned int v10; // w27
  __int64 v11; // x25
  unsigned int v12; // w19
  unsigned __int8 *v13; // x24
  unsigned int v14; // w21
  void *v15; // x28
  unsigned int v16; // w0
  unsigned int v17; // w23
  int8x16_t *v18; // x19
  int v19; // w2
  __int16 v20; // w4
  size_t v21; // x22
  unsigned __int64 v22; // x8
  int8x16_t *v23; // x10
  int8x16_t *v24; // x11
  unsigned __int64 v25; // x12
  int8x16_t v26; // q0
  int8x16_t v27; // q1
  int8x16_t v28; // q1
  unsigned __int8 *v29; // x9
  char *v30; // x10
  unsigned __int64 v31; // x8
  char v32; // t1
  size_t v33; // x8
  size_t v34; // x9
  int8x16_t *v35; // x10
  int8x16_t *v36; // x11
  size_t v37; // x12
  int8x16_t v38; // q0
  int8x16_t v39; // q1
  int8x16_t v40; // q1
  _BYTE *v41; // x9
  unsigned __int8 *v42; // x10
  size_t v43; // x8
  char v44; // t1
  int v45; // w0
  int v46; // w0
  int v47; // w8
  int v48; // w12
  unsigned __int8 *v49; // x10
  size_t v50; // x11
  signed int v51; // w9
  int v52; // t1
  int v53; // w14
  int v54; // w15
  int v55; // w14
  unsigned int v56; // w10
  char v57; // [xsp+8h] [xbp-D8h]
  char v58[64]; // [xsp+48h] [xbp-98h]
  char v59[64]; // [xsp+58h] [xbp-88h]
  __int64 v60; // [xsp+88h] [xbp-58h]

  v8 = a8;
  v9 = a7;
  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  v15 = a1;
  v60 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a7 )
    v9 = EVP_sha1();
  if ( !v8 )
    v8 = (__int64)v9;
  v16 = X509_TRUST_get_flags((__int64)v9);
  v17 = v16;
  if ( (2 * v16 | 1) + 1 > v12 )
  {
    v18 = 0LL;
LABEL_7:
    v19 = 133;
    v20 = 474;
LABEL_14:
    ERR_put_error(4, 0LL, v19, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v20);
    goto LABEL_15;
  }
  v21 = v12 - v16 - 1;
  v18 = (int8x16_t *)malloc(v21);
  if ( !v18 )
  {
    v19 = 65;
    v20 = 414;
    goto LABEL_14;
  }
  if ( !(unsigned int)sub_5BDB8(v58, v17, (__int64)&v13[v17 + 1], v21, v8) )
  {
LABEL_15:
    free(v18);
    goto LABEL_16;
  }
  if ( v17 )
  {
    if ( v17 < 0x20uLL )
    {
      v22 = 0LL;
LABEL_22:
      v29 = &v13[v22 + 1];
      v30 = &v58[v22];
      v31 = v17 - v22;
      do
      {
        v32 = *v29++;
        --v31;
        *v30 ^= v32;
        ++v30;
      }
      while ( v31 );
      goto LABEL_24;
    }
    v22 = v17 - (unsigned __int64)(v17 & 0x1F);
    if ( v17 == (unsigned __int64)(v17 & 0x1F) )
      goto LABEL_22;
    v23 = (int8x16_t *)(v13 + 17);
    v24 = (int8x16_t *)v59;
    v25 = v17 - (unsigned __int64)(v17 & 0x1F);
    do
    {
      v26 = v23[-1];
      v27 = *v23;
      v23 += 2;
      v25 -= 32LL;
      v28 = veorq_s8(*v24, v27);
      v24[-1] = veorq_s8(v24[-1], v26);
      *v24 = v28;
      v24 += 2;
    }
    while ( v25 );
    if ( v17 & 0x1F )
      goto LABEL_22;
  }
LABEL_24:
  if ( !(unsigned int)sub_5BDB8((char *)v18, v21, (__int64)v58, v17, v8) )
    goto LABEL_15;
  if ( (_DWORD)v21 )
  {
    if ( (unsigned int)v21 < 0x20 )
    {
      v33 = 0LL;
LABEL_32:
      v41 = (char *)v18 + v33;
      v42 = &v13[v33 + 1 + v17];
      v43 = v21 - v33;
      do
      {
        v44 = *v42++;
        --v43;
        *v41++ ^= v44;
      }
      while ( v43 );
      goto LABEL_34;
    }
    v34 = v21 & 0x1F;
    v33 = v21 - v34;
    if ( v21 == v34 )
      goto LABEL_32;
    v35 = (int8x16_t *)&v13[v17 + 17];
    v36 = v18 + 1;
    v37 = v21 - v34;
    do
    {
      v38 = v35[-1];
      v39 = *v35;
      v35 += 2;
      v37 -= 32LL;
      v40 = veorq_s8(*v36, v39);
      v36[-1] = veorq_s8(v36[-1], v38);
      *v36 = v40;
      v36 += 2;
    }
    while ( v37 );
    if ( v21 & 0x1F )
      goto LABEL_32;
  }
LABEL_34:
  EVP_Digest(v11, v10, (__int64)&v57, 0LL, (__int64)v9);
  if ( !v45 )
    goto LABEL_15;
  v46 = CRYPTO_memcmp((__int64)v18, (__int64)&v57, v17);
  v47 = ~(((v46 - 1) & ~v46 & (*v13 - 1)) >> 31);
  if ( v17 >= (unsigned int)v21 )
    goto LABEL_7;
  v48 = 0;
  v49 = (unsigned __int8 *)v18 + v17;
  v50 = v21 - v17;
  v51 = -1;
  do
  {
    v52 = *v49++;
    --v50;
    v53 = ((v52 ^ 1) - 1) >> 31;
    v54 = v53 & v51;
    v51 &= ~v53;
    v55 = v54 & v17++;
    v48 = v48 & ~v54 | v55;
    v47 |= v51 & ~((v52 - 1) >> 31);
  }
  while ( v50 );
  v56 = v48 + 1;
  if ( v51 | v47 )
    goto LABEL_7;
  if ( (unsigned int)v21 - v56 <= v14 )
  {
    if ( (_DWORD)v21 != v56 )
      memcpy(v15, (char *)v18 + v56, (unsigned int)v21 - v56);
  }
  else
  {
    ERR_put_error(4, 0LL, 113, (__int64)"external/boringssl/src/crypto/rsa/padding.c", 462);
  }
  free(v18);
LABEL_16:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v60;
}
// 5BF08: using guessed type char var_98[64];

//----- (000000000005C284) ----------------------------------------------------
signed __int64 __fastcall RSA_verify_PKCS1_PSS_mgf1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int8 *a5, signed int a6)
{
  __int64 v6; // x24
  signed int v7; // w23
  unsigned __int8 *v8; // x19
  __int64 v9; // x20
  __int64 v10; // x22
  __int64 v11; // x25
  __int64 v12; // x0
  size_t v13; // x20
  int v14; // w2
  __int16 v15; // w4
  int v16; // w28
  int v17; // w0
  signed __int64 v18; // x24
  int v19; // w8
  size_t v20; // x8
  signed __int64 v21; // x27
  size_t v22; // x26
  char *v23; // x0
  int8x16_t *v24; // x19
  size_t v25; // x1
  const void *v26; // x26
  unsigned __int64 v27; // x9
  unsigned int v28; // w20
  signed __int64 result; // x0
  int v30; // w2
  __int16 v31; // w4
  int8x16_t *v32; // x11
  int8x16_t *v33; // x12
  unsigned __int64 v34; // x13
  int8x16_t v35; // q0
  int8x16_t v36; // q1
  int8x16_t v37; // q1
  char *v38; // x10
  _BYTE *v39; // x11
  unsigned __int64 v40; // x8
  char v41; // t1
  __int64 v42; // x24
  __int64 v43; // x25
  int v44; // w10
  bool v45; // nf
  unsigned __int8 v46; // vf
  void *v47[4]; // [xsp+8h] [xbp-B8h]
  char v48; // [xsp+28h] [xbp-98h]
  __int64 v49; // [xsp+68h] [xbp-58h]

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v49 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(v47);
  if ( v9 )
    v11 = v9;
  else
    v11 = v10;
  v12 = X509_TRUST_get_flags(v10);
  v13 = v12;
  if ( v7 == -2 )
  {
    v7 = -2;
  }
  else if ( v7 == -1 )
  {
    v7 = v12;
  }
  else if ( (unsigned __int8)((v7 + 3 < 0) ^ __OFADD__(v7, 3)) | (v7 == -3) )
  {
    v14 = 138;
    v15 = 510;
LABEL_26:
    ERR_put_error(4, 0LL, v14, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v15);
    v28 = 0;
    v24 = 0LL;
    goto LABEL_27;
  }
  v16 = ((unsigned __int8)BN_num_bits(*(_QWORD *)(v6 + 8)) + 7) & 7;
  v17 = RSA_size(v6);
  if ( *v8 & (255 << v16) )
  {
    v14 = 122;
    v15 = 517;
    goto LABEL_26;
  }
  if ( v16 )
    v18 = (signed __int64)v8;
  else
    v18 = (signed __int64)(v8 + 1);
  v19 = v17 - (v16 == 0);
  if ( v19 < (signed int)v13 + 2 || v19 < (signed int)v13 + 2 + v7 )
  {
    v14 = 113;
    v15 = 526;
    goto LABEL_26;
  }
  if ( *(unsigned __int8 *)(v18 + v19 - 1) != 188 )
  {
    v14 = 127;
    v15 = 530;
    goto LABEL_26;
  }
  v20 = (unsigned int)v19 - v13;
  v21 = v20 + 0xFFFFFFFF;
  v22 = (signed int)v20 - 1;
  v23 = (char *)malloc(v22);
  v24 = (int8x16_t *)v23;
  if ( !v23 )
  {
    v30 = 65;
    v31 = 537;
LABEL_47:
    ERR_put_error(4, 0LL, v30, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v31);
    goto LABEL_48;
  }
  v25 = v22;
  v26 = (const void *)(v18 + v22);
  if ( !(unsigned int)sub_5BDB8(v23, v25, (__int64)v26, v13, v11) )
  {
LABEL_48:
    v28 = 0;
    goto LABEL_27;
  }
  if ( (signed int)v21 >= 1 )
  {
    if ( (unsigned int)v21 < 0x20uLL )
    {
      v27 = 0LL;
LABEL_34:
      v38 = (char *)(v18 + v27);
      v39 = (char *)v24 + v27;
      v40 = (unsigned int)v21 - v27;
      do
      {
        v41 = *v38++;
        --v40;
        *v39++ ^= v41;
      }
      while ( v40 );
      goto LABEL_36;
    }
    v27 = (unsigned int)v21 - (unsigned __int64)(v21 & 0x1F);
    if ( (unsigned int)v21 == (unsigned __int64)(v21 & 0x1F) )
      goto LABEL_34;
    v32 = (int8x16_t *)(v18 + 16);
    v33 = v24 + 1;
    v34 = (unsigned int)v21 - (unsigned __int64)(v21 & 0x1F);
    do
    {
      v35 = v32[-1];
      v36 = *v32;
      v32 += 2;
      v34 -= 32LL;
      v37 = veorq_s8(*v33, v36);
      v33[-1] = veorq_s8(v33[-1], v35);
      *v33 = v37;
      v33 += 2;
    }
    while ( v34 );
    if ( v21 & 0x1F )
      goto LABEL_34;
  }
LABEL_36:
  if ( v16 )
    LOBYTE(v24->n128_u64[0]) &= 0xFFu >> (8 - v16);
  v42 = 0LL;
  v43 = 0LL;
  do
  {
    v44 = *((unsigned __int8 *)v24->n128_u64 + v43);
    v46 = __OFSUB__(v43, ((v21 << 32) - 0x100000000LL) >> 32);
    v45 = v43++ - (((v21 << 32) - 0x100000000LL) >> 32) < 0;
    v42 += 0x100000000LL;
  }
  while ( v45 ^ v46 && !v44 );
  if ( v44 != 1 )
  {
    v30 = 139;
    v31 = 553;
    goto LABEL_47;
  }
  if ( !(v7 & 0x80000000) && (_DWORD)v21 - v7 != (_DWORD)v43 )
  {
    v30 = 138;
    v31 = 557;
    goto LABEL_47;
  }
  if ( !(unsigned int)EVP_DigestInit_ex((__int64 *)v47, v10)
    || !(unsigned int)EVP_DigestUpdate((__int64)v47)
    || !(unsigned int)EVP_DigestUpdate((__int64)v47)
    || !(unsigned int)EVP_DigestUpdate((__int64)v47)
    || !(unsigned int)EVP_DigestFinal_ex(v47, (__int64)&v48, 0LL) )
  {
    goto LABEL_48;
  }
  if ( v13 && (unsigned int)memcmp(&v48, v26, v13) )
  {
    v30 = 105;
    v31 = 568;
    goto LABEL_47;
  }
  v28 = 1;
LABEL_27:
  free(v24);
  result = EVP_MD_CTX_cleanup(v47);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v49 )
    result = v28;
  return result;
}

//----- (000000000005C650) ----------------------------------------------------
void __fastcall RSA_padding_add_PKCS1_PSS_mgf1(__int64 a1, char *a2, __int64 a3, __int64 a4, __int64 a5, int a6)
{
  int v6; // w20
  __int64 v7; // x25
  char *v8; // x19
  __int64 v9; // x21
  __int64 v10; // x23
  __int64 v11; // x22
  int v12; // w2
  __int16 v13; // w4
  int v14; // w27
  unsigned int v15; // w0
  unsigned __int64 v16; // x28
  size_t v17; // x21
  unsigned __int64 v18; // x26
  char *v19; // x0
  char *v20; // x20
  size_t v21; // x25
  __int64 v22; // x24
  int v23; // w26
  char *v24; // x8
  unsigned __int64 v25; // x9
  signed __int64 v26; // x10
  int8x16_t *v27; // x10
  int8x16_t *v28; // x11
  unsigned __int64 v29; // x12
  int8x16_t v30; // q0
  int8x16_t v31; // q1
  int8x16_t v32; // q1
  _BYTE *v33; // x8
  char *v34; // x10
  size_t v35; // x9
  char v36; // t1
  void *v37[4]; // [xsp+8h] [xbp-78h]
  __int64 v38; // [xsp+28h] [xbp-58h]

  v6 = a6;
  v7 = a4;
  v8 = a2;
  v9 = a1;
  v38 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a5 )
    v10 = a5;
  else
    v10 = a4;
  v11 = X509_TRUST_get_flags(a4);
  if ( BN_is_zero(*(_QWORD *)(v9 + 8)) )
  {
    v12 = 120;
    v13 = 597;
LABEL_33:
    ERR_put_error(4, 0LL, v12, (__int64)"external/boringssl/src/crypto/rsa/padding.c", v13);
    v20 = 0LL;
    goto LABEL_34;
  }
  v14 = ((unsigned __int8)BN_num_bits(*(_QWORD *)(v9 + 8)) + 7) & 7;
  v15 = RSA_size(v9);
  v16 = v15;
  if ( !v14 )
  {
    *v8++ = 0;
    v16 = v15 - 1LL;
  }
  if ( v16 < v11 + 2 )
  {
    v12 = 114;
    v13 = 610;
    goto LABEL_33;
  }
  v17 = v11;
  if ( v6 != -1 )
  {
    if ( v6 == -2 )
    {
      v17 = -2 - v11 + v16;
    }
    else
    {
      if ( v6 & 0x80000000 )
      {
        v12 = 138;
        v13 = 624;
        goto LABEL_33;
      }
      v17 = v6;
    }
  }
  v18 = v16 - v11;
  if ( v16 - v11 - 2 < v17 )
  {
    v12 = 114;
    v13 = 631;
    goto LABEL_33;
  }
  if ( v17 )
  {
    v19 = (char *)malloc(v17);
    v20 = v19;
    if ( !v19 )
    {
      ERR_put_error(4, 0LL, 65, (__int64)"external/boringssl/src/crypto/rsa/padding.c", 638);
      goto LABEL_34;
    }
    if ( !(unsigned int)RAND_pseudo_bytes((signed __int64)v19, v17) )
      goto LABEL_34;
  }
  else
  {
    v20 = 0LL;
  }
  EVP_MD_CTX_init(v37);
  if ( !(unsigned int)EVP_DigestInit_ex((__int64 *)v37, v7)
    || !(unsigned int)EVP_DigestUpdate((__int64)v37)
    || !(unsigned int)EVP_DigestUpdate((__int64)v37)
    || !(unsigned int)EVP_DigestUpdate((__int64)v37) )
  {
    EVP_MD_CTX_cleanup(v37);
    goto LABEL_34;
  }
  v21 = v18 - 1;
  v22 = (__int64)&v8[v18 - 1];
  v23 = EVP_DigestFinal_ex(v37, (__int64)&v8[v18 - 1], 0LL);
  EVP_MD_CTX_cleanup(v37);
  if ( v23 && (unsigned int)sub_5BDB8(v8, v21, v22, v11, v10) )
  {
    v24 = &v8[-2 - v11 + v16 - v17];
    *v24 ^= 1u;
    if ( v17 )
    {
      if ( v17 >= 0x20 )
      {
        v25 = v17 & 0xFFFFFFFFFFFFFFE0LL;
        if ( v17 & 0xFFFFFFFFFFFFFFE0LL )
        {
          v26 = v16 - 1 - v11;
          if ( &v8[v26 - v17] >= &v20[v17] || v20 >= &v8[v26] )
          {
            v24 += v25;
            v27 = (int8x16_t *)(v20 + 16);
            v28 = (int8x16_t *)&v8[v16 + 15 - v11 - v17];
            v29 = v17 & 0xFFFFFFFFFFFFFFE0LL;
            do
            {
              v30 = v27[-1];
              v31 = *v27;
              v27 += 2;
              v29 -= 32LL;
              v32 = veorq_s8(*v28, v31);
              v28[-1] = veorq_s8(v28[-1], v30);
              *v28 = v32;
              v28 += 2;
            }
            while ( v29 );
            if ( v17 == v25 )
              goto LABEL_47;
          }
          else
          {
            v25 = 0LL;
          }
        }
      }
      else
      {
        v25 = 0LL;
      }
      v33 = v24 + 1;
      v34 = &v20[v25];
      v35 = v17 - v25;
      do
      {
        v36 = *v34++;
        --v35;
        *v33++ ^= v36;
      }
      while ( v35 );
    }
LABEL_47:
    if ( v14 )
      *v8 &= 0xFFu >> (8 - v14);
    v8[v16 - 1] = -68;
  }
LABEL_34:
  free(v20);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v38;
}

//----- (000000000005C9DC) ----------------------------------------------------
_QWORD *RSA_new()
{
  return RSA_new_method(0LL);
}

//----- (000000000005C9E4) ----------------------------------------------------
_QWORD *__fastcall RSA_new_method(__int64 a1)
{
  __int64 v1; // x20
  _QWORD *v2; // x0
  _QWORD *v3; // x19
  void *v4; // x0
  __int64 v5; // x8
  unsigned int (__fastcall *v6)(_QWORD *); // x8

  v1 = a1;
  v2 = malloc(0xC8uLL);
  v3 = v2;
  if ( v2 )
  {
    memset(v2, 0, 0xC8uLL);
    if ( !v1 || (v4 = (void *)lh_num_items(v1), (*v3 = v4) == 0LL) )
    {
      v4 = &unk_D7180;
      *v3 = &unk_D7180;
    }
    std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(v4);
    v5 = *v3;
    *((_DWORD *)v3 + 22) = 1;
    *((_DWORD *)v3 + 23) = *(_DWORD *)(v5 + 112);
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v3 + 12));
    CRYPTO_new_ex_data(v3 + 10);
    v6 = *(unsigned int (__fastcall **)(_QWORD *))(*v3 + 16LL);
    if ( v6 && !v6(v3) )
    {
      CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_107148, (__int64)v3, (unsigned __int64 **)v3 + 10);
      CRYPTO_MUTEX_cleanup(v3 + 12);
      std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(*v3);
      free(v3);
      v3 = 0LL;
    }
  }
  else
  {
    ERR_put_error(4, 0LL, 65, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", 81);
  }
  return v3;
}
// 34D44: using guessed type __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(_QWORD);
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);

//----- (000000000005CAE4) ----------------------------------------------------
void __fastcall sub_5CAE4(void ***a1)
{
  void ***v1; // x19

  v1 = a1;
  if ( a1 )
  {
    BN_clear_free(*a1);
    BN_clear_free(v1[1]);
    BN_clear_free(v1[2]);
    BN_clear_free(v1[3]);
    BN_MONT_CTX_free(v1[4]);
    free(v1);
  }
}

//----- (000000000005CB3C) ----------------------------------------------------
void __fastcall RSA_free(int *a1)
{
  unsigned __int64 **v1; // x19
  unsigned __int64 *v2; // x0
  void (__fastcall *v3)(unsigned __int64 **); // x8
  unsigned __int64 *v4; // x0
  unsigned __int64 v5; // x20
  unsigned __int64 *v6; // x0

  v1 = (unsigned __int64 **)a1;
  if ( a1 && (unsigned int)CRYPTO_refcount_dec_and_test_zero(a1 + 22) )
  {
    v2 = *v1;
    v3 = (void (__fastcall *)(unsigned __int64 **))(*v1)[3];
    if ( v3 )
    {
      v3(v1);
      v2 = *v1;
    }
    std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(v2);
    CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_107148, (__int64)v1, v1 + 10);
    BN_clear_free((void **)v1[1]);
    BN_clear_free((void **)v1[2]);
    BN_clear_free((void **)v1[3]);
    BN_clear_free((void **)v1[4]);
    BN_clear_free((void **)v1[5]);
    BN_clear_free((void **)v1[6]);
    BN_clear_free((void **)v1[7]);
    BN_clear_free((void **)v1[8]);
    BN_MONT_CTX_free(v1[19]);
    BN_MONT_CTX_free(v1[20]);
    BN_MONT_CTX_free(v1[21]);
    v4 = v1[23];
    if ( *((_DWORD *)v1 + 44) )
    {
      v5 = 0LL;
      do
      {
        ECDSA_SIG_free((_DWORD **)v4[v5]);
        v4 = v1[23];
        ++v5;
      }
      while ( v5 < *((unsigned int *)v1 + 44) );
    }
    free(v4);
    free(v1[24]);
    v6 = v1[9];
    if ( v6 )
      sk_pop_free(v6, (void (*)(void))sub_5CAE4);
    CRYPTO_MUTEX_cleanup(v1 + 12);
    free(v1);
  }
}
// 34D44: using guessed type __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(_QWORD);
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);

//----- (000000000005CC54) ----------------------------------------------------
signed __int64 __fastcall RSA_up_ref(__int64 a1)
{
  CRYPTO_refcount_inc((_DWORD *)(a1 + 88));
  return 1LL;
}

//----- (000000000005CC70) ----------------------------------------------------
_QWORD *__fastcall RSA_get0_key(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if ( a2 )
    *a2 = result[1];
  if ( a3 )
    *a3 = result[2];
  if ( a4 )
    *a4 = result[3];
  return result;
}

//----- (000000000005CC98) ----------------------------------------------------
__int64 __fastcall RSA_get0_factors(__int64 result, _QWORD *a2, _QWORD *a3)
{
  if ( a2 )
    *a2 = *(_QWORD *)(result + 32);
  if ( a3 )
    *a3 = *(_QWORD *)(result + 40);
  return result;
}

//----- (000000000005CCB4) ----------------------------------------------------
_QWORD *__fastcall RSA_get0_crt_params(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if ( a2 )
    *a2 = result[6];
  if ( a3 )
    *a3 = result[7];
  if ( a4 )
    *a4 = result[8];
  return result;
}

//----- (000000000005CCDC) ----------------------------------------------------
__int64 __fastcall RSA_generate_key_ex(__int64 a1)
{
  __int64 (*v1)(void); // x4

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 120LL);
  if ( !v1 )
    JUMPOUT(&loc_5FFC4);
  return v1();
}

//----- (000000000005CCF0) ----------------------------------------------------
__int64 __fastcall RSA_generate_multi_prime_key(__int64 a1, int a2, signed int a3, __int64 a4, __int64 a5)
{
  __int64 (*v5)(void); // x5
  signed int v7; // w22
  __int64 v8; // x27
  __int64 v9; // x26
  int v10; // w20
  __int64 v11; // x21
  int v12; // w24
  unsigned int v13; // w21
  unsigned __int64 *v14; // x20
  _DWORD *v15; // x0
  __int64 v16; // x19
  _QWORD *v17; // x28
  _QWORD *v18; // x25
  _QWORD *v19; // x23
  _QWORD *v20; // x0
  signed int v21; // w23
  _QWORD *v22; // x0
  __int64 v23; // x25
  _QWORD *v24; // x0
  void **v25; // x8
  int v26; // w2
  __int16 v27; // w4
  _QWORD *v28; // x0
  _QWORD *v29; // x0
  _QWORD *v30; // x0
  _QWORD *v31; // x0
  _QWORD *v32; // x0
  _QWORD *v33; // x0
  _QWORD *v34; // x0
  _QWORD *v35; // x0
  unsigned int v36; // w28
  __int64 v37; // x26
  int v38; // w25
  int v39; // w0
  __int64 v40; // x23
  void **v41; // x0
  int v42; // w0
  unsigned int v43; // w26
  int v44; // w28
  int v45; // w0
  int v46; // w0
  int v47; // w0
  __int64 v48; // x23
  void **v49; // x0
  int v50; // w0
  signed __int64 v51; // x28
  int v52; // w25
  __int64 v53; // x8
  signed __int64 v54; // x24
  unsigned __int64 *v55; // x23
  signed int v56; // w26
  int v57; // w0
  signed __int64 v58; // x28
  signed __int64 v59; // x25
  __int64 *v60; // x0
  __int64 *v61; // x28
  __int64 *v62; // x23
  void **v63; // x0
  int v64; // w0
  __int64 v65; // x0
  __int64 v66; // x25
  __int64 v67; // x8
  void **v68; // x0
  __int64 v69; // x23
  void **v70; // x0
  unsigned __int64 v71; // x25
  __int64 v72; // x23
  void **v73; // x0
  signed __int64 v74; // x8
  __int64 v75; // x0
  unsigned __int64 v76; // x22
  __int64 *v77; // x24
  __int64 v78; // x25
  __int64 v79; // x26
  void **v80; // x0
  signed __int64 v81; // x8
  int v82; // [xsp+Ch] [xbp-B4h]
  signed __int64 v83; // [xsp+18h] [xbp-A8h]
  __int64 v84; // [xsp+20h] [xbp-A0h]
  unsigned int v85; // [xsp+2Ch] [xbp-94h]
  __int64 v86; // [xsp+38h] [xbp-88h]
  _QWORD *v87; // [xsp+40h] [xbp-80h]
  __int64 v88; // [xsp+40h] [xbp-80h]
  _QWORD *v89; // [xsp+48h] [xbp-78h]
  __int64 v90; // [xsp+48h] [xbp-78h]
  __int64 v91; // [xsp+50h] [xbp-70h]
  int v92; // [xsp+5Ch] [xbp-64h]

  v5 = *(__int64 (**)(void))(*(_QWORD *)a1 + 128LL);
  if ( v5 )
    return v5();
  v7 = a3;
  v8 = a5;
  v9 = a4;
  v10 = a2;
  v11 = a1;
  v12 = a3 - 1;
  if ( a3 > 1 )
  {
    v15 = BN_CTX_new();
    v16 = (__int64)v15;
    if ( v15 )
    {
      v92 = v10;
      BN_CTX_start((__int64)v15);
      v17 = BN_CTX_get(v16);
      v18 = BN_CTX_get(v16);
      v19 = BN_CTX_get(v16);
      v20 = BN_CTX_get(v16);
      v14 = 0LL;
      v91 = (__int64)v17;
      if ( v17 && v18 && v19 && v20 )
      {
        v86 = (__int64)v20;
        if ( v7 >= 3 )
        {
          v14 = sk_new_null();
          if ( v14 )
          {
            v87 = v19;
            v89 = v18;
            v21 = 2;
            while ( 1 )
            {
              v22 = malloc(0x28uLL);
              v23 = (__int64)v22;
              if ( !v22 )
                break;
              v22[3] = 0LL;
              v22[4] = 0LL;
              v22[1] = 0LL;
              v22[2] = 0LL;
              *v22 = 0LL;
              *v22 = BN_new();
              *(_QWORD *)(v23 + 8) = BN_new();
              *(_QWORD *)(v23 + 16) = BN_new();
              v24 = BN_new();
              v25 = *(void ***)v23;
              *(_QWORD *)(v23 + 24) = v24;
              if ( !v25 || !*(_QWORD *)(v23 + 8) || !v24 || !*(_QWORD *)(v23 + 16) || !sk_push(v14, v23) )
              {
                sub_5CAE4((void ***)v23);
                goto LABEL_23;
              }
              if ( ++v21 >= v7 )
              {
                v19 = v87;
                v18 = v89;
                if ( *(_QWORD *)(v11 + 8) )
                  goto LABEL_30;
                goto LABEL_29;
              }
            }
          }
          goto LABEL_23;
        }
        v14 = 0LL;
        if ( *(_QWORD *)(v11 + 8) )
          goto LABEL_30;
LABEL_29:
        v28 = BN_new();
        *(_QWORD *)(v11 + 8) = v28;
        if ( v28 )
        {
LABEL_30:
          if ( *(_QWORD *)(v11 + 24) || (v29 = BN_new(), (*(_QWORD *)(v11 + 24) = v29) != 0LL) )
          {
            if ( *(_QWORD *)(v11 + 16) || (v30 = BN_new(), (*(_QWORD *)(v11 + 16) = v30) != 0LL) )
            {
              if ( *(_QWORD *)(v11 + 32) || (v31 = BN_new(), (*(_QWORD *)(v11 + 32) = v31) != 0LL) )
              {
                if ( *(_QWORD *)(v11 + 40) || (v32 = BN_new(), (*(_QWORD *)(v11 + 40) = v32) != 0LL) )
                {
                  if ( *(_QWORD *)(v11 + 48) || (v33 = BN_new(), (*(_QWORD *)(v11 + 48) = v33) != 0LL) )
                  {
                    if ( *(_QWORD *)(v11 + 56) || (v34 = BN_new(), (*(_QWORD *)(v11 + 56) = v34) != 0LL) )
                    {
                      if ( *(_QWORD *)(v11 + 64) || (v35 = BN_new(), (*(_QWORD *)(v11 + 64) = v35) != 0LL) )
                      {
                        if ( BN_copy(*(_QWORD *)(v11 + 16), v9) )
                        {
                          v88 = (__int64)v19;
                          v90 = (__int64)v18;
                          v36 = 0;
                          v37 = (__int64)v19;
                          v38 = (v12 + v92) / v7;
                          while ( 1 )
                          {
                            BN_generate_prime_ex(*(__int64 **)(v11 + 32), v38, 0, 0LL, 0LL, v8);
                            if ( !v39 )
                              break;
                            v40 = *(_QWORD *)(v11 + 32);
                            v41 = BN_value_one();
                            if ( !(unsigned int)BN_sub(v37, v40, (__int64)v41)
                              || !(unsigned int)BN_gcd(v90, v37, *(_QWORD *)(v11 + 16), v16) )
                            {
                              break;
                            }
                            if ( BN_is_one(v90) )
                            {
                              v43 = v36;
                              if ( (unsigned int)BN_GENCB_call(v8, 3u, 0) )
                              {
                                v44 = (v92 + v7 - 2 - v38) / v12;
                                while ( 1 )
                                {
                                  BN_generate_prime_ex(*(__int64 **)(v11 + 40), v44, 0, 0LL, 0LL, v8);
                                  if ( !v45 )
                                    break;
                                  if ( !(unsigned int)BN_cmp(*(_QWORD *)(v11 + 32), *(_QWORD *)(v11 + 40)) )
                                  {
                                    BN_generate_prime_ex(*(__int64 **)(v11 + 40), v44, 0, 0LL, 0LL, v8);
                                    if ( !v46 )
                                      goto LABEL_23;
                                    if ( !(unsigned int)BN_cmp(*(_QWORD *)(v11 + 32), *(_QWORD *)(v11 + 40)) )
                                    {
                                      BN_generate_prime_ex(*(__int64 **)(v11 + 40), v44, 0, 0LL, 0LL, v8);
                                      if ( !v47 )
                                        goto LABEL_23;
                                      if ( !(unsigned int)BN_cmp(*(_QWORD *)(v11 + 32), *(_QWORD *)(v11 + 40)) )
                                      {
                                        v26 = 126;
                                        v27 = 883;
                                        goto LABEL_24;
                                      }
                                    }
                                  }
                                  v48 = *(_QWORD *)(v11 + 40);
                                  v49 = BN_value_one();
                                  if ( !(unsigned int)BN_sub(v88, v48, (__int64)v49)
                                    || !(unsigned int)BN_gcd(v90, v88, *(_QWORD *)(v11 + 16), v16) )
                                  {
                                    goto LABEL_23;
                                  }
                                  if ( BN_is_one(v90) )
                                  {
                                    if ( !(unsigned int)BN_GENCB_call(v8, 3u, 1u) )
                                      goto LABEL_23;
                                    v85 = v43;
                                    if ( !(unsigned int)BN_mul(
                                                          *(_QWORD *)(v11 + 8),
                                                          *(_QWORD *)(v11 + 32),
                                                          *(_QWORD *)(v11 + 40),
                                                          v16) )
                                      goto LABEL_23;
                                    v51 = v7;
                                    v52 = v7 + v92;
                                    v53 = (unsigned int)v12;
                                    v54 = 2LL;
                                    v84 = v53;
LABEL_69:
                                    if ( v51 > v54 )
                                    {
                                      v55 = sk_value(v14, v54 - 2);
                                      v83 = v51;
                                      v56 = (v52 + ~(_DWORD)v54 - (unsigned int)BN_num_bits(*(_QWORD *)(v11 + 8)))
                                          / ((signed int)v51 - (signed int)v54);
                                      v82 = v52;
                                      while ( 1 )
                                      {
                                        BN_generate_prime_ex((__int64 *)*v55, v56, 0, 0LL, 0LL, v8);
                                        if ( !v57 )
                                          goto LABEL_23;
                                        if ( (unsigned int)BN_cmp(*(_QWORD *)(v11 + 32), *v55)
                                          && (unsigned int)BN_cmp(*(_QWORD *)(v11 + 40), *v55) )
                                        {
                                          if ( v54 < 3 )
                                          {
                                            v58 = v54 - 2;
                                            LODWORD(v59) = 0;
                                          }
                                          else
                                          {
                                            v58 = v54 - 2;
                                            v59 = 0LL;
                                            do
                                            {
                                              v60 = (__int64 *)sk_value(v14, v59);
                                              if ( !(unsigned int)BN_cmp(*v60, *v55) )
                                                break;
                                              ++v59;
                                            }
                                            while ( v59 < v54 - 2 );
                                          }
                                          if ( (unsigned int)v59 == v58 )
                                          {
                                            v61 = (__int64 *)v55;
                                            v62 = (__int64 *)*v55;
                                            v63 = BN_value_one();
                                            if ( !(unsigned int)BN_sub(v88, (__int64)v62, (__int64)v63)
                                              || !(unsigned int)BN_gcd(v90, v88, *(_QWORD *)(v11 + 16), v16) )
                                            {
                                              goto LABEL_23;
                                            }
                                            v55 = (unsigned __int64 *)v61;
                                            if ( BN_is_one(v90) )
                                            {
                                              if ( v54 != v84 )
                                                goto LABEL_126;
                                              if ( !(unsigned int)BN_mul(v90, *(_QWORD *)(v11 + 8), *v61, v16) )
                                                goto LABEL_23;
                                              if ( (unsigned int)BN_num_bits(v90) == v92 )
                                              {
LABEL_126:
                                                if ( !BN_copy(v61[3], *(_QWORD *)(v11 + 8)) )
                                                  goto LABEL_23;
                                                v65 = *(_QWORD *)(v11 + 8);
                                                if ( v54 == v84 )
                                                {
                                                  if ( !BN_copy(v65, v90) )
                                                    goto LABEL_23;
                                                }
                                                else if ( !(unsigned int)BN_mul(v65, *(_QWORD *)(v11 + 8), *v61, v16) )
                                                {
                                                  goto LABEL_23;
                                                }
                                                ++v54;
                                                v52 = v82;
                                                v51 = v83;
                                                if ( (unsigned int)BN_GENCB_call(v8, 3u, 1u) )
                                                  goto LABEL_69;
                                                goto LABEL_23;
                                              }
                                              v64 = BN_GENCB_call(v8, 2u, v85++);
                                              v55 = (unsigned __int64 *)v61;
                                              if ( !v64 )
                                                goto LABEL_23;
                                            }
                                          }
                                        }
                                      }
                                    }
                                    if ( BN_cmp(*(_QWORD *)(v11 + 32), *(_QWORD *)(v11 + 40)) & 0x80000000 )
                                    {
                                      v67 = *(_QWORD *)(v11 + 32);
                                      v66 = *(_QWORD *)(v11 + 40);
                                      *(_QWORD *)(v11 + 32) = v66;
                                      *(_QWORD *)(v11 + 40) = v67;
                                    }
                                    else
                                    {
                                      v66 = *(_QWORD *)(v11 + 32);
                                    }
                                    v68 = BN_value_one();
                                    if ( !(unsigned int)BN_sub(v90, v66, (__int64)v68) )
                                      goto LABEL_23;
                                    v69 = *(_QWORD *)(v11 + 40);
                                    v70 = BN_value_one();
                                    if ( !(unsigned int)BN_sub(v88, v69, (__int64)v70)
                                      || !(unsigned int)BN_mul(v91, v90, v88, v16) )
                                    {
                                      goto LABEL_23;
                                    }
                                    if ( v7 >= 3 )
                                    {
                                      v71 = 0LL;
                                      do
                                      {
                                        v72 = *sk_value(v14, v71);
                                        v73 = BN_value_one();
                                        if ( !(unsigned int)BN_sub(v86, v72, (__int64)v73)
                                          || !(unsigned int)BN_mul(v91, v91, v86, v16) )
                                        {
                                          goto LABEL_23;
                                        }
                                        v74 = v71++ + 3;
                                      }
                                      while ( v74 < v51 );
                                    }
                                    BN_mod_inverse(*(_QWORD **)(v11 + 24), *(signed int **)(v11 + 16), v91, v16);
                                    if ( !v75
                                      || !(unsigned int)BN_div(
                                                          0LL,
                                                          *(_QWORD *)(v11 + 48),
                                                          *(_QWORD *)(v11 + 24),
                                                          v90,
                                                          v16)
                                      || !(unsigned int)BN_div(
                                                          0LL,
                                                          *(_QWORD *)(v11 + 56),
                                                          *(_QWORD *)(v11 + 24),
                                                          v88,
                                                          v16)
                                      || !sub_6BAC4(
                                            (__int64 *)(v11 + 160),
                                            (pthread_rwlock_t *)(v11 + 96),
                                            *(_QWORD *)(v11 + 32))
                                      || !(unsigned int)sub_6A064(
                                                          *(_QWORD *)(v11 + 64),
                                                          *(_QWORD *)(v11 + 40),
                                                          *(_QWORD *)(v11 + 32),
                                                          v16,
                                                          *(_QWORD *)(v11 + 160)) )
                                    {
                                      goto LABEL_23;
                                    }
                                    if ( v7 >= 3 )
                                    {
                                      v76 = 0LL;
                                      do
                                      {
                                        v77 = (__int64 *)sk_value(v14, v76);
                                        v78 = *v77;
                                        v79 = v77[1];
                                        v80 = BN_value_one();
                                        if ( !(unsigned int)BN_sub(v79, v78, (__int64)v80)
                                          || !(unsigned int)BN_div(0LL, v77[1], *(_QWORD *)(v11 + 24), v77[1], v16)
                                          || !sub_6BAC4(v77 + 4, (pthread_rwlock_t *)(v11 + 96), *v77)
                                          || !(unsigned int)sub_6A064(v77[2], v77[3], *v77, v16, v77[4]) )
                                        {
                                          goto LABEL_23;
                                        }
                                        v81 = v76++ + 3;
                                      }
                                      while ( v81 < v51 );
                                    }
                                    *(_QWORD *)(v11 + 72) = v14;
                                    v13 = RSA_check_key((_QWORD *)v11);
                                    v14 = 0LL;
                                    if ( v13 == -1 )
                                      goto LABEL_23;
                                    if ( !v13 )
                                    {
                                      ERR_put_error(
                                        4,
                                        0LL,
                                        124,
                                        (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c",
                                        1044);
                                      v14 = 0LL;
                                      if ( v16 )
                                        goto LABEL_26;
                                      goto LABEL_27;
                                    }
                                    goto LABEL_25;
                                  }
                                  v50 = BN_GENCB_call(v8, 2u, v43++);
                                  if ( !v50 )
                                    goto LABEL_23;
                                }
                              }
                              goto LABEL_23;
                            }
                            v42 = BN_GENCB_call(v8, 2u, v36++);
                            if ( !v42 )
                              goto LABEL_23;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          goto LABEL_23;
        }
      }
    }
    else
    {
      v14 = 0LL;
    }
LABEL_23:
    v26 = 3;
    v27 = 1049;
LABEL_24:
    ERR_put_error(4, 0LL, v26, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v27);
    v13 = 0;
LABEL_25:
    if ( v16 )
    {
LABEL_26:
      BN_CTX_end(v16);
      BN_CTX_free(v16);
    }
    goto LABEL_27;
  }
  ERR_put_error(4, 0LL, 129, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", 778);
  v13 = 0;
  v14 = 0LL;
LABEL_27:
  sk_pop_free(v14, (void (*)(void))sub_5CAE4);
  return v13;
}

//----- (000000000005CD04) ----------------------------------------------------
__int64 __fastcall RSA_encrypt(__int64 a1, size_t *a2, _BYTE *a3, size_t a4, const void *a5, size_t a6, int a7)
{
  __int64 (*v7)(void); // x7
  __int64 result; // x0

  v7 = *(__int64 (**)(void))(*(_QWORD *)a1 + 56LL);
  if ( v7 )
    result = v7();
  else
    result = sub_5EF88(a1, a2, a3, a4, a5, a6, a7);
  return result;
}

//----- (000000000005CD18) ----------------------------------------------------
signed __int64 __fastcall RSA_public_encrypt(size_t a1, const void *a2, _BYTE *a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // x22
  unsigned int v6; // w19
  _BYTE *v7; // x21
  const void *v8; // x20
  size_t v9; // x23
  __int64 (__fastcall *v10)(__int64); // x8
  unsigned int v11; // w0
  unsigned int (__fastcall *v12)(__int64, unsigned __int64 *, _BYTE *, _QWORD, const void *, size_t, _QWORD); // x8
  signed __int64 result; // x0
  unsigned __int64 v14; // [xsp+0h] [xbp-40h]
  __int64 v15; // [xsp+8h] [xbp-38h]

  v5 = a4;
  v6 = a5;
  v7 = a3;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a2;
  v9 = a1;
  v10 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 32LL);
  if ( v10 )
    v11 = v10(a4);
  else
    v11 = sub_5EF6C(a4);
  v12 = *(unsigned int (__fastcall **)(__int64, unsigned __int64 *, _BYTE *, _QWORD, const void *, size_t, _QWORD))(*(_QWORD *)v5 + 56LL);
  if ( v12 )
  {
    if ( !v12(v5, &v14, v7, v11, v8, v9, v6) )
      goto LABEL_10;
  }
  else if ( !(unsigned int)sub_5EF88(v5, &v14, v7, v11, v8, v9, v6) )
  {
LABEL_10:
    result = 0xFFFFFFFFLL;
    goto LABEL_11;
  }
  result = v14;
  if ( v14 >> 31 )
  {
    ERR_put_error(4, 0LL, 69, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", 243);
    goto LABEL_10;
  }
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005CE04) ----------------------------------------------------
__int64 __fastcall RSA_size(__int64 a1)
{
  __int64 (*v1)(void); // x8
  __int64 result; // x0

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 32LL);
  if ( v1 )
    result = v1();
  else
    result = sub_5EF6C(a1);
  return result;
}

//----- (000000000005CE2C) ----------------------------------------------------
__int64 __fastcall RSA_sign_raw(__int64 a1, size_t *a2, _BYTE *a3, unsigned __int64 a4, const void *a5, size_t a6, int a7)
{
  __int64 (*v7)(void); // x7
  __int64 result; // x0

  v7 = *(__int64 (**)(void))(*(_QWORD *)a1 + 64LL);
  if ( v7 )
    result = v7();
  else
    result = sub_5F2B0(a1, a2, a3, a4, a5, a6, a7);
  return result;
}

//----- (000000000005CE40) ----------------------------------------------------
signed __int64 __fastcall RSA_private_encrypt(size_t a1, const void *a2, _BYTE *a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // x22
  unsigned int v6; // w19
  _BYTE *v7; // x21
  const void *v8; // x20
  size_t v9; // x23
  __int64 (__fastcall *v10)(__int64); // x8
  unsigned int v11; // w0
  unsigned int (__fastcall *v12)(__int64, unsigned __int64 *, _BYTE *, _QWORD, const void *, size_t, _QWORD); // x8
  signed __int64 result; // x0
  unsigned __int64 v14; // [xsp+0h] [xbp-40h]
  __int64 v15; // [xsp+8h] [xbp-38h]

  v5 = a4;
  v6 = a5;
  v7 = a3;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a2;
  v9 = a1;
  v10 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 32LL);
  if ( v10 )
    v11 = v10(a4);
  else
    v11 = sub_5EF6C(a4);
  v12 = *(unsigned int (__fastcall **)(__int64, unsigned __int64 *, _BYTE *, _QWORD, const void *, size_t, _QWORD))(*(_QWORD *)v5 + 64LL);
  if ( v12 )
  {
    if ( !v12(v5, &v14, v7, v11, v8, v9, v6) )
      goto LABEL_10;
  }
  else if ( !(unsigned int)sub_5F2B0(v5, &v14, v7, v11, v8, v9, v6) )
  {
LABEL_10:
    result = 0xFFFFFFFFLL;
    goto LABEL_11;
  }
  result = v14;
  if ( v14 >> 31 )
  {
    ERR_put_error(4, 0LL, 69, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", 267);
    goto LABEL_10;
  }
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005CF2C) ----------------------------------------------------
__int64 __fastcall RSA_decrypt(__int64 a1, _QWORD *a2, unsigned __int8 *a3, unsigned __int64 a4, unsigned __int8 *a5, size_t a6, int a7)
{
  __int64 (*v7)(void); // x7
  __int64 result; // x0

  v7 = *(__int64 (**)(void))(*(_QWORD *)a1 + 72LL);
  if ( v7 )
    result = v7();
  else
    result = sub_5F400(a1, a2, a3, a4, a5, a6, a7);
  return result;
}

//----- (000000000005CF40) ----------------------------------------------------
signed __int64 __fastcall RSA_private_decrypt(size_t a1, unsigned __int8 *a2, unsigned __int8 *a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // x22
  unsigned int v6; // w19
  unsigned __int8 *v7; // x21
  unsigned __int8 *v8; // x20
  size_t v9; // x23
  __int64 (__fastcall *v10)(__int64); // x8
  unsigned int v11; // w0
  unsigned int (__fastcall *v12)(__int64, unsigned __int64 *, unsigned __int8 *, _QWORD, unsigned __int8 *, size_t, _QWORD); // x8
  signed __int64 result; // x0
  unsigned __int64 v14; // [xsp+0h] [xbp-40h]
  __int64 v15; // [xsp+8h] [xbp-38h]

  v5 = a4;
  v6 = a5;
  v7 = a3;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a2;
  v9 = a1;
  v10 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 32LL);
  if ( v10 )
    v11 = v10(a4);
  else
    v11 = sub_5EF6C(a4);
  v12 = *(unsigned int (__fastcall **)(__int64, unsigned __int64 *, unsigned __int8 *, _QWORD, unsigned __int8 *, size_t, _QWORD))(*(_QWORD *)v5 + 72LL);
  if ( v12 )
  {
    if ( !v12(v5, &v14, v7, v11, v8, v9, v6) )
      goto LABEL_10;
  }
  else if ( !(unsigned int)sub_5F400(v5, &v14, v7, v11, v8, v9, v6) )
  {
LABEL_10:
    result = 0xFFFFFFFFLL;
    goto LABEL_11;
  }
  result = v14;
  if ( v14 >> 31 )
  {
    ERR_put_error(4, 0LL, 69, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", 291);
    goto LABEL_10;
  }
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005D02C) ----------------------------------------------------
signed __int64 __fastcall RSA_public_decrypt(size_t a1, unsigned __int8 *a2, _BYTE *a3, __int64 a4, int a5)
{
  __int64 v5; // x21
  int v6; // w19
  _BYTE *v7; // x22
  unsigned __int8 *v8; // x20
  size_t v9; // x23
  __int64 (__fastcall *v10)(__int64); // x8
  unsigned int v11; // w0
  signed __int64 result; // x0
  unsigned __int64 v13; // [xsp+0h] [xbp-40h]
  __int64 v14; // [xsp+8h] [xbp-38h]

  v5 = a4;
  v6 = a5;
  v7 = a3;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a2;
  v9 = a1;
  v10 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 32LL);
  if ( v10 )
    v11 = v10(a4);
  else
    v11 = sub_5EF6C(a4);
  if ( !(unsigned int)RSA_verify_raw(v5, &v13, v7, v11, v8, v9, v6) )
    goto LABEL_7;
  result = v13;
  if ( v13 >> 31 )
  {
    ERR_put_error(4, 0LL, 69, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", 306);
LABEL_7:
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005D11C) ----------------------------------------------------
__int64 __fastcall RSA_supports_digest(__int64 a1)
{
  __int64 (*v1)(void); // x2
  __int64 result; // x0

  if ( *(_QWORD *)a1 && (v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 136LL)) != 0LL )
    result = v1();
  else
    result = 1LL;
  return result;
}

//----- (000000000005D138) ----------------------------------------------------
signed __int64 __fastcall RSA_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // x19
  int v6; // w0
  __int64 v7; // x9
  signed __int64 result; // x0
  unsigned int v9; // [xsp+4h] [xbp-1Ch]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = *(_QWORD *)(v5 + 40);
  v6 = CRYPTO_get_ex_new_index((pthread_rwlock_t *)&unk_107148, &v9, a1, a2, a4, a5);
  v7 = *(_QWORD *)(v5 + 40);
  if ( v6 )
    result = v9;
  else
    result = 1LL;
  return result;
}

//----- (000000000005D1B4) ----------------------------------------------------
signed __int64 __fastcall RSA_set_ex_data(__int64 a1, int a2, __int64 a3)
{
  return CRYPTO_set_ex_data((unsigned __int64 **)(a1 + 80), a2, a3);
}

//----- (000000000005D1BC) ----------------------------------------------------
unsigned __int64 *__fastcall RSA_get_ex_data(__int64 a1, int a2)
{
  return CRYPTO_get_ex_data((unsigned __int64 **)(a1 + 80), a2);
}

//----- (000000000005D1C4) ----------------------------------------------------
signed __int64 __fastcall RSA_add_pkcs1_prefix(_QWORD *a1, size_t *a2, _DWORD *a3, signed int a4, const void *a5, size_t a6)
{
  size_t v6; // x23
  const void *v7; // x22
  _DWORD *v8; // x19
  size_t *v9; // x20
  _QWORD *v10; // x21
  signed __int64 v11; // x8
  signed __int64 result; // x0
  int v13; // w2
  __int16 v14; // w4
  char *v15; // x27
  size_t v16; // x25
  size_t v17; // x24
  char *v18; // x0
  char *v19; // x26

  v6 = a6;
  v7 = a5;
  v8 = a3;
  v9 = a2;
  v10 = a1;
  if ( a4 > 671 )
  {
    switch ( a4 )
    {
      case 672:
        v11 = 3LL;
        goto LABEL_15;
      case 673:
        v11 = 4LL;
        goto LABEL_15;
      case 674:
        v11 = 5LL;
        goto LABEL_15;
      case 675:
        v11 = 2LL;
        goto LABEL_15;
      default:
        break;
    }
def_5D218:
    v13 = 142;
    v14 = 459;
LABEL_23:
    ERR_put_error(4, 0LL, v13, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", v14);
    return 0LL;
  }
  switch ( a4 )
  {
    case 4:
      v11 = 0LL;
      break;
    case 64:
      v11 = 1LL;
      break;
    case 114:
      if ( a6 == 36 )
      {
        *a1 = a5;
        *a2 = 36LL;
        *a3 = 0;
        return 1LL;
      }
      v13 = 125;
      v14 = 416;
      goto LABEL_23;
    default:
      goto def_5D218;
  }
LABEL_15:
  v15 = (char *)&unk_D70D8 + 24 * v11;
  v16 = (unsigned __int8)v15[4];
  if ( (signed int)v16 + (signed int)a6 < (unsigned int)v16 )
  {
    v13 = 140;
    v14 = 439;
    goto LABEL_23;
  }
  v17 = (unsigned int)(v16 + a6);
  v18 = (char *)malloc(v17);
  v19 = v18;
  if ( !v18 )
  {
    v13 = 65;
    v14 = 445;
    goto LABEL_23;
  }
  memcpy(v18, v15 + 5, v16);
  if ( v6 )
    memcpy(&v19[v16], v7, v6);
  result = 1LL;
  *v10 = v19;
  *v9 = v17;
  *v8 = 1;
  return result;
}

//----- (000000000005D370) ----------------------------------------------------
void __fastcall RSA_sign(unsigned int a1, const void *a2, unsigned int a3, _BYTE *a4, _DWORD *a5, __int64 a6)
{
  __int64 v6; // x20
  _DWORD *v7; // x19
  _BYTE *v8; // x21
  unsigned int v9; // w24
  const void *v10; // x23
  unsigned int v11; // w25
  __int64 (__fastcall *v12)(__int64); // x8
  unsigned int v13; // w0
  unsigned int v14; // w22
  void (__fastcall *v15)(_QWORD, const void *, _QWORD, _BYTE *, _DWORD *, __int64); // x8
  unsigned int (__fastcall *v16)(__int64, __int64 *, _BYTE *, _QWORD, void *); // x8
  __int64 v17; // [xsp+8h] [xbp-68h]
  int v18; // [xsp+14h] [xbp-5Ch]
  size_t v19; // [xsp+18h] [xbp-58h]
  void *v20; // [xsp+20h] [xbp-50h]
  __int64 v21; // [xsp+28h] [xbp-48h]

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)a6 + 32LL);
  if ( v12 )
    v13 = v12(a6);
  else
    v13 = sub_5EF6C(a6);
  v18 = 0;
  v14 = v13;
  v15 = *(void (__fastcall **)(_QWORD, const void *, _QWORD, _BYTE *, _DWORD *, __int64))(*(_QWORD *)v6 + 40LL);
  if ( !v15 )
  {
    if ( !(unsigned int)RSA_add_pkcs1_prefix(&v20, &v19, &v18, v11, v10, v9) )
      goto LABEL_6;
    if ( v14 < 0xB || v19 > v14 - 11 )
    {
      ERR_put_error(4, 0LL, 118, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", 483);
      goto LABEL_12;
    }
    v16 = *(unsigned int (__fastcall **)(__int64, __int64 *, _BYTE *, _QWORD, void *))(*(_QWORD *)v6 + 64LL);
    if ( v16 )
    {
      if ( !v16(v6, &v17, v8, v14, v20) )
      {
LABEL_12:
        if ( !v18 )
          goto LABEL_6;
LABEL_13:
        free(v20);
        goto LABEL_6;
      }
    }
    else if ( !(unsigned int)sub_5F2B0(v6, (size_t *)&v17, v8, v14, v20, v19, 1) )
    {
      goto LABEL_12;
    }
    *v7 = v17;
    if ( !v18 )
      goto LABEL_6;
    goto LABEL_13;
  }
  v15(v11, v10, v9, v8, v7, v6);
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v21;
}

//----- (000000000005D4FC) ----------------------------------------------------
void __fastcall RSA_verify(signed int a1, const void *a2, size_t a3, unsigned __int8 *a4, size_t a5, _QWORD *a6)
{
  __int64 v6; // x24
  size_t v7; // x23
  unsigned __int8 *v8; // x25
  size_t v9; // x20
  const void *v10; // x21
  signed int v11; // w22
  __int64 (__fastcall *v12)(_QWORD *); // x8
  unsigned int v13; // w0
  int v14; // w2
  __int16 v15; // w4
  unsigned __int64 v16; // x26
  _BYTE *v17; // x19
  int v18; // [xsp+Ch] [xbp-64h]
  size_t v19; // [xsp+10h] [xbp-60h]
  size_t v20; // [xsp+18h] [xbp-58h]
  void *v21; // [xsp+20h] [xbp-50h]
  __int64 v22; // [xsp+28h] [xbp-48h]

  v6 = (__int64)a6;
  v7 = a5;
  v8 = a4;
  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = a3;
  v10 = a2;
  v11 = a1;
  if ( !a6[1] || !a6[2] )
  {
    v14 = 144;
    v15 = 503;
LABEL_20:
    ERR_put_error(4, 0LL, v14, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", v15);
    goto LABEL_21;
  }
  v12 = *(__int64 (__fastcall **)(_QWORD *))(*a6 + 32LL);
  if ( v12 )
    v13 = v12(a6);
  else
    v13 = sub_5EF6C((__int64)a6);
  v21 = 0LL;
  v18 = 0;
  if ( v11 == 114 && v9 != 36 )
  {
    v14 = 125;
    v15 = 515;
    goto LABEL_20;
  }
  v16 = v13;
  v17 = malloc(v13);
  if ( !v17 )
  {
    v14 = 65;
    v15 = 521;
    goto LABEL_20;
  }
  if ( (unsigned int)RSA_verify_raw(v6, &v19, v17, v16, v8, v7, 1)
    && (unsigned int)RSA_add_pkcs1_prefix(&v21, &v20, &v18, v11, v10, v9)
    && (v19 != v20 || v19 && (unsigned int)memcmp(v17, v21, v19)) )
  {
    ERR_put_error(4, 0LL, 105, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", 536);
  }
  free(v17);
  if ( v18 )
    free(v21);
LABEL_21:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v22;
}

//----- (000000000005D6C8) ----------------------------------------------------
__int64 __fastcall RSA_check_key(_QWORD *a1)
{
  _DWORD *v1; // x19
  _QWORD *v2; // x20
  __int64 v3; // x8
  int v4; // w2
  __int16 v5; // w4
  bool v6; // w8
  unsigned int v7; // w21
  __int64 v8; // x21
  void **v9; // x0
  __int64 v10; // x21
  void **v11; // x0
  _QWORD *v12; // x0
  _QWORD *v13; // x21
  bool v14; // w24
  unsigned __int64 v15; // x22
  __int64 *v16; // x23
  __int64 v17; // x23
  void **v18; // x0
  int v20; // w2
  __int16 v21; // w4
  __int64 v22; // x8
  __int64 v23; // [xsp+0h] [xbp-120h]
  _QWORD v24[3]; // [xsp+18h] [xbp-108h]
  _QWORD v25[3]; // [xsp+30h] [xbp-F0h]
  _QWORD v26[3]; // [xsp+48h] [xbp-D8h]
  _QWORD v27[3]; // [xsp+60h] [xbp-C0h]
  _QWORD v28[3]; // [xsp+78h] [xbp-A8h]
  _QWORD v29[3]; // [xsp+90h] [xbp-90h]
  _QWORD v30[3]; // [xsp+A8h] [xbp-78h]
  _QWORD v31[3]; // [xsp+C0h] [xbp-60h]
  __int64 v32; // [xsp+D8h] [xbp-48h]

  v2 = a1;
  v32 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *a1 && *(_BYTE *)(*a1 + 112LL) & 1 )
  {
    v7 = 1;
    goto LABEL_27;
  }
  v3 = a1[4];
  if ( (v3 != 0) != (a1[5] != 0LL) )
  {
    v4 = 134;
    v5 = 566;
LABEL_26:
    ERR_put_error(4, 0LL, v4, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", v5);
    v7 = 0;
    goto LABEL_27;
  }
  if ( !a1[1] || !a1[2] )
  {
    v4 = 144;
    v5 = 571;
    goto LABEL_26;
  }
  v6 = v3 == 0;
  v7 = 1;
  if ( a1[3] && !v6 )
  {
    v1 = BN_CTX_new();
    if ( v1 )
    {
      BN_init(v31);
      BN_init(v30);
      BN_init(v29);
      BN_init(v28);
      BN_init(v27);
      BN_init(v26);
      BN_init(v25);
      BN_init(v24);
      BN_init(&v23);
      if ( !(unsigned int)BN_mul((__int64)v31, v2[4], v2[5], (__int64)v1)
        || (v8 = v2[4], v9 = BN_value_one(), !(unsigned int)BN_sub((__int64)v30, v8, (__int64)v9))
        || (v10 = v2[5], v11 = BN_value_one(), !(unsigned int)BN_sub((__int64)v29, v10, (__int64)v11))
        || !(unsigned int)BN_mul((__int64)v28, (__int64)v30, (__int64)v29, (__int64)v1)
        || !(unsigned int)BN_gcd((__int64)v27, (__int64)v30, (__int64)v29, (__int64)v1) )
      {
        v20 = 3;
        v21 = 603;
        goto LABEL_30;
      }
      v12 = (_QWORD *)v2[9];
      if ( v12 && (v13 = sk_num(v12), v14 = v13 == 0LL, v13) )
      {
        v15 = 0LL;
        do
        {
          v16 = (__int64 *)sk_value((unsigned __int64 *)v2[9], v15);
          if ( !(unsigned int)BN_mul((__int64)v31, (__int64)v31, *v16, (__int64)v1)
            || (v17 = *v16, v18 = BN_value_one(), !(unsigned int)BN_sub((__int64)v30, v17, (__int64)v18))
            || !(unsigned int)BN_mul((__int64)v28, (__int64)v28, (__int64)v30, (__int64)v1)
            || !(unsigned int)BN_gcd((__int64)v27, (__int64)v27, (__int64)v30, (__int64)v1) )
          {
            v20 = 3;
            v21 = 619;
            goto LABEL_30;
          }
          ++v15;
        }
        while ( v15 < (unsigned __int64)v13 );
      }
      else
      {
        v14 = 1;
      }
      if ( (unsigned int)BN_div(v28, 0LL, (__int64)v28, (__int64)v27, (__int64)v1)
        && (unsigned int)BN_gcd((__int64)v27, (__int64)v30, (__int64)v29, (__int64)v1)
        && (unsigned int)BN_mod_mul((__int64)v26, v2[3], v2[2], (__int64)v28, (__int64)v1) )
      {
        if ( (unsigned int)BN_cmp((__int64)v31, v2[1]) )
        {
          v20 = 132;
          v21 = 633;
        }
        else if ( BN_is_one((__int64)v26) )
        {
          v22 = v2[6];
          if ( ((v22 != 0) ^ (v2[7] != 0LL)) & 1 || (v22 != 0) != (v2[8] != 0LL) )
          {
            v20 = 123;
            v21 = 645;
          }
          else
          {
            if ( (v14 && v22 != 0) != 1 )
            {
              v7 = 1;
              goto LABEL_31;
            }
            if ( (unsigned int)BN_div(0LL, (__int64)v25, v2[3], (__int64)v30, (__int64)v1)
              && (unsigned int)BN_div(0LL, (__int64)v24, v2[3], (__int64)v29, (__int64)v1)
              && (unsigned int)BN_mod_mul((__int64)&v23, v2[8], v2[5], v2[4], (__int64)v1) )
            {
              if ( !(unsigned int)BN_cmp((__int64)v25, v2[6])
                && !(unsigned int)BN_cmp((__int64)v24, v2[7])
                && BN_cmp(v2[8], v2[4]) & 0x80000000 )
              {
                goto LABEL_56;
              }
              goto LABEL_53;
            }
            v20 = 3;
            v21 = 656;
          }
        }
        else
        {
          v20 = 119;
          v21 = 638;
        }
      }
      else
      {
        v20 = 3;
        v21 = 628;
      }
      goto LABEL_30;
    }
    v4 = 65;
    v5 = 583;
    goto LABEL_26;
  }
LABEL_27:
  while ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v32 )
  {
LABEL_56:
    if ( BN_is_one((__int64)&v23) )
    {
      v7 = 1;
    }
    else
    {
LABEL_53:
      v20 = 111;
      v21 = 664;
LABEL_30:
      ERR_put_error(4, 0LL, v20, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", v21);
      v7 = 0;
    }
LABEL_31:
    BN_free(v31);
    BN_free(v30);
    BN_free(v29);
    BN_free(v28);
    BN_free(v27);
    BN_free(v26);
    BN_free(v25);
    BN_free(v24);
    BN_free(&v23);
    BN_CTX_free((__int64)v1);
  }
  return v7;
}

//----- (000000000005DBBC) ----------------------------------------------------
signed __int64 __fastcall RSA_recover_crt_params(__int64 *a1)
{
  __int64 *v1; // x19
  int v2; // w2
  __int16 v3; // w4
  signed __int64 result; // x0
  _DWORD *v5; // x0
  __int64 v6; // x20
  _QWORD *v7; // x24
  _QWORD *v8; // x21
  _QWORD *v9; // x22
  _QWORD *v10; // x23
  _QWORD *v11; // x0
  _QWORD *v12; // x0
  __int64 v13; // x8
  int v14; // w2
  __int16 v15; // w4
  _DWORD *v16; // x0
  _DWORD *v17; // x0
  _DWORD *v18; // x0
  _DWORD *v19; // x0
  __int64 v20; // x22
  void **v21; // x0
  __int64 v22; // x22
  void **v23; // x0
  __int64 v24; // x0
  __int64 v25; // [xsp+8h] [xbp-38h]

  v1 = a1;
  if ( !a1[1] || !a1[2] || !a1[3] )
  {
    v2 = 120;
    v3 = 692;
    goto LABEL_11;
  }
  if ( a1[4] || a1[5] || a1[6] || a1[7] || a1[8] )
  {
    v2 = 110;
    v3 = 697;
LABEL_11:
    ERR_put_error(4, 0LL, v2, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", v3);
    return 0LL;
  }
  if ( a1[9] )
  {
    v2 = 109;
    v3 = 702;
    goto LABEL_11;
  }
  v5 = BN_CTX_new();
  v6 = (__int64)v5;
  if ( !v5 )
  {
    v2 = 65;
    v3 = 711;
    goto LABEL_11;
  }
  BN_CTX_start((__int64)v5);
  v7 = BN_CTX_get(v6);
  v8 = BN_CTX_get(v6);
  v9 = BN_CTX_get(v6);
  v10 = BN_CTX_get(v6);
  v11 = BN_CTX_get(v6);
  if ( !v7 || !v8 || !v9 || !v10 || !v11 )
  {
    v14 = 65;
    v15 = 724;
    goto LABEL_47;
  }
  v25 = (__int64)v11;
  if ( !(unsigned int)BN_mul((__int64)v7, v1[2], v1[3], v6)
    || !(unsigned int)BN_sub_word((__int64)v7, 1uLL)
    || !(unsigned int)BN_div(v9, 0LL, (__int64)v7, v1[1], v6)
    || !(unsigned int)BN_add_word((__int64)v9, 1LL)
    || !(unsigned int)BN_div(v7, (__int64)v8, (__int64)v7, (__int64)v9, v6) )
  {
    v14 = 3;
    v15 = 752;
    goto LABEL_47;
  }
  if ( !BN_is_zero((__int64)v8) )
  {
    v14 = 104;
    v15 = 757;
    goto LABEL_47;
  }
  v1[4] = (__int64)BN_new();
  v1[5] = (__int64)BN_new();
  v1[6] = (__int64)BN_new();
  v1[7] = (__int64)BN_new();
  v12 = BN_new();
  v13 = v1[4];
  v1[8] = (__int64)v12;
  if ( !v13 || !v1[5] || !v1[6] || !v12 || !v1[7] )
  {
    v14 = 65;
    v15 = 768;
    goto LABEL_47;
  }
  if ( !(unsigned int)BN_sub((__int64)v10, v1[1], (__int64)v7)
    || !(unsigned int)BN_add_word((__int64)v10, 1LL)
    || !(unsigned int)BN_sqr((__int64)v8, (__int64)v10, v6)
    || !(unsigned int)BN_lshift((__int64)v9, (__int64 *)v1[1], 2u)
    || !(unsigned int)BN_sub((__int64)v8, (__int64)v8, (__int64)v9)
    || !(unsigned int)BN_sqrt(v25, (__int64)v8, v6)
    || !(unsigned int)BN_sub(v1[5], (__int64)v10, v25)
    || !(unsigned int)BN_rshift1(v1[5], v1[5])
    || !(unsigned int)BN_div((_QWORD *)v1[4], 0LL, v1[1], v1[5], v6)
    || !(unsigned int)BN_mul((__int64)v9, v1[4], v1[5], v6) )
  {
    v14 = 3;
    v15 = 786;
    goto LABEL_47;
  }
  if ( (unsigned int)BN_cmp((__int64)v9, v1[1]) )
  {
    v14 = 124;
    v15 = 791;
LABEL_47:
    ERR_put_error(4, 0LL, v14, (__int64)"external/boringssl/src/crypto/rsa/rsa.c", v15);
    BN_CTX_end(v6);
    BN_CTX_free(v6);
    BN_free((_DWORD *)v1[4]);
    v16 = (_DWORD *)v1[5];
    v1[4] = 0LL;
    BN_free(v16);
    v17 = (_DWORD *)v1[6];
    v1[5] = 0LL;
    BN_free(v17);
    v18 = (_DWORD *)v1[7];
    v1[6] = 0LL;
    BN_free(v18);
    v19 = (_DWORD *)v1[8];
    v1[7] = 0LL;
    BN_free(v19);
    result = 0LL;
    v1[8] = 0LL;
    return result;
  }
  v20 = v1[4];
  v21 = BN_value_one();
  if ( !(unsigned int)BN_sub((__int64)v8, v20, (__int64)v21)
    || !(unsigned int)BN_div(0LL, v1[6], v1[3], (__int64)v8, v6)
    || (v22 = v1[5], v23 = BN_value_one(), !(unsigned int)BN_sub((__int64)v8, v22, (__int64)v23))
    || !(unsigned int)BN_div(0LL, v1[7], v1[3], (__int64)v8, v6)
    || (BN_mod_inverse((_QWORD *)v1[8], (signed int *)v1[5], v1[4], v6), !v24) )
  {
    v14 = 3;
    v15 = 800;
    goto LABEL_47;
  }
  BN_CTX_end(v6);
  BN_CTX_free(v6);
  return 1LL;
}

//----- (000000000005E038) ----------------------------------------------------
__int64 __fastcall sub_5E038(__int64 a1, _BYTE *a2, unsigned __int8 *a3, size_t a4)
{
  __int64 (*v4)(void); // x4
  size_t v6; // x21
  unsigned __int8 *v7; // x23
  _BYTE *v8; // x22
  __int64 v9; // x19
  _DWORD *v10; // x0
  __int64 v11; // x20
  _QWORD *v12; // x25
  _QWORD *v13; // x0
  __int64 v14; // x24
  int v15; // w2
  __int16 v16; // w4
  unsigned int v17; // w21
  _QWORD *v18; // x23
  __int64 v19; // x28
  __int64 v20; // x8
  unsigned __int64 v21; // x26
  __int64 v22; // x8
  char v23; // w26
  unsigned __int64 v24; // x26
  void *v25; // x0
  size_t v26; // x2
  _BYTE *v27; // x0
  size_t v28; // x2
  _BYTE *v29; // x26
  void *v30; // x0
  int v31; // w8
  int v32; // w0
  _QWORD *v33; // x0
  int v34; // w0
  __int16 v35; // w4
  _QWORD *v36; // x26
  _QWORD *v37; // x0
  int v38; // w0
  int v39; // w0
  __int64 *v40; // x26
  int v41; // w0
  _QWORD *v42; // x0
  __int64 v43; // x26
  int v44; // w0
  unsigned __int64 v45; // [xsp+0h] [xbp-90h]
  char v46; // [xsp+Ch] [xbp-84h]
  _QWORD *v47; // [xsp+10h] [xbp-80h]
  __int64 v48; // [xsp+18h] [xbp-78h]
  void *v49; // [xsp+20h] [xbp-70h]
  _QWORD *v50; // [xsp+20h] [xbp-70h]
  __int64 *v51; // [xsp+28h] [xbp-68h]

  v4 = *(__int64 (**)(void))(*(_QWORD *)a1 + 88LL);
  if ( v4 )
    return v4();
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = BN_CTX_new();
  v11 = (__int64)v10;
  if ( v10 )
  {
    BN_CTX_start((__int64)v10);
    v12 = BN_CTX_get(v11);
    v13 = BN_CTX_get(v11);
    v14 = (__int64)v13;
    if ( !v12 || !v13 )
    {
      v15 = 65;
      v16 = 546;
      goto LABEL_11;
    }
    if ( !BN_bin2bn(v7, v6, (__int64)v12) )
    {
LABEL_12:
      v17 = 0;
      v18 = 0LL;
      LODWORD(v19) = 0;
      goto LABEL_13;
    }
    if ( !(BN_ucmp((__int64)v12, *(_QWORD *)(v9 + 8)) & 0x80000000) )
    {
      v15 = 115;
      v16 = 556;
LABEL_11:
      ERR_put_error(4, 0LL, v15, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v16);
      goto LABEL_12;
    }
    if ( !sub_6BAC4((__int64 *)(v9 + 152), (pthread_rwlock_t *)(v9 + 96), *(_QWORD *)(v9 + 8)) )
    {
      v15 = 68;
      v16 = 561;
      goto LABEL_11;
    }
    v20 = *(_QWORD *)(v9 + 16);
    if ( *(_BYTE *)(v9 + 92) & 8 )
    {
      if ( !v20 )
      {
        v51 = (__int64 *)(v9 + 152);
        LODWORD(v19) = 0;
        v18 = 0LL;
        v23 = 1;
        if ( *(_QWORD *)(v9 + 32) )
        {
LABEL_50:
          if ( *(_QWORD *)(v9 + 40)
            && *(_QWORD *)(v9 + 16)
            && *(_QWORD *)(v9 + 48)
            && *(_QWORD *)(v9 + 56)
            && *(_QWORD *)(v9 + 64) )
          {
            v33 = *(_QWORD **)(v9 + 72);
            v46 = v23;
            if ( v33 )
              v47 = sk_num(v33);
            else
              v47 = 0LL;
            BN_CTX_start(v11);
            v36 = BN_CTX_get(v11);
            v50 = BN_CTX_get(v11);
            v37 = BN_CTX_get(v11);
            v48 = (__int64)v36;
            if ( !v36
              || !v50
              || !v37
              || !sub_6BAC4((__int64 *)(v9 + 160), (pthread_rwlock_t *)(v9 + 96), *(_QWORD *)(v9 + 32))
              || !sub_6BAC4((__int64 *)(v9 + 168), (pthread_rwlock_t *)(v9 + 96), *(_QWORD *)(v9 + 40))
              || !sub_6BAC4(v51, (pthread_rwlock_t *)(v9 + 96), *(_QWORD *)(v9 + 8))
              || !(unsigned int)BN_div(0LL, (__int64)v36, (__int64)v12, *(_QWORD *)(v9 + 40), v11)
              || (BN_mod_exp_mont_consttime(
                    (__int64)v50,
                    (__int64)v36,
                    *(_QWORD *)(v9 + 56),
                    *(_QWORD *)(v9 + 40),
                    v11,
                    *(_QWORD *)(v9 + 168)),
                  !v38)
              || !(unsigned int)BN_div(0LL, (__int64)v36, (__int64)v12, *(_QWORD *)(v9 + 32), v11)
              || (BN_mod_exp_mont_consttime(
                    v14,
                    (__int64)v36,
                    *(_QWORD *)(v9 + 48),
                    *(_QWORD *)(v9 + 32),
                    v11,
                    *(_QWORD *)(v9 + 160)),
                  !v39)
              || !(unsigned int)BN_sub(v14, v14, (__int64)v50)
              || BN_is_negative(v14) && !(unsigned int)BN_add(v14, v14, *(_QWORD *)(v9 + 32))
              || !(unsigned int)BN_mul((__int64)v36, v14, *(_QWORD *)(v9 + 64), v11)
              || !(unsigned int)BN_div(0LL, v14, (__int64)v36, *(_QWORD *)(v9 + 32), v11)
              || BN_is_negative(v14) && !(unsigned int)BN_add(v14, v14, *(_QWORD *)(v9 + 32))
              || !(unsigned int)BN_mul((__int64)v36, v14, *(_QWORD *)(v9 + 40), v11)
              || !(unsigned int)BN_add(v14, (__int64)v36, (__int64)v50) )
            {
LABEL_104:
              BN_CTX_end(v11);
              goto LABEL_103;
            }
            if ( v47 )
            {
              v45 = 0LL;
              do
              {
                v40 = (__int64 *)sk_value(*(unsigned __int64 **)(v9 + 72), v45);
                if ( !(unsigned int)BN_div(0LL, v48, (__int64)v12, *v40, v11) )
                  goto LABEL_104;
                if ( !sub_6BAC4(v40 + 4, (pthread_rwlock_t *)(v9 + 96), *v40) )
                  goto LABEL_104;
                BN_mod_exp_mont_consttime((__int64)v50, v48, v40[1], *v40, v11, v40[4]);
                if ( !v41
                  || !(unsigned int)BN_sub((__int64)v50, (__int64)v50, v14)
                  || !(unsigned int)BN_mul((__int64)v50, (__int64)v50, v40[2], v11)
                  || !(unsigned int)BN_div(0LL, (__int64)v50, (__int64)v50, *v40, v11)
                  || BN_is_negative((__int64)v50) && !(unsigned int)BN_add((__int64)v50, (__int64)v50, *v40) )
                {
                  goto LABEL_104;
                }
                if ( !(unsigned int)BN_mul((__int64)v50, (__int64)v50, v40[3], v11)
                  || !(unsigned int)BN_add(v14, v14, (__int64)v50) )
                {
                  goto LABEL_104;
                }
              }
              while ( ++v45 < (unsigned __int64)v47 );
            }
            BN_CTX_end(v11);
            if ( v46 & 1 )
              goto LABEL_59;
LABEL_96:
            v42 = BN_CTX_get(v11);
            v43 = (__int64)v42;
            if ( !v42
              || (BN_mod_exp_mont(
                    (__int64)v42,
                    v14,
                    *(_QWORD *)(v9 + 16),
                    *(_QWORD *)(v9 + 8),
                    v11,
                    *(_QWORD *)(v9 + 152)),
                  !v44)
              || !(unsigned int)BN_equal_consttime(v43, (__int64)v12) )
            {
              v35 = 613;
LABEL_102:
              ERR_put_error(4, 0LL, 68, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v35);
              goto LABEL_103;
            }
            if ( !(unsigned int)sub_87724(v14, (__int64)v18, *v51, v11) )
              goto LABEL_103;
LABEL_59:
            if ( (unsigned int)BN_bn2bin_padded(v8, v6, v14) )
            {
              v17 = 1;
              goto LABEL_13;
            }
            v35 = 623;
            goto LABEL_102;
          }
        }
LABEL_57:
        BN_mod_exp_mont_consttime(
          v14,
          (__int64)v12,
          *(_QWORD *)(v9 + 24),
          *(_QWORD *)(v9 + 8),
          v11,
          *(_QWORD *)(v9 + 152));
        if ( v34 )
        {
          if ( v23 & 1 )
            goto LABEL_59;
          goto LABEL_96;
        }
LABEL_103:
        v17 = 0;
LABEL_13:
        BN_CTX_end(v11);
        BN_CTX_free(v11);
        if ( v18 )
        {
          if ( (_DWORD)v19 == 1024 )
          {
            ECDSA_SIG_free((_DWORD **)v18);
          }
          else
          {
            CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(v9 + 96));
            *(_BYTE *)(*(_QWORD *)(v9 + 192) + (unsigned int)v19) = 0;
            CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v9 + 96));
          }
        }
        return v17;
      }
    }
    else if ( !v20 )
    {
      v15 = 130;
      v16 = 575;
      goto LABEL_11;
    }
    CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(v9 + 96));
    v21 = *(unsigned int *)(v9 + 176);
    v51 = (__int64 *)(v9 + 152);
    if ( (_DWORD)v21 )
    {
      v22 = *(_QWORD *)(v9 + 192);
      v19 = 0LL;
      while ( *(_BYTE *)(v22 + v19) )
      {
        if ( ++v19 >= v21 )
          goto LABEL_28;
      }
      *(_BYTE *)(v22 + v19) = 1;
      v18 = *(_QWORD **)(*(_QWORD *)(v9 + 184) + 8 * v19);
      if ( v18 )
        goto LABEL_47;
      LODWORD(v21) = *(_DWORD *)(v9 + 176);
    }
    else
    {
LABEL_28:
      LODWORD(v19) = 0;
    }
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v9 + 96));
    v18 = sub_8744C();
    if ( v18 )
    {
      if ( (unsigned int)v21 > 0x3FF )
      {
        LODWORD(v19) = 1024;
        goto LABEL_48;
      }
      CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(v9 + 96));
      v24 = *(unsigned int *)(v9 + 176);
      v25 = malloc(8LL * (unsigned int)(v24 + 1));
      if ( v25 )
      {
        if ( (_DWORD)v24 )
        {
          v26 = 8 * v24;
          v24 = (unsigned __int64)v25;
          memcpy(v25, *(const void **)(v9 + 184), v26);
          v25 = (void *)v24;
          LODWORD(v24) = *(_DWORD *)(v9 + 176);
        }
        v49 = v25;
        *((_QWORD *)v25 + (unsigned int)v24) = v18;
        v27 = malloc((unsigned int)(v24 + 1));
        if ( v27 )
        {
          v28 = (unsigned int)v24;
          if ( (_DWORD)v24 )
          {
            v29 = v27;
            memcpy(v27, *(const void **)(v9 + 192), v28);
            LODWORD(v19) = *(_DWORD *)(v9 + 176);
          }
          else
          {
            LODWORD(v19) = 0;
            v29 = v27;
          }
          v29[(unsigned int)v19] = 1;
          free(*(void **)(v9 + 184));
          v30 = *(void **)(v9 + 192);
          *(_QWORD *)(v9 + 184) = v49;
          free(v30);
          v31 = *(_DWORD *)(v9 + 176);
          *(_QWORD *)(v9 + 192) = v29;
          *(_DWORD *)(v9 + 176) = v31 + 1;
LABEL_47:
          CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v9 + 96));
LABEL_48:
          sub_874E0((__int64)v12, (__int64)v18, *(_QWORD *)(v9 + 16), *(_QWORD *)(v9 + 152), v11);
          if ( !v32 )
            goto LABEL_103;
          v23 = 0;
          if ( *(_QWORD *)(v9 + 32) )
            goto LABEL_50;
          goto LABEL_57;
        }
        free(v49);
      }
      CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v9 + 96));
      ECDSA_SIG_free((_DWORD **)v18);
    }
    ERR_put_error(4, 0LL, 68, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", 581);
    v17 = 0;
    v18 = 0LL;
    goto LABEL_13;
  }
  return 0;
}

//----- (000000000005E04C) ----------------------------------------------------
void __fastcall RSA_parse_public_key(unsigned __int8 **a1)
{
  sub_5E054(a1, 0);
}

//----- (000000000005E054) ----------------------------------------------------
void __fastcall sub_5E054(unsigned __int8 **a1, int a2)
{
  int v2; // w20
  unsigned __int8 **v3; // x21
  int *v4; // x19
  _QWORD *v5; // x8
  _QWORD *v6; // x8
  int v7; // w2
  __int16 v8; // w4
  unsigned __int8 *v9[2]; // [xsp+8h] [xbp-38h]
  __int64 v10; // [xsp+18h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (int *)RSA_new();
  if ( v4 )
  {
    if ( !(unsigned int)CBS_get_asn1(v3, (char *)v9, 48) )
      goto LABEL_11;
    v5 = BN_new();
    *((_QWORD *)v4 + 1) = v5;
    if ( !v5 )
      goto LABEL_11;
    if ( v2 )
    {
      if ( !BN_parse_asn1_unsigned_buggy(v9, (__int64)v5) )
        goto LABEL_11;
    }
    else if ( !BN_parse_asn1_unsigned(v9, (__int64)v5) )
    {
LABEL_11:
      v7 = 100;
      v8 = 107;
LABEL_12:
      ERR_put_error(4, 0LL, v7, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", v8);
      RSA_free(v4);
      goto LABEL_13;
    }
    v6 = BN_new();
    *((_QWORD *)v4 + 2) = v6;
    if ( !v6 || !BN_parse_asn1_unsigned(v9, (__int64)v6) || EVP_CIPHER_CTX_get_app_data((__int64)v9) )
      goto LABEL_11;
    if ( !(unsigned int)BN_is_odd(*((_QWORD *)v4 + 2)) || (unsigned int)BN_num_bits(*((_QWORD *)v4 + 2)) <= 1 )
    {
      v7 = 104;
      v8 = 114;
      goto LABEL_12;
    }
  }
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v10;
}

//----- (000000000005E184) ----------------------------------------------------
void __fastcall RSA_parse_public_key_buggy(unsigned __int8 **a1)
{
  sub_5E054(a1, 1);
}

//----- (000000000005E18C) ----------------------------------------------------
void __fastcall RSA_public_key_from_bytes(__int64 a1, __int64 a2)
{
  int *v2; // x0
  int *v3; // x19
  unsigned __int8 *v4[2]; // [xsp+8h] [xbp-28h]
  __int64 v5; // [xsp+18h] [xbp-18h]

  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CBS_init(v4, a1, a2);
  sub_5E054(v4, 0);
  v3 = v2;
  if ( !v2 || EVP_CIPHER_CTX_get_app_data((__int64)v4) )
  {
    ERR_put_error(4, 0LL, 100, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 139);
    RSA_free(v3);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005E234) ----------------------------------------------------
signed __int64 __fastcall RSA_marshal_public_key(__int64 *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x19
  __int64 v4; // x1
  signed __int64 result; // x0
  char v6; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBB_add_asn1(a1, (__int64 *)&v6, 0x30u) )
    goto LABEL_9;
  v4 = *(_QWORD *)(v2 + 8);
  if ( !v4 )
    goto LABEL_13;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
  {
LABEL_9:
    ERR_put_error(4, 0LL, 121, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 152);
    result = 0LL;
    goto LABEL_10;
  }
  v4 = *(_QWORD *)(v2 + 16);
  if ( !v4 )
  {
LABEL_13:
    ERR_put_error(4, v4, 144, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 91);
    goto LABEL_9;
  }
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) || !(unsigned int)CBB_flush(v3) )
    goto LABEL_9;
  result = 1LL;
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005E304) ----------------------------------------------------
signed __int64 __fastcall RSA_public_key_to_bytes(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // x20
  __int64 v4; // x21
  _QWORD *v5; // x19
  signed __int64 result; // x0
  __int64 v7[4]; // [xsp+8h] [xbp-48h]
  __int64 v8; // [xsp+28h] [xbp-28h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(v7);
  if ( (unsigned int)CBB_init(v7, 0LL)
    && (unsigned int)RSA_marshal_public_key(v7, v4)
    && (unsigned int)CBB_finish((__int64)v7, v3, v5) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(4, 0LL, 121, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 165);
    CBB_cleanup(v7);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005E3C8) ----------------------------------------------------
int *__fastcall RSA_parse_private_key(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // x20
  int *v2; // x19
  int v3; // w2
  __int16 v4; // w4
  __int64 i; // x0
  _QWORD *v7; // x8
  _QWORD *v8; // x8
  _QWORD *v9; // x8
  _QWORD *v10; // x8
  _QWORD *v11; // x8
  _QWORD *v12; // x8
  _QWORD *v13; // x8
  _QWORD *v14; // x8
  _QWORD *v15; // x0
  _DWORD *v16; // x21
  unsigned __int8 **v17; // x0
  __int64 v18; // x1
  __int64 v19; // x2
  int v20; // w2
  __int16 v21; // w4
  int v22; // w2
  __int16 v23; // w4
  __int64 *v24; // x21
  _QWORD *v25; // x8
  _QWORD *v26; // x8
  _QWORD *v27; // x8
  signed int *v28; // x0
  int v29; // w2
  __int16 v30; // w4
  __int64 v31; // [xsp+8h] [xbp-68h]
  unsigned __int8 *v32[2]; // [xsp+10h] [xbp-60h]
  unsigned __int64 v33; // [xsp+20h] [xbp-50h]
  unsigned __int8 *v34[2]; // [xsp+28h] [xbp-48h]
  unsigned __int8 *v35[2]; // [xsp+38h] [xbp-38h]
  __int64 v36; // [xsp+48h] [xbp-28h]

  v1 = a1;
  v36 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = (int *)RSA_new();
  if ( !v2 )
    goto LABEL_10;
  if ( !(unsigned int)CBS_get_asn1(v1, (char *)v34, 48) || !(unsigned int)CBS_get_asn1_uint64(v34, &v33) )
  {
    v3 = 100;
    v4 = 215;
    goto LABEL_7;
  }
  if ( v33 >= 2 )
  {
    v3 = 106;
    v4 = 220;
LABEL_7:
    ERR_put_error(4, 0LL, v3, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", v4);
    goto LABEL_8;
  }
  v7 = BN_new();
  *((_QWORD *)v2 + 1) = v7;
  if ( v7 )
  {
    if ( BN_parse_asn1_unsigned(v34, (__int64)v7) )
    {
      v8 = BN_new();
      *((_QWORD *)v2 + 2) = v8;
      if ( v8 )
      {
        if ( BN_parse_asn1_unsigned(v34, (__int64)v8) )
        {
          v9 = BN_new();
          *((_QWORD *)v2 + 3) = v9;
          if ( v9 )
          {
            if ( BN_parse_asn1_unsigned(v34, (__int64)v9) )
            {
              v10 = BN_new();
              *((_QWORD *)v2 + 4) = v10;
              if ( v10 )
              {
                if ( BN_parse_asn1_unsigned(v34, (__int64)v10) )
                {
                  v11 = BN_new();
                  *((_QWORD *)v2 + 5) = v11;
                  if ( v11 )
                  {
                    if ( BN_parse_asn1_unsigned(v34, (__int64)v11) )
                    {
                      v12 = BN_new();
                      *((_QWORD *)v2 + 6) = v12;
                      if ( v12 )
                      {
                        if ( BN_parse_asn1_unsigned(v34, (__int64)v12) )
                        {
                          v13 = BN_new();
                          *((_QWORD *)v2 + 7) = v13;
                          if ( v13 )
                          {
                            if ( BN_parse_asn1_unsigned(v34, (__int64)v13) )
                            {
                              v14 = BN_new();
                              *((_QWORD *)v2 + 8) = v14;
                              if ( v14 )
                              {
                                if ( BN_parse_asn1_unsigned(v34, (__int64)v14) )
                                {
                                  if ( v33 != 1 )
                                  {
                                    v1 = 0LL;
                                    v31 = 0LL;
LABEL_36:
                                    if ( EVP_CIPHER_CTX_get_app_data((__int64)v34) )
                                    {
                                      v20 = 100;
                                      v21 = 280;
                                      goto LABEL_38;
                                    }
                                    if ( !(unsigned int)RSA_check_key(v2) )
                                    {
                                      v20 = 104;
                                      v21 = 285;
                                      goto LABEL_38;
                                    }
                                    BN_CTX_free(v31);
                                    BN_free(v1);
                                    goto LABEL_10;
                                  }
                                  if ( (unsigned int)CBS_get_asn1(v34, (char *)v32, 48)
                                    && EVP_CIPHER_CTX_get_app_data((__int64)v32) )
                                  {
                                    v15 = sk_new_null();
                                    *((_QWORD *)v2 + 9) = v15;
                                    if ( v15 )
                                    {
                                      v16 = BN_CTX_new();
                                      v17 = (unsigned __int8 **)BN_new();
                                      v1 = v17;
                                      v31 = (__int64)v16;
                                      if ( !v16 || !v17 )
                                        goto LABEL_41;
                                      v18 = *((_QWORD *)v2 + 4);
                                      v19 = *((_QWORD *)v2 + 5);
                                      while ( 1 )
                                      {
                                        if ( !(unsigned int)BN_mul((__int64)v17, v18, v19, v31) )
                                          goto LABEL_41;
                                        if ( !EVP_CIPHER_CTX_get_app_data((__int64)v32) )
                                          goto LABEL_36;
                                        v24 = (__int64 *)malloc(0x28uLL);
                                        if ( !v24 )
                                          goto LABEL_63;
                                        v24[3] = 0LL;
                                        v24[4] = 0LL;
                                        v24[1] = 0LL;
                                        v24[2] = 0LL;
                                        *v24 = 0LL;
                                        if ( !(unsigned int)CBS_get_asn1(v32, (char *)v35, 48) )
                                          break;
                                        v25 = BN_new();
                                        *v24 = (__int64)v25;
                                        if ( !v25 )
                                          break;
                                        if ( !BN_parse_asn1_unsigned(v35, (__int64)v25) )
                                          break;
                                        v26 = BN_new();
                                        v24[1] = (__int64)v26;
                                        if ( !v26 )
                                          break;
                                        if ( !BN_parse_asn1_unsigned(v35, (__int64)v26) )
                                          break;
                                        v27 = BN_new();
                                        v24[2] = (__int64)v27;
                                        if ( !v27
                                          || !BN_parse_asn1_unsigned(v35, (__int64)v27)
                                          || EVP_CIPHER_CTX_get_app_data((__int64)v35) )
                                        {
                                          break;
                                        }
                                        if ( !sk_push(*((unsigned __int64 **)v2 + 9), (__int64)v24) )
                                        {
                                          v29 = 65;
                                          v30 = 266;
                                          goto LABEL_62;
                                        }
                                        v28 = BN_dup((signed int *)v1);
                                        v24[3] = (__int64)v28;
                                        if ( !v28 )
                                          goto LABEL_41;
                                        v19 = *v24;
                                        v17 = v1;
                                        v18 = (__int64)v1;
                                      }
                                      v29 = 100;
                                      v30 = 195;
LABEL_62:
                                      ERR_put_error(
                                        4,
                                        0LL,
                                        v29,
                                        (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c",
                                        v30);
                                      sub_5CAE4((void ***)v24);
                                      goto LABEL_41;
                                    }
                                    v22 = 65;
                                    v23 = 248;
                                  }
                                  else
                                  {
                                    v22 = 100;
                                    v23 = 243;
                                  }
                                  ERR_put_error(
                                    4,
                                    0LL,
                                    v22,
                                    (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c",
                                    v23);
                                  v1 = 0LL;
                                  v31 = 0LL;
                                  goto LABEL_41;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_8:
  v1 = 0LL;
  for ( i = 0LL; ; i = v31 )
  {
    BN_CTX_free(i);
    BN_free(v1);
    RSA_free(v2);
    v2 = 0LL;
LABEL_10:
    if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v36 )
      break;
LABEL_63:
    v20 = 65;
    v21 = 184;
LABEL_38:
    ERR_put_error(4, 0LL, v20, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", v21);
LABEL_41:
    ;
  }
  return v2;
}

//----- (000000000005E7F8) ----------------------------------------------------
void __fastcall RSA_private_key_from_bytes(__int64 a1, __int64 a2)
{
  int *v2; // x19
  unsigned __int8 *v3[2]; // [xsp+8h] [xbp-28h]
  __int64 v4; // [xsp+18h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CBS_init(v3, a1, a2);
  v2 = RSA_parse_private_key(v3);
  if ( !v2 || EVP_CIPHER_CTX_get_app_data((__int64)v3) )
  {
    ERR_put_error(4, 0LL, 100, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 305);
    RSA_free(v2);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005E89C) ----------------------------------------------------
signed __int64 __fastcall RSA_marshal_private_key(__int64 *a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 *v3; // x20
  _QWORD *v4; // x21
  __int64 v5; // x1
  unsigned __int64 v6; // x21
  __int64 *v7; // x22
  __int64 v8; // x1
  signed __int64 result; // x0
  __int16 v10; // w4
  char v11; // [xsp+8h] [xbp-88h]
  __int64 v12[4]; // [xsp+28h] [xbp-68h]
  char v13; // [xsp+48h] [xbp-48h]
  __int64 v14; // [xsp+68h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = sk_num(*(_QWORD **)(a2 + 72));
  if ( !(unsigned int)CBB_add_asn1(v3, (__int64 *)&v13, 0x30u)
    || !(unsigned int)CBB_add_asn1_uint64((__int64 *)&v13, v4 != 0LL) )
  {
    goto LABEL_35;
  }
  v5 = *(_QWORD *)(v2 + 8);
  if ( !v5 )
    goto LABEL_34;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
    goto LABEL_35;
  v5 = *(_QWORD *)(v2 + 16);
  if ( !v5 )
  {
LABEL_34:
    ERR_put_error(4, v5, 144, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 91);
    goto LABEL_35;
  }
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
  {
LABEL_35:
    v10 = 328;
LABEL_36:
    ERR_put_error(4, 0LL, 121, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", v10);
    result = 0LL;
    goto LABEL_37;
  }
  v5 = *(_QWORD *)(v2 + 24);
  if ( !v5 )
    goto LABEL_34;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
    goto LABEL_35;
  v5 = *(_QWORD *)(v2 + 32);
  if ( !v5 )
    goto LABEL_34;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
    goto LABEL_35;
  v5 = *(_QWORD *)(v2 + 40);
  if ( !v5 )
    goto LABEL_34;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
    goto LABEL_35;
  v5 = *(_QWORD *)(v2 + 48);
  if ( !v5 )
    goto LABEL_34;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
    goto LABEL_35;
  v5 = *(_QWORD *)(v2 + 56);
  if ( !v5 )
    goto LABEL_34;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
    goto LABEL_35;
  v5 = *(_QWORD *)(v2 + 64);
  if ( !v5 )
    goto LABEL_34;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v13, v5) )
    goto LABEL_35;
  if ( !v4 )
    goto LABEL_32;
  if ( !(unsigned int)CBB_add_asn1((__int64 *)&v13, v12, 0x30u) )
  {
    v10 = 335;
    goto LABEL_36;
  }
  if ( sk_num(*(_QWORD **)(v2 + 72)) )
  {
    v6 = 0LL;
    while ( 1 )
    {
      v7 = (__int64 *)sk_value(*(unsigned __int64 **)(v2 + 72), v6);
      if ( !(unsigned int)CBB_add_asn1(v12, (__int64 *)&v11, 0x30u) )
        break;
      v8 = *v7;
      if ( !*v7 )
        goto LABEL_45;
      if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v11, v8) )
        break;
      v8 = v7[1];
      if ( !v8 )
        goto LABEL_45;
      if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v11, v8) )
        break;
      v8 = v7[2];
      if ( !v8 )
      {
LABEL_45:
        ERR_put_error(4, v8, 144, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 91);
        break;
      }
      if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v11, v8) || !(unsigned int)CBB_flush(v12) )
        break;
      if ( ++v6 >= (unsigned __int64)sk_num(*(_QWORD **)(v2 + 72)) )
        goto LABEL_32;
    }
    v10 = 349;
    goto LABEL_36;
  }
LABEL_32:
  if ( !(unsigned int)CBB_flush(v3) )
  {
    v10 = 356;
    goto LABEL_36;
  }
  result = 1LL;
LABEL_37:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v14;
  return result;
}

//----- (000000000005EB1C) ----------------------------------------------------
signed __int64 __fastcall RSA_private_key_to_bytes(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // x20
  __int64 v4; // x21
  _QWORD *v5; // x19
  signed __int64 result; // x0
  __int64 v7[4]; // [xsp+8h] [xbp-48h]
  __int64 v8; // [xsp+28h] [xbp-28h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(v7);
  if ( (unsigned int)CBB_init(v7, 0LL)
    && (unsigned int)RSA_marshal_private_key(v7, v4)
    && (unsigned int)CBB_finish((__int64)v7, v3, v5) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(4, 0LL, 121, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 369);
    CBB_cleanup(v7);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005EBE0) ----------------------------------------------------
void __fastcall d2i_RSAPublicKey(int **a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  int **v4; // x21
  int *v5; // x0
  int *v6; // x20
  unsigned __int8 *v7[2]; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(a3 & 0x8000000000000000LL) )
  {
    CBS_init(v7, *a2, a3);
    sub_5E054(v7, 0);
    v6 = v5;
    if ( v5 )
    {
      if ( v4 )
      {
        RSA_free(*v4);
        *v4 = v6;
      }
      *v3 = lh_num_items((__int64)v7);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005EC80) ----------------------------------------------------
signed __int64 __fastcall i2d_RSAPublicKey(__int64 a1, void **a2)
{
  void **v2; // x19
  __int64 v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v5, 0LL) && (unsigned int)RSA_marshal_public_key(v5, v3) )
  {
    result = sub_6F744((__int64)v5, v2);
  }
  else
  {
    CBB_cleanup(v5);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005ED08) ----------------------------------------------------
__int64 __fastcall d2i_RSAPrivateKey(__int64 result, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  int **v4; // x21
  int *v5; // x20
  unsigned __int8 *v6[2]; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = (int **)result;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 & 0x8000000000000000LL )
  {
    v5 = 0LL;
  }
  else
  {
    CBS_init(v6, *a2, a3);
    result = (__int64)RSA_parse_private_key(v6);
    v5 = (int *)result;
    if ( result )
    {
      if ( v4 )
      {
        RSA_free(*v4);
        *v4 = v5;
      }
      result = lh_num_items((__int64)v6);
      *v3 = result;
    }
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v7 )
    result = (__int64)v5;
  return result;
}

//----- (000000000005EDA4) ----------------------------------------------------
signed __int64 __fastcall i2d_RSAPrivateKey(__int64 a1, void **a2)
{
  void **v2; // x19
  __int64 v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v5, 0LL) && (unsigned int)RSA_marshal_private_key(v5, v3) )
  {
    result = sub_6F744((__int64)v5, v2);
  }
  else
  {
    CBB_cleanup(v5);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000005EE2C) ----------------------------------------------------
void __fastcall RSAPublicKey_dup(__int64 a1)
{
  __int64 v1; // [xsp+8h] [xbp-28h]
  void *v2; // [xsp+10h] [xbp-20h]
  __int64 v3; // [xsp+18h] [xbp-18h]

  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)RSA_public_key_to_bytes(&v2, &v1, a1) )
  {
    RSA_public_key_from_bytes((__int64)v2, v1);
    free(v2);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005EEAC) ----------------------------------------------------
void __fastcall RSAPrivateKey_dup(__int64 a1)
{
  int *v1; // x19
  __int64 v2; // [xsp+8h] [xbp-38h]
  void *v3; // [xsp+10h] [xbp-30h]
  unsigned __int8 *v4[2]; // [xsp+18h] [xbp-28h]
  __int64 v5; // [xsp+28h] [xbp-18h]

  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)RSA_private_key_to_bytes(&v3, &v2, a1) )
  {
    CBS_init(v4, (__int64)v3, v2);
    v1 = RSA_parse_private_key(v4);
    if ( !v1 || EVP_CIPHER_CTX_get_app_data((__int64)v4) )
    {
      ERR_put_error(4, 0LL, 100, (__int64)"external/boringssl/src/crypto/rsa/rsa_asn1.c", 305);
      RSA_free(v1);
    }
    free(v3);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000005EF6C) ----------------------------------------------------
__int64 __fastcall sub_5EF6C(__int64 a1)
{
  return (unsigned int)BN_num_bytes(*(_QWORD *)(a1 + 8));
}

//----- (000000000005EF88) ----------------------------------------------------
__int64 __fastcall sub_5EF88(__int64 a1, size_t *a2, _BYTE *a3, size_t a4, const void *a5, size_t a6, int a7)
{
  int v7; // w25
  size_t v8; // x27
  const void *v9; // x28
  size_t v10; // x20
  _BYTE *v11; // x23
  size_t *v12; // x22
  __int64 v13; // x24
  size_t v14; // x19
  unsigned int v15; // w22
  _DWORD *v16; // x0
  __int64 v17; // x20
  _QWORD *v18; // x21
  _QWORD *v19; // x26
  unsigned __int8 *v20; // x0
  __int64 v21; // x25
  unsigned __int8 *v22; // x21
  signed int v23; // w0
  int v24; // w2
  __int16 v25; // w4
  int v27; // w0
  __int64 v28; // [xsp+8h] [xbp-58h]

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  v14 = (unsigned int)RSA_size(a1);
  if ( v14 > v10 )
  {
    ERR_put_error(4, 0LL, 135, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", 122);
    return 0;
  }
  if ( !(unsigned int)sub_5F210(v13) )
    return 0;
  v16 = BN_CTX_new();
  v17 = (__int64)v16;
  if ( !v16 )
    return 0;
  BN_CTX_start((__int64)v16);
  v18 = BN_CTX_get(v17);
  v19 = BN_CTX_get(v17);
  v20 = (unsigned __int8 *)malloc(v14);
  v28 = (__int64)v18;
  if ( !v18 || !v19 || !v20 )
  {
    v22 = v20;
    v24 = 65;
    v25 = 140;
LABEL_21:
    ERR_put_error(4, 0LL, v24, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v25);
LABEL_22:
    v15 = 0;
    goto LABEL_23;
  }
  switch ( v7 )
  {
    case 4:
      v21 = (__int64)v19;
      v22 = v20;
      RSA_padding_add_PKCS1_OAEP_mgf1(v20, v14, v9, v8, 0LL, 0LL, 0LL, 0LL);
      break;
    case 3:
      v21 = (__int64)v19;
      v22 = v20;
      v23 = sub_5B9FC(v20, v14, v9, v8);
      break;
    case 1:
      v21 = (__int64)v19;
      v22 = v20;
      v23 = sub_5B7A4(v20, v14, v9, v8);
      break;
    default:
      v22 = v20;
      v24 = 143;
      v25 = 157;
      goto LABEL_21;
  }
  if ( v23 < 1 || !BN_bin2bn(v22, v14, v28) )
    goto LABEL_22;
  if ( !(BN_ucmp(v28, *(_QWORD *)(v13 + 8)) & 0x80000000) )
  {
    v24 = 115;
    v25 = 171;
    goto LABEL_21;
  }
  if ( !sub_6BAC4((__int64 *)(v13 + 152), (pthread_rwlock_t *)(v13 + 96), *(_QWORD *)(v13 + 8)) )
    goto LABEL_22;
  BN_mod_exp_mont(v21, v28, *(_QWORD *)(v13 + 16), *(_QWORD *)(v13 + 8), v17, *(_QWORD *)(v13 + 152));
  if ( !v27 )
    goto LABEL_22;
  if ( !(unsigned int)BN_bn2bin_padded(v11, v14, v21) )
  {
    v24 = 68;
    v25 = 183;
    goto LABEL_21;
  }
  *v12 = v14;
  v15 = 1;
LABEL_23:
  BN_CTX_end(v17);
  BN_CTX_free(v17);
  if ( v22 )
  {
    OPENSSL_cleanse(v22, v14);
    free(v22);
  }
  return v15;
}

//----- (000000000005F210) ----------------------------------------------------
signed __int64 __fastcall sub_5F210(__int64 a1)
{
  __int64 v1; // x20
  unsigned int v2; // w19
  int v3; // w2
  __int16 v4; // w4

  v1 = a1;
  v2 = BN_num_bits(*(_QWORD *)(a1 + 8));
  if ( v2 > 0x4000 )
  {
    v3 = 128;
    v4 = 76;
LABEL_7:
    ERR_put_error(4, 0LL, v3, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v4);
    return 0LL;
  }
  if ( (unsigned int)BN_num_bits(*(_QWORD *)(v1 + 16)) >= 0x22 )
  {
    v3 = 101;
    v4 = 92;
    goto LABEL_7;
  }
  if ( v2 <= 0x21 )
  {
    v3 = 126;
    v4 = 101;
    goto LABEL_7;
  }
  return 1LL;
}

//----- (000000000005F2B0) ----------------------------------------------------
__int64 __fastcall sub_5F2B0(__int64 a1, size_t *a2, _BYTE *a3, unsigned __int64 a4, const void *a5, size_t a6, int a7)
{
  int v7; // w26
  size_t v8; // x24
  const void *v9; // x25
  unsigned __int64 v10; // x20
  _BYTE *v11; // x22
  size_t *v12; // x21
  __int64 v13; // x23
  unsigned int v14; // w0
  size_t v15; // x19
  int v16; // w2
  __int16 v17; // w4
  _WORD *v18; // x0
  void *v19; // x20
  unsigned int v20; // w21

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  v14 = RSA_size(a1);
  v15 = v14;
  if ( v14 <= v10 )
  {
    v18 = malloc(v14);
    v19 = v18;
    if ( !v18 )
    {
      v16 = 65;
      v17 = 327;
      goto LABEL_9;
    }
    if ( v7 == 3 )
    {
      if ( (signed int)sub_5B9FC(v18, v15, v9, v8) < 1 )
        goto LABEL_14;
    }
    else
    {
      if ( v7 != 1 )
      {
        ERR_put_error(4, 0LL, 143, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", 339);
        goto LABEL_14;
      }
      if ( (signed int)sub_5B578(v18, v15, v9, v8) < 1 )
        goto LABEL_14;
    }
    if ( (unsigned int)sub_5E038(v13, v11, (unsigned __int8 *)v19, v15) )
    {
      *v12 = v15;
      v20 = 1;
LABEL_15:
      OPENSSL_cleanse(v19, v15);
      free(v19);
      return v20;
    }
LABEL_14:
    v20 = 0;
    goto LABEL_15;
  }
  v16 = 135;
  v17 = 321;
LABEL_9:
  ERR_put_error(4, 0LL, v16, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v17);
  return 0;
}

//----- (000000000005F400) ----------------------------------------------------
__int64 __fastcall sub_5F400(__int64 a1, _QWORD *a2, unsigned __int8 *a3, unsigned __int64 a4, unsigned __int8 *a5, size_t a6, int a7)
{
  int v7; // w19
  size_t v8; // x25
  unsigned __int8 *v9; // x26
  unsigned __int64 v10; // x21
  unsigned __int8 *v11; // x24
  _QWORD *v12; // x22
  __int64 v13; // x27
  unsigned int v14; // w0
  signed int v15; // w23
  size_t v16; // x20
  int v17; // w2
  __int16 v18; // w4
  unsigned int v19; // w22
  unsigned __int8 *v20; // x21
  signed int v21; // w0
  int v22; // w2
  __int16 v23; // w4

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  v14 = RSA_size(a1);
  v15 = v14;
  v16 = v14;
  if ( v14 > v10 )
  {
    v17 = 135;
    v18 = 371;
LABEL_3:
    ERR_put_error(4, 0LL, v17, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v18);
    return 0;
  }
  v20 = v11;
  if ( v7 != 3 )
  {
    v20 = (unsigned __int8 *)malloc(v14);
    if ( !v20 )
    {
      v17 = 65;
      v18 = 381;
      goto LABEL_3;
    }
  }
  if ( v16 != v8 )
  {
    v22 = 112;
    v23 = 387;
LABEL_13:
    ERR_put_error(4, 0LL, v22, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v23);
LABEL_14:
    v19 = 0;
    if ( v7 == 3 )
      return v19;
    goto LABEL_15;
  }
  if ( !(unsigned int)sub_5E038(v13, v20, v9, v8) )
    goto LABEL_14;
  switch ( v7 )
  {
    case 4:
      sub_5BF08(v11, v15, v20, v15, 0LL, 0, 0LL, 0LL);
      break;
    case 3:
      goto LABEL_21;
    case 1:
      v21 = sub_5B8B4(v11, v15, v20, v15);
      break;
    default:
      v22 = 143;
      v23 = 408;
      goto LABEL_13;
  }
  v15 = v21;
LABEL_21:
  if ( v15 & 0x80000000 )
  {
    v22 = 136;
    v23 = 413;
    goto LABEL_13;
  }
  *v12 = v15;
  v19 = 1;
  if ( v7 == 3 )
    return v19;
LABEL_15:
  if ( v20 )
  {
    OPENSSL_cleanse(v20, v16);
    free(v20);
  }
  return v19;
}

//----- (000000000005F5C8) ----------------------------------------------------
__int64 __fastcall RSA_verify_raw(__int64 a1, _QWORD *a2, _BYTE *a3, unsigned __int64 a4, unsigned __int8 *a5, size_t a6, int a7)
{
  __int64 v7; // x26
  int v8; // w24
  size_t v9; // x25
  unsigned __int8 *v10; // x27
  unsigned __int64 v11; // x20
  _BYTE *v12; // x19
  _QWORD *v13; // x22
  unsigned int v14; // w0
  signed int v15; // w23
  int v16; // w2
  __int16 v17; // w4
  unsigned int v18; // w21
  _DWORD *v20; // x0
  __int64 v21; // x20
  _QWORD *v22; // x21
  _QWORD *v23; // x0
  __int64 v24; // x28
  _BYTE *v25; // x26
  __int16 v26; // w4
  int v27; // w0
  int v28; // w2
  __int16 v29; // w4
  _BYTE *v30; // [xsp+8h] [xbp-58h]

  v7 = a1;
  v8 = a7;
  v9 = a6;
  v10 = a5;
  v11 = a4;
  v12 = a3;
  v13 = a2;
  if ( !*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16) )
  {
    v16 = 144;
    v17 = 433;
    goto LABEL_6;
  }
  v14 = RSA_size(a1);
  v15 = v14;
  if ( v14 > v11 )
  {
    v16 = 135;
    v17 = 442;
LABEL_6:
    ERR_put_error(4, 0LL, v16, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v17);
    return 0;
  }
  if ( v14 != v9 )
  {
    v16 = 112;
    v17 = 447;
    goto LABEL_6;
  }
  if ( !(unsigned int)sub_5F210(v7) )
    return 0;
  v20 = BN_CTX_new();
  v21 = (__int64)v20;
  if ( !v20 )
    return 0;
  BN_CTX_start((__int64)v20);
  v22 = BN_CTX_get(v21);
  v23 = BN_CTX_get(v21);
  v24 = (__int64)v23;
  if ( !v22 || !v23 )
  {
    v26 = 467;
LABEL_22:
    ERR_put_error(4, 0LL, 65, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v26);
    v18 = 0;
    v25 = 0LL;
    goto LABEL_23;
  }
  v30 = v12;
  if ( v8 != 3 )
  {
    v30 = malloc(v9);
    if ( !v30 )
    {
      v26 = 477;
      goto LABEL_22;
    }
  }
  if ( !BN_bin2bn(v10, v9, (__int64)v22) )
  {
LABEL_19:
    v25 = v30;
    v18 = 0;
    goto LABEL_23;
  }
  if ( !(BN_ucmp((__int64)v22, *(_QWORD *)(v7 + 8)) & 0x80000000) )
  {
    ERR_put_error(4, 0LL, 115, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", 487);
    goto LABEL_19;
  }
  if ( !sub_6BAC4((__int64 *)(v7 + 152), (pthread_rwlock_t *)(v7 + 96), *(_QWORD *)(v7 + 8)) )
    goto LABEL_19;
  BN_mod_exp_mont(v24, (__int64)v22, *(_QWORD *)(v7 + 16), *(_QWORD *)(v7 + 8), v21, *(_QWORD *)(v7 + 152));
  if ( !v27 )
    goto LABEL_19;
  v25 = v30;
  if ( (unsigned int)BN_bn2bin_padded(v30, v9, v24) )
  {
    if ( v8 != 3 )
    {
      if ( v8 != 1 )
      {
        v28 = 143;
        v29 = 509;
        goto LABEL_37;
      }
      v15 = sub_5B644(v12, v15, v30, v15);
    }
    if ( !(v15 & 0x80000000) )
    {
      v18 = 1;
      *v13 = v15;
      goto LABEL_23;
    }
    v28 = 136;
    v29 = 514;
  }
  else
  {
    v28 = 68;
    v29 = 497;
  }
LABEL_37:
  ERR_put_error(4, 0LL, v28, (__int64)"external/boringssl/src/crypto/rsa/rsa_impl.c", v29);
  v18 = 0;
LABEL_23:
  BN_CTX_end(v21);
  BN_CTX_free(v21);
  if ( v25 != v12 )
    free(v25);
  return v18;
}

//----- (0000000000060888) ----------------------------------------------------
_QWORD *__fastcall sk_new(__int64 a1)
{
  __int64 v1; // x20
  _QWORD *v2; // x19
  _QWORD *v3; // x0

  v1 = a1;
  v2 = malloc(0x28uLL);
  if ( v2 && (v2[3] = 0LL, v2[4] = 0LL, v2[1] = 0LL, v2[2] = 0LL, *v2 = 0LL, v3 = malloc(0x20uLL), (v2[1] = v3) != 0LL) )
  {
    v3[2] = 0LL;
    v3[3] = 0LL;
    *v3 = 0LL;
    v3[1] = 0LL;
    v2[3] = 4LL;
    v2[4] = v1;
  }
  else
  {
    free(v2);
    v2 = 0LL;
  }
  return v2;
}

//----- (00000000000608F4) ----------------------------------------------------
_QWORD *sk_new_null()
{
  _QWORD *v0; // x19
  _QWORD *v1; // x0

  v0 = malloc(0x28uLL);
  if ( v0 && (v0[3] = 0LL, v0[4] = 0LL, v0[1] = 0LL, v0[2] = 0LL, *v0 = 0LL, v1 = malloc(0x20uLL), (v0[1] = v1) != 0LL) )
  {
    v1[2] = 0LL;
    v1[3] = 0LL;
    *v1 = 0LL;
    v1[1] = 0LL;
    v0[3] = 4LL;
    v0[4] = 0LL;
  }
  else
  {
    free(v0);
    v0 = 0LL;
  }
  return v0;
}

//----- (000000000006095C) ----------------------------------------------------
void **__fastcall sk_zero(void **result)
{
  void **v1; // x19
  void *v2; // x8

  v1 = result;
  if ( result )
  {
    v2 = *result;
    if ( *result )
    {
      if ( 8LL * (_QWORD)v2 )
        result = (void **)memset(result[1], 0, 8LL * (_QWORD)v2);
      *v1 = 0LL;
      *((_DWORD *)v1 + 4) = 0;
    }
  }
  return result;
}

//----- (00000000000609A0) ----------------------------------------------------
unsigned __int64 *__fastcall sk_value(unsigned __int64 *result, unsigned __int64 a2)
{
  if ( result )
  {
    if ( *result <= a2 )
      result = 0LL;
    else
      result = *(unsigned __int64 **)(result[1] + 8 * a2);
  }
  return result;
}

//----- (00000000000609C4) ----------------------------------------------------
__int64 __fastcall sk_set(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // x8
  __int64 result; // x0

  if ( !a1 )
    return 0LL;
  if ( *a1 <= a2 )
    return 0LL;
  v3 = a1[1];
  result = a3;
  *(_QWORD *)(v3 + 8 * a2) = a3;
  return result;
}

//----- (00000000000609FC) ----------------------------------------------------
void __fastcall sk_free(void **a1)
{
  void **v1; // x19

  v1 = a1;
  if ( a1 )
  {
    free(a1[1]);
    free(v1);
  }
}

//----- (0000000000060A34) ----------------------------------------------------
void __fastcall sk_pop_free(unsigned __int64 *a1, void (*a2)(void))
{
  void (*v2)(void); // x20
  unsigned __int64 *v3; // x19
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x21

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    v4 = *a1;
    if ( *a1 )
    {
      v5 = 0LL;
      do
      {
        if ( *(_QWORD *)(v3[1] + 8 * v5) )
        {
          v2();
          v4 = *v3;
        }
        ++v5;
      }
      while ( v5 < v4 );
    }
    free((void *)v3[1]);
    free(v3);
  }
}

//----- (0000000000060AA8) ----------------------------------------------------
char *__fastcall sk_insert(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x21
  __int64 v4; // x20
  _QWORD *v5; // x19
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x8
  char *result; // x0
  char **v9; // x23
  __int64 v10; // x8
  unsigned __int64 v11; // x22
  size_t v12; // x1
  char *v13; // x8
  unsigned __int64 v14; // x8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 )
    return 0LL;
  v6 = *a1;
  v7 = a1[3];
  if ( v7 > *a1 + 1LL )
  {
    v9 = (char **)(a1 + 1);
    result = (char *)a1[1];
    v10 = v6 - a3;
    if ( v6 <= a3 )
      goto LABEL_17;
    goto LABEL_14;
  }
  v11 = 2 * v7;
  if ( 2 * v7 < v7 || (v11 & 0x1FFFFFFFFFFFFFFELL) != v11 )
  {
    v11 = v7 + 1;
    v12 = 8 * (v7 + 1);
  }
  else
  {
    v12 = 16 * v7;
  }
  result = 0LL;
  if ( v11 >= v7 && v12 >> 3 == v11 )
  {
    v9 = (char **)(v5 + 1);
    result = (char *)realloc((void *)v5[1], v12);
    if ( result )
    {
      v6 = *v5;
      v5[1] = result;
      v5[3] = v11;
      v10 = v6 - v3;
      if ( v6 <= v3 )
      {
LABEL_17:
        v13 = &result[8 * v6];
LABEL_18:
        *(_QWORD *)v13 = v4;
        v14 = *v5;
        *((_DWORD *)v5 + 4) = 0;
        result = (char *)(v14 + 1);
        *v5 = v14 + 1;
        return result;
      }
LABEL_14:
      if ( 8 * v10 )
      {
        memmove(&result[8 * v3 + 8], &result[8 * v3], 8 * v10);
        result = *v9;
      }
      v13 = &result[8 * v3];
      goto LABEL_18;
    }
  }
  return result;
}

//----- (0000000000060BAC) ----------------------------------------------------
__int64 __fastcall sk_delete(unsigned __int64 *a1, unsigned __int64 a2)
{
  __int64 *v2; // x19
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9
  __int64 *v5; // x0
  __int64 v6; // x20
  signed __int64 v7; // x10

  v2 = (__int64 *)a1;
  if ( !a1 )
    return 0LL;
  v3 = *a1;
  if ( *a1 <= a2 )
    return 0LL;
  v4 = a1[1];
  v5 = (__int64 *)(v4 + 8 * a2);
  v6 = *v5;
  if ( v3 - 1 != a2 )
  {
    v7 = 8 * (*v2 - a2);
    if ( v7 != 8 )
    {
      memmove(v5, (const void *)(v4 + 8 * a2 + 8), v7 - 8);
      v3 = *v2;
    }
  }
  *v2 = v3 - 1;
  return v6;
}

//----- (0000000000060C20) ----------------------------------------------------
__int64 __fastcall sk_delete_ptr(unsigned __int64 *a1, __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 *v3; // x20
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x10
  __int64 v6; // x9
  unsigned __int64 v7; // x11
  signed __int64 v9; // x11

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return 0LL;
  v4 = *a1;
  if ( !*a1 )
    return 0LL;
  v5 = a1[1];
  v6 = 0LL;
  v7 = 0LL;
  while ( *(_QWORD *)(v5 + v6) != a2 )
  {
    ++v7;
    v6 += 8LL;
    if ( v4 <= v7 )
      return 0LL;
  }
  if ( v4 - 1 != v7 )
  {
    v9 = 8 * v4 - 8;
    if ( v9 != v6 )
    {
      memmove((void *)(v5 + v6), (const void *)(v5 + v6 + 8), v9 - v6);
      v4 = *v3;
    }
  }
  *v3 = v4 - 1;
  return v2;
}

//----- (0000000000060CB4) ----------------------------------------------------
_BYTE *__fastcall sk_find(__int64 a1, signed __int64 *a2, __int64 a3)
{
  signed __int64 *v3; // x19
  __int64 v4; // x20
  int (*v5)(const void *, const void *); // x4
  const void **v6; // x21
  signed __int64 v7; // x10
  _BYTE *result; // x0
  signed __int64 v9; // x8
  signed __int64 v10; // x21
  signed __int64 v11; // x22
  int v12; // w0
  __int64 v13; // [xsp+0h] [xbp-30h]
  __int64 v14; // [xsp+8h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = a3;
  if ( !a1 )
    goto LABEL_10;
  v5 = *(int (**)(const void *, const void *))(a1 + 32);
  if ( !v5 )
  {
    if ( *(_QWORD *)a1 )
    {
      v7 = 0LL;
      while ( *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v7) != a3 )
      {
        if ( (unsigned __int64)++v7 >= *(_QWORD *)a1 )
          goto LABEL_10;
      }
      if ( a2 )
        *a2 = v7;
      goto LABEL_24;
    }
    goto LABEL_10;
  }
  if ( !a3 )
  {
LABEL_10:
    result = 0LL;
    goto LABEL_11;
  }
  if ( *(_DWORD *)(a1 + 16) )
  {
    v6 = (const void **)(a1 + 8);
  }
  else
  {
    v6 = (const void **)(a1 + 8);
    qsort(*(void **)(a1 + 8), *(_QWORD *)a1, 8uLL, *(__compar_fn_t *)(a1 + 32));
    v5 = *(int (**)(const void *, const void *))(v4 + 32);
    *(_DWORD *)(v4 + 16) = 1;
  }
  result = bsearch(&v13, *v6, *(_QWORD *)v4, 8uLL, v5);
  if ( result )
  {
    v9 = result - (_BYTE *)*v6;
    v10 = (v9 >> 3) + 1;
    v11 = v9 - 8;
    while ( --v10 )
    {
      v12 = (*(__int64 (__fastcall **)(__int64 *, signed __int64))(v4 + 32))(&v13, *(_QWORD *)(v4 + 8) + v11);
      v11 -= 8LL;
      if ( v12 )
        goto LABEL_20;
    }
    v10 = 0LL;
LABEL_20:
    if ( v3 )
    {
      *v3 = v10;
      result = (_BYTE *)(&dword_0 + 1);
      goto LABEL_11;
    }
LABEL_24:
    result = (_BYTE *)(&dword_0 + 1);
  }
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v14;
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000060DF4) ----------------------------------------------------
void __fastcall sk_sort(__int64 a1)
{
  __int64 v1; // x19
  int (*v2)(const void *, const void *); // x3

  v1 = a1;
  if ( a1 )
  {
    v2 = *(int (**)(const void *, const void *))(a1 + 32);
    if ( v2 )
    {
      if ( !*(_DWORD *)(a1 + 16) )
      {
        qsort(*(void **)(a1 + 8), *(_QWORD *)a1, 8uLL, v2);
        *(_DWORD *)(v1 + 16) = 1;
      }
    }
  }
}

//----- (0000000000060E38) ----------------------------------------------------
__int64 __fastcall sk_shift(signed __int64 *a1)
{
  signed __int64 *v1; // x20
  signed __int64 v2; // x8
  __int64 *v3; // x0
  __int64 v4; // x19

  v1 = a1;
  if ( !a1 )
    return 0LL;
  v2 = *a1;
  if ( !*a1 )
    return 0LL;
  v3 = (__int64 *)a1[1];
  v4 = *v3;
  if ( v2 == 1 )
  {
    v2 = 1LL;
  }
  else if ( 8 * v2 != 8 )
  {
    memmove(v3, v3 + 1, 8 * v2 - 8);
    v2 = *v1;
  }
  *v1 = v2 - 1;
  return v4;
}

//----- (0000000000060EA4) ----------------------------------------------------
char *__fastcall sk_push(unsigned __int64 *a1, __int64 a2)
{
  return sk_insert(a1, a2, *a1);
}

//----- (0000000000060EAC) ----------------------------------------------------
signed __int64 __fastcall sk_pop(signed __int64 *a1)
{
  signed __int64 v1; // x8
  signed __int64 v2; // x10

  if ( !a1 )
    return 0LL;
  v1 = *a1;
  if ( *a1 )
  {
    v2 = v1 - 1;
    v1 = *(_QWORD *)(a1[1] + 8 * (v1 - 1));
    *a1 = v2;
  }
  return v1;
}

//----- (0000000000060EDC) ----------------------------------------------------
_QWORD *__fastcall sk_dup(__int64 a1)
{
  __int64 v1; // x20
  __int64 v2; // x22
  _QWORD *v3; // x19
  _QWORD *v4; // x0
  void *v5; // x21
  void *v6; // x0
  size_t v7; // x2

  v1 = a1;
  if ( !a1 )
    return 0LL;
  v2 = *(_QWORD *)(a1 + 32);
  v3 = malloc(0x28uLL);
  if ( !v3 )
    goto LABEL_9;
  v3[3] = 0LL;
  v3[4] = 0LL;
  v3[1] = 0LL;
  v3[2] = 0LL;
  *v3 = 0LL;
  v4 = malloc(0x20uLL);
  v5 = v4;
  v3[1] = v4;
  if ( !v4 )
  {
LABEL_9:
    free(v3);
    return 0LL;
  }
  v4[2] = 0LL;
  v4[3] = 0LL;
  *v4 = 0LL;
  v4[1] = 0LL;
  v3[3] = 4LL;
  v3[4] = v2;
  v6 = realloc(v4, 8LL * *(_QWORD *)(v1 + 24));
  if ( !v6 )
  {
    free(v5);
    goto LABEL_9;
  }
  v3[1] = v6;
  v7 = 8LL * *(_QWORD *)v1;
  *v3 = *(_QWORD *)v1;
  if ( v7 )
    memcpy(v6, *(const void **)(v1 + 8), v7);
  *((_DWORD *)v3 + 4) = *(_DWORD *)(v1 + 16);
  v3[3] = *(_QWORD *)(v1 + 24);
  v3[4] = *(_QWORD *)(v1 + 32);
  return v3;
}

//----- (0000000000060FAC) ----------------------------------------------------
signed __int64 __fastcall sk_is_sorted(__int64 a1)
{
  signed __int64 result; // x0

  if ( a1 )
    result = *(unsigned int *)(a1 + 16);
  else
    result = 1LL;
  return result;
}

//----- (0000000000060FC0) ----------------------------------------------------
__int64 __fastcall sk_set_cmp_func(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 result; // x0

  v2 = a1;
  result = *(_QWORD *)(a1 + 32);
  if ( result != a2 )
    *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 32) = a2;
  return result;
}

//----- (0000000000060FDC) ----------------------------------------------------
unsigned __int64 *__fastcall sk_deep_copy(__int64 a1, __int64 (*a2)(void), void (*a3)(void))
{
  void (*v3)(void); // x20
  __int64 (*v4)(void); // x21
  unsigned __int64 *v5; // x0
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x8
  __int64 v9; // x22
  __int64 v10; // x21
  __int64 v11; // x0

  v3 = a3;
  v4 = a2;
  v5 = sk_dup(a1);
  v6 = v5;
  if ( !v5 )
    return v6;
  v7 = *v5;
  if ( !*v5 )
    return v6;
  v8 = v5[1];
  v9 = 0LL;
  while ( !*(_QWORD *)(v8 + 8 * v9) )
  {
LABEL_7:
    if ( ++v9 >= v7 )
      return v6;
  }
  *(_QWORD *)(v6[1] + 8 * v9) = v4();
  v8 = v6[1];
  if ( *(_QWORD *)(v8 + 8 * v9) )
  {
    v7 = *v6;
    goto LABEL_7;
  }
  if ( v9 )
  {
    v10 = 0LL;
    while ( 1 )
    {
      v11 = *(_QWORD *)(v8 + 8 * v10++);
      if ( v11 )
        v3();
      if ( v10 == v9 )
        break;
      v8 = v6[1];
    }
  }
  free((void *)v6[1]);
  free(v6);
  return 0LL;
}

//----- (0000000000061098) ----------------------------------------------------
void __fastcall sub_61098(__int64 a1, unsigned __int64 a2, signed __int64 a3, unsigned __int8 *a4, unsigned __int64 a5, __int64 a6, int a7)
{
  int v7; // w19
  __int64 v8; // x20
  __int64 v9; // x21
  signed __int64 v10; // x23
  unsigned __int64 v11; // x24
  __int64 v12; // x25
  int v13; // w0
  int v14; // w23
  unsigned int v15; // [xsp+Ch] [xbp-A4h]
  __int64 v16; // [xsp+10h] [xbp-A0h]
  int v17; // [xsp+1Ch] [xbp-94h]
  __int64 v18; // [xsp+20h] [xbp-90h]
  __int64 v19; // [xsp+28h] [xbp-88h]
  __int64 v20; // [xsp+30h] [xbp-80h]
  __int64 v21; // [xsp+38h] [xbp-78h]
  __int64 v22; // [xsp+40h] [xbp-70h]
  char v23; // [xsp+4Ch] [xbp-64h]
  __int64 v24; // [xsp+50h] [xbp-60h]
  void *v25; // [xsp+58h] [xbp-58h]
  __int64 v26; // [xsp+60h] [xbp-50h]
  __int64 v27; // [xsp+68h] [xbp-48h]

  v7 = a7;
  v8 = a6;
  v9 = (__int64)a4;
  v10 = a3;
  v11 = a2;
  v12 = a1;
  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v24 = 0LL;
  v25 = 0LL;
  v19 = 0LL;
  v20 = 0LL;
  v18 = 0LL;
  v17 = 0;
  v16 = 0LL;
  v15 = 0;
  v26 = 0LL;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          if ( a5 )
          {
            if ( a6 )
            {
              if ( !(unsigned int)sub_9C8B0((unsigned __int8 **)&v26, a4, a5)
                && !(unsigned int)sub_9C968(v26, &v25, &v24) )
              {
                sub_612B0(v12, (unsigned __int64)v25, v24, v11, v10);
                if ( !v13
                  && !(unsigned int)sub_9CA58(v26, &v23)
                  && v23 == 2
                  && !(unsigned int)sub_9CA88(v26, &v22, &v21) )
                {
                  v14 = v22;
                  if ( !(unsigned int)sub_61B40((void ****)&v20)
                    && !(unsigned int)sub_61C54(v20, v9, -2 - (signed int)v9 + v14)
                    && !(unsigned int)sub_61C90(v20, &v18, &v17)
                    && !(unsigned int)sub_61B40((void ****)&v19)
                    && !(unsigned int)sub_61C54(v19, v18, v17)
                    && !(unsigned int)sub_61C54(v19, v8, v7)
                    && !(unsigned int)sub_61C90(v19, &v16, &v15) )
                  {
                    sub_61470((__int64)v25, v24, v22, v21, v16, v15);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  sub_61C14(v19);
  sub_61C14(v20);
  std::__1::basic_streambuf<char,std::__1::char_traits<char>>::sync();
  free(v25);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v27;
}

//----- (00000000000612B0) ----------------------------------------------------
void __fastcall sub_612B0(__int64 a1, unsigned __int64 a2, signed __int64 a3, unsigned __int64 a4, signed __int64 a5)
{
  signed __int64 v5; // x23
  unsigned __int64 v6; // x24
  signed __int64 v7; // x27
  unsigned __int64 v8; // x26
  __int64 v9; // x22
  unsigned __int64 *v10; // x19
  unsigned __int64 **v11; // x20
  unsigned __int64 *v12; // x25
  unsigned __int64 v13; // x20
  unsigned __int64 *v14; // x8
  unsigned __int64 **v15; // x0
  int v16; // w0
  __int64 *v17; // [xsp+8h] [xbp-68h]
  unsigned __int64 v18; // [xsp+10h] [xbp-60h]
  __int64 v19; // [xsp+18h] [xbp-58h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = 0LL;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  if ( a2 && a3 && a4 )
  {
    v11 = 0LL;
    if ( a5 )
    {
      v10 = sk_new_null();
      if ( v10 )
      {
        v18 = v8;
        if ( v7 < 1 )
        {
LABEL_17:
          v11 = 0LL;
        }
        else
        {
          v12 = 0LL;
          v13 = v8 + v7;
          do
          {
            v14 = d2i_X509(0LL, (const void **)&v18, (unsigned int)(v13 - v8));
            if ( !v14 )
            {
              v11 = 0LL;
              goto LABEL_19;
            }
            if ( !v12 )
              v12 = v14;
            sk_push(v10, (__int64)v14);
            LODWORD(v8) = v18;
          }
          while ( v18 < v13 );
          if ( !v12 )
            goto LABEL_17;
          if ( (unsigned int)sub_61D2C((__int64 *)&v17, v6, v5, v9) )
          {
            v11 = 0LL;
          }
          else
          {
            v15 = (unsigned __int64 **)X509_STORE_CTX_new();
            v11 = v15;
            if ( v15 )
            {
              if ( (unsigned int)X509_STORE_CTX_init(v15, v17, v12, v10) == 1 )
              {
                X509_verify_cert(v11);
                if ( v16 == 1 )
                  sub_56728(v9);
              }
            }
          }
        }
      }
      else
      {
        v11 = 0LL;
      }
    }
  }
  else
  {
    v11 = 0LL;
  }
LABEL_19:
  sk_pop_free(v10, (void (*)(void))X509_free);
  if ( v17 )
    X509_STORE_free((__int64)v17);
  X509_STORE_CTX_free((__int64)v11);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v19;
}

//----- (0000000000061470) ----------------------------------------------------
void __fastcall sub_61470(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // x19
  int *v7; // x20
  __int64 *v8; // x22
  unsigned __int64 *v9; // x0
  __int64 v10; // x0
  int **v11; // x0
  __int64 v12; // [xsp+0h] [xbp-60h]
  __int64 v13; // [xsp+8h] [xbp-58h]

  v6 = 0LL;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
  {
    v7 = 0LL;
    v8 = 0LL;
    goto LABEL_17;
  }
  v7 = 0LL;
  v8 = 0LL;
  if ( a6 )
  {
    v12 = a1;
    v9 = d2i_X509(0LL, (const void **)&v12, a2);
    v6 = (__int64)v9;
    if ( v9 )
    {
      X509_get_pubkey((__int64)v9);
      v7 = (int *)v10;
      if ( v10 )
      {
        v11 = EVP_PKEY_CTX_new(v10, 0LL);
        v8 = (__int64 *)v11;
        if ( v11 )
        {
          if ( (unsigned int)EVP_PKEY_verify_init(v11) == 1 && (unsigned int)EVP_PKEY_CTX_set_rsa_padding(v8) == 1 )
          {
            EVP_sha256();
            if ( (unsigned int)EVP_PKEY_CTX_set_signature_md(v8) == 1 )
              EVP_PKEY_verify(v8);
          }
        }
        goto LABEL_17;
      }
    }
    else
    {
      v7 = 0LL;
    }
    v8 = 0LL;
  }
LABEL_17:
  EVP_PKEY_CTX_free((int **)v8);
  EVP_PKEY_free(v7);
  X509_free(v6);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000006162C) ----------------------------------------------------
_DWORD *sub_6162C()
{
  _DWORD *result; // x0

  result = malloc(0x18uLL);
  if ( result )
  {
    *result = 1;
    result[2] = 0;
  }
  return result;
}

//----- (0000000000061654) ----------------------------------------------------
_QWORD *sub_61654()
{
  _QWORD *result; // x0

  result = malloc(0x18uLL);
  if ( result )
  {
    *(_DWORD *)result = 0;
    result[1] = 0LL;
  }
  return result;
}

//----- (0000000000061678) ----------------------------------------------------
_QWORD *sub_61678()
{
  _QWORD *result; // x0

  result = malloc(0x18uLL);
  if ( result )
  {
    *(_DWORD *)result = 3;
    result[1] = 0LL;
    result[2] = 0LL;
  }
  return result;
}

//----- (00000000000616A0) ----------------------------------------------------
__int64 __fastcall sub_616A0(__int64 result)
{
  if ( result )
  {
    if ( *(_DWORD *)result )
      result = 0LL;
    else
      result = *(_QWORD *)(result + 8);
  }
  return result;
}

//----- (00000000000616BC) ----------------------------------------------------
__int64 __fastcall sub_616BC(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x8
  __int64 result; // x0

  v2 = a1;
  result = 0LL;
  if ( v2 && a2 )
  {
    if ( *(_DWORD *)v2 == 3 )
    {
      *a2 = *(_QWORD *)(v2 + 16);
      result = *(_QWORD *)(v2 + 8);
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000616F0) ----------------------------------------------------
void __fastcall sub_616F0(_QWORD *a1)
{
  void *v1; // x19
  void *v2; // x0

  v1 = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 == 3 )
    {
      v2 = (void *)a1[2];
    }
    else
    {
      if ( *(_DWORD *)a1 )
      {
LABEL_8:
        free(v1);
        return;
      }
      v2 = (void *)a1[1];
    }
    free(v2);
    goto LABEL_8;
  }
}

//----- (0000000000061740) ----------------------------------------------------
_QWORD *__fastcall sub_61740(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  __int64 v4; // x19
  __int64 v5; // x21
  _QWORD *result; // x0
  __int64 v7; // x8
  __int64 v8; // x8

  v3 = a1;
  v4 = a3;
  v5 = a2;
  result = malloc(0x48uLL);
  if ( result )
  {
    *result = v5;
    v7 = *(_QWORD *)(v3 + 8);
    result[1] = v7;
    result[2] = v7;
    v8 = *(_QWORD *)(v3 + 24);
    result[8] = 0LL;
    result[5] = 0LL;
    result[6] = 0LL;
    *((_BYTE *)result + 56) = 1;
    result[3] = v8;
    result[4] = v4;
  }
  return result;
}

//----- (000000000006179C) ----------------------------------------------------
signed __int64 __fastcall sub_6179C(_QWORD *a1, __int64 a2, size_t a3, const void *a4, __int64 a5)
{
  __int64 v5; // x19
  const void *v6; // x23
  size_t v7; // x21
  __int64 v8; // x22
  _QWORD *v9; // x20
  signed __int64 result; // x0
  char *v11; // x0
  char *v12; // x24
  signed __int64 v13; // x25

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  result = 4294967274LL;
  if ( v9 && a2 && a3 && a4 )
  {
    v11 = (char *)malloc(a3 + 72);
    v12 = v11;
    if ( v11 )
    {
      v13 = (signed __int64)(v11 + 72);
      memcpy(v11 + 72, v6, v7);
      result = 0LL;
      *(_QWORD *)v12 = v8;
      *((_QWORD *)v12 + 1) = v13;
      *((_QWORD *)v12 + 8) = 0LL;
      v12[56] = 0;
      *((_QWORD *)v12 + 5) = 0LL;
      *((_QWORD *)v12 + 6) = 0LL;
      *((_QWORD *)v12 + 3) = v13 + v7;
      *((_QWORD *)v12 + 4) = v5;
      *((_QWORD *)v12 + 2) = v13;
      *v9 = v12;
    }
    else
    {
      result = 4294967284LL;
    }
  }
  return result;
}

//----- (0000000000061844) ----------------------------------------------------
void __fastcall sub_61844(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 v2; // x8
  void **v3; // x20

  if ( a1 )
  {
    do
    {
      v1 = a1;
      a1 = (_QWORD *)a1[6];
    }
    while ( a1 );
    while ( 1 )
    {
      v2 = v1[5];
      if ( !v2 )
        break;
      v1 = (_QWORD *)v1[5];
      v3 = *(void ***)(v2 + 48);
      if ( v3 )
      {
        free(v3[8]);
        free(v3);
        v1[6] = 0LL;
      }
    }
    free(v1);
  }
}

//----- (00000000000618A4) ----------------------------------------------------
__int64 __fastcall sub_618A4(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x19
  _QWORD *v3; // x21
  __int64 v4; // x8
  __int64 result; // x0
  const char **v6; // x23
  const char *v7; // x22
  const char *v8; // x20
  size_t v9; // x0
  __int64 v10; // x22
  _QWORD *v11; // x0
  _QWORD *v12; // x20
  __int64 v13; // x8
  __int64 v14; // x8
  __int64 v15; // x8
  __int64 v16; // x21
  _QWORD *v17; // x21
  const char **v18; // x24
  const char *v19; // x22
  const char *v20; // x23
  size_t v21; // x0
  __int64 v22; // x24
  _BYTE *v23; // t1
  __int64 (__fastcall *v24)(_QWORD *, __int64 *, __int64); // x8
  __int64 v25; // x22
  _QWORD *v26; // x0
  __int64 v27; // x8
  __int64 v28; // x8
  __int64 v29; // x20
  unsigned __int64 v30; // x8
  unsigned __int64 v31; // x9
  __int64 v32; // [xsp+0h] [xbp-40h]
  __int64 v33; // [xsp+8h] [xbp-38h]

  v2 = a2;
  v33 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v32 = 0LL;
  if ( !a1 )
  {
    result = 4294967274LL;
    goto LABEL_37;
  }
  do
  {
    v3 = a1;
    a1 = (_QWORD *)a1[6];
  }
  while ( a1 );
  v4 = *v3;
  if ( !*v3 )
    goto LABEL_36;
  v3[1] = v3[2];
  result = (*(__int64 (__fastcall **)(_QWORD *, __int64 *, _QWORD))(v4 + 16))(v3, &v32, 0LL);
  if ( result & 0x80000000 )
    goto LABEL_37;
  if ( v32 )
  {
    v6 = (const char **)v3[4];
    if ( v6 )
    {
      v7 = *v6;
      v8 = *(const char **)(*v3 + 8LL);
      v9 = strlen(*(const char **)(*v3 + 8LL));
      if ( !(unsigned int)strncmp(v8, v7, v9) )
        v6 = (const char **)(v3[4] + 8LL);
    }
    v10 = v32;
    v11 = malloc(0x48uLL);
    v12 = v11;
    if ( !v11 )
    {
      result = 4294967284LL;
      goto LABEL_37;
    }
    v3[6] = v11;
    *v11 = v10;
    v13 = v3[1];
    v11[1] = v13;
    v11[2] = v13;
    v14 = v3[3];
    v11[5] = v3;
    v11[6] = 0LL;
    v11[8] = 0LL;
    v11[3] = v14;
    v11[4] = v6;
    *((_BYTE *)v11 + 56) = *((_BYTE *)v3 + 56);
    v15 = *v11;
    if ( !*v11 )
      goto LABEL_36;
LABEL_17:
    v17 = v12;
    while ( 1 )
    {
      v18 = (const char **)v12[4];
      if ( !v18
        || (v19 = *(const char **)(v15 + 8),
            v20 = *v18,
            v21 = strlen(*(const char **)(v15 + 8)),
            (unsigned int)strncmp(v19, v20, v21))
        || (v22 = v12[4], v23 = *(_BYTE **)(v22 + 8), v18 = (const char **)(v22 + 8), *v23) )
      {
        v24 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, __int64))(*v17 + 16LL);
      }
      else
      {
        v24 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, __int64))(*v17 + 16LL);
        if ( v12[1] == v12[2] )
        {
          LODWORD(result) = v24(v12, &v32, v2);
          if ( (signed int)result >= 0 )
            result = 1LL;
          else
            result = (unsigned int)result;
          goto LABEL_37;
        }
      }
      result = v24(v12, &v32, 0LL);
      if ( result & 0x80000000 )
        goto LABEL_37;
      v25 = v32;
      if ( v32 )
      {
        v26 = malloc(0x48uLL);
        v17 = v26;
        if ( !v26 )
        {
          result = 4294967284LL;
          goto LABEL_37;
        }
        v12[6] = v26;
        *v26 = v25;
        v27 = v12[1];
        v26[1] = v27;
        v26[2] = v27;
        v28 = v12[3];
        v26[5] = v12;
        v26[6] = 0LL;
        v26[8] = 0LL;
        v26[3] = v28;
        v26[4] = v18;
        *((_BYTE *)v26 + 56) = *((_BYTE *)v12 + 56);
      }
      else
      {
        v17 = (_QWORD *)v12[5];
        if ( !v17 )
        {
          v30 = v12[3];
          v31 = v12[1];
          goto LABEL_43;
        }
        v29 = v17[6];
        v17[1] = *(_QWORD *)(v29 + 8);
        if ( v29 )
        {
          free(*(void **)(v29 + 64));
          free((void *)v29);
          v17[6] = 0LL;
        }
      }
      v15 = *v17;
      v12 = v17;
      if ( !*v17 )
        goto LABEL_36;
    }
  }
  v12 = (_QWORD *)v3[5];
  if ( v12 )
  {
    v16 = v12[6];
    v12[1] = *(_QWORD *)(v16 + 8);
    if ( v16 )
    {
      free(*(void **)(v16 + 64));
      free((void *)v16);
      v12[6] = 0LL;
    }
    v15 = *v12;
    if ( *v12 )
      goto LABEL_17;
LABEL_36:
    result = 4294966280LL;
    goto LABEL_37;
  }
  v30 = v3[3];
  v31 = v3[1];
LABEL_43:
  if ( v30 >= v31 )
    result = 0LL;
  else
    result = 4294966280LL;
LABEL_37:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v33;
  return result;
}

//----- (0000000000061B40) ----------------------------------------------------
__int64 __fastcall sub_61B40(void ****a1)
{
  void ****v1; // x19
  void ***v2; // x20
  void ***v3; // x20
  __int64 *v4; // x22
  __int64 v5; // x0
  unsigned int v6; // w19

  v1 = a1;
  if ( !a1 )
    return (unsigned int)-22;
  v2 = (void ***)malloc(0x28uLL);
  *v1 = v2;
  if ( !v2 )
    return (unsigned int)-22;
  (*v1)[4] = (void **)EVP_MD_CTX_create();
  v3 = *v1;
  v4 = (__int64 *)(*v1)[4];
  if ( !v4 )
  {
    v6 = -12;
    if ( !v3 )
      return v6;
    goto LABEL_12;
  }
  v5 = EVP_get_digestbyname("SHA256");
  if ( (unsigned int)EVP_DigestInit_ex(v4, v5) != 1 )
  {
    v3 = *v1;
    v6 = -1019;
    if ( !v3 )
      return v6;
LABEL_12:
    EVP_MD_CTX_cleanup(v3[4]);
    EVP_MD_CTX_destroy(v3[4]);
    free(v3);
    return v6;
  }
  return 0;
}

//----- (0000000000061C14) ----------------------------------------------------
void __fastcall sub_61C14(__int64 a1)
{
  void ***v1; // x19

  v1 = (void ***)a1;
  if ( a1 )
  {
    EVP_MD_CTX_cleanup(*(_QWORD **)(a1 + 32));
    EVP_MD_CTX_destroy(v1[4]);
    free(v1);
  }
}

//----- (0000000000061C54) ----------------------------------------------------
signed __int64 __fastcall sub_61C54(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0

  v3 = a1;
  result = 4294967274LL;
  if ( v3 && a2 && a3 )
  {
    if ( (unsigned int)EVP_DigestUpdate(*(_QWORD *)(v3 + 32)) == 1 )
      result = 0LL;
    else
      result = 4294966277LL;
  }
  return result;
}

//----- (0000000000061C90) ----------------------------------------------------
signed __int64 __fastcall sub_61C90(__int64 a1, __int64 *a2, _DWORD *a3)
{
  _DWORD *v3; // x19
  __int64 *v4; // x20
  __int64 v5; // x21
  signed __int64 result; // x0
  int v7; // [xsp+4h] [xbp-2Ch]
  __int64 v8; // [xsp+8h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  result = 4294967274LL;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = 0;
  if ( v5 && a2 && a3 )
  {
    if ( (unsigned int)EVP_DigestFinal_ex(*(void ***)(v5 + 32), v5, &v7) == 1 )
    {
      *v4 = v5;
      result = 0LL;
      *v3 = v7;
    }
    else
    {
      result = 4294966277LL;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000061D2C) ----------------------------------------------------
signed __int64 __fastcall sub_61D2C(__int64 *a1, unsigned __int64 a2, signed __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  signed __int64 v5; // x22
  unsigned __int64 v6; // x21
  __int64 *v7; // x20
  _DWORD *v8; // x0
  unsigned __int64 v9; // x22
  unsigned __int64 *v10; // x8
  signed __int64 result; // x0
  unsigned __int64 v12; // [xsp+0h] [xbp-30h]
  __int64 v13; // [xsp+8h] [xbp-28h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v12 = 0LL;
  v8 = X509_STORE_new();
  *v7 = (__int64)v8;
  if ( v8 )
  {
    v12 = v6;
    if ( v5 < 1 )
    {
LABEL_7:
      X509_STORE_set_verify_cb((__int64)v8, (__int64)sub_61E04);
      result = 0LL;
      qword_107190 = v4;
    }
    else
    {
      v9 = v6 + v5;
      while ( 1 )
      {
        v10 = d2i_X509(0LL, (const void **)&v12, v9 - v6);
        if ( !v10 )
          break;
        X509_STORE_add_cert(*v7, (__int64)v10);
        v6 = v12;
        if ( v12 >= v9 )
        {
          v8 = (_DWORD *)*v7;
          goto LABEL_7;
        }
      }
      result = 4294966280LL;
    }
  }
  else
  {
    result = 4294967284LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 107190: using guessed type __int64 qword_107190;

//----- (0000000000061E04) ----------------------------------------------------
void __fastcall sub_61E04(int a1, __int64 a2)
{
  __int64 v2; // x23
  int v3; // w21
  __int64 v4; // x20
  int v5; // w19
  __int64 v6; // x22
  unsigned __int64 **v7; // x0
  unsigned __int64 **v8; // x23
  int v9; // w0
  int v10; // w24
  void *v11; // x20
  signed int v12; // w23
  void *v13; // x24
  _QWORD *v14; // x21
  int v15; // w0
  int v16; // w22
  unsigned __int64 *v17; // x0
  __int64 v18; // x24
  _QWORD *v19; // x0
  void *v20; // x25
  int v21; // w0
  __int64 v22; // x27
  void *v23; // x23
  signed int *v24; // x0
  __int64 v25; // x26
  unsigned __int64 v26; // x25
  _OWORD *v27; // x0
  void *v28; // x24
  unsigned __int64 v29; // x8
  unsigned __int64 v30; // x10
  unsigned __int64 v31; // x9
  int v32; // w0
  int v33; // w24
  signed __int64 v34; // x11
  __int128 *v35; // x11
  _OWORD *v36; // x12
  unsigned __int64 v37; // x13
  __int128 v38; // q0
  __int128 v39; // q1
  _QWORD *v40; // x0
  void *v41; // [xsp+0h] [xbp-60h]
  __int64 v42; // [xsp+8h] [xbp-58h]

  v2 = a2;
  v3 = a1;
  v42 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = X509_STORE_CTX_get_current_cert(a2);
  v5 = X509_STORE_CTX_get_error_depth(v2);
  if ( lh_num_items(v2) )
  {
    v6 = qword_107190;
    if ( qword_107190 )
    {
      if ( v3 )
      {
        v7 = (unsigned __int64 **)X509_get_subject_name(v4);
        v8 = v7;
        if ( v7 && (v9 = X509_NAME_get_text_by_NID(v7, 0xDu, 0LL, 0), v9 >= 1) )
        {
          v10 = v9 + 1;
          v11 = malloc(v9 + 1);
          if ( v11 )
          {
            v12 = X509_NAME_get_text_by_NID(v8, 0xDu, v11, v10);
            if ( v12 >= 1 )
            {
              v13 = malloc(0x18uLL);
              if ( v13 )
              {
                *(_DWORD *)v13 = v5;
                *((_QWORD *)v13 + 1) = v11;
                *((_QWORD *)v13 + 2) = v12;
                sub_57020(v6, (__int64)v13);
                free(*((void **)v13 + 1));
                free(v13);
                goto LABEL_12;
              }
            }
          }
        }
        else
        {
          v11 = 0LL;
        }
        free(v11);
        goto LABEL_12;
      }
      if ( lh_num_items(v2) )
      {
        v14 = (_QWORD *)qword_107190;
        if ( qword_107190 )
        {
          v15 = X509_STORE_CTX_get_error(v2);
          if ( (unsigned int)(v15 - 9) >= 2 )
          {
            if ( v15 != 34 )
            {
              X509_STORE_CTX_get_error_depth(v2);
              goto LABEL_12;
            }
            v16 = -1;
            while ( 1 )
            {
              v16 = X509_get_ext_by_critical(v4, 1, v16);
              if ( v16 == -1 )
                goto LABEL_12;
              v17 = X509_get_ext(v4, v16);
              v18 = (__int64)v17;
              if ( !v17 )
                goto LABEL_12;
              v41 = 0LL;
              v19 = sk_num(v17);
              v20 = v19;
              if ( !v19 )
              {
                v23 = 0LL;
                v28 = 0LL;
                goto LABEL_35;
              }
              v21 = i2d_ASN1_OBJECT((signed __int64)v19, 0LL);
              if ( !v21 )
                break;
              v22 = v21;
              v23 = malloc(v21 + 1LL);
              if ( !v23 )
                goto LABEL_33;
              v41 = v23;
              i2d_ASN1_OBJECT((signed __int64)v20, &v41);
              v24 = (signed int *)X509_EXTENSION_get_data(v18);
              v25 = (__int64)v24;
              if ( v24 )
              {
                v26 = *v24;
                if ( (_DWORD)v26 )
                {
                  v27 = malloc(*v24);
                  v28 = v27;
                  if ( v27 )
                  {
                    v29 = *(_QWORD *)(v25 + 8);
                    if ( v26 <= 1 )
                      v30 = 1LL;
                    else
                      v30 = v26;
                    v41 = *(void **)(v25 + 8);
                    if ( v30 < 0x20 )
                    {
                      v31 = 0LL;
                      goto LABEL_50;
                    }
                    v31 = v30 & 0xFFFFFFFFFFFFFFE0LL;
                    if ( !(v30 & 0xFFFFFFFFFFFFFFE0LL) )
                      goto LABEL_59;
                    if ( v26 <= 1 )
                      v34 = 1LL;
                    else
                      v34 = v26;
                    if ( (unsigned __int64)v27 < v29 + v34 && v29 < (unsigned __int64)v27 + v34 )
                    {
                      v31 = 0LL;
                      goto LABEL_50;
                    }
                    v35 = (__int128 *)(v29 + 16);
                    v36 = v27 + 1;
                    v37 = v30 & 0xFFFFFFFFFFFFFFE0LL;
                    do
                    {
                      v38 = *(v35 - 1);
                      v39 = *v35;
                      v35 += 2;
                      v37 -= 32LL;
                      *(v36 - 1) = v38;
                      *v36 = v39;
                      v36 += 2;
                    }
                    while ( v37 );
                    if ( v30 != v31 )
                    {
LABEL_59:
                      do
                      {
LABEL_50:
                        *((_BYTE *)v27 + v31) = *(_BYTE *)(v29 + v31);
                        ++v31;
                      }
                      while ( v31 < v26 );
                    }
                    v40 = malloc(0x28uLL);
                    v25 = (__int64)v40;
                    if ( v40 )
                    {
                      v40[1] = v23;
                      v40[2] = v22;
                      v40[3] = v28;
                      v40[4] = v26;
                      v20 = v40;
                      v23 = 0LL;
                      v28 = 0LL;
                      *(_DWORD *)v40 = v5;
                    }
                    else
                    {
                      v20 = 0LL;
                    }
                    goto LABEL_36;
                  }
LABEL_34:
                  v20 = 0LL;
LABEL_35:
                  v25 = 0LL;
                  goto LABEL_36;
                }
LABEL_33:
                v28 = 0LL;
                goto LABEL_34;
              }
              v28 = 0LL;
              v20 = 0LL;
LABEL_36:
              free(v23);
              free(v28);
              if ( v25 )
              {
                sub_56E8C(v14, v25);
                v33 = v32;
                free(*(void **)(v25 + 8));
                free(*(void **)(v25 + 24));
                free(v20);
                if ( !v33 )
                  continue;
              }
              goto LABEL_12;
            }
            v23 = 0LL;
            goto LABEL_33;
          }
        }
      }
    }
  }
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v42;
}
// 107190: using guessed type __int64 qword_107190;

//----- (000000000006218C) ----------------------------------------------------
signed __int64 __fastcall i2d_ASN1_OBJECT(signed __int64 result, void **a2)
{
  void **v2; // x20
  signed __int64 v3; // x21
  unsigned int v4; // w19
  size_t v5; // x2
  __int64 v6; // x8
  void *v7; // [xsp+0h] [xbp-30h]
  __int64 v8; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v3 = result;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( result && *(_QWORD *)(result + 24) )
  {
    result = ASN1_object_size(0, *(_DWORD *)(result + 20), 6);
    v4 = result;
    if ( v2 && (_DWORD)result != -1 )
    {
      v7 = *v2;
      ASN1_put_object((_BYTE **)&v7, 0, *(_DWORD *)(v3 + 20), 6, 0);
      result = (signed __int64)v7;
      v5 = *(signed int *)(v3 + 20);
      if ( (_DWORD)v5 )
      {
        memcpy(v7, *(const void **)(v3 + 24), v5);
        result = (signed __int64)v7;
        v6 = *(signed int *)(v3 + 20);
      }
      else
      {
        v6 = 0LL;
      }
      v7 = (void *)(result + v6);
      *v2 = (void *)(result + v6);
    }
  }
  else
  {
    v4 = 0;
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v8 )
    result = v4;
  return result;
}

//----- (0000000000062268) ----------------------------------------------------
void __fastcall a2d_ASN1_OBJECT(__int64 a1, int a2, const char *a3, int a4)
{
  const char *v4; // x20
  int v5; // w19
  __int64 v6; // x24
  __int64 v7; // x8
  int v8; // w21
  int v9; // w2
  __int16 v10; // w4
  __int64 v11; // x28
  unsigned __int64 **v12; // x19
  int v13; // w23
  unsigned __int8 *v14; // x22
  char *v15; // x20
  unsigned __int64 v16; // x25
  signed int v17; // w27
  int i; // w26
  int v19; // w25
  unsigned int v20; // w8
  int v21; // w24
  __int64 v22; // x8
  __int64 v23; // x25
  signed __int64 v24; // x0
  bool v25; // zf
  int v26; // w9
  __int64 v27; // x10
  __int64 v28; // x11
  __int64 v29; // x12
  signed __int64 v30; // x13
  __int64 v31; // x8
  char v32; // w14
  int v33; // w2
  __int16 v34; // w4
  signed __int64 v35; // [xsp+0h] [xbp-A0h]
  __int64 v36; // [xsp+8h] [xbp-98h]
  signed int v37; // [xsp+10h] [xbp-90h]
  int v38; // [xsp+1Ch] [xbp-84h]
  __int64 v39; // [xsp+20h] [xbp-80h]
  int v40; // [xsp+28h] [xbp-78h]
  char v41; // [xsp+30h] [xbp-70h]
  __int64 v42; // [xsp+48h] [xbp-58h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v42 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a4 )
    goto LABEL_9;
  if ( a4 == -1 )
    a4 = strlen(a3);
  v7 = *(unsigned __int8 *)v4;
  if ( (((_DWORD)v7 - 48) & 0xFFu) > 2 )
  {
    v9 = 122;
    v10 = 110;
    goto LABEL_8;
  }
  v8 = a4 - 2;
  if ( a4 < 2 )
  {
    v9 = 154;
    v10 = 115;
LABEL_8:
    ERR_put_error(12, 0LL, v9, (__int64)"external/boringssl/src/crypto/asn1/a_object.c", v10);
    goto LABEL_9;
  }
  if ( v8 < 1 )
    goto LABEL_9;
  v38 = v5;
  LODWORD(v11) = *((unsigned __int8 *)v4 + 1);
  v39 = v6;
  v40 = 24;
  v12 = 0LL;
  v13 = 0;
  v14 = (unsigned __int8 *)(v4 + 2);
  v15 = &v41;
  v37 = v7 - 48;
  v35 = 40 * (v7 - 48);
  v36 = 40 * ((signed int)v7 - 48);
  while ( 1 )
  {
    if ( (_DWORD)v11 != 46 && (_DWORD)v11 != 32 )
    {
      v33 = 147;
      v34 = 124;
LABEL_68:
      ERR_put_error(12, 0LL, v33, (__int64)"external/boringssl/src/crypto/asn1/a_object.c", v34);
      goto LABEL_69;
    }
    v16 = 0LL;
    v17 = 0;
    for ( i = v8 - 1; v8 >= 1; i = v8 - 1 )
    {
      v11 = *v14;
      if ( (_DWORD)v11 == 32 || (_DWORD)v11 == 46 )
      {
        ++v14;
        v8 = i;
        break;
      }
      if ( (unsigned int)(v11 - 48) >= 0xA )
      {
        v33 = 143;
        v34 = 137;
        goto LABEL_68;
      }
      if ( v17 || v16 < 0x1999999999999991LL )
      {
        if ( !v17 )
        {
          v16 = v11 + 10 * v16 - 48;
          ++v14;
          v8 = i;
          v17 = 0;
          continue;
        }
      }
      else
      {
        if ( !v12 )
        {
          v12 = (unsigned __int64 **)BN_new();
          if ( !v12 )
            goto LABEL_69;
        }
        if ( !(unsigned int)BN_set_word((__int64)v12, v16) )
          goto LABEL_69;
        v17 = 1;
      }
      if ( !(unsigned int)BN_mul_word(v12, 0xAuLL) )
        goto LABEL_69;
      v8 = i;
      ++v14;
      if ( !(unsigned int)BN_add_word((__int64)v12, v11 - 48) )
        goto LABEL_69;
    }
    if ( !v13 )
      break;
    if ( v17 )
      goto LABEL_40;
LABEL_52:
    v22 = 0LL;
    do
    {
      v15[v22++] = v16 & 0x7F;
      v16 >>= 7;
    }
    while ( v16 );
LABEL_54:
    if ( v39 )
    {
      if ( (signed int)v22 + v13 > v38 )
      {
        v33 = 107;
        v34 = 196;
        goto LABEL_68;
      }
      v26 = v13 + 1;
      v27 = v13;
      v28 = (unsigned int)(v22 - 2);
      if ( (signed int)v22 >= 2 )
      {
        v29 = v26;
        v30 = (signed int)v22;
        v26 = v22 + v13;
        v31 = v29;
        do
        {
          v32 = v15[v30-- - 1];
          *(_BYTE *)(v39 + v27) = v32 | 0x80;
          v27 = v31++;
        }
        while ( v30 > 1 );
        v27 = v29 + v28;
      }
      v13 = v26;
      *(_BYTE *)(v39 + v27) = *v15;
      if ( v8 <= 0 )
        goto LABEL_63;
    }
    else
    {
      v13 += v22;
      if ( v8 <= 0 )
      {
LABEL_63:
        if ( v15 != &v41 )
          free(v15);
        if ( v12 )
          BN_free(v12);
        goto LABEL_9;
      }
    }
  }
  if ( v37 <= 1 && v16 >= 0x28 )
  {
    v33 = 167;
    v34 = 156;
    goto LABEL_68;
  }
  if ( !v17 )
  {
    v16 += v35;
    goto LABEL_52;
  }
  if ( !(unsigned int)BN_add_word((__int64)v12, v36) )
    goto LABEL_69;
LABEL_40:
  v19 = BN_num_bits((__int64)v12);
  v20 = ((unsigned __int64)(-1840700269LL * (v19 + 6)) >> 32) + v19 + 6;
  v21 = ((signed int)v20 >> 2) + (v20 >> 31);
  if ( v21 <= v40 )
    goto LABEL_78;
  if ( v15 != &v41 )
    free(v15);
  v40 = v21 + 32;
  v15 = (char *)malloc(v21 + 32);
  if ( v15 )
  {
LABEL_78:
    if ( (unsigned int)(v19 + 12) >= 0xD )
    {
      v23 = 0LL;
      while ( 1 )
      {
        v24 = BN_div_word((__int64)v12, 0x80uLL);
        if ( v24 == -1 )
          break;
        LODWORD(v22) = v23 + 1;
        v25 = v21 == (_DWORD)v23 + 1;
        v15[v23++] = v24;
        if ( v25 )
          goto LABEL_54;
      }
LABEL_69:
      if ( v15 == &v41 )
        goto LABEL_71;
      goto LABEL_70;
    }
    LODWORD(v22) = 0;
    goto LABEL_54;
  }
LABEL_70:
  free(v15);
LABEL_71:
  if ( v12 )
    BN_free(v12);
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v42;
}

//----- (000000000006269C) ----------------------------------------------------
void __fastcall i2t_ASN1_OBJECT(_BYTE *a1, signed int a2, unsigned int *a3)
{
  OBJ_obj2txt(a1, a2, a3, 0);
}

//----- (00000000000626A4) ----------------------------------------------------
void __fastcall i2a_ASN1_OBJECT(_QWORD *a1, __int64 a2)
{
  unsigned int *v2; // x21
  _QWORD *v3; // x20
  signed int v4; // w0
  unsigned int v5; // w19
  signed int v6; // w23
  _BYTE *v7; // x0
  void *v8; // x22
  const char *v9; // x1
  unsigned int v10; // w2
  char v11; // [xsp+8h] [xbp-88h]
  __int64 v12; // [xsp+58h] [xbp-38h]

  v2 = (unsigned int *)a2;
  v3 = a1;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 || !*(_QWORD *)(a2 + 24) )
  {
    v9 = "NULL";
    v10 = 4;
LABEL_7:
    BIO_write(v3, (__int64)v9, v10);
    goto LABEL_8;
  }
  OBJ_obj2txt(&v11, 80, (unsigned int *)a2, 0);
  v5 = v4;
  if ( v4 < 80 )
  {
    if ( v4 >= 1 )
    {
      BIO_write(v3, (__int64)&v11, v4);
      goto LABEL_8;
    }
    v9 = "<INVALID>";
    v10 = 9;
    goto LABEL_7;
  }
  v6 = v4 + 1;
  v7 = malloc(v4 + 1);
  v8 = v7;
  if ( v7 )
  {
    OBJ_obj2txt(v7, v6, v2, 0);
    BIO_write(v3, (__int64)v8, v5);
    free(v8);
  }
LABEL_8:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v12;
}

//----- (00000000000627C0) ----------------------------------------------------
_QWORD *__fastcall d2i_ASN1_OBJECT(_QWORD *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  _QWORD *v4; // x20
  _QWORD *result; // x0
  int v6; // w2
  __int64 v7; // [xsp+0h] [xbp-30h]
  int v8; // [xsp+4h] [xbp-2Ch]
  __int64 v9; // [xsp+8h] [xbp-28h]
  __int64 v10; // [xsp+10h] [xbp-20h]
  __int64 v11; // [xsp+18h] [xbp-18h]

  v3 = a2;
  v4 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = *a2;
  if ( ASN1_get_object((unsigned __int8 **)&v10, &v9, &v8, (int *)&v7, a3) & 0x80 )
  {
    v6 = 103;
LABEL_7:
    ERR_put_error(12, 0LL, v6, (__int64)"external/boringssl/src/crypto/asn1/a_object.c", 269);
    result = 0LL;
    goto LABEL_8;
  }
  if ( v8 != 6 )
  {
    v6 = 116;
    goto LABEL_7;
  }
  result = c2i_ASN1_OBJECT(v4, (const void **)&v10, v9);
  if ( result )
    *v3 = v10;
LABEL_8:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000062888) ----------------------------------------------------
_QWORD *__fastcall c2i_ASN1_OBJECT(_QWORD *a1, const void **a2, __int64 a3)
{
  int v3; // w21
  const void **v4; // x20
  _QWORD *v5; // x19
  char *v6; // x22
  __int64 v7; // x8
  _QWORD *v8; // x23
  _QWORD *v9; // x0
  void *v10; // x24
  __int16 v11; // w4
  size_t v13; // x25

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a2 || (unsigned __int64)(a3 - 1) > 0x7FFFFFFE || (v6 = (char *)*a2) == 0LL || v6[a3 - 1] & 0x80000000 )
  {
    v11 = 288;
LABEL_20:
    ERR_put_error(12, 0LL, 146, (__int64)"external/boringssl/src/crypto/asn1/a_object.c", v11);
    return 0LL;
  }
  if ( (signed int)a3 >= 1 )
  {
    v7 = 0LL;
    while ( (unsigned __int8)v6[v7] != 128 || (_DWORD)v7 && v6[v7 - 1] & 0x80000000 )
    {
      if ( (signed int)++v7 >= (signed int)a3 )
        goto LABEL_11;
    }
    v11 = 295;
    goto LABEL_20;
  }
LABEL_11:
  if ( !a1 || (v8 = (_QWORD *)*a1) == 0LL || !(v8[4] & 1) )
  {
    v9 = malloc(0x28uLL);
    v8 = v9;
    if ( !v9 )
    {
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_object.c", 353);
      return v8;
    }
    v9[2] = 0LL;
    v9[3] = 0LL;
    *v9 = 0LL;
    v9[1] = 0LL;
    *((_DWORD *)v9 + 8) = 1;
  }
  v10 = (void *)v8[3];
  v8[3] = 0LL;
  if ( v10 )
  {
    if ( *((_DWORD *)v8 + 5) >= v3 )
    {
      v13 = v3;
      if ( !v3 )
        goto LABEL_31;
LABEL_30:
      memcpy(v10, v6, v13);
      goto LABEL_31;
    }
    *((_DWORD *)v8 + 5) = 0;
    free(v10);
  }
  else
  {
    *((_DWORD *)v8 + 5) = 0;
  }
  v13 = v3;
  v10 = malloc(v3);
  if ( !v10 )
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_object.c", 341);
    if ( !v5 || (_QWORD *)*v5 != v8 )
      ASN1_OBJECT_free((void **)v8);
    return 0LL;
  }
  *((_DWORD *)v8 + 8) |= 8u;
  if ( v3 )
    goto LABEL_30;
LABEL_31:
  v8[3] = v10;
  *((_DWORD *)v8 + 5) = v3;
  *v8 = 0LL;
  v8[1] = 0LL;
  if ( v5 )
    *v5 = v8;
  *v4 = &v6[v13];
  return v8;
}

//----- (0000000000062A70) ----------------------------------------------------
_QWORD *ASN1_OBJECT_new()
{
  _QWORD *result; // x0

  result = malloc(0x28uLL);
  if ( result )
  {
    result[2] = 0LL;
    result[3] = 0LL;
    *result = 0LL;
    result[1] = 0LL;
    *((_DWORD *)result + 8) = 1;
  }
  else
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_object.c", 353);
    result = 0LL;
  }
  return result;
}

//----- (0000000000062AC4) ----------------------------------------------------
void __fastcall ASN1_OBJECT_free(void **a1)
{
  void **v1; // x19
  int v2; // w8
  void *v3; // x0
  void *v4; // x0
  void *v5; // x0

  v1 = a1;
  if ( a1 )
  {
    v2 = *((_DWORD *)a1 + 8);
    if ( v2 & 4 )
    {
      v3 = *a1;
      if ( *v1 )
        free(v3);
      v4 = v1[1];
      if ( v4 )
        free(v4);
      v2 = *((_DWORD *)v1 + 8);
      *v1 = 0LL;
      v1[1] = 0LL;
    }
    if ( v2 & 8 )
    {
      v5 = v1[3];
      if ( v5 )
      {
        free(v5);
        v2 = *((_DWORD *)v1 + 8);
      }
      v1[3] = 0LL;
      *((_DWORD *)v1 + 5) = 0;
    }
    if ( v2 & 1 )
      free(v1);
  }
}

//----- (0000000000062B3C) ----------------------------------------------------
__int64 *__fastcall ASN1_OBJECT_create(int a1, __int64 a2, int a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // x19
  __int64 *result; // x0
  __int64 v7; // [xsp+0h] [xbp-40h]
  __int64 v8; // [xsp+8h] [xbp-38h]
  int v9; // [xsp+10h] [xbp-30h]
  int v10; // [xsp+14h] [xbp-2Ch]
  __int64 v11; // [xsp+18h] [xbp-28h]
  int v12; // [xsp+20h] [xbp-20h]
  __int64 v13; // [xsp+28h] [xbp-18h]

  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v13 = *(_QWORD *)(v5 + 40);
  v9 = a1;
  v10 = a3;
  v7 = a4;
  v8 = a5;
  v11 = a2;
  v12 = 13;
  result = OBJ_dup((__int64)&v7);
  *(_QWORD *)(v5 + 40);
  return result;
}

//----- (0000000000062B98) ----------------------------------------------------
signed __int64 __fastcall ASN1_const_check_infinite_end(_QWORD *a1, signed __int64 a2)
{
  _BYTE *v3; // x8

  if ( a2 >= 1 )
  {
    if ( a2 == 1 )
      return 0LL;
    v3 = (_BYTE *)*a1;
    if ( *(_BYTE *)*a1 )
      return 0LL;
    if ( v3[1] )
      return 0LL;
    *a1 = v3 + 2;
  }
  return 1LL;
}

//----- (0000000000062BE0) ----------------------------------------------------
signed __int64 __fastcall ASN1_get_object(unsigned __int8 **a1, signed __int64 *a2, _DWORD *a3, int *a4, __int64 a5)
{
  unsigned __int8 **v5; // x19
  signed __int64 v6; // x9
  char *v7; // x8
  unsigned __int8 v8; // w10
  signed __int64 v9; // x12
  char v10; // t1
  int v11; // w11
  int v12; // w20
  signed __int64 v13; // x9
  unsigned __int8 *v14; // x21
  signed int v15; // w22
  signed __int64 v16; // x10
  signed __int64 v18; // x11
  unsigned __int8 v19; // t1

  v5 = a1;
  if ( !a5 )
    goto LABEL_31;
  v6 = a5 - 1;
  v7 = (char *)(*a1 + 1);
  v8 = **a1;
  LODWORD(v9) = v8 & 0x1F;
  if ( (_DWORD)v9 == 31 )
  {
    if ( a5 == 1 )
      goto LABEL_31;
    v9 = 0LL;
    v6 = a5 - 2;
    while ( 1 )
    {
      v10 = *v7++;
      v9 = v10 & 0x7F | (unsigned __int64)(v9 << 7);
      if ( !(v10 & 0x80000000) )
        break;
      if ( v6 )
      {
        --v6;
        if ( v9 <= 0xFFFFFF )
          continue;
      }
      goto LABEL_31;
    }
    if ( !v6 || !(v8 & 0xC0) && (signed int)v9 > 255 )
      goto LABEL_31;
  }
  else if ( a5 == 1 )
  {
    goto LABEL_31;
  }
  *a3 = v9;
  *a4 = v8 & 0xC0;
  if ( v6 < 1 )
    goto LABEL_31;
  v11 = (unsigned __int8)*v7;
  v12 = v8 & 0x20;
  if ( v11 != 128 )
  {
    v16 = v11 & 0x7F;
    v14 = (unsigned __int8 *)(v7 + 1);
    if ( v11 & 0x80 )
    {
      if ( (unsigned int)v16 > 8 || v16 >= v6 )
        goto LABEL_31;
      v13 = 0LL;
      if ( v11 & 0x7F )
      {
        v18 = -v16;
        do
        {
          v19 = *v14++;
          ++v18;
          v13 = v19 | (unsigned __int64)(v13 << 8);
        }
        while ( v18 );
        if ( v13 & 0x8000000000000000LL )
          goto LABEL_31;
        v14 = (unsigned __int8 *)&v7[v16 + 1];
      }
    }
    else
    {
      v13 = v11 & 0x7F;
    }
    v15 = 0;
    *a2 = v13;
    goto LABEL_21;
  }
  *a2 = 0LL;
  if ( !(v8 & 0x20) )
  {
LABEL_31:
    ERR_put_error(12, 0LL, 123, (__int64)"external/boringssl/src/crypto/asn1/asn1_lib.c", 202);
    return 128LL;
  }
  v13 = 0LL;
  v14 = (unsigned __int8 *)(v7 + 1);
  v15 = 1;
LABEL_21:
  if ( v13 > (signed __int64)&(*a1)[a5 - (_QWORD)v14] )
  {
    ERR_put_error(12, 0LL, 177, (__int64)"external/boringssl/src/crypto/asn1/asn1_lib.c", 192);
    v12 |= 0x80u;
  }
  *v5 = v14;
  return v12 | (unsigned int)v15;
}

//----- (0000000000062D64) ----------------------------------------------------
_BYTE **__fastcall ASN1_put_object(_BYTE **result, int a2, signed int a3, signed int a4, char a5)
{
  _BYTE *v5; // x8
  int v6; // w10
  _BYTE *v7; // x8
  __int64 v8; // x9
  unsigned int v9; // w10
  int v10; // w11
  __int64 v11; // x12
  char v12; // w13
  __int64 v13; // x9
  unsigned int v14; // w10
  __int64 v15; // x10

  v5 = *result;
  v6 = (unsigned __int8)(a5 & 0xC0) | 32 * (a2 != 0);
  if ( a4 > 30 )
  {
    v8 = 0LL;
    *v5 = v6 | 0x1F;
    v9 = a4;
    do
    {
      v9 >>= 7;
      ++v8;
    }
    while ( v9 );
    if ( !(((_DWORD)v8 - 1) & 0x80000000) )
    {
      v10 = 0;
      v11 = v8;
      do
      {
        v12 = a4 & 0x7F;
        if ( v10 )
          v12 = a4 & 0x7F | 0x80;
        ++v10;
        a4 >>= 7;
        v5[v11--] = v12;
      }
      while ( v11 > 0 );
    }
    v7 = &v5[v8 + 1];
    if ( a2 != 2 )
      goto LABEL_13;
LABEL_12:
    *v7 = -128;
    *result = v7 + 1;
    return result;
  }
  *v5 = v6 | a4 & 0x1F;
  v7 = v5 + 1;
  if ( a2 == 2 )
    goto LABEL_12;
LABEL_13:
  if ( a3 >= 128 )
  {
    v13 = 0LL;
    v14 = a3;
    do
    {
      v14 >>= 8;
      ++v13;
    }
    while ( v14 );
    *v7 = v13 | 0x80;
    if ( !(((_DWORD)v13 - 1) & 0x80000000) )
    {
      v15 = v13;
      do
      {
        v7[v15] = a3;
        a3 >>= 8;
        --v15;
      }
      while ( v15 > 0 );
    }
    *result = &v7[v13 + 1];
  }
  else
  {
    *v7 = a3;
    *result = v7 + 1;
  }
  return result;
}

//----- (0000000000062E70) ----------------------------------------------------
signed __int64 __fastcall ASN1_put_eoc(_BYTE **a1)
{
  _QWORD *v1; // x8
  _BYTE *v2; // x9
  signed __int64 result; // x0

  v1 = a1;
  v2 = *a1;
  result = 2LL;
  *v2 = 0;
  v2[1] = 0;
  *v1 = v2 + 2;
  return result;
}

//----- (0000000000062E90) ----------------------------------------------------
signed __int64 __fastcall ASN1_object_size(int a1, signed int a2, signed int a3)
{
  signed int v3; // w8
  int v4; // w8
  signed __int64 result; // x0
  unsigned int v6; // w9

  if ( a2 & 0x80000000 )
    return 0xFFFFFFFFLL;
  v3 = 1;
  if ( a3 >= 31 )
  {
    do
    {
      a3 >>= 7;
      ++v3;
    }
    while ( a3 > 0 );
  }
  if ( a1 == 2 )
  {
    v4 = v3 + 3;
  }
  else
  {
    v4 = v3 + 1;
    if ( a2 >= 128 )
    {
      v6 = a2;
      do
      {
        v6 >>= 8;
        ++v4;
      }
      while ( v6 );
    }
  }
  if ( v4 >= 0x7FFFFFFF - a2 )
    result = 1LL;
  else
    result = (unsigned int)(v4 + a2);
  return result;
}

//----- (0000000000062EFC) ----------------------------------------------------
signed __int64 __fastcall asn1_const_Finish(__int64 a1)
{
  int v1; // w8
  __int64 v2; // x9
  signed int v4; // w9
  signed __int64 v5; // x9
  _BYTE *v6; // x9

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 != 33 || *(_DWORD *)(a1 + 8) || (v5 = *(_QWORD *)(a1 + 32), v5 < 1) )
  {
    v2 = *(_QWORD *)(a1 + 32);
    if ( !v2 )
      return 1LL;
LABEL_4:
    if ( v1 & 1 && !(v2 & 0x8000000000000000LL) )
      return 1LL;
    v4 = 100;
    goto LABEL_13;
  }
  if ( v5 == 1 || (v6 = *(_BYTE **)a1, **(_BYTE **)a1) || v6[1] )
  {
    v4 = 152;
LABEL_13:
    *(_DWORD *)(a1 + 12) = v4;
    return 0LL;
  }
  *(_QWORD *)a1 = v6 + 2;
  v2 = *(_QWORD *)(a1 + 32);
  if ( v2 )
    goto LABEL_4;
  return 1LL;
}

//----- (0000000000062F8C) ----------------------------------------------------
signed __int64 __fastcall ASN1_STRING_copy(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  signed __int64 result; // x0

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    return 0LL;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  result = ASN1_STRING_set(a1, *(const char **)(a2 + 8), *(_DWORD *)a2);
  if ( (_DWORD)result )
  {
    result = 1LL;
    *(_QWORD *)(v3 + 16) = *(_QWORD *)(v2 + 16);
  }
  return result;
}

//----- (0000000000062FE0) ----------------------------------------------------
signed __int64 __fastcall ASN1_STRING_set(__int64 a1, const char *a2, int a3)
{
  int v3; // w21
  const char *v4; // x20
  __int64 v5; // x19
  void *v6; // x22
  size_t v7; // x8
  __int64 v8; // x23
  signed __int64 result; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 & 0x80000000 )
  {
    if ( !a2 )
      return 0LL;
    v3 = strlen(a2);
  }
  v6 = *(void **)(v5 + 8);
  if ( *(_DWORD *)v5 <= v3 )
  {
    v7 = v3 + 1;
    if ( !v6 )
    {
LABEL_10:
      v6 = malloc(v7);
      v8 = 0LL;
      *(_QWORD *)(v5 + 8) = v6;
      if ( v6 )
        goto LABEL_11;
LABEL_16:
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/asn1_lib.c", 400);
      result = 0LL;
      *(_QWORD *)(v5 + 8) = v8;
      return result;
    }
    v8 = *(_QWORD *)(v5 + 8);
    v6 = realloc(*(void **)(v5 + 8), v3 + 1);
    *(_QWORD *)(v5 + 8) = v6;
    if ( !v6 )
      goto LABEL_16;
  }
  else if ( !v6 )
  {
    v7 = v3 + 1;
    goto LABEL_10;
  }
LABEL_11:
  *(_DWORD *)v5 = v3;
  if ( v4 )
  {
    if ( v3 )
    {
      memcpy(v6, v4, v3);
      v6 = *(void **)(v5 + 8);
    }
    *((_BYTE *)v6 + v3) = 0;
  }
  return 1LL;
}

//----- (00000000000630E8) ----------------------------------------------------
_BYTE *__fastcall ASN1_STRING_dup(__int64 a1)
{
  __int64 v1; // x20
  char *v2; // x0
  _BYTE *v3; // x19
  void **v4; // x21

  v1 = a1;
  if ( !a1 )
    return 0LL;
  v2 = (char *)malloc(0x18uLL);
  v3 = v2;
  if ( !v2 )
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/asn1_lib.c", 433);
    return v3;
  }
  *(_DWORD *)v2 = 0;
  *((_QWORD *)v2 + 1) = 0LL;
  v4 = (void **)(v2 + 8);
  *((_QWORD *)v2 + 2) = 0LL;
  *((_DWORD *)v2 + 1) = *(_DWORD *)(v1 + 4);
  if ( !(unsigned int)ASN1_STRING_set((__int64)v2, *(const char **)(v1 + 8), *(_DWORD *)v1) )
  {
    if ( *v4 && !(v3[16] & 0x10) )
      free(*v4);
    free(v3);
    return 0LL;
  }
  *((_QWORD *)v3 + 2) = *(_QWORD *)(v1 + 16);
  return v3;
}

//----- (000000000006319C) ----------------------------------------------------
_QWORD *ASN1_STRING_new()
{
  _QWORD *result; // x0

  result = malloc(0x18uLL);
  if ( result )
  {
    result[1] = 0LL;
    result[2] = 0LL;
    *result = 0x400000000LL;
  }
  else
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/asn1_lib.c", 433);
    result = 0LL;
  }
  return result;
}

//----- (00000000000631EC) ----------------------------------------------------
void __fastcall ASN1_STRING_free(__int64 a1)
{
  _BYTE *v1; // x19
  void *v2; // x0

  v1 = (_BYTE *)a1;
  if ( a1 )
  {
    v2 = *(void **)(a1 + 8);
    if ( v2 )
    {
      if ( !(v1[16] & 0x10) )
        free(v2);
    }
    free(v1);
  }
}

//----- (0000000000063230) ----------------------------------------------------
void __fastcall ASN1_STRING_set0(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x20
  void *v4; // x0
  int v5; // w19
  __int64 v6; // x21

  v3 = a1;
  v4 = *(void **)(a1 + 8);
  v5 = a3;
  v6 = a2;
  if ( v4 )
    free(v4);
  *(_QWORD *)(v3 + 8) = v6;
  *(_DWORD *)v3 = v5;
}

//----- (0000000000063270) ----------------------------------------------------
_DWORD *__fastcall ASN1_STRING_type_new(int a1)
{
  int v1; // w19
  _DWORD *result; // x0

  v1 = a1;
  result = malloc(0x18uLL);
  if ( result )
  {
    *result = 0;
    result[1] = v1;
    *((_QWORD *)result + 1) = 0LL;
    *((_QWORD *)result + 2) = 0LL;
  }
  else
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/asn1_lib.c", 433);
    result = 0LL;
  }
  return result;
}

//----- (00000000000632C4) ----------------------------------------------------
__int64 __fastcall ASN1_STRING_cmp(const void **a1, __int64 a2)
{
  __int64 v2; // x19
  const void **v3; // x20
  size_t v4; // x2
  __int64 result; // x0

  v2 = a2;
  v3 = a1;
  v4 = *(signed int *)a1;
  result = (unsigned int)(v4 - *(_DWORD *)a2);
  if ( (_DWORD)v4 == *(_DWORD *)a2 )
  {
    if ( !(_DWORD)v4 || (result = memcmp(v3[1], *(const void **)(a2 + 8), v4), !(_DWORD)result) )
      result = (unsigned int)(*((_DWORD *)v3 + 1) - *(_DWORD *)(v2 + 4));
  }
  return result;
}

//----- (0000000000063314) ----------------------------------------------------
_DWORD *__fastcall ASN1_STRING_length_set(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

//----- (000000000006331C) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_OCTET_STRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_OCTET_STRING_it);
}

//----- (0000000000063328) ----------------------------------------------------
void i2d_ASN1_OCTET_STRING()
{
  ASN1_item_i2d();
}

//----- (0000000000063334) ----------------------------------------------------
_DWORD *ASN1_OCTET_STRING_new()
{
  return ASN1_STRING_type_new(4);
}

//----- (0000000000063340) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_INTEGER(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_INTEGER_it);
}

//----- (000000000006334C) ----------------------------------------------------
void i2d_ASN1_INTEGER()
{
  ASN1_item_i2d();
}

//----- (0000000000063358) ----------------------------------------------------
_DWORD *ASN1_INTEGER_new()
{
  return ASN1_STRING_type_new(2);
}

//----- (0000000000063360) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_ENUMERATED(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_ENUMERATED_it);
}

//----- (000000000006336C) ----------------------------------------------------
void i2d_ASN1_ENUMERATED()
{
  ASN1_item_i2d();
}

//----- (0000000000063378) ----------------------------------------------------
_DWORD *ASN1_ENUMERATED_new()
{
  return ASN1_STRING_type_new(10);
}

//----- (0000000000063380) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_BIT_STRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_BIT_STRING_it);
}

//----- (000000000006338C) ----------------------------------------------------
void i2d_ASN1_BIT_STRING()
{
  ASN1_item_i2d();
}

//----- (0000000000063398) ----------------------------------------------------
_DWORD *ASN1_BIT_STRING_new()
{
  return ASN1_STRING_type_new(3);
}

//----- (00000000000633A0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_UTF8STRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_UTF8STRING_it);
}

//----- (00000000000633AC) ----------------------------------------------------
void i2d_ASN1_UTF8STRING()
{
  ASN1_item_i2d();
}

//----- (00000000000633B8) ----------------------------------------------------
_DWORD *ASN1_UTF8STRING_new()
{
  return ASN1_STRING_type_new(12);
}

//----- (00000000000633C0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_PRINTABLESTRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_PRINTABLESTRING_it);
}

//----- (00000000000633CC) ----------------------------------------------------
void i2d_ASN1_PRINTABLESTRING()
{
  ASN1_item_i2d();
}

//----- (00000000000633D8) ----------------------------------------------------
_DWORD *ASN1_PRINTABLESTRING_new()
{
  return ASN1_STRING_type_new(19);
}

//----- (00000000000633E0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_T61STRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_T61STRING_it);
}

//----- (00000000000633EC) ----------------------------------------------------
void i2d_ASN1_T61STRING()
{
  ASN1_item_i2d();
}

//----- (00000000000633F8) ----------------------------------------------------
_DWORD *ASN1_T61STRING_new()
{
  return ASN1_STRING_type_new(20);
}

//----- (0000000000063400) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_IA5STRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_IA5STRING_it);
}

//----- (000000000006340C) ----------------------------------------------------
void i2d_ASN1_IA5STRING()
{
  ASN1_item_i2d();
}

//----- (0000000000063418) ----------------------------------------------------
_DWORD *ASN1_IA5STRING_new()
{
  return ASN1_STRING_type_new(22);
}

//----- (0000000000063420) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_GENERALSTRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_GENERALSTRING_it);
}

//----- (000000000006342C) ----------------------------------------------------
void i2d_ASN1_GENERALSTRING()
{
  ASN1_item_i2d();
}

//----- (0000000000063438) ----------------------------------------------------
_DWORD *ASN1_GENERALSTRING_new()
{
  return ASN1_STRING_type_new(27);
}

//----- (0000000000063440) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_UTCTIME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_UTCTIME_it);
}

//----- (000000000006344C) ----------------------------------------------------
void i2d_ASN1_UTCTIME()
{
  ASN1_item_i2d();
}

//----- (0000000000063458) ----------------------------------------------------
_DWORD *ASN1_UTCTIME_new()
{
  return ASN1_STRING_type_new(23);
}

//----- (0000000000063460) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_GENERALIZEDTIME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_GENERALIZEDTIME_it);
}

//----- (000000000006346C) ----------------------------------------------------
void i2d_ASN1_GENERALIZEDTIME()
{
  ASN1_item_i2d();
}

//----- (0000000000063478) ----------------------------------------------------
_DWORD *ASN1_GENERALIZEDTIME_new()
{
  return ASN1_STRING_type_new(24);
}

//----- (0000000000063480) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_VISIBLESTRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_VISIBLESTRING_it);
}

//----- (000000000006348C) ----------------------------------------------------
void i2d_ASN1_VISIBLESTRING()
{
  ASN1_item_i2d();
}

//----- (0000000000063498) ----------------------------------------------------
_DWORD *ASN1_VISIBLESTRING_new()
{
  return ASN1_STRING_type_new(26);
}

//----- (00000000000634A0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_UNIVERSALSTRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_UNIVERSALSTRING_it);
}

//----- (00000000000634AC) ----------------------------------------------------
void i2d_ASN1_UNIVERSALSTRING()
{
  ASN1_item_i2d();
}

//----- (00000000000634B8) ----------------------------------------------------
_DWORD *ASN1_UNIVERSALSTRING_new()
{
  return ASN1_STRING_type_new(28);
}

//----- (00000000000634C0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_BMPSTRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_BMPSTRING_it);
}

//----- (00000000000634CC) ----------------------------------------------------
void i2d_ASN1_BMPSTRING()
{
  ASN1_item_i2d();
}

//----- (00000000000634D8) ----------------------------------------------------
_DWORD *ASN1_BMPSTRING_new()
{
  return ASN1_STRING_type_new(30);
}

//----- (00000000000634E0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_NULL(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_NULL_it);
}

//----- (00000000000634EC) ----------------------------------------------------
void i2d_ASN1_NULL()
{
  ASN1_item_i2d();
}

//----- (00000000000634F8) ----------------------------------------------------
__int64 ASN1_NULL_new()
{
  return ASN1_item_new((unsigned __int8 *)&ASN1_NULL_it);
}

//----- (0000000000063504) ----------------------------------------------------
void __fastcall ASN1_NULL_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&ASN1_NULL_it);
}

//----- (0000000000063510) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_TYPE(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_ANY_it);
}

//----- (000000000006351C) ----------------------------------------------------
void i2d_ASN1_TYPE()
{
  ASN1_item_i2d();
}

//----- (0000000000063528) ----------------------------------------------------
__int64 ASN1_TYPE_new()
{
  return ASN1_item_new((unsigned __int8 *)&ASN1_ANY_it);
}

//----- (0000000000063534) ----------------------------------------------------
void __fastcall ASN1_TYPE_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&ASN1_ANY_it);
}

//----- (0000000000063540) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_PRINTABLE(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_PRINTABLE_it);
}

//----- (000000000006354C) ----------------------------------------------------
void i2d_ASN1_PRINTABLE()
{
  ASN1_item_i2d();
}

//----- (0000000000063558) ----------------------------------------------------
__int64 ASN1_PRINTABLE_new()
{
  return ASN1_item_new((unsigned __int8 *)&ASN1_PRINTABLE_it);
}

//----- (0000000000063564) ----------------------------------------------------
void __fastcall ASN1_PRINTABLE_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&ASN1_PRINTABLE_it);
}

//----- (0000000000063570) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_DISPLAYTEXT(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&DISPLAYTEXT_it);
}

//----- (000000000006357C) ----------------------------------------------------
void i2d_DISPLAYTEXT()
{
  ASN1_item_i2d();
}

//----- (0000000000063588) ----------------------------------------------------
__int64 DISPLAYTEXT_new()
{
  return ASN1_item_new((unsigned __int8 *)&DISPLAYTEXT_it);
}

//----- (0000000000063594) ----------------------------------------------------
void __fastcall DISPLAYTEXT_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&DISPLAYTEXT_it);
}

//----- (00000000000635A0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_DIRECTORYSTRING(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&DIRECTORYSTRING_it);
}

//----- (00000000000635AC) ----------------------------------------------------
void i2d_DIRECTORYSTRING()
{
  ASN1_item_i2d();
}

//----- (00000000000635B8) ----------------------------------------------------
__int64 DIRECTORYSTRING_new()
{
  return ASN1_item_new((unsigned __int8 *)&DIRECTORYSTRING_it);
}

//----- (00000000000635C4) ----------------------------------------------------
void __fastcall DIRECTORYSTRING_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&DIRECTORYSTRING_it);
}

//----- (00000000000635D0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_SEQUENCE_ANY(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_SEQUENCE_ANY_it);
}

//----- (00000000000635DC) ----------------------------------------------------
void i2d_ASN1_SEQUENCE_ANY()
{
  ASN1_item_i2d();
}

//----- (00000000000635E8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_SET_ANY(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_SET_ANY_it);
}

//----- (00000000000635F4) ----------------------------------------------------
void i2d_ASN1_SET_ANY()
{
  ASN1_item_i2d();
}

//----- (0000000000063600) ----------------------------------------------------
_DWORD *__fastcall BIO_new(__int64 a1)
{
  __int64 v1; // x20
  char *v2; // x0
  _DWORD *v3; // x19
  unsigned int (__fastcall *v4)(_DWORD *); // x8

  v1 = a1;
  v2 = (char *)malloc(0x50uLL);
  v3 = v2;
  if ( v2 )
  {
    memset(v2 + 8, 0, 0x48uLL);
    *(_QWORD *)v3 = v1;
    v3[7] = 1;
    v3[11] = 1;
    v4 = *(unsigned int (__fastcall **)(_DWORD *))(v1 + 56);
    if ( v4 && !v4(v3) )
    {
      free(v3);
      v3 = 0LL;
    }
  }
  else
  {
    ERR_put_error(17, 0LL, 65, (__int64)"external/boringssl/src/crypto/bio/bio.c", 74);
  }
  return v3;
}

//----- (0000000000063690) ----------------------------------------------------
__int64 __fastcall BIO_free(__int64 a1)
{
  __int64 v1; // x20
  __int64 *v2; // x19
  __int64 result; // x0
  __int64 (__fastcall *v4)(__int64, signed __int64, _QWORD, _QWORD, _QWORD, signed __int64); // x8
  __int64 v5; // x8
  void (__fastcall *v6)(__int64 *); // x8

  v1 = a1;
  if ( !a1 )
    return 1LL;
  while ( 1 )
  {
    v2 = (__int64 *)v1;
    result = CRYPTO_refcount_dec_and_test_zero((int *)(v1 + 44));
    if ( !(_DWORD)result )
      break;
    v4 = *(__int64 (__fastcall **)(__int64, signed __int64, _QWORD, _QWORD, _QWORD, signed __int64))(v1 + 8);
    if ( v4 )
    {
      result = v4(v1, 1LL, 0LL, 0LL, 0LL, 1LL);
      if ( (signed int)result < 1 )
        break;
    }
    v1 = *(_QWORD *)(v1 + 56);
    v5 = *v2;
    v2[7] = 0LL;
    if ( v5 )
    {
      v6 = *(void (__fastcall **)(__int64 *))(v5 + 64);
      if ( v6 )
        v6(v2);
    }
    free(v2);
    if ( !v1 )
      return 1LL;
  }
  return result;
}

//----- (000000000006371C) ----------------------------------------------------
__int64 __fastcall BIO_pop(__int64 a1)
{
  __int64 v1; // x8
  __int64 result; // x0

  v1 = a1;
  if ( !a1 )
    return 0LL;
  result = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(v1 + 56) = 0LL;
  return result;
}

//----- (0000000000063738) ----------------------------------------------------
signed __int64 __fastcall BIO_up_ref(__int64 a1)
{
  CRYPTO_refcount_inc((_DWORD *)(a1 + 44));
  return 1LL;
}

//----- (0000000000063754) ----------------------------------------------------
void __fastcall BIO_vfree(__int64 a1)
{
  __int64 v1; // x20
  __int64 *v2; // x19
  signed int (__fastcall *v3)(__int64, signed __int64, _QWORD, _QWORD, _QWORD, signed __int64); // x8
  __int64 v4; // x8
  void (__fastcall *v5)(__int64 *); // x8

  v1 = a1;
  while ( v1 )
  {
    v2 = (__int64 *)v1;
    if ( !(unsigned int)CRYPTO_refcount_dec_and_test_zero((int *)(v1 + 44)) )
      break;
    v3 = *(signed int (__fastcall **)(__int64, signed __int64, _QWORD, _QWORD, _QWORD, signed __int64))(v1 + 8);
    if ( v3 )
    {
      if ( v3(v1, 1LL, 0LL, 0LL, 0LL, 1LL) < 1 )
        break;
    }
    v1 = *(_QWORD *)(v1 + 56);
    v4 = *v2;
    v2[7] = 0LL;
    if ( v4 )
    {
      v5 = *(void (__fastcall **)(__int64 *))(v4 + 64);
      if ( v5 )
        v5(v2);
    }
    free(v2);
  }
}

//----- (00000000000637DC) ----------------------------------------------------
__int64 __fastcall BIO_read(_QWORD *a1, __int64 a2, unsigned int a3)
{
  return sub_637EC(a1, a2, a3, 24LL, 2, a1 + 8);
}

//----- (00000000000637EC) ----------------------------------------------------
__int64 __fastcall sub_637EC(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, int a5, _QWORD *a6)
{
  _QWORD *v6; // x23
  int v7; // w22
  unsigned int v8; // w19
  __int64 v9; // x20
  _QWORD *v10; // x21
  __int64 (__fastcall *v11)(_QWORD *, __int64, _QWORD); // x24
  __int64 (*v12)(void); // x8
  __int64 result; // x0
  __int64 (__fastcall *v14)(_QWORD *, _QWORD, __int64, _QWORD, _QWORD, _QWORD); // x8
  int v15; // w2
  __int16 v16; // w4

  v6 = a6;
  v7 = a5;
  v8 = a3;
  v9 = a2;
  v10 = a1;
  if ( !a1 || !*a1 || (v11 = *(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD))(*a1 + a4)) == 0LL )
  {
    v15 = 115;
    v16 = 142;
LABEL_14:
    ERR_put_error(17, 0LL, v15, (__int64)"external/boringssl/src/crypto/bio/bio.c", v16);
    return 4294967294LL;
  }
  v12 = (__int64 (*)(void))a1[1];
  if ( v12 )
  {
    result = v12();
    if ( (signed int)result < 1 )
      return result;
  }
  if ( !*((_DWORD *)v10 + 6) )
  {
    v15 = 114;
    v16 = 154;
    goto LABEL_14;
  }
  result = 0LL;
  if ( v9 )
  {
    if ( (signed int)v8 >= 1 )
    {
      result = v11(v10, v9, v8);
      if ( (signed int)result >= 1 )
        *v6 += (signed int)result;
    }
  }
  v14 = (__int64 (__fastcall *)(_QWORD *, _QWORD, __int64, _QWORD, _QWORD, _QWORD))v10[1];
  if ( v14 )
    result = v14(v10, v7 | 0x80u, v9, v8, 0LL, (signed int)result);
  return result;
}

//----- (0000000000063904) ----------------------------------------------------
__int64 __fastcall BIO_gets(_QWORD *a1, __int64 a2, unsigned int a3)
{
  return sub_637EC(a1, a2, a3, 40LL, 5, a1 + 8);
}

//----- (0000000000063914) ----------------------------------------------------
__int64 __fastcall BIO_write(_QWORD *a1, __int64 a2, unsigned int a3)
{
  return sub_637EC(a1, a2, a3, 16LL, 3, a1 + 9);
}

//----- (0000000000063924) ----------------------------------------------------
__int64 __fastcall BIO_puts(_QWORD *a1, const char *a2)
{
  __int64 v2; // x19
  _QWORD *v3; // x20
  unsigned int v4; // w2

  v2 = (__int64)a2;
  v3 = a1;
  v4 = strlen(a2);
  return sub_637EC(v3, v2, v4, 16LL, 3, v3 + 9);
}

//----- (0000000000063964) ----------------------------------------------------
__int64 __fastcall BIO_flush(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 (__fastcall *v2)(_QWORD *, signed __int64, _QWORD, _QWORD); // x8
  __int64 (*v3)(void); // x9
  __int64 v4; // x0
  unsigned int v5; // w8
  __int64 v6; // x0
  __int64 (__fastcall *v7)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64); // x9

  v1 = a1;
  if ( !a1 )
    return 0;
  if ( !*a1 || (v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*a1 + 48LL)) == 0LL )
  {
    ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
    return (unsigned int)-2;
  }
  v3 = (__int64 (*)(void))a1[1];
  if ( v3 )
  {
    v4 = v3();
    v5 = v4;
    if ( v4 < 1 )
      return v5;
    v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*v1 + 48LL);
  }
  v6 = v2(v1, 11LL, 0LL, 0LL);
  v7 = (__int64 (__fastcall *)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64))v1[1];
  v5 = v6;
  if ( v7 )
    v5 = v7(v1, 134LL, 0LL, 11LL, 0LL, v6);
  return v5;
}

//----- (0000000000063A3C) ----------------------------------------------------
__int64 __fastcall BIO_ctrl(_QWORD *a1, unsigned int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x20
  __int64 v5; // x19
  unsigned int v6; // w21
  _QWORD *v7; // x22
  __int64 (__fastcall *v8)(_QWORD *, _QWORD, __int64, __int64); // x8
  __int64 (*v9)(void); // x9
  __int64 v10; // x8
  __int64 v11; // x0
  __int64 (__fastcall *v12)(_QWORD *, signed __int64, __int64, _QWORD, __int64, __int64); // x6

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a1 )
    return 0LL;
  if ( !*a1 || (v8 = *(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, __int64))(*a1 + 48LL)) == 0LL )
  {
    ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
    return -2LL;
  }
  v9 = (__int64 (*)(void))a1[1];
  if ( v9 )
  {
    v10 = v9();
    if ( v10 < 1 )
      return v10;
    v8 = *(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, __int64))(*v7 + 48LL);
  }
  v11 = v8(v7, v6, v5, v4);
  v12 = (__int64 (__fastcall *)(_QWORD *, signed __int64, __int64, _QWORD, __int64, __int64))v7[1];
  v10 = v11;
  if ( v12 )
    return v12(v7, 134LL, v4, v6, v5, v11);
  return v10;
}

//----- (0000000000063B2C) ----------------------------------------------------
__int64 __fastcall BIO_ptr_ctrl(_QWORD *a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // x19
  unsigned int v4; // w20
  _QWORD *v5; // x21
  __int64 (__fastcall *v6)(_QWORD *, _QWORD, __int64, __int64 *); // x8
  __int64 (*v7)(void); // x9
  __int64 v8; // x8
  __int64 v9; // x0
  __int64 (__fastcall *v10)(_QWORD *, signed __int64, __int64 *, _QWORD, __int64, __int64); // x9
  __int64 v11; // x10
  __int64 result; // x0
  __int64 v13; // [xsp+0h] [xbp-30h]
  __int64 v14; // [xsp+8h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = 0LL;
  if ( a1 )
  {
    if ( *a1 && (v6 = *(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, __int64 *))(*a1 + 48LL)) != 0LL )
    {
      v7 = (__int64 (*)(void))a1[1];
      if ( v7 )
      {
        v8 = v7();
        if ( v8 < 1 )
          goto LABEL_11;
        v6 = *(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, __int64 *))(*v5 + 48LL);
      }
      v9 = v6(v5, v4, v3, &v13);
      v10 = (__int64 (__fastcall *)(_QWORD *, signed __int64, __int64 *, _QWORD, __int64, __int64))v5[1];
      v8 = v9;
      if ( v10 )
        v8 = v10(v5, 134LL, &v13, v4, v3, v9);
    }
    else
    {
      ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
      v8 = -2LL;
    }
  }
  else
  {
    v8 = 0LL;
  }
LABEL_11:
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( v8 >= 1 )
    result = v13;
  else
    result = 0LL;
  return result;
}

//----- (0000000000063C4C) ----------------------------------------------------
void __fastcall BIO_int_ctrl(_QWORD *a1, unsigned int a2, __int64 a3, int a4)
{
  __int64 v4; // x19
  unsigned int v5; // w20
  _QWORD *v6; // x21
  __int64 (__fastcall *v7)(_QWORD *, _QWORD, __int64, int *); // x8
  __int64 (*v8)(void); // x9
  __int64 v9; // x0
  void (__fastcall *v10)(_QWORD *, signed __int64, int *, _QWORD, __int64, __int64); // x9
  int v11; // [xsp+4h] [xbp-2Ch]
  __int64 v12; // [xsp+8h] [xbp-28h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = a4;
  if ( a1 )
  {
    if ( !*a1 || (v7 = *(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, int *))(*a1 + 48LL)) == 0LL )
    {
      ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
      goto LABEL_10;
    }
    v8 = (__int64 (*)(void))a1[1];
    if ( v8 )
    {
      if ( v8() < 1 )
        goto LABEL_10;
      v7 = *(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, int *))(*v6 + 48LL);
    }
    v9 = v7(v6, v5, v4, &v11);
    v10 = (void (__fastcall *)(_QWORD *, signed __int64, int *, _QWORD, __int64, __int64))v6[1];
    if ( v10 )
      v10(v6, 134LL, &v11, v5, v4, v9);
  }
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000063D64) ----------------------------------------------------
__int64 __fastcall BIO_reset(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 (__fastcall *v2)(_QWORD *, signed __int64, _QWORD, _QWORD); // x8
  __int64 (*v3)(void); // x9
  __int64 v4; // x0
  unsigned int v5; // w8
  __int64 v6; // x0
  __int64 (__fastcall *v7)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64); // x9

  v1 = a1;
  if ( !a1 )
    return 0;
  if ( !*a1 || (v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*a1 + 48LL)) == 0LL )
  {
    ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
    return (unsigned int)-2;
  }
  v3 = (__int64 (*)(void))a1[1];
  if ( v3 )
  {
    v4 = v3();
    v5 = v4;
    if ( v4 < 1 )
      return v5;
    v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*v1 + 48LL);
  }
  v6 = v2(v1, 1LL, 0LL, 0LL);
  v7 = (__int64 (__fastcall *)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64))v1[1];
  v5 = v6;
  if ( v7 )
    v5 = v7(v1, 134LL, 0LL, 1LL, 0LL, v6);
  return v5;
}

//----- (0000000000063E3C) ----------------------------------------------------
__int64 __fastcall BIO_eof(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 (__fastcall *v2)(_QWORD *, signed __int64, _QWORD, _QWORD); // x8
  __int64 (*v3)(void); // x9
  __int64 v4; // x0
  unsigned int v5; // w8
  __int64 v6; // x0
  __int64 (__fastcall *v7)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64); // x9

  v1 = a1;
  if ( !a1 )
    return 0;
  if ( !*a1 || (v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*a1 + 48LL)) == 0LL )
  {
    ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
    return (unsigned int)-2;
  }
  v3 = (__int64 (*)(void))a1[1];
  if ( v3 )
  {
    v4 = v3();
    v5 = v4;
    if ( v4 < 1 )
      return v5;
    v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*v1 + 48LL);
  }
  v6 = v2(v1, 2LL, 0LL, 0LL);
  v7 = (__int64 (__fastcall *)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64))v1[1];
  v5 = v6;
  if ( v7 )
    v5 = v7(v1, 134LL, 0LL, 2LL, 0LL, v6);
  return v5;
}

//----- (0000000000063F14) ----------------------------------------------------
__int64 __fastcall BIO_set_flags(__int64 result, int a2)
{
  *(_DWORD *)(result + 32) |= a2;
  return result;
}

//----- (0000000000063F24) ----------------------------------------------------
__int64 __fastcall BIO_test_flags(__int64 a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 32) & a2;
}

//----- (0000000000063F30) ----------------------------------------------------
__int64 __fastcall BIO_should_read(__int64 a1)
{
  return *(_DWORD *)(a1 + 32) & 1;
}

//----- (0000000000063F3C) ----------------------------------------------------
__int64 __fastcall BIO_should_write(__int64 a1)
{
  return *(_DWORD *)(a1 + 32) & 2;
}

//----- (0000000000063F48) ----------------------------------------------------
__int64 __fastcall BIO_should_retry(__int64 a1)
{
  return *(_DWORD *)(a1 + 32) & 8;
}

//----- (0000000000063F54) ----------------------------------------------------
__int64 __fastcall BIO_should_io_special(__int64 a1)
{
  return *(_DWORD *)(a1 + 32) & 4;
}

//----- (0000000000063F60) ----------------------------------------------------
__int64 __fastcall BIO_get_retry_reason(__int64 a1)
{
  return *(unsigned int *)(a1 + 36);
}

//----- (0000000000063F68) ----------------------------------------------------
__int64 __fastcall BIO_clear_flags(__int64 result, int a2)
{
  *(_DWORD *)(result + 32) &= ~a2;
  return result;
}

//----- (0000000000063F78) ----------------------------------------------------
__int64 __fastcall BIO_set_retry_read(__int64 result)
{
  *(_DWORD *)(result + 32) |= 9u;
  return result;
}

//----- (0000000000063F8C) ----------------------------------------------------
__int64 __fastcall BIO_set_retry_write(__int64 result)
{
  *(_DWORD *)(result + 32) |= 0xAu;
  return result;
}

//----- (0000000000063FA0) ----------------------------------------------------
__int64 __fastcall BIO_get_retry_flags(__int64 a1)
{
  return *(_DWORD *)(a1 + 32) & 0xF;
}

//----- (0000000000063FAC) ----------------------------------------------------
__int64 __fastcall BIO_clear_retry_flags(__int64 result)
{
  *(_QWORD *)(result + 32) = *(_DWORD *)(result + 32) & 0xFFFFFFF0;
  return result;
}

//----- (0000000000063FBC) ----------------------------------------------------
__int64 __fastcall BIO_copy_next_retry(__int64 result)
{
  int v1; // w8
  __int64 v2; // x9

  v1 = *(_DWORD *)(result + 32);
  v2 = *(_QWORD *)(result + 56);
  *(_DWORD *)(result + 32) = v1 & 0xFFFFFFF0;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 32) = v1 & 0xFFFFFFF0 | *(_DWORD *)(v2 + 32) & 0xF;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v2 + 36);
  return result;
}

//----- (0000000000063FE4) ----------------------------------------------------
__int64 __fastcall BIO_callback_ctrl(_QWORD *a1, unsigned int a2, __int64 a3)
{
  unsigned int v3; // w19
  _QWORD *v4; // x20
  __int64 (*v5)(void); // x8
  __int64 (*v6)(void); // x21
  __int64 result; // x0
  __int64 v8; // x0
  __int64 v9; // [xsp+0h] [xbp-30h]
  __int64 v10; // [xsp+8h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = a3;
  if ( !a1 )
    goto LABEL_8;
  if ( !*a1 || (v5 = *(__int64 (**)(void))(*a1 + 72LL)) == 0LL )
  {
    ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 316);
LABEL_8:
    result = 0LL;
    goto LABEL_9;
  }
  v6 = (__int64 (*)(void))a1[1];
  if ( v6 )
  {
    result = v6();
    if ( result >= 1 )
    {
      v8 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64))(*v4 + 72LL))(v4, v3, v9);
      result = ((__int64 (__fastcall *)(_QWORD *, signed __int64, __int64 *, _QWORD, _QWORD, __int64))v6)(
                 v4,
                 134LL,
                 &v9,
                 v3,
                 0LL,
                 v8);
    }
  }
  else
  {
    result = v5();
  }
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v10;
  return result;
}

//----- (00000000000640E4) ----------------------------------------------------
__int64 __fastcall BIO_pending(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 (__fastcall *v2)(_QWORD *, signed __int64, _QWORD, _QWORD); // x8
  __int64 (*v3)(void); // x9
  __int64 v4; // x8
  __int64 v5; // x0
  __int64 (__fastcall *v6)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64); // x9
  __int64 result; // x0

  v1 = a1;
  if ( a1 )
  {
    if ( *a1 && (v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*a1 + 48LL)) != 0LL )
    {
      v3 = (__int64 (*)(void))a1[1];
      if ( v3 )
      {
        v4 = v3();
        if ( v4 < 1 )
          goto LABEL_11;
        v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*v1 + 48LL);
      }
      v5 = v2(v1, 10LL, 0LL, 0LL);
      v6 = (__int64 (__fastcall *)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64))v1[1];
      v4 = v5;
      if ( v6 )
        v4 = v6(v1, 134LL, 0LL, 10LL, 0LL, v5);
    }
    else
    {
      ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
      v4 = -2LL;
    }
  }
  else
  {
    v4 = 0LL;
  }
LABEL_11:
  if ( v4 >= 0 )
    result = v4;
  else
    result = 0LL;
  return result;
}

//----- (00000000000641C4) ----------------------------------------------------
__int64 __fastcall BIO_wpending(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 (__fastcall *v2)(_QWORD *, signed __int64, _QWORD, _QWORD); // x8
  __int64 (*v3)(void); // x9
  __int64 v4; // x8
  __int64 v5; // x0
  __int64 (__fastcall *v6)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64); // x9
  __int64 result; // x0

  v1 = a1;
  if ( a1 )
  {
    if ( *a1 && (v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*a1 + 48LL)) != 0LL )
    {
      v3 = (__int64 (*)(void))a1[1];
      if ( v3 )
      {
        v4 = v3();
        if ( v4 < 1 )
          goto LABEL_11;
        v2 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, _QWORD, _QWORD))(*v1 + 48LL);
      }
      v5 = v2(v1, 13LL, 0LL, 0LL);
      v6 = (__int64 (__fastcall *)(_QWORD *, signed __int64, _QWORD, signed __int64, _QWORD, __int64))v1[1];
      v4 = v5;
      if ( v6 )
        v4 = v6(v1, 134LL, 0LL, 13LL, 0LL, v5);
    }
    else
    {
      ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
      v4 = -2LL;
    }
  }
  else
  {
    v4 = 0LL;
  }
LABEL_11:
  if ( v4 >= 0 )
    result = v4;
  else
    result = 0LL;
  return result;
}

//----- (00000000000642A0) ----------------------------------------------------
__int64 __fastcall BIO_set_close(_QWORD *a1, int a2)
{
  _QWORD *v2; // x19
  __int64 (__fastcall *v3)(_QWORD *, signed __int64, __int64, _QWORD); // x8
  __int64 (*v4)(void); // x9
  __int64 v5; // x20
  __int64 v6; // x0
  unsigned int v7; // w8
  __int64 v8; // x0
  __int64 (__fastcall *v9)(_QWORD *, signed __int64, _QWORD, signed __int64, __int64, __int64); // x9

  v2 = a1;
  if ( !a1 )
    return 0;
  if ( !*a1 || (v3 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, __int64, _QWORD))(*a1 + 48LL)) == 0LL )
  {
    ERR_put_error(17, 0LL, 115, (__int64)"external/boringssl/src/crypto/bio/bio.c", 206);
    return (unsigned int)-2;
  }
  v4 = (__int64 (*)(void))a1[1];
  v5 = a2;
  if ( v4 )
  {
    v6 = v4();
    v7 = v6;
    if ( v6 < 1 )
      return v7;
    v3 = *(__int64 (__fastcall **)(_QWORD *, signed __int64, __int64, _QWORD))(*v2 + 48LL);
  }
  v8 = v3(v2, 9LL, v5, 0LL);
  v9 = (__int64 (__fastcall *)(_QWORD *, signed __int64, _QWORD, signed __int64, __int64, __int64))v2[1];
  v7 = v8;
  if ( v9 )
    v7 = v9(v2, 134LL, 0LL, 9LL, v5, v8);
  return v7;
}

//----- (000000000006437C) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_set_chain(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

//----- (0000000000064384) ----------------------------------------------------
__int64 __fastcall BIO_number_read(__int64 a1)
{
  return *(_QWORD *)(a1 + 64);
}

//----- (000000000006438C) ----------------------------------------------------
__int64 __fastcall BIO_number_written(__int64 a1)
{
  return *(_QWORD *)(a1 + 72);
}

//----- (0000000000064394) ----------------------------------------------------
__int64 __fastcall BIO_push(__int64 result, __int64 a2)
{
  __int64 v2; // x9
  __int64 v3; // x8

  if ( result )
  {
    v2 = result;
    do
    {
      v3 = v2;
      v2 = *(_QWORD *)(v2 + 56);
    }
    while ( v2 );
    *(_QWORD *)(v3 + 56) = a2;
  }
  return result;
}

//----- (00000000000643B0) ----------------------------------------------------
__int64 __fastcall BIO_next(__int64 result)
{
  if ( result )
    result = *(_QWORD *)(result + 56);
  return result;
}

//----- (00000000000643BC) ----------------------------------------------------
int *__fastcall BIO_find_type(int *result, int a2)
{
  int v2; // w9

  for ( ; result; result = (int *)*((_QWORD *)result + 7) )
  {
    if ( *(_QWORD *)result )
    {
      v2 = **(_DWORD **)result;
      if ( (_BYTE)a2 )
      {
        if ( v2 == a2 )
          return result;
      }
      else if ( v2 & a2 )
      {
        return result;
      }
    }
  }
  return result;
}

//----- (00000000000643F4) ----------------------------------------------------
signed __int64 __fastcall BIO_indent(_QWORD *a1, int a2, int a3)
{
  _QWORD *v3; // x19
  _QWORD *v4; // x20
  int v5; // w22
  unsigned int v6; // w0

  v3 = a1;
  v4 = a1 + 9;
  if ( ~a3 > (unsigned int)~a2 )
    v5 = !a3;
  else
    v5 = ~a2;
  while ( ++v5 )
  {
    v6 = __strlen_chk();
    if ( (unsigned int)sub_637EC(v3, (__int64)" ", v6, 16LL, 3, v4) != 1 )
      return 0LL;
  }
  return 1LL;
}

//----- (0000000000064478) ----------------------------------------------------
char *__fastcall ERR_print_errors(__int64 a1)
{
  return ERR_print_errors_cb((__int64 (__fastcall *)(char *, __int64, __int64))sub_64490, a1);
}

//----- (0000000000064490) ----------------------------------------------------
__int64 __fastcall sub_64490(__int64 a1, unsigned int a2, _QWORD *a3)
{
  return sub_637EC(a3, a1, a2, 16LL, 3, a3 + 9);
}

//----- (00000000000644B4) ----------------------------------------------------
_WORD *__fastcall BIO_read_asn1(_QWORD *a1, void **a2, _QWORD *a3, unsigned __int64 a4)
{
  _QWORD *v4; // x20
  _QWORD *v5; // x21
  unsigned __int64 v6; // x23
  _QWORD *v7; // x22
  void **v8; // x19
  unsigned __int64 v9; // x25
  size_t v10; // x24
  size_t v11; // x8
  _WORD *result; // x0
  __int64 v13; // x25
  size_t v14; // x24
  signed __int64 v15; // x25
  unsigned __int8 *v16; // x26
  int v17; // w10
  __int64 v18; // x9
  unsigned __int8 v19; // t1
  unsigned int v20; // w8
  void *v21; // x0
  int v22; // w0
  bool v23; // cf
  bool v24; // zf
  void *v25; // x0
  __int16 v26; // [xsp+0h] [xbp-50h]
  _BYTE v27[6]; // [xsp+2h] [xbp-4Eh]
  __int64 v28; // [xsp+8h] [xbp-48h]

  v4 = a1;
  v5 = a1 + 8;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)sub_637EC(a1, (__int64)&v26, 2u, 24LL, 2, a1 + 8) != 2 || (v26 & 0x1F) == 31 )
    goto LABEL_42;
  v9 = HIBYTE(v26);
  if ( v26 & 0x8000u )
  {
    v13 = HIBYTE(v26) & 0x7F;
    if ( v26 & 0x20 && !(v26 & 0x7F00) )
    {
      if ( v6 >> 1 >= 0x801 )
        v14 = 4098LL;
      else
        v14 = v6;
      if ( v14 < 2 )
        goto LABEL_42;
      result = malloc(v14);
      *v8 = result;
      if ( !result )
        goto LABEL_43;
      v15 = 2LL;
      *result = v26;
      while ( 1 )
      {
        v21 = *v8;
        if ( v14 == v15 )
          goto LABEL_41;
        v22 = sub_637EC(v4, (__int64)v21 + v15, (signed int)v14 - (signed int)v15, 24LL, 2, v5);
        if ( v22 == -1 )
          goto LABEL_40;
        if ( !v22 )
        {
          *v7 = v15;
          result = (_WORD *)(&dword_0 + 1);
          goto LABEL_43;
        }
        v15 += v22;
        if ( v14 < v6 && v14 - v15 <= 0x7FF )
        {
          if ( v14 + 4096 <= v6 )
          {
            v23 = v14 >= 0xFFFFFFFFFFFFEFFFLL;
            v24 = v14 == -4097LL;
          }
          else
          {
            v23 = 1;
            v24 = 0;
          }
          if ( !v24 && v23 )
            v14 = v6;
          else
            v14 += 4096LL;
          v25 = realloc(*v8, v14);
          if ( !v25 )
            goto LABEL_40;
          *v8 = v25;
        }
      }
    }
    if ( (unsigned int)(v13 - 1) > 3 )
      goto LABEL_42;
    v16 = v27;
    if ( (unsigned int)sub_637EC(v4, (__int64)v27, v13, 24LL, 2, v5) != (_DWORD)v13 )
      goto LABEL_42;
    v17 = 0;
    v10 = v13 + 2;
    v18 = v13;
    do
    {
      v19 = *v16++;
      --v18;
      v20 = v19 | (v17 << 8);
      v17 = v19 | (v17 << 8);
    }
    while ( v18 );
    if ( v20 < 0x80 )
      goto LABEL_42;
    if ( !(v20 >> (8 * v13 - 8)) )
      goto LABEL_42;
    v9 = v20;
    v23 = __CFADD__(v10, v20);
    v11 = v10 + v20;
    if ( v23 )
      goto LABEL_42;
  }
  else
  {
    v10 = 2LL;
    v11 = HIBYTE(v26) + 2LL;
    if ( HIBYTE(v26) >= 0xFFFFFFFFFFFFFFFELL )
    {
LABEL_42:
      result = 0LL;
      goto LABEL_43;
    }
  }
  result = 0LL;
  if ( !(v9 >> 31) && v11 <= v6 )
  {
    *v7 = v11;
    result = malloc(v11);
    *v8 = result;
    if ( result )
    {
      memcpy(result, &v26, v10);
      if ( (unsigned int)sub_637EC(v4, (__int64)*v8 + v10, v9, 24LL, 2, v5) == (_DWORD)v9 )
      {
        result = (_WORD *)(&dword_0 + 1);
        goto LABEL_43;
      }
LABEL_40:
      v21 = *v8;
LABEL_41:
      free(v21);
      goto LABEL_42;
    }
  }
LABEL_43:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v28;
  return result;
}
// 0: using guessed type int dword_0;

//----- (000000000006471C) ----------------------------------------------------
__int64 __fastcall BIO_set_retry_special(__int64 result)
{
  *(_DWORD *)(result + 32) |= 5u;
  return result;
}

//----- (0000000000064730) ----------------------------------------------------
__int64 __fastcall BN_add(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // w20
  __int64 v4; // x19
  __int64 result; // x0
  bool v6; // zf
  __int64 v7; // x20
  __int64 v8; // x21
  int v9; // w8
  signed int v10; // w9

  v3 = *(_DWORD *)(a2 + 16);
  v4 = a1;
  if ( v3 == *(_DWORD *)(a3 + 16) )
  {
    result = BN_uadd(a1, a2, a3);
    *(_DWORD *)(v4 + 16) = v3;
    return result;
  }
  v6 = v3 == 0;
  if ( v3 )
    v7 = a2;
  else
    v7 = a3;
  if ( v6 )
    v8 = a2;
  else
    v8 = a3;
  if ( BN_ucmp(v8, v7) & 0x80000000 )
  {
    result = BN_usub(v4, v7, v8);
    if ( !(_DWORD)result )
      return result;
    v10 = 1;
    goto LABEL_14;
  }
  v9 = BN_usub(v4, v8, v7);
  v10 = 0;
  result = 0LL;
  if ( v9 )
  {
LABEL_14:
    *(_DWORD *)(v4 + 16) = v10;
    result = 1LL;
  }
  return result;
}

//----- (00000000000647D4) ----------------------------------------------------
__int64 __fastcall BN_usub(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 **v3; // x20
  char **v4; // x21
  int v5; // w22
  int v6; // w24
  __int64 v7; // x19
  __int64 v8; // x23
  __int64 result; // x0
  char *v10; // x8
  char *v11; // x0
  unsigned __int64 *v12; // x11
  signed __int64 v13; // x9
  signed int v14; // w10
  char *v15; // x1
  char *v16; // x13
  char *v17; // x14
  unsigned __int64 v18; // x15
  unsigned __int64 v19; // t1
  unsigned __int64 v20; // x16
  unsigned __int64 v21; // t1
  bool v22; // cf
  bool v23; // zf
  __int64 v24; // x15
  signed int v25; // w17
  signed int v26; // w18
  __int64 v27; // x15
  __int64 v28; // x10
  signed __int64 v29; // x9
  signed __int64 v30; // x14
  __int64 v31; // x13

  v3 = (unsigned __int64 **)a3;
  v4 = (char **)a2;
  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a3 + 8);
  v7 = a1;
  v8 = (unsigned int)(v5 - v6);
  if ( v8 & 0x80000000 )
  {
    ERR_put_error(3, 0LL, 100, (__int64)"external/boringssl/src/crypto/bn/add.c", 272);
    return 0LL;
  }
  result = bn_wexpand(a1, v5);
  if ( !result )
    return result;
  v10 = *v4;
  v11 = *(char **)v7;
  if ( !v6 )
  {
    v15 = *v4;
    if ( (signed int)v8 >= 1 )
      goto LABEL_26;
    goto LABEL_29;
  }
  v12 = *v3;
  v13 = (unsigned int)(v6 - 1);
  LOBYTE(v14) = 0;
  v15 = &v10[8 * (v13 + 1)];
  v16 = *(char **)v7;
  v17 = *v4;
  do
  {
    v19 = *(_QWORD *)v17;
    v17 += 8;
    v18 = v19;
    v21 = *v12;
    ++v12;
    v20 = v21;
    --v6;
    v22 = v18 >= v21;
    v23 = v18 == v21;
    v24 = v18 - (v14 & 1);
    if ( !v23 && v22 )
      v25 = 0;
    else
      v25 = 1;
    v26 = !v22;
    v27 = v24 - v20;
    if ( v14 & 1 )
      v14 = v25;
    else
      v14 = v26;
    *(_QWORD *)v16 = v27;
    v16 += 8;
  }
  while ( v6 );
  if ( !v14 )
  {
    v11 += 8 * (v13 + 1);
    if ( (signed int)v8 >= 1 )
    {
LABEL_26:
      if ( v11 != v15 )
      {
        if ( (_DWORD)v8 )
          memcpy(v11, v15, v8 << 32 >> 29);
      }
    }
LABEL_29:
    *(_DWORD *)(v7 + 8) = v5;
    *(_DWORD *)(v7 + 16) = 0;
    bn_correct_top(v7);
    return 1LL;
  }
  if ( (_DWORD)v8 )
  {
    v28 = 0LL;
    v29 = 8 * v13;
    do
    {
      v30 = v29 + v28;
      v31 = *(_QWORD *)&v10[v29 + 8 + v28];
      v8 = (unsigned int)(v8 - 1);
      v28 += 8LL;
      *(_QWORD *)&v11[v30 + 8] = v31 - 1;
    }
    while ( (_DWORD)v8 && !v31 );
    v15 = &v10[v29 + 8 + v28];
    v11 += v29 + v28 + 8;
    if ( (signed int)v8 < 1 )
      goto LABEL_29;
    goto LABEL_26;
  }
  return 0LL;
}

//----- (0000000000064950) ----------------------------------------------------
__int64 __fastcall BN_uadd(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // w8
  int v4; // w9
  __int64 v5; // x19
  __int64 v6; // x22
  __int64 v7; // x23
  __int64 v8; // x21
  signed __int64 v9; // x20
  __int64 result; // x0
  unsigned __int64 *v11; // x22
  _QWORD *v12; // x2
  _QWORD *v13; // x21
  int v14; // w23
  unsigned __int64 v15; // x0
  signed __int64 v16; // x10
  unsigned __int64 v17; // x8
  unsigned __int64 *v18; // x9
  unsigned __int64 *v19; // x8
  unsigned __int64 v20; // t1

  v3 = *(_DWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a3 + 8);
  v5 = a1;
  if ( v3 >= v4 )
    v6 = a2;
  else
    v6 = a3;
  v7 = *(signed int *)(v6 + 8);
  if ( v3 >= v4 )
    v8 = a3;
  else
    v8 = a2;
  v9 = *(signed int *)(v8 + 8);
  result = bn_wexpand(a1, v7 + 1);
  if ( result )
  {
    *(_DWORD *)(v5 + 8) = v7;
    v11 = *(unsigned __int64 **)v6;
    v12 = *(_QWORD **)v8;
    v13 = *(_QWORD **)v5;
    v14 = v7 - v9;
    v15 = sub_6A448(*(_QWORD **)v5, v11, v12, v9);
    v16 = v9;
    if ( v15 )
    {
      do
      {
        if ( !v14 )
        {
          v13[v9] = 1LL;
          ++*(_DWORD *)(v5 + 8);
          goto LABEL_18;
        }
        v17 = v11[v16];
        --v14;
        ++v11;
        v13[v16] = ++v17;
        ++v13;
      }
      while ( !v17 );
      v18 = &v11[v16];
      v19 = &v13[v16];
      if ( v14 )
        goto LABEL_14;
    }
    else
    {
      v19 = &v13[v16];
      v18 = &v11[v16];
      if ( v14 )
      {
LABEL_14:
        if ( v19 != v18 )
        {
          do
          {
            v20 = *v18;
            ++v18;
            --v14;
            *v19 = v20;
            ++v19;
          }
          while ( v14 );
        }
      }
    }
LABEL_18:
    result = 1LL;
    *(_DWORD *)(v5 + 16) = 0;
  }
  return result;
}

//----- (0000000000064A44) ----------------------------------------------------
__int64 __fastcall BN_add_word(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  unsigned int v5; // w20
  __int64 v6; // x8
  __int64 v7; // x21
  signed __int64 v8; // x10
  __int64 v9; // x11
  unsigned __int8 v10; // cf
  __int64 v11; // x11
  __int64 v12; // x9

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    if ( BN_is_zero(a1) )
      return BN_set_word(v3, v2);
    if ( *(_DWORD *)(v3 + 16) )
    {
      *(_DWORD *)(v3 + 16) = 0;
      v5 = BN_sub_word(v3, v2);
      if ( !BN_is_zero(v3) )
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v3 + 16) == 0;
      return v5;
    }
    v6 = 0LL;
    while ( 1 )
    {
      v7 = *(signed int *)(v3 + 8);
      if ( v6 >= v7 )
        break;
      v8 = 8 * v6++;
      v9 = *(_QWORD *)(*(_QWORD *)v3 + v8);
      v10 = __CFADD__(v9, v2);
      v11 = v9 + v2;
      if ( v10 )
        v2 = 1LL;
      else
        v2 = 0LL;
      *(_QWORD *)(*(_QWORD *)v3 + v8) = v11;
      if ( !v10 )
        return 1;
    }
    if ( (_DWORD)v6 == (_DWORD)v7 )
    {
      if ( !bn_wexpand(v3, v7 + 1) )
        return 0;
      v12 = *(_QWORD *)v3;
      ++*(_DWORD *)(v3 + 8);
      *(_QWORD *)(v12 + 8 * v7) = v2;
    }
  }
  return 1;
}

//----- (0000000000064B40) ----------------------------------------------------
__int64 __fastcall BN_sub_word(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x20
  __int64 v3; // x19
  unsigned int v4; // w20
  __int64 result; // x0
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x9
  __int64 v8; // x8
  signed __int64 v9; // x10
  unsigned __int64 v10; // x11
  bool v11; // cf
  unsigned __int64 v12; // x11

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    return 1;
  if ( BN_is_zero(a1) )
  {
    v4 = BN_set_word(v3, v2);
    if ( v4 )
      BN_set_negative(v3, 1);
    return v4;
  }
  if ( *(_DWORD *)(v3 + 16) )
  {
    *(_DWORD *)(v3 + 16) = 0;
    result = BN_add_word(v3, v2);
    *(_DWORD *)(v3 + 16) = 1;
    return result;
  }
  if ( *(_DWORD *)(v3 + 8) != 1 || (v6 = **(_QWORD **)v3, v6 >= v2) )
  {
    v8 = 0LL;
    do
    {
      v9 = 8 * v8++;
      v10 = *(_QWORD *)(*(_QWORD *)v3 + v9);
      v11 = v10 >= v2;
      v12 = v10 - v2;
      v2 = 1LL;
      *(_QWORD *)(*(_QWORD *)v3 + v9) = v12;
    }
    while ( !v11 );
    if ( !*(_QWORD *)(*(_QWORD *)v3 + 8 * v8 - 8) && *(_DWORD *)(v3 + 8) == (_DWORD)v8 )
      *(_DWORD *)(v3 + 8) = v8 - 1;
    return 1;
  }
  v7 = v2 - v6;
  v4 = 1;
  **(_QWORD **)v3 = v7;
  *(_DWORD *)(v3 + 16) = 1;
  return v4;
}

//----- (0000000000064C38) ----------------------------------------------------
__int64 __fastcall BN_sub(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  int v4; // w8
  __int64 v5; // x19
  _BOOL4 v6; // w21
  __int64 v7; // x21
  __int64 result; // x0
  __int64 v9; // x8
  int v10; // w8
  signed int v11; // w9

  v3 = a2;
  v4 = *(_DWORD *)(a3 + 16);
  v5 = a1;
  if ( *(_DWORD *)(a2 + 16) )
  {
    v6 = v4 == 0;
    if ( v4 )
    {
      v7 = a3;
      goto LABEL_9;
    }
LABEL_6:
    result = BN_uadd(a1, a2, a3);
    if ( !(_DWORD)result )
      return result;
    *(_DWORD *)(v5 + 16) = v6;
    goto LABEL_19;
  }
  if ( v4 )
  {
    v6 = 0;
    goto LABEL_6;
  }
  v7 = a2;
  v3 = a3;
LABEL_9:
  if ( *(_DWORD *)(v7 + 8) <= *(_DWORD *)(v3 + 8) )
    v9 = v3;
  else
    v9 = v7;
  result = bn_wexpand(a1, *(signed int *)(v9 + 8));
  if ( result )
  {
    if ( BN_ucmp(v7, v3) & 0x80000000 )
    {
      result = BN_usub(v5, v3, v7);
      if ( !(_DWORD)result )
        return result;
      v11 = 1;
    }
    else
    {
      v10 = BN_usub(v5, v7, v3);
      v11 = 0;
      result = 0LL;
      if ( !v10 )
        return result;
    }
    *(_DWORD *)(v5 + 16) = v11;
LABEL_19:
    result = 1LL;
  }
  return result;
}

//----- (0000000000064D1C) ----------------------------------------------------
_QWORD *BN_new()
{
  _QWORD *result; // x0

  result = malloc(0x18uLL);
  if ( result )
  {
    *result = 0LL;
    result[1] = 0LL;
    *((_DWORD *)result + 4) = 0;
    *((_DWORD *)result + 5) = 1;
  }
  else
  {
    ERR_put_error(3, 0LL, 65, (__int64)"external/boringssl/src/crypto/bn/bn.c", 72);
    result = 0LL;
  }
  return result;
}

//----- (0000000000064D6C) ----------------------------------------------------
_QWORD *__fastcall BN_init(_QWORD *result)
{
  result[1] = 0LL;
  result[2] = 0LL;
  *result = 0LL;
  return result;
}

//----- (0000000000064D78) ----------------------------------------------------
void __fastcall BN_free(_DWORD *a1)
{
  _DWORD *v1; // x19
  int v2; // w8

  v1 = a1;
  if ( a1 )
  {
    v2 = a1[5];
    if ( !(v2 & 2) )
    {
      free(*(void **)a1);
      v2 = v1[5];
    }
    if ( v2 & 1 )
      free(v1);
    else
      *(_QWORD *)v1 = 0LL;
  }
}

//----- (0000000000064DC4) ----------------------------------------------------
void __fastcall BN_clear_free(void **a1)
{
  void **v1; // x19
  void *v2; // x0
  int *v3; // x20
  int v4; // w20

  v1 = a1;
  if ( a1 )
  {
    v2 = *a1;
    if ( *v1 )
    {
      OPENSSL_cleanse(v2, 8LL * *((signed int *)v1 + 3));
      v3 = (int *)((char *)v1 + 20);
      if ( !(*((_BYTE *)v1 + 20) & 2) )
        free(*v1);
    }
    else
    {
      v3 = (int *)((char *)v1 + 20);
    }
    v4 = *v3;
    OPENSSL_cleanse(v1, 0x18uLL);
    if ( v4 & 1 )
      free(v1);
  }
}

//----- (0000000000064E38) ----------------------------------------------------
signed int *__fastcall BN_dup(signed int *a1)
{
  signed int *v1; // x19
  signed int *v2; // x0
  signed int *v3; // x20
  __int64 v4; // x8
  signed int v5; // w8
  int v7; // w8

  v1 = a1;
  if ( !a1 )
    return v1;
  v2 = (signed int *)malloc(0x18uLL);
  v3 = v2;
  if ( !v2 )
  {
    ERR_put_error(3, 0LL, 65, (__int64)"external/boringssl/src/crypto/bn/bn.c", 72);
    return 0LL;
  }
  *(_QWORD *)v2 = 0LL;
  *((_QWORD *)v2 + 1) = 0LL;
  v2[4] = 0;
  v2[5] = 1;
  if ( v2 == v1 )
    return v1;
  if ( !bn_wexpand((__int64)v2, v1[2]) )
  {
    v7 = v3[5];
    if ( !(v7 & 2) )
    {
      free(*(void **)v3);
      v7 = v3[5];
    }
    if ( !(v7 & 1) )
    {
      v1 = 0LL;
      *(_QWORD *)v3 = 0LL;
      return v1;
    }
    free(v3);
    return 0LL;
  }
  v4 = v1[2];
  if ( (_DWORD)v4 )
  {
    memcpy(*(void **)v3, *(const void **)v1, 8 * v4);
    LODWORD(v4) = v1[2];
  }
  v3[2] = v4;
  v5 = v1[4];
  v1 = v3;
  v3[4] = v5;
  return v1;
}

//----- (0000000000064F10) ----------------------------------------------------
__int64 __fastcall BN_copy(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 v4; // x8

  v2 = a2;
  v3 = a1;
  if ( a2 == a1 )
    return a2;
  if ( !bn_wexpand(a1, *(signed int *)(a2 + 8)) )
    return 0LL;
  v4 = *(signed int *)(v2 + 8);
  if ( (_DWORD)v4 )
  {
    memcpy(*(void **)v3, *(const void **)v2, 8 * v4);
    LODWORD(v4) = *(_DWORD *)(v2 + 8);
  }
  *(_DWORD *)(v3 + 8) = v4;
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 16);
  return v3;
}

//----- (0000000000064F84) ----------------------------------------------------
__int64 __fastcall bn_wexpand(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x19
  int v3; // w20
  int v4; // w2
  __int16 v5; // w4
  void *v6; // x0
  void *v7; // x21
  __int64 v8; // x8

  v2 = a1;
  v3 = a2;
  if ( *(signed int *)(a1 + 12) < a2 )
  {
    if ( a2 >= 0x800000 )
    {
      v4 = 102;
      v5 = 317;
LABEL_11:
      ERR_put_error(3, 0LL, v4, (__int64)"external/boringssl/src/crypto/bn/bn.c", v5);
      return 0LL;
    }
    if ( *(_BYTE *)(a1 + 20) & 2 )
    {
      v4 = 106;
      v5 = 322;
      goto LABEL_11;
    }
    v6 = malloc(8 * a2);
    v7 = v6;
    if ( !v6 )
    {
      v4 = 65;
      v5 = 328;
      goto LABEL_11;
    }
    v8 = *(signed int *)(v2 + 8);
    if ( (_DWORD)v8 )
      memcpy(v6, *(const void **)v2, 8 * v8);
    free(*(void **)v2);
    *(_QWORD *)v2 = v7;
    *(_DWORD *)(v2 + 12) = v3;
  }
  return v2;
}

//----- (0000000000065058) ----------------------------------------------------
void *__fastcall BN_clear(void **a1)
{
  void **v1; // x19
  void *result; // x0
  __int64 v3; // x8

  v1 = a1;
  result = *a1;
  if ( result )
  {
    v3 = *((signed int *)v1 + 3);
    if ( (_DWORD)v3 )
      result = memset(result, 0, 8 * v3);
  }
  *((_DWORD *)v1 + 2) = 0;
  *((_DWORD *)v1 + 4) = 0;
  return result;
}

//----- (0000000000065098) ----------------------------------------------------
void **BN_value_one()
{
  return &off_F7C50;
}
// F7C50: using guessed type void *off_F7C50;

//----- (00000000000650A4) ----------------------------------------------------
__int64 __fastcall BN_num_bits_word(unsigned __int64 a1)
{
  __int64 result; // x0

  if ( a1 >> 32 )
  {
    if ( a1 >> 48 )
    {
      if ( a1 >> 56 )
        result = (unsigned int)byte_D7220[a1 >> 56] + 56;
      else
        result = (unsigned int)byte_D7220[a1 >> 48] + 48;
    }
    else if ( a1 & 0xFF0000000000LL )
    {
      result = (unsigned int)byte_D7220[a1 >> 40] + 40;
    }
    else
    {
      result = (unsigned int)byte_D7220[a1 >> 32] + 32;
    }
  }
  else if ( a1 & 0xFFFF0000 )
  {
    if ( a1 & 0xFF000000 )
      result = (unsigned int)byte_D7220[(signed int)(a1 >> 24)] + 24;
    else
      result = (unsigned int)byte_D7220[(signed int)(a1 >> 16)] + 16;
  }
  else if ( a1 & 0xFF00 )
  {
    result = (unsigned int)byte_D7220[(signed int)(a1 >> 8)] + 8;
  }
  else
  {
    result = byte_D7220[(signed int)a1];
  }
  return result;
}

//----- (0000000000065188) ----------------------------------------------------
__int64 __fastcall BN_num_bits(__int64 a1)
{
  _QWORD *v1; // x19
  __int64 v2; // x20
  __int64 result; // x0

  v1 = (_QWORD *)a1;
  v2 = *(signed int *)(a1 + 8);
  if ( BN_is_zero(a1) )
    result = 0LL;
  else
    result = (unsigned int)BN_num_bits_word(*(_QWORD *)(*v1 + 8 * (v2 - 1))) + (((_DWORD)v2 - 1) << 6);
  return result;
}

//----- (00000000000651CC) ----------------------------------------------------
__int64 __fastcall BN_num_bytes(__int64 a1)
{
  _QWORD *v1; // x19
  __int64 v2; // x20
  __int64 result; // x0

  v1 = (_QWORD *)a1;
  v2 = *(signed int *)(a1 + 8);
  if ( BN_is_zero(a1) )
    result = 0LL;
  else
    result = (((((_DWORD)v2 - 1) << 6) | 7) + (unsigned int)BN_num_bits_word(*(_QWORD *)(*v1 + 8 * (v2 - 1)))) >> 3;
  return result;
}

//----- (000000000006521C) ----------------------------------------------------
__int64 __fastcall BN_zero(__int64 result)
{
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

//----- (0000000000065228) ----------------------------------------------------
__int64 __fastcall BN_one(__int64 a1)
{
  __int64 v1; // x20
  unsigned int v2; // w19
  _QWORD *v3; // x8

  v1 = a1;
  v2 = 1;
  if ( bn_wexpand(a1, 1uLL) )
  {
    v3 = *(_QWORD **)v1;
    *(_DWORD *)(v1 + 16) = 0;
    *v3 = 1LL;
    *(_DWORD *)(v1 + 8) = 1;
  }
  else
  {
    v2 = 0;
  }
  return v2;
}

//----- (0000000000065270) ----------------------------------------------------
__int64 __fastcall BN_set_word(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 result; // x0
  _QWORD *v5; // x8
  signed int v6; // w8

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    result = bn_wexpand(a1, 1uLL);
    if ( !result )
      return result;
    v5 = *(_QWORD **)v3;
    *(_DWORD *)(v3 + 16) = 0;
    *v5 = v2;
    v6 = 1;
  }
  else
  {
    v6 = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
  result = 1LL;
  *(_DWORD *)(v3 + 8) = v6;
  return result;
}

//----- (00000000000652C8) ----------------------------------------------------
__int64 __fastcall bn_correct_top(__int64 result)
{
  int v1; // w8
  _QWORD *v2; // x9
  unsigned __int8 v3; // vf

  v1 = *(_DWORD *)(result + 8);
  if ( v1 >= 1 )
  {
    v2 = (_QWORD *)(*(_QWORD *)result + 8LL * (v1 - 1));
    do
    {
      if ( *v2 )
        break;
      --v2;
      v3 = __OFSUB__(v1--, 1);
    }
    while ( !((unsigned __int8)((v1 < 0) ^ v3) | (v1 == 0)) );
    *(_DWORD *)(result + 8) = v1;
  }
  if ( !v1 )
    *(_DWORD *)(result + 16) = 0;
  return result;
}

//----- (0000000000065300) ----------------------------------------------------
bool __fastcall BN_is_negative(__int64 a1)
{
  return *(_DWORD *)(a1 + 16) != 0;
}

//----- (0000000000065310) ----------------------------------------------------
__int64 __fastcall BN_set_negative(__int64 result, int a2)
{
  __int64 v2; // x19
  _BOOL4 v3; // w8

  v2 = result;
  v3 = 0;
  if ( a2 )
  {
    result = BN_is_zero(result);
    if ( !(_DWORD)result )
      v3 = 1;
  }
  *(_DWORD *)(v2 + 16) = v3;
  return result;
}

//----- (000000000006534C) ----------------------------------------------------
__int64 __fastcall sub_6534C(__int64 a1, unsigned __int64 a2)
{
  if ( a2 <= 0xFFFFFFFFFFFFFFC0LL )
    return bn_wexpand(a1, (a2 + 63) >> 6);
  ERR_put_error(3, 0LL, 102, (__int64)"external/boringssl/src/crypto/bn/bn.c", 343);
  return 0LL;
}

//----- (0000000000065390) ----------------------------------------------------
bool __fastcall BN_parse_asn1_unsigned(unsigned __int8 **a1, __int64 a2)
{
  __int64 v2; // x19
  int v3; // w2
  __int16 v4; // w4
  _BOOL8 result; // x0
  unsigned __int8 *v6; // x20
  __int64 v7; // x0
  char v8; // [xsp+8h] [xbp-28h]
  __int64 v9; // [xsp+18h] [xbp-18h]

  v2 = a2;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a1, &v8, 2) && EVP_CIPHER_CTX_get_app_data((__int64)&v8) )
  {
    if ( *(char *)lh_num_items((__int64)&v8) & 0x80000000 )
    {
      v3 = 109;
      v4 = 30;
    }
    else
    {
      if ( *(_BYTE *)lh_num_items((__int64)&v8)
        || (unsigned __int64)EVP_CIPHER_CTX_get_app_data((__int64)&v8) < 2
        || *(char *)(lh_num_items((__int64)&v8) + 1) & 0x80000000 )
      {
        v6 = (unsigned __int8 *)lh_num_items((__int64)&v8);
        v7 = EVP_CIPHER_CTX_get_app_data((__int64)&v8);
        result = BN_bin2bn(v6, v7, v2) != 0;
        goto LABEL_11;
      }
      v3 = 117;
      v4 = 38;
    }
  }
  else
  {
    v3 = 117;
    v4 = 25;
  }
  ERR_put_error(3, 0LL, v3, (__int64)"external/boringssl/src/crypto/bn/bn_asn1.c", v4);
  result = 0LL;
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
  return result;
}

//----- (00000000000654B4) ----------------------------------------------------
bool __fastcall BN_parse_asn1_unsigned_buggy(unsigned __int8 **a1, __int64 a2)
{
  __int64 v2; // x19
  unsigned __int8 *v3; // x20
  __int64 v4; // x0
  _BOOL8 result; // x0
  char v6; // [xsp+8h] [xbp-28h]
  __int64 v7; // [xsp+18h] [xbp-18h]

  v2 = a2;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a1, &v6, 2) && EVP_CIPHER_CTX_get_app_data((__int64)&v6) )
  {
    v3 = (unsigned __int8 *)lh_num_items((__int64)&v6);
    v4 = EVP_CIPHER_CTX_get_app_data((__int64)&v6);
    result = BN_bin2bn(v3, v4, v2) != 0;
  }
  else
  {
    ERR_put_error(3, 0LL, 117, (__int64)"external/boringssl/src/crypto/bn/bn_asn1.c", 49);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000065568) ----------------------------------------------------
signed __int64 __fastcall BN_marshal_asn1(__int64 *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x19
  int v4; // w2
  __int16 v5; // w4
  unsigned int v6; // w0
  signed __int64 result; // x0
  char v8; // [xsp+8h] [xbp-38h]
  __int64 v9; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( BN_is_negative(a2) )
  {
    v4 = 109;
    v5 = 64;
LABEL_10:
    ERR_put_error(3, 0LL, v4, (__int64)"external/boringssl/src/crypto/bn/bn_asn1.c", v5);
    result = 0LL;
    goto LABEL_11;
  }
  if ( !(unsigned int)CBB_add_asn1(v3, (__int64 *)&v8, 2u)
    || !(BN_num_bits(v2) & 7) && !(unsigned int)CBB_add_u8((__int64 *)&v8, 0)
    || (v6 = BN_num_bytes(v2), !(unsigned int)BN_bn2cbb_padded((__int64 *)&v8, v6, v2))
    || !(unsigned int)CBB_flush(v3) )
  {
    v4 = 118;
    v5 = 75;
    goto LABEL_10;
  }
  result = 1LL;
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000006565C) ----------------------------------------------------
__int64 __fastcall BN_ucmp(__int64 a1, __int64 a2)
{
  __int64 *v2; // x8
  __int64 v3; // x10
  int v4; // w9
  __int64 result; // x0
  __int64 v6; // x8
  signed __int64 v7; // x10
  unsigned __int64 v8; // x12
  unsigned __int64 v9; // x11

  v2 = (__int64 *)a1;
  v3 = *(signed int *)(a1 + 8);
  v4 = *(_DWORD *)(a2 + 8);
  result = (unsigned int)(v3 - v4);
  if ( (_DWORD)v3 == v4 )
  {
    v6 = *v2;
    v7 = v3 - 1;
    while ( v7 + 1 >= 1 )
    {
      v8 = *(_QWORD *)(v6 + 8 * v7);
      v9 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v7--);
      if ( v8 != v9 )
        return v8 > v9;
    }
    result = 0LL;
  }
  return result;
}

//----- (00000000000656B4) ----------------------------------------------------
signed __int64 __fastcall BN_cmp(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  int v3; // w9
  signed __int64 result; // x0
  __int64 v5; // x10
  signed int v6; // w11
  unsigned int v7; // w9
  signed __int64 v8; // x10
  unsigned __int64 v9; // x11
  unsigned __int64 v10; // x12

  v2 = a1;
  if ( a1 && a2 )
  {
    v3 = *(_DWORD *)(a1 + 16);
    result = v3 == 0;
    if ( v3 == *(_DWORD *)(a2 + 16) )
    {
      v5 = *(signed int *)(v2 + 8);
      v6 = *(_DWORD *)(a2 + 8);
      v7 = v3 ? 0 : -1;
      if ( (signed int)v5 <= v6 )
      {
        if ( (signed int)v5 < v6 )
        {
LABEL_13:
          result = v7;
        }
        else
        {
          v8 = v5 - 1;
          while ( v8 + 1 >= 1 )
          {
            v9 = *(_QWORD *)(*(_QWORD *)v2 + 8 * v8);
            v10 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v8);
            if ( v9 > v10 )
              return result;
            --v8;
            if ( v9 < v10 )
              goto LABEL_13;
          }
          result = 0LL;
        }
      }
    }
  }
  else if ( a1 )
  {
    result = 1LL;
  }
  else
  {
    result = a2 != 0;
  }
  return result;
}

//----- (000000000006575C) ----------------------------------------------------
signed __int64 __fastcall sub_6575C(__int64 a1, __int64 a2, int a3)
{
  signed __int64 v3; // x8
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x8
  bool v6; // cf
  bool v7; // zf
  __int64 v8; // x8
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x9
  unsigned __int8 v11; // vf
  signed __int64 result; // x0

  v3 = (signed __int64)((unsigned __int64)(unsigned int)(a3 - 1) << 32) >> 29;
  v4 = *(_QWORD *)(a1 + v3);
  v5 = *(_QWORD *)(a2 + v3);
  v6 = v4 >= v5;
  v7 = v4 == v5;
  if ( v4 == v5 )
  {
    LODWORD(v8) = a3 - 2;
    if ( (a3 - 2) & 0x80000000 )
      return 0LL;
    v8 = (signed int)v8;
    while ( 1 )
    {
      v9 = *(_QWORD *)(a1 + 8 * v8);
      v10 = *(_QWORD *)(a2 + 8 * v8);
      v6 = v9 >= v10;
      v7 = v9 == v10;
      if ( v9 != v10 )
        break;
      v11 = __OFSUB__(v8--, 1LL);
      if ( (v8 < 0) ^ v11 )
        return 0LL;
    }
  }
  if ( !v7 && v6 )
    result = 1LL;
  else
    result = 0LL;
  return result;
}

//----- (00000000000657B8) ----------------------------------------------------
signed __int64 __fastcall sub_657B8(__int64 a1, __int64 a2, int a3, int a4)
{
  int v4; // w8
  signed __int64 v5; // x9
  _QWORD *v6; // x10
  __int64 v7; // x10
  __int64 v8; // x9
  signed __int64 v9; // x8
  bool v10; // nf
  unsigned __int8 v11; // vf
  signed __int64 v12; // x8
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x8
  bool v15; // cf
  bool v16; // zf
  __int64 v17; // x8
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x9
  signed __int64 result; // x0

  v4 = a3 - 1;
  if ( a4 & 0x80000000 )
  {
    v5 = a4 - 1LL;
    v6 = (_QWORD *)(a2 + 8 * (v4 - (signed __int64)a4));
    while ( !*v6 )
    {
      ++v5;
      --v6;
      if ( !((unsigned __int8)((v5 + 2 < 0) ^ __OFADD__(v5, 2LL)) | (v5 == -2)) )
        goto LABEL_5;
    }
    result = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_5:
    if ( a4 <= 0 )
    {
      v8 = v4;
LABEL_12:
      v12 = 8 * v8;
      v13 = *(_QWORD *)(a1 + 8 * v8);
      v14 = *(_QWORD *)(a2 + v12);
      v15 = v13 >= v14;
      v16 = v13 == v14;
      if ( v13 == v14 )
      {
        LODWORD(v17) = a3 - 2;
        if ( (a3 - 2) & 0x80000000 )
          return 0LL;
        v17 = (signed int)v17;
        while ( 1 )
        {
          v18 = *(_QWORD *)(a1 + 8 * v17);
          v19 = *(_QWORD *)(a2 + 8 * v17);
          v15 = v18 >= v19;
          v16 = v18 == v19;
          if ( v18 != v19 )
            break;
          v11 = __OFSUB__(v17--, 1LL);
          if ( (v17 < 0) ^ v11 )
            return 0LL;
        }
      }
      if ( !v16 && v15 )
        result = 1LL;
      else
        result = 0LL;
    }
    else
    {
      v7 = a4;
      v8 = v4;
      v9 = a1 + 8LL * v4;
      while ( !*(_QWORD *)(v9 + 8 * v7) )
      {
        v11 = __OFSUB__(v7, 2LL);
        v10 = v7-- - 2 < 0;
        if ( v10 ^ v11 )
          goto LABEL_12;
      }
      result = 1LL;
    }
  }
  return result;
}

//----- (0000000000065888) ----------------------------------------------------
bool __fastcall BN_abs_is_word(__int64 a1, __int64 a2)
{
  int v2; // w8

  v2 = *(_DWORD *)(a1 + 8);
  if ( !v2 )
    return a2 == 0;
  if ( v2 == 1 )
    return **(_QWORD **)a1 == a2;
  return 0LL;
}

//----- (00000000000658C0) ----------------------------------------------------
signed __int64 __fastcall BN_cmp_word(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x20
  __int64 v3; // x19
  signed __int64 result; // x0
  _BOOL4 v5; // w9
  int v6; // w8
  signed __int64 v7; // x10
  unsigned int v8; // w8
  signed __int64 v9; // x11
  unsigned __int64 v10; // x10
  bool v11; // cf
  unsigned __int64 *v12; // [xsp+8h] [xbp-38h]
  _BOOL4 v13; // [xsp+10h] [xbp-30h]
  int v14; // [xsp+14h] [xbp-2Ch]
  int v15; // [xsp+18h] [xbp-28h]
  int v16; // [xsp+1Ch] [xbp-24h]
  unsigned __int64 v17; // [xsp+20h] [xbp-20h]
  __int64 v18; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = a2;
  BN_init(&v12);
  result = 1LL;
  v5 = v2 != 0;
  v12 = &v17;
  v13 = v2 != 0;
  v14 = 1;
  v16 = 2;
  if ( v3 )
  {
    v6 = *(_DWORD *)(v3 + 16);
    result = v6 == 0;
    if ( v6 == v15 )
    {
      v7 = *(signed int *)(v3 + 8);
      v8 = v6 ? 0 : -1;
      if ( (signed int)v7 <= v5 )
      {
        if ( (signed int)v7 < v5 )
        {
LABEL_11:
          result = v8;
        }
        else
        {
          while ( 1 )
          {
            v9 = v7 - 1;
            if ( v7 < 1 )
              break;
            v10 = *(_QWORD *)(*(_QWORD *)v3 + 8 * v7 - 8);
            v11 = v10 >= v17;
            if ( v10 > v17 )
              goto LABEL_13;
            v7 = v9;
            if ( !v11 )
              goto LABEL_11;
          }
          result = 0LL;
        }
      }
    }
  }
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000659A8) ----------------------------------------------------
bool __fastcall BN_is_zero(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

//----- (00000000000659B8) ----------------------------------------------------
bool __fastcall BN_is_one(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 16) )
    return 0LL;
  if ( *(_DWORD *)(a1 + 8) == 1 )
    return **(_QWORD **)a1 == 1LL;
  return 0LL;
}

//----- (00000000000659F0) ----------------------------------------------------
bool __fastcall BN_is_word(__int64 a1, __int64 a2)
{
  int v2; // w8
  _BOOL8 result; // x0

  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 == 1 )
  {
    if ( **(_QWORD **)a1 == a2 )
    {
      if ( a2 )
        result = *(_DWORD *)(a1 + 16) == 0;
      else
        result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else if ( v2 )
  {
    result = 0LL;
  }
  else
  {
    result = a2 == 0;
  }
  return result;
}

//----- (0000000000065A48) ----------------------------------------------------
__int64 __fastcall BN_is_odd(__int64 a1)
{
  __int64 result; // x0

  if ( *(_DWORD *)(a1 + 8) < 1 )
    result = 0LL;
  else
    result = **(_BYTE **)a1 & 1;
  return result;
}

//----- (0000000000065A6C) ----------------------------------------------------
bool __fastcall BN_is_pow2(__int64 *a1)
{
  signed int v1; // w10
  __int64 v3; // x8
  int v4; // w9
  __int64 v5; // x10

  v1 = *((_DWORD *)a1 + 2);
  if ( !v1 )
    return 0LL;
  if ( *((_DWORD *)a1 + 4) )
    return 0LL;
  v3 = *a1;
  v4 = v1 - 1;
  if ( v1 < 2 )
    return ((*(_QWORD *)(v3 + 8LL * v4) - 1LL) & *(_QWORD *)(v3 + 8LL * v4)) == 0;
  v5 = 0LL;
  while ( !*(_QWORD *)(v3 + 8 * v5) )
  {
    if ( (signed int)++v5 >= v4 )
      return ((*(_QWORD *)(v3 + 8LL * v4) - 1LL) & *(_QWORD *)(v3 + 8LL * v4)) == 0;
  }
  return 0LL;
}

//----- (0000000000065AD0) ----------------------------------------------------
__int64 __fastcall BN_equal_consttime(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 result; // x0

  v2 = *(signed int *)(a1 + 8);
  if ( (_DWORD)v2 == *(_DWORD *)(a2 + 8) )
    result = ((unsigned int)CRYPTO_memcmp(*(_QWORD *)a1, *(_QWORD *)a2, 8 * v2) == 0) & ((((*(_DWORD *)(a2 + 16) ^ *(_DWORD *)(a1 + 16))
                                                                                         - 1) & (unsigned int)~(*(_DWORD *)(a2 + 16) ^ *(_DWORD *)(a1 + 16))) >> 31);
  else
    result = 0LL;
  return result;
}

//----- (0000000000065B38) ----------------------------------------------------
__int64 __fastcall BN_bin2bn(unsigned __int8 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  unsigned __int8 *v5; // x21
  _QWORD *v6; // x23
  unsigned __int64 v7; // x22
  int v8; // w8
  unsigned __int64 v9; // x9
  int v10; // w8
  unsigned __int8 v11; // t1
  unsigned __int64 v12; // x10

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v6 = 0LL;
    if ( !a2 )
      goto LABEL_8;
  }
  else
  {
    v6 = BN_new();
    v3 = (__int64)v6;
    if ( !v6 )
      return 0LL;
    if ( !v4 )
    {
LABEL_8:
      *(_DWORD *)(v3 + 8) = 0;
      return v3;
    }
  }
  v7 = ((unsigned __int64)(v4 - 1) >> 3) + 1;
  if ( !bn_wexpand(v3, v7) )
  {
    if ( v6 )
      BN_free(v6);
    return 0LL;
  }
  v8 = ((_BYTE)v4 - 1) & 7;
  *(_DWORD *)(v3 + 8) = v7;
  *(_DWORD *)(v3 + 16) = 0;
LABEL_9:
  v9 = 0LL;
  v10 = ~v8;
  while ( v4 )
  {
    v11 = *v5++;
    --v4;
    ++v10;
    v12 = v11 | (v9 << 8);
    v9 = v11 | (v9 << 8);
    if ( !v10 )
    {
      *(_QWORD *)(*(_QWORD *)v3 + 8 * --v7) = v12;
      v8 = 7;
      goto LABEL_9;
    }
  }
  bn_correct_top(v3);
  return v3;
}

//----- (0000000000065C1C) ----------------------------------------------------
__int64 __fastcall BN_le2bn(const void *a1, size_t a2, __int64 a3)
{
  __int64 v3; // x19
  size_t v4; // x20
  const void *v5; // x21
  _QWORD *v6; // x22
  unsigned __int64 v7; // x24
  _QWORD *v8; // x8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
  {
    v6 = 0LL;
    if ( !a2 )
      goto LABEL_8;
  }
  else
  {
    v6 = BN_new();
    v3 = (__int64)v6;
    if ( !v6 )
      return 0LL;
    if ( !v4 )
    {
LABEL_8:
      *(_DWORD *)(v3 + 8) = 0;
      *(_DWORD *)(v3 + 16) = 0;
      return v3;
    }
  }
  v7 = (v4 - 1) >> 3;
  if ( !bn_wexpand(v3, v7 + 1) )
  {
    BN_free(v6);
    return 0LL;
  }
  v8 = *(_QWORD **)v3;
  *(_DWORD *)(v3 + 8) = v7 + 1;
  v8[v7] = 0LL;
  memcpy(*(void **)v3, v5, v4);
  bn_correct_top(v3);
  return v3;
}

//----- (0000000000065CD4) ----------------------------------------------------
__int64 __fastcall BN_bn2bin(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // x19
  _QWORD *v3; // x20
  __int64 result; // x0
  signed __int64 v5; // x8
  signed __int64 v6; // x9
  unsigned __int64 v7; // x11
  unsigned __int64 v8; // x10

  v2 = a2;
  v3 = (_QWORD *)a1;
  result = (unsigned int)BN_num_bytes(a1);
  if ( (_DWORD)result )
  {
    v5 = 8 * result - 8;
    v6 = result - 1;
    do
    {
      v7 = v6-- & 0xFFFFFFFFFFFFFFF8LL;
      v8 = *(_QWORD *)(*v3 + v7);
      LOBYTE(v7) = v5 & 0x38;
      v5 -= 8LL;
      *v2++ = v8 >> v7;
    }
    while ( v6 != -1 );
  }
  return result;
}

//----- (0000000000065D38) ----------------------------------------------------
signed __int64 __fastcall BN_bn2le_padded(char *a1, size_t a2, __int64 a3)
{
  const void **v3; // x22
  char *v4; // x19
  size_t v5; // x20
  size_t v6; // x21

  v3 = (const void **)a3;
  v4 = a1;
  v5 = a2;
  v6 = (unsigned int)BN_num_bytes(a3);
  if ( v6 > v5 )
    return 0LL;
  if ( (_DWORD)v6 )
    memcpy(v4, *v3, v6);
  if ( v5 != v6 )
    memset(&v4[v6], 0, v5 - v6);
  return 1LL;
}

//----- (0000000000065DAC) ----------------------------------------------------
signed __int64 __fastcall BN_bn2bin_padded(_BYTE *a1, size_t a2, __int64 a3)
{
  __int64 v3; // x20
  _BYTE *v4; // x19
  size_t v5; // x21
  int v7; // w8
  signed __int64 v8; // x9
  unsigned __int64 i; // x10

  v3 = a3;
  v4 = a1;
  v5 = a2;
  if ( BN_is_zero(a3) )
  {
    if ( v5 )
      memset(v4, 0, v5);
    return 1LL;
  }
  v7 = *(_DWORD *)(v3 + 8);
  if ( v7 <= (v5 + 7) >> 3
    && (!(v5 & 7)
     || !((*(_QWORD *)(*(_QWORD *)v3
                     + 8
                     * ((((*(signed int *)(v3 + 12) + ~(v5 >> 3)) >> 63) - 1) & (v5 >> 3) | (*(signed int *)(v3 + 12)
                                                                                           - 1LL) & ((signed __int64)(*(signed int *)(v3 + 12) + ~(v5 >> 3)) >> 63))) & (((v7 + ~(v5 >> 3)) >> 63) - 1)) >> 8 * ((unsigned __int8)v5 & 7u))) )
  {
    if ( v5 )
    {
      v8 = 8 * v5 - 8;
      for ( i = v5 - 1; ; --i )
      {
        *v4 = ((((~(i >> 3) + v7) >> 63) - 1) & *(_QWORD *)(*(_QWORD *)v3
                                                          + 8
                                                          * ((((*(signed int *)(v3 + 12) + ~(i >> 3)) >> 63) - 1) & (i >> 3) | (*(signed int *)(v3 + 12) - 1LL) & ((signed __int64)(*(signed int *)(v3 + 12) + ~(i >> 3)) >> 63)))) >> (v8 & 0x38);
        if ( !i )
          break;
        v7 = *(_DWORD *)(v3 + 8);
        ++v4;
        LOBYTE(v8) = v8 - 8;
      }
    }
    return 1LL;
  }
  return 0LL;
}

//----- (0000000000065EE4) ----------------------------------------------------
signed __int64 __fastcall BN_bn2cbb_padded(__int64 *a1, __int64 a2, __int64 a3)
{
  size_t v3; // x20
  __int64 v4; // x19
  signed __int64 result; // x0
  _BYTE *v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v3 = a2;
  v4 = a3;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = CBB_add_space(a1, &v6, a2);
  if ( (_DWORD)result )
    result = (unsigned int)BN_bn2bin_padded(v6, v3, v4) != 0;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000065F58) ----------------------------------------------------
_BYTE *__fastcall BN_bn2hex(__int64 a1)
{
  __int64 v1; // x20
  _BYTE *v2; // x0
  _BYTE *v3; // x19
  _BYTE *v4; // x21
  __int64 v5; // x8
  signed int v6; // w11
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x11
  char v9; // w10
  signed __int64 v10; // x12
  char v11; // w10
  signed __int64 v12; // x12
  char v13; // w10
  signed __int64 v14; // x12
  char v15; // w10
  unsigned int v16; // w12
  char v17; // w10
  unsigned int v18; // w12
  char v19; // w10
  unsigned int v20; // w12
  char v21; // w10
  unsigned int v22; // w12
  char v23; // w10

  v1 = a1;
  v2 = malloc(16 * *(_DWORD *)(a1 + 8) | 3);
  v3 = v2;
  if ( v2 )
  {
    v4 = v2;
    if ( *(_DWORD *)(v1 + 16) )
    {
      *v2 = 45;
      v4 = v2 + 1;
    }
    if ( BN_is_zero(v1) )
      *v4++ = 48;
    v5 = *(signed int *)(v1 + 8);
    if ( (signed int)v5 >= 1 )
    {
      v6 = 0;
      do
      {
        v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        if ( (v7 >> 56) | (unsigned int)v6 )
        {
          v8 = v7 >> 60;
          v9 = a0123456789abcd[(v7 >> 56) & 0xF];
          *v4 = a0123456789abcd[v8];
          v4[1] = v9;
          v4 += 2;
          v6 = 1;
          v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        }
        v10 = (v7 >> 48) & 0xFF;
        if ( BYTE6(v7) | v6 )
        {
          v11 = a0123456789abcd[(v7 >> 48) & 0xF];
          *v4 = a0123456789abcd[(unsigned int)v10 >> 4];
          v4[1] = v11;
          v4 += 2;
          v6 = 1;
          v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        }
        v12 = (v7 >> 40) & 0xFF;
        if ( BYTE5(v7) | v6 )
        {
          v13 = a0123456789abcd[(v7 >> 40) & 0xF];
          *v4 = a0123456789abcd[(unsigned int)v12 >> 4];
          v4[1] = v13;
          v4 += 2;
          v6 = 1;
          v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        }
        v14 = (v7 >> 32) & 0xFF;
        if ( (unsigned int)v14 | v6 )
        {
          v15 = a0123456789abcd[(v7 >> 32) & 0xF];
          *v4 = a0123456789abcd[(unsigned int)v14 >> 4];
          v4[1] = v15;
          v4 += 2;
          v6 = 1;
          v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        }
        v16 = (unsigned int)v7 >> 24;
        if ( ((unsigned int)v7 >> 24) | v6 )
        {
          v17 = a0123456789abcd[(v7 >> 24) & 0xF];
          *v4 = a0123456789abcd[v16 >> 4];
          v4[1] = v17;
          v4 += 2;
          v6 = 1;
          v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        }
        v18 = ((unsigned int)v7 >> 16) & 0xFF;
        if ( v18 | v6 )
        {
          v19 = a0123456789abcd[(v7 >> 16) & 0xF];
          *v4 = a0123456789abcd[v18 >> 4];
          v4[1] = v19;
          v4 += 2;
          v6 = 1;
          v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        }
        v20 = (unsigned __int16)v7 >> 8;
        if ( v20 | v6 )
        {
          v21 = a0123456789abcd[(v7 >> 8) & 0xF];
          *v4 = a0123456789abcd[v20 >> 4];
          v4[1] = v21;
          v4 += 2;
          v6 = 1;
          v7 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8);
        }
        --v5;
        v22 = (unsigned __int8)v7;
        if ( (unsigned __int8)v7 | v6 )
        {
          v23 = a0123456789abcd[v7 & 0xF];
          *v4 = a0123456789abcd[v22 >> 4];
          v4[1] = v23;
          v4 += 2;
          v6 = 1;
        }
      }
      while ( v5 + 1 > 1 );
    }
    *v4 = 0;
  }
  else
  {
    ERR_put_error(3, 0LL, 65, (__int64)"external/boringssl/src/crypto/bn/convert.c", 260);
  }
  return v3;
}

//----- (00000000000661D4) ----------------------------------------------------
__int64 __fastcall BN_hex2bn(__int64 *a1, _BYTE *a2)
{
  signed __int64 v2; // x22
  __int64 *v3; // x19
  signed int v4; // w23
  int v5; // w26
  signed int v6; // w25
  unsigned __int8 *v7; // x21
  int v8; // t1
  int v9; // w0
  int v10; // w24
  unsigned int v11; // w20
  _DWORD *v12; // x21
  int v13; // w24
  __int64 v14; // x9
  signed __int64 v15; // x11
  signed int v16; // w12
  signed __int64 v17; // x13
  unsigned __int8 *v18; // x14
  __int64 v19; // x15
  signed __int64 v20; // x15
  int v21; // w13

  v2 = (signed __int64)a2;
  v3 = a1;
  if ( !a2 )
    return 0;
  v4 = 0;
  if ( *a2 )
  {
    if ( *a2 == 45 )
    {
      v2 = (signed __int64)(a2 + 1);
      v4 = 1;
    }
    v5 = 0;
    v6 = -4;
    v7 = (unsigned __int8 *)v2;
    do
    {
      v8 = *v7++;
      v9 = isxdigit(v8);
      v10 = v5 + 1;
      v6 += 4;
      if ( 0x7FFFFFFF - v4 == v5 )
        break;
      ++v5;
    }
    while ( v9 );
    v11 = v4 + v10 - 1;
    if ( v3 )
    {
      v12 = (_DWORD *)*v3;
      if ( *v3 )
      {
        BN_zero(*v3);
      }
      else
      {
        v12 = BN_new();
        if ( !v12 )
          return 0;
      }
      v13 = v10 - 1;
      if ( v13 >= 0x20000000 )
      {
        ERR_put_error(3, 0LL, 102, (__int64)"external/boringssl/src/crypto/bn/convert.c", 293);
        if ( !*v3 )
          goto LABEL_34;
        return 0;
      }
      if ( !sub_6534C((__int64)v12, v6) )
      {
        if ( !*v3 )
LABEL_34:
          BN_free(v12);
        return 0;
      }
      if ( v13 < 1 )
      {
        v21 = 0;
      }
      else
      {
        v14 = 0LL;
        do
        {
          v15 = 0LL;
          if ( v13 >= 16 )
            v16 = 16;
          else
            v16 = v13;
          v17 = v16 + 1;
          v18 = (unsigned __int8 *)(v2 + 1 + v13 - v17);
          do
          {
            v19 = *v18;
            --v17;
            if ( (unsigned int)(v19 - 48) > 9 )
            {
              if ( (((_DWORD)v19 - 97) & 0xFFu) > 5 )
              {
                if ( (unsigned int)(v19 - 65) > 5 )
                  v20 = 0LL;
                else
                  v20 = v19 - 55;
              }
              else
              {
                v20 = v19 - 87;
              }
            }
            else
            {
              v20 = v19 - 48;
            }
            v15 = v20 | 16 * v15;
            ++v18;
          }
          while ( v17 > 1 );
          v13 -= v16;
          v21 = v14 + 1;
          *(_QWORD *)(*(_QWORD *)v12 + 8 * v14++) = v15;
        }
        while ( v13 > 0 );
      }
      v12[2] = v21;
      bn_correct_top((__int64)v12);
      if ( !BN_is_zero((__int64)v12) )
        v12[4] = v4;
      *v3 = (__int64)v12;
    }
  }
  else
  {
    v11 = 0;
  }
  return v11;
}

//----- (00000000000663CC) ----------------------------------------------------
__int64 __fastcall BN_bn2dec(signed int *a1)
{
  signed int *v1; // x20
  signed int *v2; // x19
  __int64 result; // x0
  signed int *v4; // x0
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x8
  signed __int64 v7; // x9
  char v8; // w12
  _BOOL4 v9; // w21
  signed int v10; // w25
  _BOOL4 v11; // w9
  unsigned __int64 v12; // x22
  unsigned __int64 v13; // [xsp+8h] [xbp-78h]
  __int64 v14; // [xsp+10h] [xbp-70h]
  __int64 v15[4]; // [xsp+18h] [xbp-68h]
  __int64 v16; // [xsp+38h] [xbp-48h]

  v1 = a1;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBB_init(v15, 0x10uLL) || !(unsigned int)CBB_add_u8(v15, 0) )
  {
    v2 = 0LL;
LABEL_7:
    ERR_put_error(3, 0LL, 65, (__int64)"external/boringssl/src/crypto/bn/convert.c", 481);
LABEL_8:
    BN_free(v2);
    CBB_cleanup(v15);
    result = 0LL;
    goto LABEL_9;
  }
  if ( BN_is_zero((__int64)v1) )
  {
    v2 = 0LL;
    if ( !(unsigned int)CBB_add_u8(v15, 48) )
      goto LABEL_7;
  }
  else
  {
    v4 = BN_dup(v1);
    v2 = v4;
    if ( !v4 )
      goto LABEL_8;
    if ( !BN_is_zero((__int64)v4) )
    {
      while ( 1 )
      {
        v12 = BN_div_word((__int64)v2, 0x8AC7230489E80000LL);
        if ( v12 == -1LL )
          goto LABEL_8;
        v9 = BN_is_zero((__int64)v2);
        if ( !v9 || v12 )
        {
          v10 = 1;
          while ( (unsigned int)CBB_add_u8(
                                  v15,
                                  (v12
                                 - 10 * ((unsigned __int64)(v12 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL >> 64) >> 3)) | 0x30) )
          {
            v11 = v12 > 9;
            if ( v10 <= 18 )
            {
              ++v10;
              v12 = (unsigned __int64)(v12 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL >> 64) >> 3;
              if ( v9 == 0 || v11 )
                continue;
            }
            goto LABEL_23;
          }
          goto LABEL_7;
        }
LABEL_23:
        if ( BN_is_zero((__int64)v2) )
          break;
      }
    }
  }
  if ( BN_is_negative((__int64)v1) && !(unsigned int)CBB_add_u8(v15, 45)
    || !(unsigned int)CBB_finish((__int64)v15, &v14, &v13) )
  {
    goto LABEL_7;
  }
  v5 = v13;
  if ( v13 >= 2 )
  {
    v6 = 0LL;
    v7 = -1LL;
    do
    {
      v8 = *(_BYTE *)(v14 + v6);
      *(_BYTE *)(v14 + v6++) = *(_BYTE *)(v14 + v5 + v7);
      *(_BYTE *)(v14 + v13 + v7) = v8;
      v5 = v13;
      --v7;
    }
    while ( v6 < v13 >> 1 );
  }
  BN_free(v2);
  result = v14;
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v16;
  return result;
}

//----- (00000000000665EC) ----------------------------------------------------
__int64 __fastcall BN_dec2bn(__int64 *a1, _BYTE *a2)
{
  signed __int64 v2; // x21
  __int64 *v3; // x20
  signed __int64 v4; // x19
  __int64 v5; // x8
  signed __int64 v6; // x23
  int v7; // w10
  signed __int64 v8; // x24
  unsigned __int64 **v9; // x22
  signed __int64 v10; // x25
  __int64 v11; // x26
  __int64 v12; // x23
  int v13; // w8

  v2 = (signed __int64)a2;
  v3 = a1;
  if ( !a2 )
    goto LABEL_27;
  v4 = 0LL;
  if ( *a2 )
  {
    if ( *a2 == 45 )
    {
      v2 = (signed __int64)(a2 + 1);
      v4 = 1LL;
    }
    v5 = 0LL;
    do
    {
      v6 = v5 + 1;
      if ( !((_DWORD)v4 - 0x7FFFFFFF + (_DWORD)v5) )
        break;
      v7 = *(unsigned __int8 *)(v2 + v5++);
    }
    while ( (unsigned int)(v7 - 48) < 0xA );
    v8 = v4 + v6 - 1;
    if ( !a1 )
    {
      LODWORD(v4) = v4 + v6 - 1;
      return (unsigned int)v4;
    }
    v9 = (unsigned __int64 **)*a1;
    if ( *a1 )
    {
      BN_zero(*a1);
    }
    else
    {
      v9 = (unsigned __int64 **)BN_new();
      if ( !v9 )
        goto LABEL_27;
    }
    v10 = v6 - 1;
    if ( (signed int)v6 - 1 < 1 )
    {
LABEL_22:
      bn_correct_top((__int64)v9);
      if ( !BN_is_zero((__int64)v9) )
        *((_DWORD *)v9 + 4) = v4;
      *v3 = (__int64)v9;
      LODWORD(v4) = v8;
      return (unsigned int)v4;
    }
    v11 = 0LL;
    v12 = 0LL;
    if ( (_DWORD)v10 == 19
                      * ((unsigned int)(1808407283LL * (signed int)v10 >> 35)
                       + ((unsigned __int64)(1808407283LL * (signed int)v10) >> 63)) )
      v13 = 0;
    else
      v13 = 19
          - (v10
           - 19 * ((1808407283LL * (signed int)v10 >> 35) + ((unsigned __int64)(1808407283LL * (signed int)v10) >> 63)));
    while ( 1 )
    {
      ++v13;
      v12 = *(unsigned __int8 *)(v2 + v11) + 10 * v12 - 48;
      if ( v13 == 19 )
      {
        if ( !(unsigned int)BN_mul_word(v9, 0x8AC7230489E80000LL) || !(unsigned int)BN_add_word((__int64)v9, v12) )
        {
          if ( !*v3 )
            BN_free(v9);
LABEL_27:
          LODWORD(v4) = 0;
          return (unsigned int)v4;
        }
        v13 = 0;
        v12 = 0LL;
      }
      if ( ++v11 >= v10 )
        goto LABEL_22;
    }
  }
  return (unsigned int)v4;
}

//----- (0000000000066780) ----------------------------------------------------
__int64 __fastcall BN_asc2bn(__int64 *a1, _BYTE *a2)
{
  _BYTE *v2; // x20
  __int64 *v3; // x19
  __int64 result; // x0
  _BOOL4 v5; // w8

  v2 = a2;
  v3 = a1;
  if ( *a2 == 45 )
    ++a2;
  if ( *a2 != 48 || ((unsigned __int8)a2[1] | 0x20) != 120 )
  {
    result = BN_dec2bn(a1, a2);
    if ( !(_DWORD)result )
      return result;
  }
  else
  {
    result = BN_hex2bn(a1, a2 + 2);
    if ( !(_DWORD)result )
      return result;
  }
  if ( *v2 != 45 )
    return 1LL;
  v5 = BN_is_zero(*v3);
  result = 1LL;
  if ( !v5 )
    *(_DWORD *)(*v3 + 16) = 1;
  return result;
}

//----- (000000000006681C) ----------------------------------------------------
signed __int64 __fastcall BN_print(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x19
  _QWORD *v3; // x20
  signed __int64 v4; // x21
  signed int v5; // w23
  signed __int64 v6; // x24
  signed __int64 v7; // x25
  signed __int64 v8; // x8
  signed __int64 result; // x0

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a2 + 16) && (unsigned int)BIO_write(a1, (__int64)"-", 1u) != 1
    || BN_is_zero(v2) && (unsigned int)BIO_write(v3, (__int64)"0", 1u) != 1 )
  {
    return 0LL;
  }
  v4 = *(signed int *)(v2 + 8);
  if ( (signed int)v4 >= 1 )
  {
    v5 = 0;
LABEL_7:
    v6 = v4--;
    v7 = 60LL;
    while ( 1 )
    {
      v8 = (*(_QWORD *)(*(_QWORD *)v2 + 8 * v4) >> v7) & 0xFLL;
      if ( (unsigned int)v8 | v5 )
      {
        v5 = 1;
        if ( (unsigned int)BIO_write(v3, (__int64)&a0123456789abcd[v8], 1u) != 1 )
          return 0LL;
      }
      v7 -= 4LL;
      if ( v7 & 0x8000000000000000LL )
      {
        result = 1LL;
        if ( v6 >= 2 )
          goto LABEL_7;
        return result;
      }
    }
  }
  return 1LL;
}

//----- (000000000006691C) ----------------------------------------------------
__int64 __fastcall BN_print_fp(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x21
  void *v4; // x0
  _QWORD *v5; // x0
  _QWORD *v6; // x20
  unsigned int v7; // w19

  v2 = a2;
  v3 = a1;
  v4 = BIO_s_file();
  v5 = BIO_new((__int64)v4);
  v6 = v5;
  if ( !v5 )
    return 0LL;
  BIO_set_fp(v5, v3, 0);
  v7 = BN_print(v6, v2);
  BIO_free((__int64)v6);
  return v7;
}

//----- (0000000000066988) ----------------------------------------------------
signed __int64 __fastcall BN_get_word(_DWORD *a1)
{
  int v1; // w8

  v1 = a1[2];
  if ( !v1 )
    return 0LL;
  if ( v1 == 1 )
    return **(_QWORD **)a1;
  return -1LL;
}

//----- (00000000000669B4) ----------------------------------------------------
signed __int64 __fastcall BN_get_u64(__int64 **a1, _QWORD *a2)
{
  int v2; // w8
  __int64 v3; // x8
  signed __int64 result; // x0

  v2 = *((_DWORD *)a1 + 2);
  if ( !v2 )
  {
    v3 = 0LL;
    goto LABEL_5;
  }
  if ( v2 == 1 )
  {
    v3 = **a1;
LABEL_5:
    result = 1LL;
    *a2 = v3;
    return result;
  }
  return 0LL;
}

//----- (00000000000669E8) ----------------------------------------------------
signed __int64 __fastcall BN_bn2mpi(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // x19
  __int64 v3; // x20
  unsigned int v4; // w0
  unsigned __int64 v5; // x9
  __int64 v6; // x23
  unsigned __int64 v7; // x22
  signed __int64 v8; // x21
  unsigned int v9; // w0
  signed __int64 v10; // x9
  _BYTE *v11; // x8
  signed __int64 v12; // x10
  unsigned __int64 v13; // x12
  unsigned __int64 v14; // x11

  v2 = a2;
  v3 = a1;
  v4 = BN_num_bits(a1);
  v5 = ((unsigned __int64)v4 + 7) >> 3;
  v6 = ((v4 & 7) == 0LL) & (unsigned __int8)(v5 != 0);
  v7 = v6 + v5;
  v8 = v6 + v5 + 4;
  if ( v2 )
  {
    *v2 = BYTE3(v7);
    v2[1] = BYTE2(v7);
    v2[2] = BYTE1(v7);
    v2[3] = v7;
    if ( (v4 & 7) == 0LL && v5 != 0 )
      v2[4] = 0;
    v9 = BN_num_bytes(v3);
    if ( v9 )
    {
      v10 = v9 - 1LL;
      v11 = &v2[v6 + 4];
      v12 = 8LL * v9 - 8;
      do
      {
        v13 = v10-- & 0xFFFFFFFFFFFFFFF8LL;
        v14 = *(_QWORD *)(*(_QWORD *)v3 + v13);
        LOBYTE(v13) = v12 & 0x38;
        v12 -= 8LL;
        *v11++ = v14 >> v13;
      }
      while ( v10 != -1 );
    }
    if ( v7 && *(_DWORD *)(v3 + 16) )
      v2[4] |= 0x80u;
  }
  return v8;
}

//----- (0000000000066AD4) ----------------------------------------------------
_DWORD *__fastcall BN_mpi2bn(unsigned __int8 *a1, unsigned __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // x19
  unsigned __int8 *v4; // x20
  __int16 v5; // w4
  __int64 v6; // x21
  signed int v7; // w22
  unsigned __int8 *v9; // x20
  unsigned int v10; // w8
  int v11; // w0

  v3 = a3;
  v4 = a1;
  if ( a2 <= 3 )
  {
    v5 = 631;
LABEL_8:
    ERR_put_error(3, 0LL, 117, (__int64)"external/boringssl/src/crypto/bn/convert.c", v5);
    return 0LL;
  }
  v6 = ((*a1 << 24) & 0xFF00FFFF | (a1[1] << 16)) & 0xFFFF00FF | ((unsigned __int64)a1[2] << 8) | a1[3];
  if ( v6 != a2 - 4 )
  {
    v5 = 639;
    goto LABEL_8;
  }
  if ( a3 )
  {
    v7 = 0;
    if ( !v6 )
    {
LABEL_16:
      BN_zero((__int64)v3);
      return v3;
    }
  }
  else
  {
    v3 = BN_new();
    if ( !v3 )
    {
      ERR_put_error(3, 0LL, 65, (__int64)"external/boringssl/src/crypto/bn/convert.c", 647);
      return v3;
    }
    v7 = 1;
    if ( !v6 )
      goto LABEL_16;
  }
  v9 = v4 + 4;
  if ( !BN_bin2bn(v9, v6, (__int64)v3) )
  {
    if ( v7 )
      BN_free(v3);
    return 0LL;
  }
  v10 = (char)*v9;
  v3[4] = (v10 >> 7) & 1;
  if ( v10 & 0x80000000 )
  {
    v11 = BN_num_bits((__int64)v3);
    BN_clear_bit((__int64)v3, v11 - 1);
  }
  return v3;
}

//----- (0000000000066C0C) ----------------------------------------------------
_DWORD *BN_CTX_new()
{
  _DWORD *result; // x0

  result = malloc(0x40uLL);
  if ( result )
  {
    result[14] = 0;
    *((_QWORD *)result + 5) = 0LL;
    *((_QWORD *)result + 6) = 0LL;
    *((_QWORD *)result + 3) = 0LL;
    *((_QWORD *)result + 4) = 0LL;
    *((_QWORD *)result + 1) = 0LL;
    *((_QWORD *)result + 2) = 0LL;
    *(_QWORD *)result = 0LL;
  }
  else
  {
    ERR_put_error(3, 0LL, 65, (__int64)"external/boringssl/src/crypto/bn/ctx.c", 129);
    result = 0LL;
  }
  return result;
}

//----- (0000000000066C64) ----------------------------------------------------
void __fastcall BN_CTX_free(__int64 a1)
{
  void ***v1; // x19
  void **i; // x20
  void **v3; // x0

  v1 = (void ***)a1;
  if ( a1 )
  {
    free(*(void **)(a1 + 32));
    for ( i = *v1; i; *v1 = i )
    {
      if ( *i )
        BN_clear_free(i);
      if ( i[3] )
        BN_clear_free(i + 3);
      if ( i[6] )
        BN_clear_free(i + 6);
      if ( i[9] )
        BN_clear_free(i + 9);
      if ( i[12] )
        BN_clear_free(i + 12);
      if ( i[15] )
        BN_clear_free(i + 15);
      if ( i[18] )
        BN_clear_free(i + 18);
      if ( i[21] )
        BN_clear_free(i + 21);
      if ( i[24] )
        BN_clear_free(i + 24);
      if ( i[27] )
        BN_clear_free(i + 27);
      if ( i[30] )
        BN_clear_free(i + 30);
      if ( i[33] )
        BN_clear_free(i + 33);
      if ( i[36] )
        BN_clear_free(i + 36);
      if ( i[39] )
        BN_clear_free(i + 39);
      if ( i[42] )
        BN_clear_free(i + 42);
      if ( i[45] )
        BN_clear_free(i + 45);
      v3 = *v1;
      v1[1] = (void **)(*v1)[49];
      free(v3);
      i = v1[1];
    }
    free(v1);
  }
}

//----- (0000000000066DC0) ----------------------------------------------------
void __fastcall BN_CTX_start(__int64 a1)
{
  __int64 v1; // x19
  int v2; // w8
  __int64 v3; // x22
  int v4; // w21
  signed __int64 v5; // x23
  _DWORD *v6; // x0
  _DWORD *v7; // x20

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 )
    goto LABEL_4;
  if ( *(_DWORD *)(a1 + 56) )
  {
    v2 = 0;
LABEL_4:
    *(_DWORD *)(v1 + 52) = v2 + 1;
    return;
  }
  v3 = *(unsigned int *)(a1 + 40);
  v4 = *(_DWORD *)(a1 + 48);
  if ( (_DWORD)v3 == *(_DWORD *)(a1 + 44) )
  {
    if ( (_DWORD)v3 )
      v5 = (unsigned int)(3 * v3) >> 1;
    else
      v5 = 32LL;
    v6 = malloc(4 * v5);
    v7 = v6;
    if ( !v6 )
    {
      ERR_put_error(3, 0LL, 116, (__int64)"external/boringssl/src/crypto/bn/ctx.c", 158);
      v2 = *(_DWORD *)(v1 + 52);
      goto LABEL_4;
    }
    if ( (_DWORD)v3 )
      memcpy(v6, *(const void **)(v1 + 32), 4 * v3);
    free(*(void **)(v1 + 32));
    LODWORD(v3) = *(_DWORD *)(v1 + 40);
    *(_QWORD *)(v1 + 32) = v7;
    *(_DWORD *)(v1 + 44) = v5;
  }
  else
  {
    v7 = *(_DWORD **)(a1 + 32);
  }
  *(_DWORD *)(v1 + 40) = v3 + 1;
  v7[(unsigned int)v3] = v4;
}

//----- (0000000000066EA0) ----------------------------------------------------
_QWORD *__fastcall BN_CTX_get(__int64 a1)
{
  __int64 v1; // x19
  int v2; // w8
  _QWORD *v3; // x0
  _QWORD *v4; // x20
  __int64 v5; // x8
  _QWORD *v6; // x8
  __int64 v7; // x9
  _QWORD *v8; // x11
  __int64 v9; // x10
  __int64 *v10; // x9
  int v11; // w8

  v1 = a1;
  if ( *(_DWORD *)(a1 + 52) || *(_DWORD *)(a1 + 56) )
    return 0LL;
  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 == *(_DWORD *)(a1 + 28) )
  {
    v3 = malloc(0x190uLL);
    v4 = v3;
    if ( v3 )
    {
      BN_init(v3);
      BN_init(v4 + 3);
      BN_init(v4 + 6);
      BN_init(v4 + 9);
      BN_init(v4 + 12);
      BN_init(v4 + 15);
      BN_init(v4 + 18);
      BN_init(v4 + 21);
      BN_init(v4 + 24);
      BN_init(v4 + 27);
      BN_init(v4 + 30);
      BN_init(v4 + 33);
      BN_init(v4 + 36);
      BN_init(v4 + 39);
      BN_init(v4 + 42);
      BN_init(v4 + 45);
      v5 = *(_QWORD *)(v1 + 16);
      v4[48] = v5;
      v4[49] = 0LL;
      if ( *(_QWORD *)v1 )
      {
        *(_QWORD *)(v5 + 392) = v4;
        v6 = (_QWORD *)(v1 + 8);
        *(_QWORD *)(v1 + 16) = v4;
      }
      else
      {
        *(_QWORD *)(v1 + 8) = v4;
        *(_QWORD *)(v1 + 16) = v4;
        v6 = (_QWORD *)v1;
      }
      *v6 = v4;
      v11 = *(_DWORD *)(v1 + 28) + 16;
      ++*(_DWORD *)(v1 + 24);
      *(_DWORD *)(v1 + 28) = v11;
      if ( v4 )
        goto LABEL_16;
    }
    goto LABEL_17;
  }
  if ( v2 )
  {
    v8 = (_QWORD *)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 8);
    v9 = v2 & 0xF;
    if ( v2 & 0xF )
      goto LABEL_12;
    v10 = (__int64 *)(v7 + 392);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
    v10 = (__int64 *)a1;
  }
  v7 = *v10;
  v9 = 0LL;
  *v8 = v7;
LABEL_12:
  v4 = (_QWORD *)(v7 + 24 * v9);
  *(_DWORD *)(a1 + 24) = v2 + 1;
  if ( !v4 )
  {
LABEL_17:
    *(_DWORD *)(v1 + 56) = 1;
    ERR_put_error(3, 0LL, 116, (__int64)"external/boringssl/src/crypto/bn/ctx.c", 174);
    return 0LL;
  }
LABEL_16:
  BN_zero((__int64)v4);
  ++*(_DWORD *)(v1 + 48);
  return v4;
}

//----- (0000000000067078) ----------------------------------------------------
__int64 __fastcall BN_CTX_end(__int64 result)
{
  int v1; // w8
  __int64 v2; // x9
  unsigned int v3; // w8
  unsigned int v4; // w8
  unsigned int v5; // w9
  int v6; // w11
  int v7; // w10
  int v8; // w9

  v1 = *(_DWORD *)(result + 52);
  if ( v1 )
  {
    *(_DWORD *)(result + 52) = v1 - 1;
  }
  else
  {
    v2 = *(_QWORD *)(result + 32);
    v3 = *(_DWORD *)(result + 40) - 1;
    *(_DWORD *)(result + 40) = v3;
    v4 = *(_DWORD *)(v2 + 4LL * v3);
    v5 = *(_DWORD *)(result + 48);
    if ( v5 > v4 )
    {
      v6 = *(_DWORD *)(result + 24);
      *(_DWORD *)(result + 24) = v6 - (v5 - v4);
      if ( v5 != v4 )
      {
        v7 = (v6 + 15) & 0xF;
        v8 = v4 - v5;
        do
        {
          while ( v7 )
          {
            --v7;
            if ( !++v8 )
              goto LABEL_10;
          }
          *(_QWORD *)(result + 8) = *(_QWORD *)(*(_QWORD *)(result + 8) + 384LL);
          v7 = 15;
          ++v8;
        }
        while ( v8 );
      }
    }
LABEL_10:
    *(_DWORD *)(result + 48) = v4;
    *(_DWORD *)(result + 56) = 0;
  }
  return result;
}

//----- (0000000000067100) ----------------------------------------------------
signed __int64 __fastcall BN_div(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x22
  int v6; // w8
  __int64 v7; // x19
  __int64 v8; // x26
  __int64 v9; // x25
  _QWORD *v10; // x20
  unsigned __int8 v11; // vf
  int v12; // w8
  int v13; // w8
  int v14; // w8
  int v15; // w2
  __int16 v16; // w4
  _QWORD *v17; // x21
  _QWORD *v18; // x9
  _QWORD *v19; // x0
  unsigned int v20; // w27
  __int64 v21; // x8
  __int64 v22; // x9
  __int64 v23; // x0
  __int64 v24; // x11
  _QWORD *v25; // x10
  signed __int64 v26; // x20
  __int64 v27; // x0
  signed __int64 v28; // x8
  __int64 v29; // x21
  signed int v30; // w27
  signed __int64 v31; // x8
  unsigned __int64 v32; // x24
  unsigned __int64 v33; // x28
  __int64 v34; // x23
  unsigned __int64 *v35; // x25
  int v36; // w23
  unsigned __int64 *v37; // x26
  unsigned __int64 *v38; // x21
  unsigned __int64 **v39; // x14
  unsigned __int64 v40; // x27
  __int64 v41; // x20
  unsigned __int64 v42; // x0
  unsigned __int64 v43; // x9
  unsigned __int64 v44; // x10
  unsigned __int64 v45; // x8
  unsigned __int64 v46; // x11
  bool v47; // w12
  unsigned __int64 v48; // kr00_8
  unsigned __int8 v49; // cf
  bool v50; // w12
  unsigned __int64 v51; // x19
  unsigned __int64 **v52; // x24
  int v53; // w20
  __int64 v55; // [xsp+0h] [xbp-B0h]
  unsigned int v56; // [xsp+Ch] [xbp-A4h]
  unsigned __int64 v57; // [xsp+18h] [xbp-98h]
  __int64 v58; // [xsp+20h] [xbp-90h]
  int v59; // [xsp+2Ch] [xbp-84h]
  __int64 v60; // [xsp+38h] [xbp-78h]
  __int64 v61; // [xsp+40h] [xbp-70h]
  __int64 v62; // [xsp+48h] [xbp-68h]
  unsigned __int64 **v63; // [xsp+50h] [xbp-60h]
  __int64 v64; // [xsp+58h] [xbp-58h]

  v5 = a3;
  v6 = *(_DWORD *)(a3 + 8);
  v7 = a5;
  v8 = a4;
  v9 = a2;
  v10 = a1;
  v11 = __OFSUB__(v6, 1);
  v12 = v6 - 1;
  if ( !((v12 < 0) ^ v11) && !*(_QWORD *)(*(_QWORD *)a3 + 8LL * v12)
    || (v13 = *(_DWORD *)(a4 + 8), v11 = __OFSUB__(v13, 1), v14 = v13 - 1, !((v14 < 0) ^ v11))
    && !*(_QWORD *)(*(_QWORD *)a4 + 8LL * v14) )
  {
    v15 = 111;
    v16 = 204;
    goto LABEL_8;
  }
  if ( !BN_is_zero(a4) )
  {
    BN_CTX_start(v7);
    v63 = (unsigned __int64 **)BN_CTX_get(v7);
    v17 = BN_CTX_get(v7);
    v18 = BN_CTX_get(v7);
    v64 = (__int64)v18;
    if ( !v10 )
    {
      v19 = BN_CTX_get(v7);
      v18 = (_QWORD *)v64;
      v10 = v19;
    }
    v61 = (__int64)v17;
    v62 = (__int64)v10;
    if ( !v17 )
      goto LABEL_54;
    if ( !v63 )
      goto LABEL_54;
    if ( !v18 )
      goto LABEL_54;
    if ( !v10 )
      goto LABEL_54;
    v20 = 64 - (BN_num_bits(v8) & 0x3F);
    if ( !(unsigned int)BN_lshift(v64, (__int64 *)v8, v20) )
      goto LABEL_54;
    *(_DWORD *)(v64 + 16) = 0;
    v56 = v20 + 64;
    if ( !(unsigned int)BN_lshift((__int64)v17, (__int64 *)v5, v20 + 64) )
      goto LABEL_54;
    *((_DWORD *)v17 + 4) = 0;
    v21 = *(signed int *)(v64 + 8);
    v22 = *((signed int *)v17 + 2);
    if ( (signed int)v22 <= (signed int)v21 + 1 )
    {
      v27 = bn_wexpand((__int64)v17, v21 + 2);
      v24 = v64;
      if ( !v27 )
        goto LABEL_54;
      v25 = v17;
      v28 = *((signed int *)v17 + 2);
      LODWORD(v26) = *(_DWORD *)(v64 + 8) + 2;
      if ( (signed int)v28 < (signed int)v26 )
      {
        do
        {
          *(_QWORD *)(*v17 + 8 * v28++) = 0LL;
          v26 = *(signed int *)(v64 + 8) + 2LL;
        }
        while ( v28 < v26 );
      }
    }
    else
    {
      v23 = bn_wexpand((__int64)v17, v22 + 1);
      v24 = v64;
      if ( !v23 )
        goto LABEL_54;
      v25 = v17;
      *(_QWORD *)(*v17 + 8LL * *((signed int *)v17 + 2)) = 0LL;
      LODWORD(v26) = *((_DWORD *)v17 + 2) + 1;
    }
    *((_DWORD *)v25 + 2) = v26;
    v60 = *(signed int *)(v24 + 8);
    v29 = *v25;
    v30 = v26 - v60;
    v31 = *(_QWORD *)v24 + 8 * v60;
    v32 = *(_QWORD *)(v31 - 8);
    if ( (_DWORD)v60 == 1 )
      v33 = 0LL;
    else
      v33 = *(_QWORD *)(v31 - 16);
    *(_DWORD *)(v62 + 16) = *(_DWORD *)(v8 + 16) ^ *(_DWORD *)(v5 + 16);
    if ( !bn_wexpand(v62, v30 + 1) )
      goto LABEL_54;
    *(_DWORD *)(v62 + 8) = v30 - 1;
    v34 = *(_QWORD *)v62;
    if ( !bn_wexpand((__int64)v63, v60 + 1) )
      goto LABEL_54;
    v55 = v9;
    v35 = (unsigned __int64 *)(v34 + 8LL * (v30 - 1));
    v59 = v30 - 1;
    if ( *(_DWORD *)(v62 + 8) )
    {
      --v35;
      if ( v30 < 2 )
        goto LABEL_49;
    }
    else
    {
      *(_DWORD *)(v62 + 16) = 0;
      if ( v30 < 2 )
      {
LABEL_49:
        bn_correct_top(v61);
        if ( !v55 )
        {
LABEL_53:
          bn_correct_top(v62);
          BN_CTX_end(v7);
          return 1LL;
        }
        v53 = *(_DWORD *)(v5 + 16);
        if ( (unsigned int)BN_rshift(v55, v61, v56) )
        {
          if ( !BN_is_zero(v55) )
            *(_DWORD *)(v55 + 16) = v53;
          goto LABEL_53;
        }
LABEL_54:
        BN_CTX_end(v7);
        return 0LL;
      }
    }
    v36 = 0;
    v37 = (unsigned __int64 *)(v29 + 8LL * v30);
    v38 = (unsigned __int64 *)(v29 + 8LL * ((signed int)v26 - 1));
    v57 = v33;
    v58 = v7;
    do
    {
      if ( *v38 == v32 )
      {
        v39 = (unsigned __int64 **)v64;
        v40 = -1LL;
      }
      else
      {
        v41 = *(v38 - 1);
        v42 = _udivti3(*(v38 - 1), *v38, v32, 0LL);
        v43 = *(v38 - 2);
        v40 = v42;
        v44 = v42 * v33;
        v45 = v41 - v42 * v32;
        v46 = v33 * (unsigned __int128)v42 >> 64;
        v47 = v42 * v33 <= v43;
        if ( v46 != v45 )
          v47 = v46 <= v45;
        if ( v47 )
        {
          v39 = (unsigned __int64 **)v64;
        }
        else
        {
          v39 = (unsigned __int64 **)v64;
          do
          {
            v48 = v44 - v33;
            v46 = (__PAIR__(v46, v44) - v33) >> 64;
            v44 -= v33;
            --v40;
            v49 = __CFADD__(v45, v32);
            v45 += v32;
            if ( v49 )
              break;
            v50 = v48 <= v43;
            if ( v46 != v45 )
              v50 = v46 <= v45;
          }
          while ( !v50 );
        }
      }
      v51 = v32;
      v52 = v39;
      --v37;
      (*v63)[v60] = sub_6A220(*v63, *v39, v60, v40);
      if ( sub_6A564((__int64 *)v37, v37, *v63, (signed int)v60 + 1) )
      {
        --v40;
        if ( sub_6A448(v37, v37, *v52, v60) )
          ++*v38;
      }
      v32 = v51;
      v33 = v57;
      v7 = v58;
      *v35 = v40;
      --v35;
      ++v36;
      --v38;
    }
    while ( v36 < v59 );
    goto LABEL_49;
  }
  v15 = 105;
  v16 = 209;
LABEL_8:
  ERR_put_error(3, 0LL, v15, (__int64)"external/boringssl/src/crypto/bn/div.c", v16);
  return 0LL;
}

//----- (0000000000067554) ----------------------------------------------------
signed __int64 __fastcall BN_nnmod(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  signed __int64 result; // x0
  __int64 (__fastcall *v7)(__int64, __int64, __int64); // x3

  v4 = a3;
  v5 = a1;
  result = BN_div(0LL, a1, a2, a3, a4);
  if ( (_DWORD)result )
  {
    if ( *(_DWORD *)(v5 + 16) )
    {
      if ( *(_DWORD *)(v4 + 16) )
        v7 = BN_sub;
      else
        v7 = BN_add;
      result = v7(v5, v5, v4);
    }
    else
    {
      result = 1LL;
    }
  }
  return result;
}

//----- (00000000000675D8) ----------------------------------------------------
__int64 __fastcall BN_mod_add(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x21
  __int64 v6; // x19
  __int64 v7; // x20
  __int64 result; // x0
  __int64 (__fastcall *v9)(__int64, __int64, __int64); // x3

  v5 = a5;
  v6 = a4;
  v7 = a1;
  result = BN_add(a1, a2, a3);
  if ( (_DWORD)result )
  {
    result = BN_div(0LL, v7, v7, v6, v5);
    if ( (_DWORD)result )
    {
      if ( *(_DWORD *)(v7 + 16) )
      {
        if ( *(_DWORD *)(v6 + 16) )
          v9 = BN_sub;
        else
          v9 = BN_add;
        result = v9(v7, v7, v6);
      }
      else
      {
        result = 1LL;
      }
    }
  }
  return result;
}

//----- (000000000006766C) ----------------------------------------------------
__int64 __fastcall BN_mod_add_quick(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  __int64 result; // x0

  v4 = a4;
  v5 = a1;
  result = BN_uadd(a1, a2, a3);
  if ( (_DWORD)result )
  {
    if ( BN_ucmp(v5, v4) & 0x80000000 )
      result = 1LL;
    else
      result = BN_usub(v5, v5, v4);
  }
  return result;
}

//----- (00000000000676C0) ----------------------------------------------------
__int64 __fastcall BN_mod_sub(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x21
  __int64 v6; // x19
  __int64 v7; // x20
  __int64 result; // x0
  __int64 (__fastcall *v9)(__int64, __int64, __int64); // x3

  v5 = a5;
  v6 = a4;
  v7 = a1;
  result = BN_sub(a1, a2, a3);
  if ( (_DWORD)result )
  {
    result = BN_div(0LL, v7, v7, v6, v5);
    if ( (_DWORD)result )
    {
      if ( *(_DWORD *)(v7 + 16) )
      {
        if ( *(_DWORD *)(v6 + 16) )
          v9 = BN_sub;
        else
          v9 = BN_add;
        result = v9(v7, v7, v6);
      }
      else
      {
        result = 1LL;
      }
    }
  }
  return result;
}

//----- (0000000000067754) ----------------------------------------------------
__int64 __fastcall BN_mod_sub_quick(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  __int64 result; // x0

  v4 = a4;
  v5 = a1;
  result = BN_sub(a1, a2, a3);
  if ( (_DWORD)result )
  {
    if ( *(_DWORD *)(v5 + 16) )
      result = BN_add(v5, v5, v4);
    else
      result = 1LL;
  }
  return result;
}

//----- (00000000000677A0) ----------------------------------------------------
__int64 __fastcall BN_mod_mul(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x19
  __int64 v6; // x21
  __int64 v7; // x20
  __int64 v8; // x24
  __int64 v9; // x23
  _QWORD *v10; // x0
  __int64 v11; // x22
  _BOOL4 v12; // w20
  __int64 (__fastcall *v13)(__int64, __int64, __int64); // x8

  v5 = a5;
  v6 = a1;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  BN_CTX_start(a5);
  v10 = BN_CTX_get(v5);
  v11 = (__int64)v10;
  if ( !v10 )
    goto LABEL_4;
  if ( v9 == v8 )
  {
    if ( !(unsigned int)BN_sqr((__int64)v10, v9, v5) )
    {
LABEL_12:
      v12 = 0;
      goto LABEL_14;
    }
  }
  else if ( !(unsigned int)BN_mul((__int64)v10, v9, v8, v5) )
  {
LABEL_4:
    v12 = 0;
    goto LABEL_14;
  }
  if ( !(unsigned int)BN_div(0LL, v6, v11, v7, v5) )
    goto LABEL_12;
  if ( *(_DWORD *)(v6 + 16) )
  {
    if ( *(_DWORD *)(v7 + 16) )
      v13 = BN_sub;
    else
      v13 = BN_add;
    v12 = (unsigned __int64)v13(v6, v6, v7) != 0;
  }
  else
  {
    v12 = 1;
  }
LABEL_14:
  BN_CTX_end(v5);
  return (unsigned int)v12;
}

//----- (000000000006789C) ----------------------------------------------------
__int64 __fastcall BN_mod_sqr(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  __int64 v6; // x21
  __int64 result; // x0

  v4 = a4;
  v5 = a3;
  v6 = a1;
  result = BN_sqr(a1, a2, a4);
  if ( (_DWORD)result )
    result = BN_div(0LL, v6, v6, v5, v4);
  return result;
}

//----- (00000000000678F8) ----------------------------------------------------
__int64 __fastcall BN_mod_lshift(__int64 a1, __int64 a2, signed int a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x20
  signed int v6; // w19
  signed int *v7; // x21
  __int64 (__fastcall *v8)(__int64, __int64, __int64); // x8
  signed int *v9; // x0
  signed int *v10; // x22
  __int64 v12; // x3
  unsigned int v13; // w19

  v5 = a1;
  v6 = a3;
  v7 = (signed int *)a4;
  if ( !(unsigned int)BN_div(0LL, a1, a2, a4, a5) )
    return 0LL;
  if ( *(_DWORD *)(v5 + 16) )
  {
    v8 = v7[4] ? BN_sub : BN_add;
    if ( !(unsigned int)v8(v5, v5, (__int64)v7) )
      return 0LL;
  }
  if ( !v7[4] )
  {
    v10 = 0LL;
    goto LABEL_12;
  }
  v9 = BN_dup(v7);
  v10 = v9;
  if ( !v9 )
    return 0LL;
  v9[4] = 0;
LABEL_12:
  if ( v10 )
    v12 = (__int64)v10;
  else
    v12 = (__int64)v7;
  v13 = BN_mod_lshift_quick(v5, v5, v6, v12);
  BN_free(v10);
  return v13;
}

//----- (00000000000679C8) ----------------------------------------------------
__int64 __fastcall BN_mod_lshift_quick(__int64 a1, __int64 a2, signed int a3, __int64 a4)
{
  __int64 v4; // x19
  signed int v5; // w20
  __int64 *v6; // x21
  __int64 result; // x0
  int v8; // w22
  signed int v9; // w8
  unsigned int v10; // w22

  v4 = a4;
  v5 = a3;
  v6 = (__int64 *)a1;
  if ( a1 == a2 || (result = BN_copy(a1, a2)) != 0 )
  {
    if ( v5 < 1 )
    {
LABEL_16:
      result = 1LL;
    }
    else
    {
      while ( 1 )
      {
        v8 = BN_num_bits(v4);
        v9 = v8 - (unsigned __int64)BN_num_bits((__int64)v6);
        if ( v9 & 0x80000000 )
          break;
        if ( v9 <= v5 )
          v10 = v9;
        else
          v10 = v5;
        if ( v10 )
        {
          result = BN_lshift((__int64)v6, v6, v10);
          if ( !(_DWORD)result )
            return result;
          v5 -= v10;
        }
        else
        {
          result = BN_lshift1((__int64)v6, (__int64)v6);
          if ( !(_DWORD)result )
            return result;
          --v5;
        }
        if ( !(BN_cmp((__int64)v6, v4) & 0x80000000) )
        {
          result = BN_sub((__int64)v6, (__int64)v6, v4);
          if ( !(_DWORD)result )
            return result;
        }
        if ( v5 <= 0 )
          goto LABEL_16;
      }
      ERR_put_error(3, 0LL, 107, (__int64)"external/boringssl/src/crypto/bn/div.c", 520);
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000067AB4) ----------------------------------------------------
__int64 __fastcall BN_mod_lshift1(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x21
  __int64 v5; // x19
  __int64 v6; // x20
  __int64 result; // x0
  __int64 (__fastcall *v8)(__int64, __int64, __int64); // x3

  v4 = a4;
  v5 = a3;
  v6 = a1;
  result = BN_lshift1(a1, a2);
  if ( (_DWORD)result )
  {
    result = BN_div(0LL, v6, v6, v5, v4);
    if ( (_DWORD)result )
    {
      if ( *(_DWORD *)(v6 + 16) )
      {
        if ( *(_DWORD *)(v5 + 16) )
          v8 = BN_sub;
        else
          v8 = BN_add;
        result = v8(v6, v6, v5);
      }
      else
      {
        result = 1LL;
      }
    }
  }
  return result;
}

//----- (0000000000067B48) ----------------------------------------------------
__int64 __fastcall BN_mod_lshift1_quick(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 result; // x0

  v3 = a3;
  v4 = a1;
  result = BN_lshift1(a1, a2);
  if ( (_DWORD)result )
  {
    if ( BN_cmp(v4, v3) & 0x80000000 )
      result = 1LL;
    else
      result = BN_sub(v4, v4, v3);
  }
  return result;
}

//----- (0000000000067B9C) ----------------------------------------------------
signed __int64 __fastcall BN_div_word(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x21
  __int64 v3; // x19
  unsigned int v4; // w20
  int v5; // w8
  unsigned __int64 v6; // x1
  unsigned __int64 v7; // x21
  signed __int64 v8; // x23
  __int64 v9; // x24
  signed __int64 v10; // x25
  __int64 v11; // x22
  unsigned __int64 v12; // x0
  signed __int64 v13; // x8
  int v14; // w9

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    return -1LL;
  if ( !*(_DWORD *)(a1 + 8) )
    return 0LL;
  v4 = 64 - (unsigned __int64)BN_num_bits_word(a2);
  if ( !(unsigned int)BN_lshift(v3, (__int64 *)v3, v4) )
    return -1LL;
  v5 = *(_DWORD *)(v3 + 8);
  if ( v5 < 1 )
  {
    v6 = 0LL;
  }
  else
  {
    v6 = 0LL;
    v7 = v2 << v4;
    v8 = v5 - 1LL;
    do
    {
      v9 = *(_QWORD *)v3;
      v10 = 8 * v8;
      v11 = *(_QWORD *)(*(_QWORD *)v3 + 8 * v8);
      v12 = _udivti3(*(_QWORD *)(*(_QWORD *)v3 + 8 * v8), v6, v7, 0LL);
      v6 = v11 - v12 * v7;
      v13 = v8-- + 1;
      *(_QWORD *)(v9 + v10) = v12;
    }
    while ( v13 > 1 );
    v5 = *(_DWORD *)(v3 + 8);
    v14 = v5 - 1;
    if ( v5 >= 1 )
    {
      if ( *(_QWORD *)(*(_QWORD *)v3 + 8LL * v14) )
        return v6 >> v4;
      *(_DWORD *)(v3 + 8) = v14;
      if ( v5 != 1 )
        return v6 >> v4;
      goto LABEL_16;
    }
  }
  if ( !v5 )
LABEL_16:
    *(_DWORD *)(v3 + 16) = 0;
  return v6 >> v4;
}

//----- (0000000000067CA4) ----------------------------------------------------
signed __int64 __fastcall BN_mod_word(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x19
  __int64 v3; // x9
  __int64 v4; // x20
  unsigned __int64 v5; // x8
  signed __int64 v6; // x21
  signed __int64 v7; // x9

  v2 = a2;
  if ( !a2 )
    return -1LL;
  v3 = *((signed int *)a1 + 2);
  if ( (signed int)v3 < 1 )
    return 0LL;
  v4 = *a1;
  v5 = 0LL;
  v6 = v3 - 1;
  do
  {
    v5 = _umodti3(*(_QWORD *)(v4 + 8 * v6), v5, v2, 0LL);
    v7 = v6-- + 1;
  }
  while ( v7 > 1 );
  return v5;
}

//----- (0000000000067D20) ----------------------------------------------------
__int64 __fastcall BN_mod_pow2(__int64 a1, __int64 a2, __int64 a3)
{
  char v3; // w22
  __int64 v4; // x20
  __int64 v5; // x19
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x23
  signed __int64 v8; // x21
  __int64 result; // x0
  int v10; // w8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a3 || (v6 = *(signed int *)(a2 + 8), !(_DWORD)v6) )
  {
    BN_zero(a1);
    return 1LL;
  }
  v7 = (unsigned __int64)(a3 - 1) >> 6;
  v8 = v7 + 1;
  if ( v6 < v7 + 1 )
    return BN_copy(a1, a2) != 0;
  result = bn_wexpand(a1, v7 + 1);
  if ( result )
  {
    memcpy(*(void **)v5, *(const void **)v4, 8 * v8);
    if ( v3 & 0x3F )
      *(_QWORD *)(*(_QWORD *)v5 + 8 * v7) &= (1LL << (v3 & 0x3F)) - 1;
    v10 = *(_DWORD *)(v4 + 16);
    *(_DWORD *)(v5 + 8) = v8;
    *(_DWORD *)(v5 + 16) = v10;
    bn_correct_top(v5);
    return 1LL;
  }
  return result;
}

//----- (0000000000067DF8) ----------------------------------------------------
__int64 __fastcall BN_nnmod_pow2(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  __int64 v4; // x19
  __int64 result; // x0
  signed __int64 v6; // x21
  __int64 v7; // x9
  signed __int64 v8; // x8
  signed __int64 v9; // x10
  void **v10; // x2

  v3 = a3;
  v4 = a1;
  result = BN_mod_pow2(a1, a2, a3);
  if ( (_DWORD)result )
  {
    if ( BN_is_zero(v4) || !*(_DWORD *)(v4 + 16) )
    {
      result = 1LL;
    }
    else
    {
      v6 = ((unsigned __int64)(v3 - 1) >> 6) + 1;
      result = bn_wexpand(v4, v6);
      if ( result )
      {
        v7 = *(signed int *)(v4 + 8);
        if ( v6 != v7 )
          memset((void *)(*(_QWORD *)v4 + 8 * v7), 0, 8 * (v6 - v7));
        *(_DWORD *)(v4 + 16) = 0;
        *(_DWORD *)(v4 + 8) = v6;
        if ( (signed int)v6 >= 1 )
        {
          v8 = 0LL;
          do
          {
            v9 = 8 * v8++;
            *(_QWORD *)(*(_QWORD *)v4 + v9) = ~*(_QWORD *)(*(_QWORD *)v4 + v9);
            v6 = *(signed int *)(v4 + 8);
          }
          while ( v8 < v6 );
        }
        if ( v3 & 0x3F )
          *(_QWORD *)(*(_QWORD *)v4 + ((signed __int64)((unsigned __int64)(unsigned int)(v6 - 1) << 32) >> 29)) &= (1LL << (v3 & 0x3F)) - 1;
        bn_correct_top(v4);
        v10 = BN_value_one();
        result = BN_add(v4, v4, (__int64)v10);
      }
    }
  }
  return result;
}

//----- (0000000000067F08) ----------------------------------------------------
__int64 __fastcall BN_exp(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  __int64 v6; // x21
  __int64 v7; // x25
  _QWORD *v8; // x22
  _QWORD *v9; // x0
  __int64 v10; // x23
  unsigned int v11; // w24
  signed int v12; // w24
  unsigned int v13; // w25

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  BN_CTX_start(a4);
  if ( v5 == v7 || (v8 = (_QWORD *)v5, v5 == v6) )
    v8 = BN_CTX_get(v4);
  v9 = BN_CTX_get(v4);
  v10 = (__int64)v9;
  v11 = 0;
  if ( v8 && v9 )
  {
    if ( BN_copy((__int64)v9, v7) )
    {
      v12 = BN_num_bits(v6);
      if ( (unsigned int)BN_is_odd(v6) )
      {
        if ( !BN_copy((__int64)v8, v7) )
          goto LABEL_20;
      }
      else if ( !(unsigned int)BN_one((__int64)v8) )
      {
        goto LABEL_20;
      }
      if ( v12 >= 2 )
      {
        v13 = 1;
        while ( (unsigned int)BN_sqr(v10, v10, v4)
             && (!(unsigned int)BN_is_bit_set(v6, v13) || (unsigned int)BN_mul((__int64)v8, (__int64)v8, v10, v4)) )
        {
          if ( (signed int)++v13 >= v12 )
            goto LABEL_17;
        }
        goto LABEL_20;
      }
LABEL_17:
      if ( v8 == (_QWORD *)v5 || BN_copy(v5, (__int64)v8) )
      {
        v11 = 1;
        goto LABEL_21;
      }
    }
LABEL_20:
    v11 = 0;
  }
LABEL_21:
  BN_CTX_end(v4);
  return v11;
}

//----- (0000000000068054) ----------------------------------------------------
void __fastcall BN_mod_exp(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x26
  _QWORD *v6; // x21
  __int64 v7; // x19
  __int64 v8; // x22
  __int64 v9; // x27
  signed int v10; // w23
  _QWORD *v11; // x24
  _QWORD *v12; // x0
  __int64 v13; // x25
  __int64 v14; // x0
  signed int v15; // w26
  signed int v16; // w8
  __int64 v17; // x25
  signed __int64 v18; // x27
  _QWORD *v19; // x0
  signed __int64 v20; // x8
  signed int v21; // w23
  signed int v22; // w24
  signed int v23; // w28
  unsigned int v24; // w24
  int v25; // w27
  signed int v26; // w25
  bool v27; // zf
  char v28; // w8
  int v29; // w8
  signed int v30; // w24
  signed int v31; // [xsp+14h] [xbp-19Ch]
  _QWORD v32[6]; // [xsp+18h] [xbp-198h]
  __int64 v33; // [xsp+30h] [xbp-180h]
  __int64 v34; // [xsp+48h] [xbp-168h]
  int v35; // [xsp+50h] [xbp-160h]
  __int64 v36[32]; // [xsp+58h] [xbp-158h]
  __int64 v37; // [xsp+158h] [xbp-58h]

  v5 = a4;
  v6 = a1;
  v7 = a5;
  v8 = a3;
  v9 = a2;
  v37 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)BN_is_odd(a4) )
  {
    BN_mod_exp_mont((__int64)v6, v9, v8, v5, v7, 0LL);
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v37;
    return;
  }
  v10 = BN_num_bits(v8);
  if ( !v10 )
  {
    if ( BN_is_one(v5) )
      BN_zero((__int64)v6);
    else
      BN_one((__int64)v6);
    goto LABEL_21;
  }
  BN_CTX_start(v7);
  v11 = BN_CTX_get(v7);
  v12 = BN_CTX_get(v7);
  v13 = (__int64)v12;
  v36[0] = (__int64)v12;
  if ( !v11 || !v12 )
    goto LABEL_20;
  BN_init(v32);
  BN_init(&v33);
  v34 = 0LL;
  v35 = 0;
  if ( *(_DWORD *)(v5 + 16) )
  {
    if ( !BN_copy((__int64)v11, v5) )
      goto LABEL_20;
    *((_DWORD *)v11 + 4) = 0;
    if ( !BN_copy((__int64)v32, (__int64)v11) )
      goto LABEL_20;
    BN_zero((__int64)&v33);
    v14 = (__int64)v11;
  }
  else
  {
    if ( !BN_copy((__int64)v32, v5) )
      goto LABEL_20;
    BN_zero((__int64)&v33);
    v14 = v5;
  }
  v34 = (unsigned int)BN_num_bits(v14);
  if ( !(unsigned int)BN_nnmod(v13, v9, v5, v7) )
    goto LABEL_20;
  if ( BN_is_zero(v13) )
  {
    BN_zero((__int64)v6);
    goto LABEL_20;
  }
  if ( v10 > 671 )
  {
    v15 = 6;
    goto LABEL_31;
  }
  if ( v10 > 239 )
  {
    v15 = 5;
    goto LABEL_31;
  }
  if ( v10 > 79 )
  {
    v15 = 4;
    goto LABEL_31;
  }
  if ( v10 >= 24 )
  {
    v15 = 3;
LABEL_31:
    if ( !(unsigned int)sub_69364(v11, v13, v13, (__int64)v32, v7) )
      goto LABEL_20;
    v16 = 1 << (v15 - 1);
    if ( v16 >= 2 )
    {
      v17 = 0LL;
      v18 = v16;
      do
      {
        v19 = BN_CTX_get(v7);
        v36[v17 + 1] = (__int64)v19;
        if ( !v19 || !(unsigned int)sub_69364(v19, v36[v17], (__int64)v11, (__int64)v32, v7) )
          goto LABEL_20;
        v20 = v17++ + 2;
      }
      while ( v20 < v18 );
    }
    goto LABEL_40;
  }
  v15 = 1;
LABEL_40:
  if ( !(unsigned int)BN_one((__int64)v6) )
    goto LABEL_20;
  v21 = v10 - 1;
  v22 = 1;
  do
  {
    do
    {
      while ( !(unsigned int)BN_is_bit_set(v8, v21) )
      {
        if ( !v22 && !(unsigned int)sub_69364(v6, (__int64)v6, (__int64)v6, (__int64)v32, v7) )
          goto LABEL_20;
        v27 = v21 == 0;
        if ( v21 )
          --v21;
        else
          v21 = 0;
        if ( v27 )
          v28 = 6;
        else
          v28 = 7;
        v29 = v28 & 7;
        if ( v29 )
          goto LABEL_68;
      }
      v31 = v22;
      if ( v15 < 2 )
      {
        v23 = 0;
        v25 = 1;
      }
      else
      {
        v23 = 0;
        v24 = v21 - 1;
        v25 = 1;
        v26 = 1;
        do
        {
          if ( v24 & 0x80000000 )
            break;
          if ( (unsigned int)BN_is_bit_set(v8, v24) )
          {
            v25 = (v25 << (v26 - v23)) | 1;
            v23 = v26;
          }
          ++v26;
          --v24;
        }
        while ( v26 < v15 );
      }
      if ( !v31 && !(v23 & 0x80000000) )
      {
        v30 = -1;
        while ( (unsigned int)sub_69364(v6, (__int64)v6, (__int64)v6, (__int64)v32, v7) )
        {
          if ( ++v30 >= v23 )
            goto LABEL_66;
        }
        goto LABEL_20;
      }
LABEL_66:
      if ( !(unsigned int)sub_69364(v6, (__int64)v6, v36[v25 >> 1], (__int64)v32, v7) )
        goto LABEL_20;
      v21 = v21 - 1 - v23;
      v22 = 0;
      v29 = (v21 >> 31) & 6;
    }
    while ( !v29 );
LABEL_68:
    ;
  }
  while ( v29 == 7 );
  if ( v29 != 6 )
    goto LABEL_21;
LABEL_20:
  BN_CTX_end(v7);
  BN_free(v32);
  BN_free(&v33);
LABEL_21:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v37;
}
// 68054: using guessed type __int64 var_158[32];

//----- (0000000000068470) ----------------------------------------------------
void __fastcall BN_mod_exp_mont(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // x26
  __int64 v7; // x21
  __int64 v8; // x23
  __int64 v9; // x19
  __int64 v10; // x22
  __int64 v11; // x20
  signed int v12; // w25
  _QWORD *v13; // x27
  _QWORD *v14; // x24
  _QWORD *v15; // x0
  __int64 v16; // x28
  _DWORD *v17; // x10
  _QWORD *v18; // x0
  int v19; // w0
  signed int v20; // w8
  signed int v21; // w8
  __int64 v22; // x20
  signed __int64 v23; // x21
  _QWORD *v24; // x0
  signed __int64 v25; // x8
  __int64 v26; // x20
  void **v27; // x0
  signed __int64 v28; // x8
  signed __int64 v29; // x10
  signed int v30; // w25
  signed int v31; // w28
  signed int v32; // w27
  unsigned int v33; // w20
  int v34; // w26
  signed int v35; // w21
  bool v36; // zf
  int v37; // w8
  signed int v38; // w20
  signed int v39; // [xsp+14h] [xbp-16Ch]
  _DWORD *v40; // [xsp+18h] [xbp-168h]
  __int64 v41; // [xsp+20h] [xbp-160h]
  __int64 v42[32]; // [xsp+28h] [xbp-158h]
  __int64 v43; // [xsp+128h] [xbp-58h]

  v6 = a4;
  v7 = a1;
  v8 = a6;
  v9 = a5;
  v10 = a3;
  v11 = a2;
  v43 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)BN_is_odd(a4) )
  {
    ERR_put_error(3, 0LL, 104, (__int64)"external/boringssl/src/crypto/bn/exponentiation.c", 585);
    goto def_688BC;
  }
  v12 = BN_num_bits(v10);
  if ( !v12 )
  {
    if ( BN_is_one(v6) )
      BN_zero(v7);
    else
      BN_one(v7);
    goto def_688BC;
  }
  v41 = v7;
  BN_CTX_start(v9);
  v13 = BN_CTX_get(v9);
  v14 = BN_CTX_get(v9);
  v15 = BN_CTX_get(v9);
  v16 = (__int64)v15;
  v17 = 0LL;
  v42[0] = (__int64)v15;
  if ( !v13 || !v14 || !v15 )
    goto LABEL_76;
  if ( v8 )
  {
    v40 = 0LL;
    if ( !*(_DWORD *)(v11 + 16) )
      goto LABEL_8;
  }
  else
  {
    v18 = BN_MONT_CTX_new();
    if ( !v18 )
    {
      v17 = 0LL;
      goto LABEL_76;
    }
    v8 = (__int64)v18;
    if ( !BN_MONT_CTX_set((__int64)v18, v6) )
    {
      v17 = (_DWORD *)v8;
      goto LABEL_76;
    }
    v40 = (_DWORD *)v8;
    if ( !*(_DWORD *)(v11 + 16) )
    {
LABEL_8:
      if ( BN_ucmp(v11, v6) & 0x80000000 )
        goto LABEL_18;
      goto LABEL_17;
    }
  }
LABEL_17:
  v19 = BN_nnmod(v16, v11, v6, v9);
  v11 = v16;
  if ( !v19 )
    goto LABEL_75;
LABEL_18:
  if ( BN_is_zero(v11) )
  {
    BN_zero(v7);
    v17 = v40;
LABEL_76:
    BN_MONT_CTX_free(v17);
    BN_CTX_end(v9);
    goto def_688BC;
  }
  if ( !(unsigned int)BN_to_montgomery(v16, v11, v8, v9) )
    goto LABEL_75;
  if ( v12 <= 671 )
  {
    if ( v12 <= 239 )
    {
      if ( v12 <= 79 )
      {
        if ( v12 < 24 )
        {
          v39 = 1;
          goto LABEL_39;
        }
        v20 = 3;
      }
      else
      {
        v20 = 4;
      }
    }
    else
    {
      v20 = 5;
    }
  }
  else
  {
    v20 = 6;
  }
  v39 = v20;
  if ( !(unsigned int)BN_mod_mul_montgomery((__int64)v13, v16, v16, v8, v9) )
    goto LABEL_75;
  v21 = 1 << (v39 - 1);
  if ( v21 >= 2 )
  {
    v22 = 0LL;
    v23 = v21;
    do
    {
      v24 = BN_CTX_get(v9);
      v42[v22 + 1] = (__int64)v24;
      if ( !v24 || !(unsigned int)BN_mod_mul_montgomery((__int64)v24, v42[v22], (__int64)v13, v8, v9) )
        goto LABEL_75;
      v25 = v22++ + 2;
    }
    while ( v25 < v23 );
  }
LABEL_39:
  v26 = *(unsigned int *)(v6 + 8);
  if ( *(_QWORD *)(*(_QWORD *)v6 + 8LL * ((signed int)v26 - 1)) & 0x8000000000000000LL )
  {
    if ( !bn_wexpand((__int64)v14, (signed int)v26) )
      goto LABEL_75;
    *(_QWORD *)*v14 = -**(_QWORD **)v6;
    if ( (signed int)v26 >= 2 )
    {
      v28 = 1LL;
      do
      {
        v29 = 8 * v28++;
        *(_QWORD *)(*v14 + v29) = ~*(_QWORD *)(*(_QWORD *)v6 + v29);
      }
      while ( v26 != v28 );
    }
    *((_DWORD *)v14 + 2) = v26;
    bn_correct_top((__int64)v14);
  }
  else
  {
    v27 = BN_value_one();
    if ( !(unsigned int)BN_to_montgomery((__int64)v14, (__int64)v27, v8, v9) )
      goto LABEL_75;
  }
  v30 = v12 - 1;
  v31 = 1;
  while ( 2 )
  {
    if ( !(unsigned int)BN_is_bit_set(v10, v30) )
    {
      if ( !v31 && !(unsigned int)BN_mod_mul_montgomery((__int64)v14, (__int64)v14, (__int64)v14, v8, v9) )
        goto LABEL_75;
      v36 = v30 == 0;
      if ( v30 )
        --v30;
      else
        v30 = 0;
      if ( v36 )
        LOBYTE(v37) = 9;
      else
        LOBYTE(v37) = 10;
      goto LABEL_73;
    }
    if ( v39 < 2 )
    {
      v32 = 0;
      v34 = 1;
    }
    else
    {
      v32 = 0;
      v33 = v30 - 1;
      v34 = 1;
      v35 = 1;
      do
      {
        if ( v33 & 0x80000000 )
          break;
        if ( (unsigned int)BN_is_bit_set(v10, v33) )
        {
          v34 = (v34 << (v35 - v32)) | 1;
          v32 = v35;
        }
        ++v35;
        --v33;
      }
      while ( v35 < v39 );
    }
    if ( !v31 && !(v32 & 0x80000000) )
    {
      v38 = -1;
      while ( (unsigned int)BN_mod_mul_montgomery((__int64)v14, (__int64)v14, (__int64)v14, v8, v9) )
      {
        if ( ++v38 >= v32 )
          goto LABEL_71;
      }
      goto LABEL_75;
    }
LABEL_71:
    if ( !(unsigned int)BN_mod_mul_montgomery((__int64)v14, (__int64)v14, v42[v34 >> 1], v8, v9) )
    {
LABEL_75:
      v17 = v40;
      goto LABEL_76;
    }
    v30 = v30 - 1 - v32;
    v31 = 0;
    v37 = (v30 >> 31) & 9;
LABEL_73:
    v17 = v40;
    switch ( v37 & 0xF )
    {
      case 0:
      case 0xA:
        continue;
      case 2:
        goto LABEL_76;
      case 9:
        BN_from_montgomery(v41, (__int64)v14, v8, v9);
        v17 = v40;
        goto LABEL_76;
      default:
        goto def_688BC;
    }
  }
def_688BC:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 68470: using guessed type __int64 var_158[32];

//----- (0000000000068938) ----------------------------------------------------
void __fastcall BN_mod_exp_mont_consttime(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // x21
  __int64 v7; // x26
  __int64 v8; // x24
  __int64 v9; // x22
  __int64 v10; // x23
  __int64 v11; // x19
  __int64 v12; // x25
  signed int v13; // w27
  _DWORD *v14; // x20
  void **v15; // x28
  _QWORD *v16; // x0
  void **v17; // x0
  signed int v18; // w11
  void *v19; // x22
  int v20; // w21
  char *v21; // x26
  int v22; // w9
  signed int v23; // w11
  signed int v24; // w8
  int v25; // w28
  unsigned __int64 v26; // x9
  char *v27; // x20
  char *v28; // x0
  signed __int64 v29; // x10
  char *v30; // x8
  _QWORD *v31; // x9
  __int64 v32; // x11
  __int64 v33; // x10
  void **v34; // x0
  int v35; // w0
  signed int v36; // w28
  signed __int64 v37; // x8
  signed __int64 v38; // x10
  __int64 v39; // x10
  __int64 v40; // x9
  __int64 v41; // x8
  __int64 v42; // x11
  _QWORD *v43; // x12
  __int64 v44; // x13
  __int64 v45; // x10
  __int64 v46; // x9
  __int64 v47; // x8
  _QWORD *v48; // x11
  __int64 v49; // x12
  __int64 v50; // x13
  __int64 v51; // x10
  __int64 v52; // x9
  __int64 v53; // x8
  _QWORD *v54; // x11
  __int64 v55; // x12
  __int64 v56; // x13
  signed __int64 v57; // x19
  signed __int64 v58; // x21
  __int64 v59; // x20
  __int64 v60; // x10
  __int64 v61; // x9
  __int64 v62; // x8
  _QWORD *v63; // x11
  __int64 v64; // x12
  int v65; // w19
  int v66; // w20
  int v67; // w8
  int v68; // w21
  int v69; // w20
  signed int v70; // w21
  _BOOL4 v71; // w19
  __int64 v72; // [xsp+0h] [xbp-C0h]
  void *v73; // [xsp+8h] [xbp-B8h]
  int v74; // [xsp+10h] [xbp-B0h]
  unsigned int v75; // [xsp+14h] [xbp-ACh]
  void **v76; // [xsp+18h] [xbp-A8h]
  _DWORD *v77; // [xsp+20h] [xbp-A0h]
  __int64 v78; // [xsp+28h] [xbp-98h]
  __int64 v79; // [xsp+30h] [xbp-90h]
  char *v80; // [xsp+38h] [xbp-88h]
  int v81; // [xsp+40h] [xbp-80h]
  int v82; // [xsp+44h] [xbp-7Ch]
  int v83; // [xsp+48h] [xbp-78h]
  int v84; // [xsp+4Ch] [xbp-74h]
  char *v85; // [xsp+50h] [xbp-70h]
  int v86; // [xsp+58h] [xbp-68h]
  int v87; // [xsp+5Ch] [xbp-64h]
  int v88; // [xsp+60h] [xbp-60h]
  int v89; // [xsp+64h] [xbp-5Ch]
  __int64 v90; // [xsp+68h] [xbp-58h]

  v6 = a4;
  v7 = a1;
  v8 = a6;
  v9 = a5;
  v10 = a3;
  v11 = a2;
  v90 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)BN_is_odd(a4) )
  {
    ERR_put_error(3, 0LL, 104, (__int64)"external/boringssl/src/crypto/bn/exponentiation.c", 866);
    goto LABEL_91;
  }
  v12 = *(unsigned int *)(v6 + 8);
  v13 = BN_num_bits(v10);
  if ( !v13 )
  {
    if ( BN_is_one(v6) )
      BN_zero(v7);
    else
      BN_one(v7);
    goto LABEL_91;
  }
  if ( v8 )
  {
    v14 = 0LL;
    if ( *(_DWORD *)(v11 + 16) )
      goto LABEL_13;
  }
  else
  {
    v16 = BN_MONT_CTX_new();
    v14 = v16;
    if ( !v16 || !BN_MONT_CTX_set((__int64)v16, v6) )
    {
      v19 = 0LL;
      v20 = 0;
      v21 = 0LL;
      v15 = 0LL;
      goto LABEL_89;
    }
    v8 = (__int64)v14;
    if ( *(_DWORD *)(v11 + 16) )
      goto LABEL_13;
  }
  if ( BN_ucmp(v11, v6) & 0x80000000 )
  {
    v15 = 0LL;
    goto LABEL_16;
  }
LABEL_13:
  v17 = (void **)BN_new();
  v15 = v17;
  if ( !v17 || !(unsigned int)BN_nnmod((__int64)v17, v11, v6, v9) )
  {
    v19 = 0LL;
    v20 = 0;
    v21 = 0LL;
    goto LABEL_89;
  }
  v11 = (__int64)v15;
LABEL_16:
  v76 = v15;
  v77 = v14;
  if ( v13 <= 937 )
  {
    if ( v13 <= 306 )
    {
      if ( v13 <= 89 )
      {
        if ( v13 <= 22 )
          v18 = 1;
        else
          v18 = 3;
      }
      else
      {
        v18 = 4;
      }
    }
    else
    {
      v18 = 5;
    }
  }
  else
  {
    v18 = 6;
  }
  v22 = (_DWORD)v12 << v18;
  v74 = v18;
  v23 = 1 << v18;
  if ( 2 * (signed int)v12 <= v23 )
    v24 = v23;
  else
    v24 = 2 * v12;
  v25 = 8 * (v24 + v22);
  v75 = v23;
  v78 = (unsigned int)(8 * (v24 + v22));
  if ( v25 < 3072 )
  {
    v26 = (v25 + 64 + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
    v27 = (char *)&v72 - v26;
    v72 = v7;
    v21 = (char *)&v81 - v26 - (((unsigned __int64)&v72 - v26) & 0x30);
    if ( !v25 )
    {
LABEL_37:
      v29 = 8LL * (signed int)v12;
      v86 = 0;
      v87 = v12;
      v30 = &v21[v29 * v75];
      v79 = v75;
      v85 = &v21[v29 * v75];
      v88 = 0;
      v89 = 2;
      v80 = &v30[v29];
      v81 = 0;
      v82 = v12;
      v83 = 0;
      v84 = 2;
      v31 = *(_QWORD **)v6;
      if ( v25 >= 3072 )
        v32 = (__int64)v27;
      else
        v32 = 0LL;
      v33 = v31[(unsigned __int64)v29 / 8 - 1];
      v73 = (void *)v32;
      if ( v33 & 0x8000000000000000LL )
      {
        v36 = v74;
        *(_QWORD *)v30 = -*v31;
        if ( (signed int)v12 >= 2 )
        {
          v37 = 1LL;
          do
          {
            v38 = 8 * v37++;
            *(_QWORD *)&v85[v38] = ~*(_QWORD *)(*(_QWORD *)v6 + v38);
          }
          while ( v12 != v37 );
        }
        v86 = v12;
      }
      else
      {
        v34 = BN_value_one();
        v35 = BN_to_montgomery((__int64)&v85, (__int64)v34, v8, v9);
        v36 = v74;
        if ( !v35 )
          goto LABEL_88;
      }
      if ( (unsigned int)BN_to_montgomery((__int64)&v80, v11, v8, v9) )
      {
        if ( v86 >= (signed int)v12 )
          LODWORD(v39) = v12;
        else
          LODWORD(v39) = v86;
        if ( (signed int)v39 >= 1 )
        {
          v40 = (__int64)v85;
          v41 = 0LL;
          v39 = (signed int)v39;
          v42 = 8 * v79;
          v43 = v21;
          do
          {
            v44 = *(_QWORD *)(v40 + 8 * v41++);
            *v43 = v44;
            v43 = (_QWORD *)((char *)v43 + v42);
          }
          while ( v41 < v39 );
        }
        if ( v81 >= (signed int)v12 )
          LODWORD(v45) = v12;
        else
          LODWORD(v45) = v81;
        if ( (signed int)v45 >= 1 )
        {
          v46 = (__int64)v80;
          v47 = 0LL;
          v45 = (signed int)v45;
          v48 = v21 + 8;
          v49 = 8 * v79;
          do
          {
            v50 = *(_QWORD *)(v46 + 8 * v47++);
            *v48 = v50;
            v48 = (_QWORD *)((char *)v48 + v49);
          }
          while ( v47 < v45 );
        }
        if ( (unsigned int)v36 < 2 )
        {
LABEL_78:
          v65 = v13 - 1;
          v66 = 0;
          v67 = v65 - v65 / v36 * v36;
          if ( !(v67 & 0x80000000) )
          {
            v68 = v67 + 1;
            do
            {
              v66 = (unsigned __int64)BN_is_bit_set(v10, v65--) + 2 * v66;
              --v68;
            }
            while ( v68 > 0 );
          }
          if ( (unsigned int)sub_68F3C((__int64)&v85, v12, (__int64)v21, v66, v36) )
          {
LABEL_82:
            if ( v65 & 0x80000000 )
            {
              v71 = (unsigned __int64)BN_from_montgomery(v72, (__int64)&v85, v8, v9) != 0;
            }
            else
            {
              v69 = 0;
              v70 = 0;
              while ( (unsigned int)BN_mod_mul_montgomery((__int64)&v85, (__int64)&v85, (__int64)&v85, v8, v9) )
              {
                v69 = (unsigned __int64)BN_is_bit_set(v10, v65) + 2 * v69;
                ++v70;
                --v65;
                if ( v70 >= v36 )
                {
                  if ( (unsigned int)sub_68F3C((__int64)&v80, v12, (__int64)v21, v69, v36)
                    && (unsigned int)BN_mod_mul_montgomery((__int64)&v85, (__int64)&v85, (__int64)&v80, v8, v9) )
                  {
                    goto LABEL_82;
                  }
                  goto LABEL_88;
                }
              }
            }
          }
          goto LABEL_88;
        }
        if ( (unsigned int)BN_mod_mul_montgomery((__int64)&v85, (__int64)&v80, (__int64)&v80, v8, v9) )
        {
          if ( v86 >= (signed int)v12 )
            LODWORD(v51) = v12;
          else
            LODWORD(v51) = v86;
          if ( (signed int)v51 >= 1 )
          {
            v52 = (__int64)v85;
            v53 = 0LL;
            v51 = (signed int)v51;
            v54 = v21 + 16;
            v55 = 8 * v79;
            do
            {
              v56 = *(_QWORD *)(v52 + 8 * v53++);
              *v54 = v56;
              v54 = (_QWORD *)((char *)v54 + v55);
            }
            while ( v53 < v51 );
          }
          if ( (signed int)v75 >= 4 )
          {
            v57 = (signed __int64)(v21 + 24);
            v58 = 3LL;
            v59 = 8 * v79;
            while ( (unsigned int)BN_mod_mul_montgomery((__int64)&v85, (__int64)&v80, (__int64)&v85, v8, v9) )
            {
              if ( v86 >= (signed int)v12 )
                LODWORD(v60) = v12;
              else
                LODWORD(v60) = v86;
              if ( (signed int)v60 >= 1 )
              {
                v61 = (__int64)v85;
                v62 = 0LL;
                v60 = (signed int)v60;
                v63 = (_QWORD *)v57;
                do
                {
                  v64 = *(_QWORD *)(v61 + 8 * v62++);
                  *v63 = v64;
                  v63 = (_QWORD *)((char *)v63 + v59);
                }
                while ( v62 < v60 );
              }
              ++v58;
              v57 += 8LL;
              if ( v58 >= v79 )
                goto LABEL_78;
            }
            goto LABEL_88;
          }
          goto LABEL_78;
        }
      }
LABEL_88:
      v15 = v76;
      v14 = v77;
      v20 = v78;
      v19 = v73;
      goto LABEL_89;
    }
LABEL_36:
    memset(v21, 0, v25);
    goto LABEL_37;
  }
  v28 = (char *)malloc(v25 + 64);
  v27 = v28;
  if ( v28 )
  {
    v25 = v78;
    v72 = v7;
    v21 = &v28[64LL - ((unsigned __int8)v28 & 0x3F)];
    goto LABEL_36;
  }
  v15 = v76;
  v14 = v77;
  v20 = v78;
  v19 = 0LL;
  v21 = 0LL;
LABEL_89:
  BN_MONT_CTX_free(v14);
  BN_clear_free(v15);
  if ( v21 )
  {
    OPENSSL_cleanse(v21, v20);
    free(v19);
  }
LABEL_91:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v90;
}

//----- (0000000000068F3C) ----------------------------------------------------
__int64 __fastcall sub_68F3C(__int64 a1, signed int a2, __int64 a3, int a4, signed int a5)
{
  signed int v5; // w20
  signed int v6; // w23
  int v7; // w22
  __int64 v8; // x21
  __int64 v9; // x19
  __int64 result; // x0
  __int64 v11; // x11
  __int64 v12; // x8
  __int64 v13; // x9
  __int64 v14; // x11
  __int64 v15; // x13
  __int64 v16; // x12
  signed __int64 v17; // x14
  __int64 v18; // x14
  int v19; // w12
  int v20; // w17
  int v21; // w18
  int v22; // w0
  unsigned int v23; // w15
  int v24; // w16
  int v25; // w12
  int v26; // w13
  int v27; // w17
  int v28; // w18
  unsigned int v29; // w16
  unsigned int v30; // w0
  unsigned int v31; // w17
  unsigned int v32; // w18
  signed __int64 v33; // x15
  __int64 v34; // x2
  __int64 v35; // x3
  __int64 v36; // x8
  __int64 v37; // x11
  __int64 v38; // x13
  __int64 v39; // x14
  signed __int64 v40; // x16
  signed __int64 v41; // x17
  __int64 v42; // x18
  __int64 v43; // x0
  __int64 v44; // x2
  __int64 v45; // x3
  signed __int64 v46; // x7

  v5 = a2;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a1;
  result = bn_wexpand(a1, a2);
  if ( result )
  {
    v11 = (unsigned int)(1 << v6);
    if ( v6 > 3 )
    {
      if ( v5 >= 1 )
      {
        v18 = (unsigned int)(1 << (v6 - 2));
        v19 = v7 >> (v6 - 2);
        v20 = v19 ^ 1;
        v21 = v19 ^ 2;
        v22 = v19 ^ 3;
        v23 = v19 ^ 0x80000000;
        v24 = v19 - 1;
        v25 = (v18 - 1) & v7;
        v26 = v20 - 1;
        v27 = v21 - 1;
        v28 = v22 - 1;
        v29 = v24 & v23;
        v30 = v26 & v23;
        v31 = v27 & v23;
        v32 = v28 & v23;
        v33 = (signed __int64)((unsigned __int64)(unsigned int)(2 * v18) << 32) >> 29;
        v34 = v31 >> 31;
        v35 = v32 >> 31;
        v36 = 0LL;
        v37 = v11 << 32 >> 29;
        v38 = (signed int)v18;
        v39 = v18 << 32 >> 29;
        v40 = -(signed __int64)(v29 >> 31);
        v41 = -(signed __int64)(v30 >> 31);
        v42 = -v34;
        v43 = -v35;
        do
        {
          if ( v6 == 33 )
          {
            v44 = 0LL;
          }
          else
          {
            v45 = 0LL;
            v44 = 0LL;
            do
            {
              v46 = (*(_QWORD *)(v8 + v39 + 8 * v45) & v41 | *(_QWORD *)(v8 + 8 * v45) & v40 | *(_QWORD *)(v8 + v33 + 8 * v45) & v42 | *(_QWORD *)(v8 + ((signed __int64)((unsigned __int64)(unsigned int)(3 << (v6 - 2)) << 32) >> 29) + 8 * v45) & v43) & -(signed __int64)(((((unsigned int)v45 ^ v25) - 1) & ~((unsigned int)v45 ^ v25)) >> 31);
              ++v45;
              v44 |= v46;
            }
            while ( v45 < v38 );
          }
          v8 += v37;
          *(_QWORD *)(*(_QWORD *)v9 + 8 * v36++) = v44;
        }
        while ( v36 != v5 );
      }
    }
    else if ( v5 >= 1 )
    {
      v12 = 0LL;
      v13 = (signed int)v11;
      v14 = v11 << 32 >> 29;
      do
      {
        v15 = 0LL;
        v16 = 0LL;
        do
        {
          v17 = *(_QWORD *)(v8 + 8 * v15) & -(signed __int64)(((((unsigned int)v15 ^ v7) - 1) & ~((unsigned int)v15 ^ v7)) >> 31);
          ++v15;
          v16 |= v17;
        }
        while ( v15 < v13 );
        v8 += v14;
        *(_QWORD *)(*(_QWORD *)v9 + 8 * v12++) = v16;
      }
      while ( v12 != v5 );
    }
    *(_DWORD *)(v9 + 8) = v5;
    bn_correct_top(v9);
    result = 1LL;
  }
  return result;
}

//----- (0000000000069140) ----------------------------------------------------
void __fastcall BN_mod_exp_mont_word(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // x23
  __int64 v7; // x19
  __int64 v8; // x20
  __int64 v9; // x21
  __int64 v10; // x22
  __int64 v11; // x24
  __int64 v12; // [xsp+0h] [xbp-50h]
  __int64 v13; // [xsp+18h] [xbp-38h]

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  BN_init(&v12);
  if ( (unsigned int)BN_set_word((__int64)&v12, v11) )
    BN_mod_exp_mont(v6, (__int64)&v12, v10, v9, v8, v7);
  else
    ERR_put_error(3, 0LL, 68, (__int64)"external/boringssl/src/crypto/bn/exponentiation.c", 1191);
  BN_free(&v12);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000069214) ----------------------------------------------------
void __fastcall BN_mod_exp2_mont(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v8; // x21
  __int64 v9; // x22
  __int64 v10; // x20
  __int64 v11; // x23
  __int64 v12; // x24
  __int64 v13; // x25
  __int64 v14; // x26
  __int64 v15; // x27
  _DWORD *v16; // x19
  int v17; // w0
  int v18; // w0
  _BOOL4 v19; // w20
  _QWORD *v20; // x0
  __int64 v21; // [xsp+0h] [xbp-70h]
  __int64 v22; // [xsp+18h] [xbp-58h]

  v8 = a1;
  v9 = a8;
  v10 = a7;
  v11 = a6;
  v12 = a5;
  v13 = a4;
  v14 = a3;
  v15 = a2;
  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  BN_init(&v21);
  if ( v9 )
  {
    v16 = 0LL;
  }
  else
  {
    v20 = BN_MONT_CTX_new();
    v16 = v20;
    if ( !v20 || !BN_MONT_CTX_set((__int64)v20, v11) )
      goto LABEL_10;
    v9 = (__int64)v16;
  }
  BN_mod_exp_mont(v8, v15, v14, v11, v10, v9);
  if ( v17 )
  {
    BN_mod_exp_mont((__int64)&v21, v13, v12, v11, v10, v9);
    if ( v18 )
    {
      if ( (unsigned int)BN_to_montgomery(v8, v8, v9, v10) )
        v19 = (unsigned __int64)BN_mod_mul_montgomery(v8, v8, (__int64)&v21, v9, v10) != 0;
    }
  }
LABEL_10:
  BN_MONT_CTX_free(v16);
  BN_free(&v21);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000069364) ----------------------------------------------------
__int64 __fastcall sub_69364(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x19
  _QWORD *v6; // x21
  __int64 v7; // x20
  __int64 v8; // x23
  __int64 v9; // x24
  _QWORD *v10; // x0
  __int64 v11; // x22
  unsigned int v12; // w26
  _QWORD *v13; // x25
  _QWORD *v14; // x24
  _QWORD *v15; // x23
  int v16; // w0
  unsigned int v17; // w26
  _QWORD *v18; // x0
  __int64 v19; // x27
  signed int v20; // w27
  signed int v21; // w24
  int v23; // w8

  v5 = a5;
  v6 = a1;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  BN_CTX_start(a5);
  v10 = BN_CTX_get(v5);
  v11 = (__int64)v10;
  if ( !v10 )
    goto LABEL_5;
  if ( !v8 )
  {
    v11 = v9;
    goto LABEL_8;
  }
  if ( v9 == v8 )
  {
    if ( !(unsigned int)BN_sqr((__int64)v10, v8, v5) )
    {
      v12 = 0;
      goto LABEL_47;
    }
LABEL_8:
    BN_CTX_start(v5);
    v13 = BN_CTX_get(v5);
    v14 = BN_CTX_get(v5);
    v15 = BN_CTX_get(v5);
    if ( !v6 )
      v6 = BN_CTX_get(v5);
    v12 = 0;
    if ( !v13 || !v14 || !v15 || !v6 )
      goto LABEL_46;
    if ( BN_ucmp(v11, v7) & 0x80000000 )
    {
      BN_zero((__int64)v15);
      if ( BN_copy((__int64)v6, v11) )
      {
        BN_CTX_end(v5);
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 0;
LABEL_46:
      BN_CTX_end(v5);
      goto LABEL_47;
    }
    v16 = BN_num_bits(v11);
    if ( 2 * *(_DWORD *)(v7 + 48) <= v16 )
      v17 = v16;
    else
      v17 = 2 * *(_DWORD *)(v7 + 48);
    if ( v17 == *(_DWORD *)(v7 + 52) )
    {
      if ( v17 == -1 )
      {
LABEL_43:
        v12 = 0;
        goto LABEL_46;
      }
    }
    else
    {
      BN_CTX_start(v5);
      v18 = BN_CTX_get(v5);
      v19 = (__int64)v18;
      if ( v18 && (unsigned int)BN_set_bit((__int64)v18, v17) )
      {
        if ( (unsigned int)BN_div((_QWORD *)(v7 + 24), 0LL, v19, v7, v5) )
          v20 = v17;
        else
          v20 = 1;
      }
      else
      {
        v20 = -1;
      }
      BN_CTX_end(v5);
      *(_DWORD *)(v7 + 52) = v20;
      if ( v20 == -1 )
        goto LABEL_43;
    }
    if ( (unsigned int)BN_rshift((__int64)v13, v11, *(_DWORD *)(v7 + 48)) )
    {
      if ( (unsigned int)BN_mul((__int64)v14, (__int64)v13, v7 + 24, v5)
        && (unsigned int)BN_rshift((__int64)v15, (__int64)v14, v17 - *(_DWORD *)(v7 + 48))
        && (*((_DWORD *)v15 + 4) = 0, (unsigned int)BN_mul((__int64)v14, v7, (__int64)v15, v5))
        && (unsigned int)BN_usub((__int64)v6, v11, (__int64)v14) )
      {
        v21 = -1;
        *((_DWORD *)v6 + 4) = 0;
        while ( !(BN_ucmp((__int64)v6, v7) & 0x80000000) )
        {
          if ( ++v21 >= 3 )
          {
            ERR_put_error(3, 0LL, 101, (__int64)"external/boringssl/src/crypto/bn/exponentiation.c", 342);
LABEL_51:
            v12 = 0;
            goto LABEL_46;
          }
          if ( !(unsigned int)BN_usub((__int64)v6, (__int64)v6, v7) )
            goto LABEL_51;
          v12 = 0;
          if ( !(unsigned int)BN_add_word((__int64)v15, 1LL) )
            goto LABEL_46;
        }
        if ( BN_is_zero((__int64)v6) )
          v23 = 0;
        else
          v23 = *(_DWORD *)(v11 + 16);
        *((_DWORD *)v6 + 4) = v23;
        v12 = 1;
        *((_DWORD *)v15 + 4) = *(_DWORD *)(v7 + 16) ^ *(_DWORD *)(v11 + 16);
      }
      else
      {
        v12 = 0;
      }
      goto LABEL_46;
    }
    goto LABEL_43;
  }
  if ( (unsigned int)BN_mul((__int64)v10, v9, v8, v5) )
    goto LABEL_8;
LABEL_5:
  v12 = 0;
LABEL_47:
  BN_CTX_end(v5);
  return v12;
}

//----- (0000000000069674) ----------------------------------------------------
__int64 __fastcall BN_gcd(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  __int64 v6; // x23
  __int64 v7; // x25
  _QWORD *v8; // x22
  _QWORD *v9; // x0
  __int64 v10; // x24
  _BOOL4 v11; // w21
  int v12; // w0
  __int64 v13; // x23
  __int64 *v14; // x24
  unsigned int v15; // w21
  int v16; // w25
  int v17; // w24
  int v18; // w0
  int v19; // w0
  int v20; // w0

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  BN_CTX_start(a4);
  v8 = BN_CTX_get(v4);
  v9 = BN_CTX_get(v4);
  v10 = (__int64)v9;
  v11 = 0;
  if ( v8 && v9 )
  {
    if ( !BN_copy((__int64)v8, v7) || !BN_copy(v10, v6) )
      goto LABEL_38;
    *((_DWORD *)v8 + 4) = 0;
    *(_DWORD *)(v10 + 16) = 0;
    v12 = BN_cmp((__int64)v8, v10);
    if ( v12 >= 0 )
      v13 = (__int64)v8;
    else
      v13 = v10;
    if ( v12 >= 0 )
      v8 = (_QWORD *)v10;
    if ( BN_is_zero((__int64)v8) )
    {
      v14 = (__int64 *)v13;
      goto LABEL_12;
    }
    v15 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v16 = BN_is_odd(v13);
        v17 = BN_is_odd((__int64)v8);
        if ( !v16 )
          break;
        if ( !v17 )
        {
          if ( !(unsigned int)BN_rshift1((__int64)v8, (__int64)v8) )
            goto LABEL_38;
          goto LABEL_24;
        }
        if ( !(unsigned int)BN_sub(v13, v13, (__int64)v8) )
          goto LABEL_38;
        v18 = BN_rshift1(v13, v13);
LABEL_23:
        if ( !v18 )
          goto LABEL_38;
LABEL_24:
        v19 = BN_cmp(v13, (__int64)v8);
        if ( v19 >= 0 )
          v14 = (__int64 *)v13;
        else
          v14 = v8;
        if ( v19 < 0 )
          v8 = (_QWORD *)v13;
        v13 = (__int64)v14;
        if ( BN_is_zero((__int64)v8) )
          goto LABEL_33;
      }
      v18 = BN_rshift1(v13, v13);
      if ( v17 )
        goto LABEL_23;
      if ( !v18 || !(unsigned int)BN_rshift1((__int64)v8, (__int64)v8) )
        goto LABEL_38;
      ++v15;
      if ( BN_is_zero((__int64)v8) )
      {
        v14 = (__int64 *)v13;
LABEL_33:
        if ( v15 )
        {
          v20 = BN_lshift((__int64)v14, v14, v15);
          v11 = 0;
          if ( !v14 || !v20 )
            break;
LABEL_12:
          v11 = BN_copy(v5, (__int64)v14) != 0;
          break;
        }
        if ( v14 )
          goto LABEL_12;
LABEL_38:
        v11 = 0;
        break;
      }
    }
  }
  BN_CTX_end(v4);
  return (unsigned int)v11;
}

//----- (0000000000069844) ----------------------------------------------------
__int64 __fastcall sub_69844(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x20
  _DWORD *v6; // x22
  __int64 v7; // x21
  __int64 v8; // x19
  __int64 v9; // x27
  int v10; // w2
  __int16 v11; // w4
  unsigned int v12; // w27
  _QWORD *v14; // x24
  _QWORD *v15; // x25
  _QWORD *v16; // x26
  _QWORD *v17; // x0
  __int64 v18; // x23
  signed int v19; // w28
  signed int v20; // w28

  v5 = a4;
  v6 = a2;
  v7 = a1;
  v8 = a5;
  v9 = a3;
  *a2 = 0;
  if ( !(unsigned int)BN_is_odd(a4) )
  {
    v10 = 104;
    v11 = 237;
    goto LABEL_6;
  }
  if ( !BN_is_negative(v9) && BN_cmp(v9, v5) & 0x80000000 )
  {
    BN_CTX_start(v8);
    v14 = BN_CTX_get(v8);
    v15 = BN_CTX_get(v8);
    v16 = BN_CTX_get(v8);
    v17 = BN_CTX_get(v8);
    v18 = (__int64)v17;
    if ( v17 )
    {
      BN_zero((__int64)v17);
      if ( (unsigned int)BN_one((__int64)v16) )
      {
        if ( BN_copy((__int64)v15, v9) && BN_copy((__int64)v14, v5) )
        {
          *((_DWORD *)v14 + 4) = 0;
          while ( !BN_is_zero((__int64)v15) )
          {
            v19 = 0;
            while ( !(unsigned int)BN_is_bit_set((__int64)v15, v19) )
            {
              if ( (unsigned int)BN_is_odd((__int64)v16) && !(unsigned int)BN_uadd((__int64)v16, (__int64)v16, v5) )
                goto LABEL_44;
              ++v19;
              v12 = 0;
              if ( !(unsigned int)BN_rshift1((__int64)v16, (__int64)v16) )
                goto LABEL_45;
            }
            if ( v19 >= 1 && !(unsigned int)BN_rshift((__int64)v15, (__int64)v15, v19) )
              goto LABEL_44;
            v20 = 0;
            while ( !(unsigned int)BN_is_bit_set((__int64)v14, v20) )
            {
              if ( (unsigned int)BN_is_odd(v18) && !(unsigned int)BN_uadd(v18, v18, v5) )
                goto LABEL_44;
              ++v20;
              v12 = 0;
              if ( !(unsigned int)BN_rshift1(v18, v18) )
                goto LABEL_45;
            }
            if ( v20 >= 1 && !(unsigned int)BN_rshift((__int64)v14, (__int64)v14, v20) )
              goto LABEL_44;
            if ( BN_ucmp((__int64)v15, (__int64)v14) & 0x80000000 )
            {
              if ( !(unsigned int)BN_uadd(v18, v18, (__int64)v16)
                || !(unsigned int)BN_usub((__int64)v14, (__int64)v14, (__int64)v15) )
              {
                goto LABEL_44;
              }
            }
            else if ( !(unsigned int)BN_uadd((__int64)v16, (__int64)v16, v18)
                   || !(unsigned int)BN_usub((__int64)v15, (__int64)v15, (__int64)v14) )
            {
              goto LABEL_44;
            }
          }
          if ( BN_is_one((__int64)v14) )
          {
            if ( (unsigned int)BN_sub(v18, v5, v18) )
            {
              if ( !*(_DWORD *)(v18 + 16) && BN_ucmp(v18, v5) & 0x80000000 )
              {
                if ( BN_copy(v7, v18) )
                  goto LABEL_42;
              }
              else if ( (unsigned int)BN_nnmod(v7, v18, v5, v8) )
              {
LABEL_42:
                v12 = 1;
LABEL_45:
                BN_CTX_end(v8);
                return v12;
              }
            }
          }
          else
          {
            *v6 = 1;
            ERR_put_error(3, 0LL, 112, (__int64)"external/boringssl/src/crypto/bn/gcd.c", 365);
          }
        }
      }
    }
LABEL_44:
    v12 = 0;
    goto LABEL_45;
  }
  v10 = 107;
  v11 = 242;
LABEL_6:
  ERR_put_error(3, 0LL, v10, (__int64)"external/boringssl/src/crypto/bn/gcd.c", v11);
  return 0;
}

//----- (0000000000069B58) ----------------------------------------------------
void __fastcall BN_mod_inverse(_QWORD *a1, signed int *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x21
  __int64 v5; // x23
  signed int *v6; // x25
  _QWORD *v7; // x19
  _DWORD *v8; // x20
  signed int *v9; // x0
  signed int *v10; // x22
  _QWORD *v11; // x26
  _QWORD *v12; // x27
  _QWORD *v13; // x28
  _QWORD *v14; // x24
  _QWORD *v15; // x20
  int v16; // w22
  __int64 v17; // x25
  __int64 v18; // x0
  int v19; // w0
  _DWORD *v20; // [xsp+8h] [xbp-78h]
  signed int *v21; // [xsp+10h] [xbp-70h]
  _QWORD *v22; // [xsp+18h] [xbp-68h]
  int v23; // [xsp+24h] [xbp-5Ch]
  __int64 v24; // [xsp+28h] [xbp-58h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v8 = 0LL;
    if ( a2[4] )
      goto LABEL_7;
    goto LABEL_6;
  }
  v7 = BN_new();
  v8 = v7;
  if ( v7 )
  {
    if ( v6[4] )
      goto LABEL_7;
LABEL_6:
    if ( BN_ucmp((__int64)v6, v5) & 0x80000000 )
    {
      v10 = 0LL;
      goto LABEL_13;
    }
LABEL_7:
    v9 = BN_dup(v6);
    v6 = v9;
    if ( !v9 )
    {
      v10 = 0LL;
      goto LABEL_35;
    }
    v10 = v9;
    if ( !(unsigned int)BN_nnmod((__int64)v9, (__int64)v9, v5, v4) )
      goto LABEL_35;
LABEL_13:
    if ( (unsigned int)BN_is_odd(v5) )
    {
      if ( !(unsigned int)sub_69844((__int64)v7, &v23, (__int64)v6, v5, v4) )
        goto LABEL_35;
LABEL_36:
      BN_free(v10);
      goto LABEL_37;
    }
    v20 = v8;
    v21 = v10;
    v23 = 0;
    BN_CTX_start(v4);
    v11 = BN_CTX_get(v4);
    v12 = BN_CTX_get(v4);
    v13 = BN_CTX_get(v4);
    v22 = BN_CTX_get(v4);
    v14 = BN_CTX_get(v4);
    v15 = BN_CTX_get(v4);
    if ( BN_CTX_get(v4) )
    {
      BN_zero((__int64)v15);
      if ( (unsigned int)BN_one((__int64)v13) )
      {
        if ( BN_copy((__int64)v12, (__int64)v6) && BN_copy((__int64)v11, v5) )
        {
          v16 = -1;
          *((_DWORD *)v11 + 4) = 0;
          while ( 1 )
          {
            v17 = (__int64)v12;
            v18 = (__int64)v12;
            v12 = v14;
            v14 = v15;
            if ( BN_is_zero(v18) )
              break;
            if ( (unsigned int)BN_div(v22, (__int64)v12, (__int64)v11, v17, v4) )
            {
              if ( (unsigned int)BN_mul((__int64)v11, (__int64)v22, (__int64)v13, v4) )
              {
                v19 = BN_add((__int64)v11, (__int64)v11, (__int64)v15);
                v16 = -v16;
                v15 = v13;
                v13 = v11;
                v11 = (_QWORD *)v17;
                if ( v19 )
                  continue;
              }
            }
            goto LABEL_34;
          }
          if ( BN_is_one((__int64)v11) )
          {
            if ( !(v16 & 0x80000000) || (unsigned int)BN_sub((__int64)v15, v5, (__int64)v15) )
            {
              if ( !*((_DWORD *)v15 + 4) && BN_ucmp((__int64)v15, v5) & 0x80000000 )
              {
                if ( BN_copy((__int64)v7, (__int64)v15) )
                  goto LABEL_32;
              }
              else if ( (unsigned int)BN_nnmod((__int64)v7, (__int64)v15, v5, v4) )
              {
LABEL_32:
                BN_CTX_end(v4);
                v10 = v21;
                goto LABEL_36;
              }
            }
          }
          else
          {
            v23 = 1;
            ERR_put_error(3, 0LL, 112, (__int64)"external/boringssl/src/crypto/bn/gcd.c", 576);
          }
        }
      }
    }
LABEL_34:
    BN_CTX_end(v4);
    v8 = v20;
    v10 = v21;
LABEL_35:
    BN_free(v8);
    goto LABEL_36;
  }
  ERR_put_error(3, 0LL, 65, (__int64)"external/boringssl/src/crypto/bn/gcd.c", 406);
LABEL_37:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v24;
}

//----- (0000000000069E64) ----------------------------------------------------
void __fastcall sub_69E64(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x23
  _DWORD *v6; // x22
  __int64 v7; // x21
  __int64 v8; // x19
  __int64 v9; // x20
  __int64 v10; // [xsp+0h] [xbp-50h]
  __int64 v11; // [xsp+18h] [xbp-38h]

  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = a5;
  v9 = a4;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *a2 = 0;
  if ( !BN_is_negative(a3) && BN_cmp(v5, v9 + 24) & 0x80000000 )
  {
    BN_init(&v10);
    if ( !(unsigned int)BN_rand_range_ex((__int64)&v10, 1uLL, v9 + 24)
      || !(unsigned int)BN_mod_mul_montgomery(v7, (__int64)&v10, v5, v9, v8)
      || !(unsigned int)sub_69844(v7, v6, v7, v9 + 24, v8)
      || !(unsigned int)BN_mod_mul_montgomery(v7, (__int64)&v10, v7, v9, v8) )
    {
      ERR_put_error(3, 0LL, 3, (__int64)"external/boringssl/src/crypto/bn/gcd.c", 462);
    }
    BN_free(&v10);
  }
  else
  {
    ERR_put_error(3, 0LL, 107, (__int64)"external/boringssl/src/crypto/bn/gcd.c", 450);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v11;
}

//----- (0000000000069FB8) ----------------------------------------------------
__int64 __fastcall sub_69FB8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x19
  __int64 v6; // x23
  __int64 v7; // x20
  __int64 v8; // x21
  __int64 v9; // x22
  _QWORD *v10; // x0
  __int64 v11; // x24
  int v12; // w0
  _BOOL4 v13; // w20

  v5 = a4;
  v6 = a1;
  v7 = a5;
  v8 = a3;
  v9 = a2;
  BN_CTX_start(a4);
  v10 = BN_CTX_get(v5);
  v11 = (__int64)v10;
  if ( v10 && BN_copy((__int64)v10, v8) && (unsigned int)BN_sub_word(v11, 2uLL) )
  {
    BN_mod_exp_mont(v6, v9, v11, v8, v5, v7);
    v13 = v12 != 0;
  }
  else
  {
    v13 = 0;
  }
  BN_CTX_end(v5);
  return (unsigned int)v13;
}

//----- (000000000006A064) ----------------------------------------------------
__int64 __fastcall sub_6A064(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x19
  __int64 v6; // x23
  __int64 v7; // x20
  __int64 v8; // x21
  __int64 v9; // x22
  _QWORD *v10; // x0
  __int64 v11; // x24
  int v12; // w0
  _BOOL4 v13; // w20

  v5 = a4;
  v6 = a1;
  v7 = a5;
  v8 = a3;
  v9 = a2;
  BN_CTX_start(a4);
  v10 = BN_CTX_get(v5);
  v11 = (__int64)v10;
  if ( v10 && BN_copy((__int64)v10, v8) && (unsigned int)BN_sub_word(v11, 2uLL) )
  {
    BN_mod_exp_mont_consttime(v6, v9, v11, v8, v5, v7);
    v13 = v12 != 0;
  }
  else
  {
    v13 = 0;
  }
  BN_CTX_end(v5);
  return (unsigned int)v13;
}

//----- (000000000006A110) ----------------------------------------------------
__int64 __fastcall sub_6A110(_QWORD *a1, unsigned __int64 *a2, unsigned int a3, unsigned __int64 a4)
{
  __int64 v4; // x8
  int v5; // w10
  __int64 v6; // x12
  signed __int64 v7; // x9
  unsigned __int64 *v8; // x13
  unsigned __int64 v9; // x16
  unsigned __int64 v10; // x14
  unsigned __int8 v11; // cf
  __int64 v12; // x8
  __int64 v13; // x17
  __int64 v14; // x14
  __int64 v15; // x15
  unsigned __int64 v16; // x16
  __int64 v17; // x8
  __int64 v18; // x14
  unsigned __int64 v19; // x14
  unsigned __int128 v20; // kr30_16
  unsigned __int64 v21; // t1
  __int64 v22; // x8
  __int64 v23; // x9

  if ( (signed int)a3 >= 1 )
  {
    v4 = 0LL;
    v5 = a3 - 4;
    if ( a3 >= 4 )
    {
      v6 = v5 & 0xFFFFFFFC;
      v7 = (signed __int64)&a1[v6 + 4];
      v8 = a2;
      do
      {
        v9 = a1[1];
        v10 = *v8;
        a3 -= 4;
        v11 = __CFADD__(*a1, v4);
        v12 = *a1 + v4;
        v13 = *v8 * a4;
        *a1 = v12 + v13;
        v14 = (v10 * (unsigned __int128)a4 >> 64) + __CFADD__(v12, v13) + (unsigned __int64)v11;
        v15 = (v8[1] * (unsigned __int128)a4 + __PAIR__(__CFADD__(v12, v14), v9)) >> 64;
        a1[1] = v8[1] * a4 + v9 + v14;
        v16 = a1[3];
        v17 = (v8[2] * (unsigned __int128)a4 + (unsigned __int64)a1[2]) >> 64;
        v18 = v8[2] * a4 + a1[2];
        v11 = __CFADD__(v18, v15);
        a1[2] = v18 + v15;
        v19 = v8[3];
        v8 += 4;
        v20 = v19 * (unsigned __int128)a4 + v16 + (unsigned __int64)v11 + v17;
        v4 = v20 >> 64;
        a1[3] = v20;
        a1 += 4;
      }
      while ( a3 > 3 );
      a3 = v5 - v6;
      if ( v5 == (_DWORD)v6 )
        return v4;
      a2 += v6 + 4;
      a1 = (_QWORD *)v7;
    }
    do
    {
      v21 = *a2;
      ++a2;
      --a3;
      v11 = __CFADD__(*a1, v4);
      v22 = *a1 + v4;
      v23 = v22 + v21 * a4;
      v4 = (v21 * (unsigned __int128)a4 >> 64) + __CFADD__(v22, v21 * a4) + (unsigned __int64)v11;
      *a1 = v23;
      ++a1;
    }
    while ( a3 );
    return v4;
  }
  return 0LL;
}

//----- (000000000006A220) ----------------------------------------------------
unsigned __int64 __fastcall sub_6A220(_QWORD *a1, unsigned __int64 *a2, unsigned int a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // x8
  int v5; // w10
  __int64 v6; // x12
  signed __int64 v7; // x9
  unsigned __int64 *v8; // x13
  unsigned __int64 v9; // x14
  __int64 v10; // x15
  unsigned __int8 v11; // cf
  unsigned __int64 v12; // x8
  __int64 v13; // x14
  unsigned __int64 v14; // x14
  __int64 v15; // x8
  unsigned __int64 v16; // x8
  unsigned __int128 v17; // kr00_16
  unsigned __int64 v18; // t1
  unsigned __int128 v19; // kr10_16

  if ( (signed int)a3 >= 1 )
  {
    v4 = 0LL;
    v5 = a3 - 4;
    if ( a3 >= 4 )
    {
      v6 = v5 & 0xFFFFFFFC;
      v7 = (signed __int64)&a1[v6 + 4];
      v8 = a2;
      do
      {
        v9 = *v8;
        a3 -= 4;
        v10 = *v8 * a4;
        v11 = __CFADD__(v10, v4);
        *a1 = v10 + v4;
        v12 = v8[1];
        v13 = v11 + (v9 * (unsigned __int128)a4 >> 64);
        v11 = __CFADD__(v12 * a4, v13);
        a1[1] = v12 * a4 + v13;
        v14 = v8[2];
        v15 = v11 + (v12 * (unsigned __int128)a4 >> 64);
        v11 = __CFADD__(v14 * a4, v15);
        a1[2] = v14 * a4 + v15;
        v16 = v8[3];
        v8 += 4;
        v17 = v16 * (unsigned __int128)a4 + (unsigned __int64)(v11 + (v14 * (unsigned __int128)a4 >> 64));
        v4 = v17 >> 64;
        a1[3] = v17;
        a1 += 4;
      }
      while ( a3 > 3 );
      a3 = v5 - v6;
      if ( v5 == (_DWORD)v6 )
        return v4;
      a2 += v6 + 4;
      a1 = (_QWORD *)v7;
    }
    do
    {
      v18 = *a2;
      ++a2;
      --a3;
      v19 = v18 * (unsigned __int128)a4 + v4;
      v4 = v19 >> 64;
      *a1 = v19;
      ++a1;
    }
    while ( a3 );
    return v4;
  }
  return 0LL;
}

//----- (000000000006A2FC) ----------------------------------------------------
double *__fastcall sub_6A2FC(double *result, int8x16_t *a2, unsigned int a3)
{
  int v3; // w9
  __int64 v4; // x11
  signed __int64 v5; // x10
  double *v6; // x8
  int v7; // w11
  unsigned __int64 *v8; // x12
  unsigned __int64 v9; // x13
  unsigned __int64 v10; // x9
  signed __int64 v11; // x11
  signed __int64 v12; // x12
  double *v13; // x9
  int8x16_t *v14; // x10
  unsigned __int64 v15; // t1
  signed __int64 v16; // x13
  int8x16_t v17; // t1
  unsigned __int64 v18; // x14
  unsigned __int64 v19; // x16
  float64x2x2_t v20; // 0:q0.16,16:q1.16

  if ( (signed int)a3 >= 1 )
  {
    if ( a3 <= 3 )
    {
      v6 = result;
    }
    else
    {
      v3 = a3 - 4;
      v4 = (a3 - 4) >> 2;
      v5 = 4 * v4 + 4;
      v6 = &result[8 * v4 + 8];
      v7 = 4 * v4;
      v8 = (unsigned __int64 *)a2;
      do
      {
        a3 -= 4;
        *(_OWORD *)result = *v8 * (unsigned __int128)*v8;
        *((_OWORD *)result + 1) = v8[1] * (unsigned __int128)v8[1];
        *((_OWORD *)result + 2) = v8[2] * (unsigned __int128)v8[2];
        v9 = v8[3];
        v8 += 4;
        *((_OWORD *)result + 3) = v9 * (unsigned __int128)v9;
        result += 8;
      }
      while ( a3 > 3 );
      a3 = v3 - v7;
      if ( v3 == v7 )
        return result;
      a2 = (int8x16_t *)((char *)a2 + 8 * v5);
    }
    v10 = a3 - 1;
    v11 = v10 + 1;
    if ( v10 == 0
      || v10 >= 0xFFFFFFFFFFFFFFFFLL
      || (v12 = v11 & 0x1FFFFFFFELL) == 0
      || v6 < (double *)&a2->n128_u64[(unsigned int)v10 + 1] && a2 < (int8x16_t *)&v6[2 * (unsigned int)v10 + 2] )
    {
      v13 = v6;
      v14 = a2;
      do
      {
LABEL_14:
        v15 = v14->n128_u64[0];
        v14 = (int8x16_t *)((char *)v14 + 8);
        --a3;
        *(_OWORD *)v13 = v15 * (unsigned __int128)v15;
        v13 += 2;
      }
      while ( a3 );
      return result;
    }
    v13 = &v6[2 * v12];
    v14 = (int8x16_t *)((char *)a2 + 8 * v12);
    a3 -= v12;
    v16 = v11 & 0x1FFFFFFFELL;
    do
    {
      v17 = *a2;
      ++a2;
      v16 -= 2LL;
      v18 = v17.n128_u64[0];
      v19 = (unsigned __int128)vextq_s8(v17, v17, 8uLL);
      v20.val[0].n128_u64[0] = v18 * v18;
      v20.val[0].n128_u64[1] = v19 * v19;
      v20.val[1].n128_u64[0] = v18 * (unsigned __int128)v18 >> 64;
      v20.val[1].n128_u64[1] = v19 * (unsigned __int128)v19 >> 64;
      vst2q_f64(v6, v20);
      v6 += 4;
    }
    while ( v16 );
    if ( v11 != v12 )
      goto LABEL_14;
  }
  return result;
}

//----- (000000000006A448) ----------------------------------------------------
unsigned __int64 __fastcall sub_6A448(_QWORD *a1, unsigned __int64 *a2, _QWORD *a3, unsigned int a4)
{
  int v4; // w12
  __int64 v5; // x14
  signed __int64 v6; // x11
  unsigned __int64 v7; // x8
  unsigned __int64 *v8; // x10
  _QWORD *v9; // x11
  _QWORD *v10; // x15
  unsigned __int64 v11; // x8
  __int64 v12; // x9
  unsigned __int8 v13; // cf
  unsigned __int64 v14; // x8
  __int64 v15; // x16
  __int64 v16; // x9
  unsigned __int64 v17; // x8
  __int64 v18; // x16
  unsigned __int64 v19; // x8
  __int64 v20; // x9
  __int64 v21; // x16
  unsigned __int64 v22; // x8
  __int64 v23; // x9
  unsigned __int64 v24; // x8
  __int64 v25; // x16
  unsigned __int64 v26; // kr10_8
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // t1
  unsigned __int64 v30; // t1
  unsigned __int128 v31; // kr20_16

  if ( (signed int)a4 < 1 )
    return 0LL;
  if ( a4 <= 3 )
  {
    v7 = 0LL;
  }
  else
  {
    v4 = a4 - 4;
    v5 = (a4 - 4) & 0xFFFFFFFC;
    v6 = v5 + 4;
    v7 = 0LL;
    v8 = &a2[v6];
    v9 = &a1[v6];
    v10 = a3;
    do
    {
      a4 -= 4;
      v12 = (*a2 + (unsigned __int128)v7) >> 64;
      v11 = *a2 + v7;
      v13 = __CFADD__(v11, *v10);
      *a1 = v11 + *v10;
      v14 = a2[1];
      v15 = v10[1];
      v16 = v13 + v12;
      v13 = __CFADD__(v15, v14);
      v17 = v15 + v14;
      v18 = v13;
      v13 = __CFADD__(v17, v16);
      a1[1] = v17 + v16;
      v19 = a2[2];
      v20 = v10[2];
      v21 = v13 + v18;
      v13 = __CFADD__(v20, v19);
      v22 = v20 + v19;
      v23 = v13;
      v13 = __CFADD__(v22, v21);
      a1[2] = v22 + v21;
      v24 = a2[3];
      v25 = v10[3];
      a2 += 4;
      v10 += 4;
      v26 = v25 + v24 + v13 + v23;
      v7 = (__PAIR__(__CFADD__(v25, v24), v25 + v24) + (unsigned __int64)v13 + v23) >> 64;
      a1[3] = v26;
      a1 += 4;
    }
    while ( a4 > 3 );
    a4 = v4 - v5;
    if ( v4 == (_DWORD)v5 )
      return v7;
    a3 += v5 + 4;
    a2 = v8;
    a1 = v9;
  }
  do
  {
    v29 = *a2;
    ++a2;
    v28 = v29;
    v30 = *a3;
    ++a3;
    --a4;
    v31 = v28 + (unsigned __int128)v7 + v30;
    v7 = v31 >> 64;
    *a1 = v31;
    ++a1;
  }
  while ( a4 );
  return v7;
}

//----- (000000000006A564) ----------------------------------------------------
__int64 __fastcall sub_6A564(__int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned int a4)
{
  int v4; // w8
  __int64 v5; // x13
  signed __int64 v6; // x11
  int v7; // w9
  unsigned __int64 *v8; // x10
  __int64 *v9; // x11
  unsigned __int64 *v10; // x14
  unsigned __int64 v11; // x15
  unsigned __int64 v12; // x16
  unsigned __int64 v13; // x17
  unsigned __int64 v14; // x18
  _BOOL4 v15; // w15
  unsigned __int64 v16; // x15
  unsigned __int64 v17; // x16
  _BOOL4 v18; // w17
  bool v19; // cf
  bool v20; // zf
  __int64 v21; // x15
  unsigned __int64 v22; // x15
  unsigned __int64 v23; // x17
  signed int v24; // w16
  bool v25; // zf
  __int64 v26; // x15
  signed int v27; // w16
  __int64 v28; // x15
  __int64 v29; // x8
  unsigned __int64 v31; // x10
  unsigned __int64 v32; // t1
  unsigned __int64 v33; // t1
  __int64 v34; // x8
  _BOOL4 v35; // w10
  __int64 v36; // x8

  if ( (signed int)a4 < 1 )
    return 0LL;
  if ( a4 <= 3 )
  {
    v29 = 0LL;
    v7 = 0;
  }
  else
  {
    v4 = a4 - 4;
    v5 = (a4 - 4) & 0xFFFFFFFC;
    v6 = v5 + 4;
    v7 = 0;
    v8 = &a2[v6];
    v9 = &a1[v6];
    v10 = a3;
    do
    {
      v11 = *a2;
      v12 = *v10;
      a4 -= 4;
      *a1 = *a2 - v7 - *v10;
      v13 = a2[1];
      v14 = v10[1];
      v20 = v11 == v12;
      v15 = v11 < v12;
      if ( !v20 )
        v7 = v15;
      v20 = v13 == v14;
      a1[1] = v13 - v14 - v7;
      v16 = a2[2];
      v17 = v10[2];
      v18 = v13 < v14;
      if ( !v20 )
        v7 = v18;
      v19 = v16 >= v17;
      v21 = v16 - v17;
      v20 = v21 == 0;
      a1[2] = v21 - v7;
      v22 = a2[3];
      v23 = v10[3];
      v24 = !v19;
      if ( !v20 )
        v7 = v24;
      a2 += 4;
      v19 = v22 >= v23;
      v26 = v22 - v23;
      v25 = v26 == 0;
      v27 = !v19;
      v28 = v26 - v7;
      v10 += 4;
      if ( !v25 )
        v7 = v27;
      a1[3] = v28;
      a1 += 4;
    }
    while ( a4 > 3 );
    a4 = v4 - v5;
    v29 = v7;
    if ( !a4 )
      return v29;
    a3 += v5 + 4;
    a2 = v8;
    a1 = v9;
  }
  do
  {
    v32 = *a2;
    ++a2;
    v31 = v32;
    v33 = *a3;
    ++a3;
    --a4;
    v34 = v31 - v29;
    v20 = v31 == v33;
    v35 = v31 < v33;
    v36 = v34 - v33;
    if ( !v20 )
      v7 = v35;
    *a1 = v36;
    ++a1;
    v29 = v7;
  }
  while ( a4 );
  return v29;
}

//----- (000000000006A684) ----------------------------------------------------
#error "6A684: too complex function (funcsize=518)"

//----- (000000000006AE9C) ----------------------------------------------------
_QWORD *__fastcall sub_6AE9C(_QWORD *result, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x10
  signed __int64 v5; // x8
  unsigned __int128 v6; // kr00_16
  unsigned __int128 v7; // kr10_16
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x12
  unsigned __int64 v10; // x13
  unsigned __int64 v11; // x14
  unsigned __int64 v12; // x11
  unsigned __int64 v13; // x15
  signed __int64 v14; // x16
  unsigned __int64 v15; // x17
  unsigned __int64 v16; // x10
  __int64 v17; // x13
  unsigned __int64 v18; // x12
  unsigned __int128 v19; // kr20_16
  unsigned __int64 v20; // x14
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x15
  __int64 v23; // x9
  signed __int64 v24; // x10
  signed __int64 v25; // x12
  signed __int64 v26; // x13
  signed __int64 v27; // x9
  signed __int64 v28; // x10
  unsigned __int128 v29; // kr30_16
  unsigned __int64 v30; // x9
  unsigned __int64 v31; // x11
  unsigned __int64 v32; // x12
  unsigned __int64 v33; // x13
  unsigned __int64 v34; // x14
  unsigned __int64 v35; // x15
  unsigned __int64 v36; // x16
  unsigned __int64 v37; // x17
  unsigned __int64 v38; // x18
  unsigned __int64 v39; // x3
  unsigned __int64 v40; // x12
  unsigned __int64 v41; // x13
  unsigned __int64 v42; // x11
  __int64 v43; // x12
  unsigned __int64 v44; // kr40_8
  __int64 v45; // x14
  unsigned __int64 v46; // x16
  unsigned __int64 v47; // x17
  unsigned __int64 v48; // x15
  unsigned __int128 v49; // kr50_16
  unsigned __int8 v50; // cf
  signed __int64 v51; // x10
  signed __int64 v52; // x12
  signed __int64 v53; // x13
  signed __int64 v54; // x10
  __int64 v55; // x9
  __int64 v56; // x9
  signed __int64 v57; // x10
  unsigned __int128 v58; // kr60_16
  unsigned __int64 v59; // x9
  unsigned __int64 v60; // x11
  unsigned __int64 v61; // x14
  unsigned __int64 v62; // x12
  unsigned __int64 v63; // x15
  unsigned __int64 v64; // x13
  unsigned __int64 v65; // x16
  unsigned __int64 v66; // x17
  unsigned __int64 v67; // x11
  __int64 v68; // x12
  unsigned __int64 v69; // x14
  unsigned __int128 v70; // kr70_16
  unsigned __int64 v71; // x15
  unsigned __int64 v72; // x13
  __int64 v73; // x12
  unsigned __int8 v74; // cf
  signed __int64 v75; // x10
  unsigned __int64 v76; // x9
  signed __int64 v77; // x11
  signed __int64 v78; // x14
  signed __int64 v79; // x10
  unsigned __int128 v80; // kr80_16
  signed __int64 v81; // x10
  unsigned __int128 v82; // kr90_16
  unsigned __int128 v83; // krA0_16
  unsigned __int8 v84; // cf
  signed __int64 v85; // x9
  unsigned __int64 v86; // x11
  unsigned __int64 v87; // x12
  signed __int64 v88; // x13
  signed __int64 v89; // x9
  __int64 v90; // x10
  unsigned __int64 v91; // x11

  v3 = *a2;
  v4 = *a3;
  *result = *a3 * *a2;
  v5 = 2LL;
  v6 = a3[1] * (unsigned __int128)*a2 + (unsigned __int64)(v4 * (unsigned __int128)v3 >> 64);
  v7 = *a3 * (unsigned __int128)a2[1] + (unsigned __int64)v6;
  result[1] = v7;
  v9 = a2[1];
  v8 = a2[2];
  v10 = *a3;
  v11 = a3[1];
  v12 = *a2;
  v13 = a3[2];
  if ( __CFADD__(*((_QWORD *)&v7 + 1), *((_QWORD *)&v6 + 1)) )
    v14 = 1LL;
  else
    v14 = 0LL;
  v15 = v10 * (unsigned __int128)v8 >> 64;
  v16 = v10 * v8;
  v17 = v11 * (unsigned __int128)v9 >> 64;
  v18 = v11 * v9;
  v19 = __PAIR__(v15, *((_QWORD *)&v7 + 1) + *((_QWORD *)&v6 + 1)) + v16;
  v20 = v13 * (unsigned __int128)v12 >> 64;
  v21 = v13 * v12;
  v22 = v19 + v18;
  v23 = __CFADD__((_QWORD)v19, v18) + v17;
  v24 = *((_QWORD *)&v19 + 1) + v14;
  if ( __CFADD__(*((_QWORD *)&v19 + 1), v14) )
    v25 = 1LL;
  else
    v25 = 0LL;
  if ( __CFADD__(*((_QWORD *)&v19 + 1), v14) )
    v26 = 2LL;
  else
    v26 = 1LL;
  v50 = __CFADD__(v23, v24);
  v27 = v23 + v24;
  if ( v50 )
    v28 = v26;
  else
    v28 = v25;
  v29 = __PAIR__(v20, v22) + v21;
  result[2] = v29;
  v50 = __CFADD__(v27, *((_QWORD *)&v29 + 1));
  v30 = v27 + *((_QWORD *)&v29 + 1);
  v31 = a3[2];
  v32 = a3[3];
  v33 = *a2;
  v34 = a2[1];
  v35 = *a3;
  v36 = a3[1];
  v37 = a2[2];
  v38 = a2[3];
  if ( v50 )
    ++v28;
  v39 = v32 * (unsigned __int128)v33 >> 64;
  v40 = v32 * v33;
  v41 = v31 * (unsigned __int128)v34 >> 64;
  v42 = v31 * v34;
  v44 = v30 + v40;
  v43 = (__PAIR__(v39, v30) + v40) >> 64;
  v45 = v36 * (unsigned __int128)v37 >> 64;
  v46 = v36 * v37;
  v47 = v35 * (unsigned __int128)v38 >> 64;
  v48 = v35 * v38;
  v49 = __PAIR__(v41, v44) + v42;
  v50 = __CFADD__(v28, v43);
  v51 = v28 + v43;
  if ( v50 )
    v52 = 1LL;
  else
    v52 = 0LL;
  if ( v50 )
    v53 = 2LL;
  else
    v53 = 1LL;
  v50 = __CFADD__(*((_QWORD *)&v49 + 1), v51);
  v54 = *((_QWORD *)&v49 + 1) + v51;
  if ( v50 )
    v52 = v53;
  v55 = __CFADD__((_QWORD)v49, v46) + v45;
  v50 = __CFADD__(v54, v55);
  v56 = v54 + v55;
  if ( v50 )
    v57 = v52 + 1;
  else
    v57 = v52;
  v58 = __PAIR__(v47, (unsigned __int64)v49 + v46) + v48;
  result[3] = v58;
  v50 = __CFADD__(v56, *((_QWORD *)&v58 + 1));
  v59 = v56 + *((_QWORD *)&v58 + 1);
  v61 = a2[2];
  v60 = a2[3];
  v62 = a3[1];
  v63 = a3[2];
  v64 = a2[1];
  v65 = a3[3];
  if ( v50 )
    ++v57;
  v66 = v62 * (unsigned __int128)v60 >> 64;
  v67 = v62 * v60;
  v68 = v63 * (unsigned __int128)v61 >> 64;
  v69 = v63 * v61;
  v70 = __PAIR__(v66, v59) + v67;
  v71 = v65 * (unsigned __int128)v64 >> 64;
  v72 = v65 * v64;
  v73 = __CFADD__((_QWORD)v70, v69) + v68;
  v74 = __CFADD__(v57, *((_QWORD *)&v70 + 1));
  v75 = v57 + *((_QWORD *)&v70 + 1);
  v76 = v70 + v69;
  if ( v74 )
    v77 = 1LL;
  else
    v77 = 0LL;
  if ( v74 )
    v78 = 2LL;
  else
    v78 = 1LL;
  v50 = __CFADD__(v73, v75);
  v79 = v73 + v75;
  if ( v50 )
    v77 = v78;
  v80 = __PAIR__(v71, v76) + v72;
  result[4] = v80;
  v50 = __CFADD__(v79, *((_QWORD *)&v80 + 1));
  v81 = v79 + *((_QWORD *)&v80 + 1);
  if ( v50 )
    ++v77;
  v82 = a3[3] * (unsigned __int128)a2[2] + (unsigned __int64)v81;
  v83 = (unsigned __int64)v82 + a3[2] * (unsigned __int128)a2[3];
  result[5] = v83;
  v84 = __CFADD__(v77, *((_QWORD *)&v82 + 1));
  v85 = v77 + *((_QWORD *)&v82 + 1);
  v86 = a2[3];
  v87 = a3[3];
  if ( v84 )
    v88 = 1LL;
  else
    v88 = 0LL;
  if ( !v84 )
    v5 = 1LL;
  v50 = __CFADD__(*((_QWORD *)&v83 + 1), v85);
  v89 = *((_QWORD *)&v83 + 1) + v85;
  v90 = v87 * (unsigned __int128)v86 >> 64;
  v91 = v87 * v86;
  if ( !v50 )
    v5 = v88;
  result[6] = v89 + v91;
  result[7] = __CFADD__(v89, v91) + v90 + v5;
  return result;
}

//----- (000000000006B094) ----------------------------------------------------
#error "6B094: too complex function (funcsize=422)"

//----- (000000000006B72C) ----------------------------------------------------
_QWORD *__fastcall sub_6B72C(_QWORD *result, unsigned __int64 *a2)
{
  unsigned __int64 v2; // x9
  unsigned __int64 v3; // x11
  signed __int64 v4; // x8
  __int64 v5; // x12
  unsigned __int64 v6; // x10
  unsigned __int128 v7; // kr00_16
  __int64 v8; // x10
  unsigned __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x11
  signed __int64 v12; // x13
  unsigned __int64 v13; // x15
  unsigned __int128 v14; // t0
  unsigned __int64 v15; // x9
  unsigned __int128 v16; // kr10_16
  __int64 v17; // x10
  unsigned __int8 v18; // cf
  signed __int64 v19; // x11
  signed __int64 v20; // x13
  signed __int64 v21; // x14
  signed __int64 v22; // x10
  signed __int64 v23; // x11
  unsigned __int128 v24; // kr30_16
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x13
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x12
  unsigned __int64 v29; // x14
  unsigned __int64 v30; // x15
  unsigned __int64 v31; // x13
  __int64 v32; // x14
  unsigned __int64 v33; // x9
  __int64 v34; // x12
  unsigned __int128 v35; // kr50_16
  unsigned __int8 v36; // cf
  signed __int64 v37; // x11
  signed __int64 v38; // x12
  signed __int64 v39; // x15
  signed __int64 v40; // x11
  __int64 v41; // x13
  __int64 v42; // x10
  __int64 v43; // x10
  signed __int64 v44; // x11
  unsigned __int64 v45; // x9
  unsigned __int64 v46; // x13
  __int64 v47; // x12
  unsigned __int64 v48; // x10
  unsigned __int64 v49; // x12
  unsigned __int64 v50; // x14
  unsigned __int64 v51; // x13
  __int64 v52; // x15
  unsigned __int128 v53; // t0
  unsigned __int64 v54; // x9
  unsigned __int128 v55; // kr60_16
  unsigned __int128 v56; // kr70_16
  unsigned __int8 v57; // cf
  signed __int64 v58; // x11
  signed __int64 v59; // x12
  signed __int64 v60; // x14
  signed __int64 v61; // x11
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x12
  __int64 v64; // x13
  unsigned __int128 v65; // t0
  unsigned __int64 v66; // x9
  unsigned __int128 v67; // kr80_16
  unsigned __int128 v68; // kr90_16
  unsigned __int8 v69; // cf
  signed __int64 v70; // x9
  unsigned __int64 v71; // x11
  signed __int64 v72; // x12
  signed __int64 v73; // x9
  __int64 v74; // x10
  unsigned __int64 v75; // x11

  v2 = *a2;
  *result = v2 * v2;
  v3 = a2[1];
  v4 = 2LL;
  v5 = *a2 * (unsigned __int128)v3 >> 64;
  v6 = *a2 * v3;
  v7 = *a2 * (unsigned __int128)v3 + (unsigned __int64)(v2 * (unsigned __int128)v2 >> 64);
  result[1] = v7 + v6;
  v8 = __CFADD__((_QWORD)v7, v6) + v5;
  v9 = *a2;
  v18 = __CFADD__(v8, *((_QWORD *)&v7 + 1));
  v10 = v8 + *((_QWORD *)&v7 + 1);
  v11 = a2[2];
  if ( v18 )
    v12 = 1LL;
  else
    v12 = 0LL;
  v14 = v9 * (unsigned __int128)v11;
  v13 = *((_QWORD *)&v14 + 1);
  v15 = v9 * v11;
  v16 = a2[1] * (unsigned __int128)a2[1] + (unsigned __int64)v10;
  v17 = ((unsigned __int64)v16 + __PAIR__(*((unsigned __int64 *)&v14 + 1), v15)) >> 64;
  v18 = __CFADD__(*((_QWORD *)&v16 + 1), v12);
  v19 = *((_QWORD *)&v16 + 1) + v12;
  if ( __CFADD__(*((_QWORD *)&v16 + 1), v12) )
    v20 = 1LL;
  else
    v20 = 0LL;
  if ( v18 )
    v21 = 2LL;
  else
    v21 = 1LL;
  v18 = __CFADD__(v17, v19);
  v22 = v17 + v19;
  if ( v18 )
    v23 = v21;
  else
    v23 = v20;
  v24 = __PAIR__(v13, (unsigned __int64)v16 + v15) + v15;
  result[2] = v24;
  v25 = a2[2];
  v26 = a2[3];
  v18 = __CFADD__(v22, *((_QWORD *)&v24 + 1));
  v27 = v22 + *((_QWORD *)&v24 + 1);
  v29 = *a2;
  v28 = a2[1];
  if ( v18 )
    ++v23;
  v30 = v29 * (unsigned __int128)v26 >> 64;
  v31 = v29 * v26;
  v32 = v28 * (unsigned __int128)v25 >> 64;
  v33 = v28 * v25;
  v34 = (__PAIR__(v30, v27) + v31) >> 64;
  v35 = __PAIR__(v30, v27 + v31) + v31;
  v36 = __CFADD__(v23, v34);
  v37 = v23 + v34;
  if ( v36 )
    v38 = 1LL;
  else
    v38 = 0LL;
  if ( v36 )
    v39 = 2LL;
  else
    v39 = 1LL;
  v18 = __CFADD__(*((_QWORD *)&v35 + 1), v37);
  v40 = *((_QWORD *)&v35 + 1) + v37;
  if ( v18 )
    v38 = v39;
  v41 = v35 + v33;
  v42 = __CFADD__((_QWORD)v35, v33) + v32;
  v18 = __CFADD__(v40, v42);
  v43 = v40 + v42;
  if ( v18 )
    v44 = v38 + 1;
  else
    v44 = v38;
  v18 = __CFADD__(v41, v33);
  result[3] = v41 + v33;
  v45 = a2[1];
  v46 = a2[2];
  v47 = v18 + v32;
  v18 = __CFADD__(v43, v47);
  v48 = v43 + v47;
  v49 = a2[3];
  v50 = v46 * (unsigned __int128)v46 >> 64;
  v51 = v46 * v46;
  if ( v18 )
    ++v44;
  v53 = v45 * (unsigned __int128)v49;
  v52 = *((_QWORD *)&v53 + 1);
  v54 = v45 * v49;
  v55 = __PAIR__(v50, v48) + v51;
  v56 = (unsigned __int64)v55 + __PAIR__(*((unsigned __int64 *)&v53 + 1), v54);
  v57 = __CFADD__(v44, *((_QWORD *)&v55 + 1));
  v58 = v44 + *((_QWORD *)&v55 + 1);
  if ( v57 )
    v59 = 1LL;
  else
    v59 = 0LL;
  if ( v57 )
    v60 = 2LL;
  else
    v60 = 1LL;
  if ( __CFADD__(*((_QWORD *)&v56 + 1), v58) )
    v61 = v60;
  else
    v61 = v59;
  v18 = __CFADD__((_QWORD)v56, v54);
  result[4] = v56 + v54;
  v62 = a2[2];
  v63 = a2[3];
  v64 = v18 + v52;
  if ( __CFADD__(*((_QWORD *)&v56 + 1), v64) )
    ++v61;
  v65 = v62 * (unsigned __int128)v63;
  v66 = v62 * v63;
  v67 = (unsigned __int64)(*((_QWORD *)&v56 + 1) + v64) + __PAIR__(*((unsigned __int64 *)&v65 + 1), v66);
  v68 = (unsigned __int64)v67 + __PAIR__(*((unsigned __int64 *)&v65 + 1), v66);
  result[5] = v68;
  v69 = __CFADD__(v61, *((_QWORD *)&v67 + 1));
  v70 = v61 + *((_QWORD *)&v67 + 1);
  v71 = a2[3];
  if ( v69 )
    v72 = 1LL;
  else
    v72 = 0LL;
  if ( !v69 )
    v4 = 1LL;
  v18 = __CFADD__(*((_QWORD *)&v68 + 1), v70);
  v73 = *((_QWORD *)&v68 + 1) + v70;
  v74 = v71 * (unsigned __int128)v71 >> 64;
  v75 = v71 * v71;
  if ( !v18 )
    v4 = v72;
  result[6] = v73 + v75;
  result[7] = __CFADD__(v73, v75) + v74 + v4;
  return result;
}

//----- (000000000006B8CC) ----------------------------------------------------
_QWORD *BN_MONT_CTX_new()
{
  _QWORD *v0; // x0
  _QWORD *v1; // x19

  v0 = malloc(0x40uLL);
  v1 = v0;
  if ( v0 )
  {
    v0[6] = 0LL;
    v0[7] = 0LL;
    v0[4] = 0LL;
    v0[5] = 0LL;
    v0[1] = 0LL;
    v0[2] = 0LL;
    *v0 = 0LL;
    v0[3] = 0LL;
    BN_init(v0);
    BN_init(v1 + 3);
  }
  return v1;
}

//----- (000000000006B920) ----------------------------------------------------
void __fastcall BN_MONT_CTX_free(_DWORD *a1)
{
  _DWORD *v1; // x19

  v1 = a1;
  if ( a1 )
  {
    BN_free(a1);
    BN_free(v1 + 6);
    free(v1);
  }
}

//----- (000000000006B960) ----------------------------------------------------
__int64 __fastcall BN_MONT_CTX_copy(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19

  v2 = a2;
  v3 = a1;
  if ( a1 != a2 )
  {
    if ( BN_copy(a1, a2) && BN_copy(v3 + 24, v2 + 24) )
    {
      *(_QWORD *)(v3 + 48) = *(_QWORD *)(v2 + 48);
      *(_QWORD *)(v3 + 56) = *(_QWORD *)(v2 + 56);
    }
    else
    {
      v3 = 0LL;
    }
  }
  return v3;
}

//----- (000000000006B9C4) ----------------------------------------------------
bool __fastcall BN_MONT_CTX_set(__int64 a1, __int64 a2)
{
  __int64 **v2; // x20
  __int64 v3; // x19
  int v4; // w2
  __int16 v5; // w4
  int v7; // w0

  v2 = (__int64 **)a2;
  v3 = a1;
  if ( BN_is_zero(a2) )
  {
    v4 = 105;
    v5 = 178;
LABEL_3:
    ERR_put_error(3, 0LL, v4, (__int64)"external/boringssl/src/crypto/bn/montgomery.c", v5);
    return 0LL;
  }
  if ( !(unsigned int)BN_is_odd((__int64)v2) )
  {
    v4 = 104;
    v5 = 182;
    goto LABEL_3;
  }
  if ( BN_is_negative((__int64)v2) )
  {
    v4 = 109;
    v5 = 186;
    goto LABEL_3;
  }
  if ( !BN_copy(v3 + 24, (__int64)v2) )
  {
    v4 = 68;
    v5 = 192;
    goto LABEL_3;
  }
  *(_QWORD *)(v3 + 48) = sub_6C0A4(v2);
  *(_QWORD *)(v3 + 56) = 0LL;
  v7 = BN_num_bits((__int64)v2);
  return (unsigned int)sub_6C0E8(v3, (2 * v7 + 126) & 0xFFFFFF80, v3 + 24) != 0;
}

//----- (000000000006BAC4) ----------------------------------------------------
bool __fastcall sub_6BAC4(__int64 *a1, pthread_rwlock_t *a2, __int64 a3)
{
  pthread_rwlock_t *v3; // x19
  __int64 *v4; // x20
  __int64 v5; // x22
  __int64 v6; // x21
  __int64 v8; // x21
  _QWORD *v9; // x0

  v3 = a2;
  v4 = a1;
  v5 = a3;
  CRYPTO_STATIC_MUTEX_lock_read(a2);
  v6 = *v4;
  CRYPTO_STATIC_MUTEX_unlock_write(v3);
  if ( v6 )
    return 1LL;
  CRYPTO_STATIC_MUTEX_lock_write(v3);
  v8 = *v4;
  if ( !*v4 )
  {
    v9 = malloc(0x40uLL);
    v8 = (__int64)v9;
    if ( v9 )
    {
      v9[6] = 0LL;
      v9[7] = 0LL;
      v9[4] = 0LL;
      v9[5] = 0LL;
      v9[1] = 0LL;
      v9[2] = 0LL;
      *v9 = 0LL;
      v9[3] = 0LL;
      BN_init(v9);
      BN_init((_QWORD *)(v8 + 24));
      if ( BN_MONT_CTX_set(v8, v5) )
      {
        *v4 = v8;
      }
      else
      {
        BN_free((_DWORD *)v8);
        BN_free((_DWORD *)(v8 + 24));
        free((void *)v8);
        v8 = 0LL;
      }
    }
  }
  CRYPTO_STATIC_MUTEX_unlock_write(v3);
  return v8 != 0;
}

//----- (000000000006BBA8) ----------------------------------------------------
__int64 __fastcall BN_to_montgomery(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return BN_mod_mul_montgomery(a1, a2, a3, a3, a4);
}

//----- (000000000006BBB8) ----------------------------------------------------
__int64 __fastcall BN_mod_mul_montgomery(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x21
  signed int v6; // w24
  __int64 v7; // x20
  __int64 v8; // x23
  __int64 v9; // x22
  __int64 v10; // x19
  int v11; // w8
  int v12; // w9
  _BOOL4 v13; // w19
  _QWORD *v14; // x0
  __int64 v15; // x24

  v5 = a4;
  v6 = *(_DWORD *)(a4 + 32);
  v7 = a5;
  v8 = a3;
  v9 = a2;
  v10 = a1;
  if ( v6 < 2 || *(_DWORD *)(a2 + 8) != v6 || *(_DWORD *)(a3 + 8) != v6 )
  {
    BN_CTX_start(a5);
    v14 = BN_CTX_get(v7);
    v15 = (__int64)v14;
    if ( v14 )
    {
      if ( v9 == v8 )
      {
        if ( !(unsigned int)BN_sqr((__int64)v14, v9, v7) )
        {
          v13 = 0;
          goto LABEL_13;
        }
      }
      else if ( !(unsigned int)BN_mul((__int64)v14, v9, v8, v7) )
      {
        goto LABEL_10;
      }
      v13 = (unsigned __int64)sub_6BD98(v10, v15, v5) != 0;
      goto LABEL_13;
    }
LABEL_10:
    v13 = 0;
LABEL_13:
    BN_CTX_end(v7);
    return (unsigned int)v13;
  }
  if ( bn_wexpand(a1, v6) )
  {
    if ( (unsigned int)sub_9B640(
                         *(_QWORD *)v10,
                         *(_QWORD *)v9,
                         *(_QWORD *)v8,
                         *(_QWORD *)(v5 + 24),
                         v5 + 48,
                         (unsigned int)v6) )
    {
      v11 = *(_DWORD *)(v9 + 16);
      v12 = *(_DWORD *)(v8 + 16);
      *(_DWORD *)(v10 + 8) = v6;
      *(_DWORD *)(v10 + 16) = v12 ^ v11;
      bn_correct_top(v10);
      v13 = 1;
    }
    else
    {
      ERR_put_error(3, 0LL, 68, (__int64)"external/boringssl/src/crypto/bn/montgomery.c", 387);
      v13 = 0;
    }
  }
  else
  {
    v13 = 0;
  }
  return (unsigned int)v13;
}
// 9B640: using guessed type __int64 __fastcall sub_9B640(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000006BD10) ----------------------------------------------------
__int64 __fastcall BN_from_montgomery(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x21
  __int64 v6; // x20
  __int64 v7; // x22
  _QWORD *v8; // x0
  __int64 v9; // x23
  unsigned int v10; // w20

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  BN_CTX_start(a4);
  v8 = BN_CTX_get(v4);
  v9 = (__int64)v8;
  if ( v8 && BN_copy((__int64)v8, v7) )
    v10 = sub_6BD98(v5, v9, v6);
  else
    v10 = 0;
  BN_CTX_end(v4);
  return v10;
}

//----- (000000000006BD98) ----------------------------------------------------
__int64 __fastcall sub_6BD98(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x24
  signed int v4; // w22
  __int64 v5; // x20
  __int64 v6; // x19
  int v7; // w26
  __int64 result; // x0
  __int64 v9; // x8
  _QWORD *v10; // x23
  unsigned __int64 *v11; // x25
  unsigned __int64 v12; // x28
  __int64 v13; // x24
  signed __int64 v14; // x27
  signed int v15; // w26
  __int64 v16; // x0
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x9
  __int64 *v19; // x23
  _QWORD *v20; // x27
  unsigned __int64 v21; // x24
  __int64 v22; // x0
  unsigned __int64 v23; // x8
  signed __int64 v24; // x9
  signed __int64 v25; // x10
  unsigned __int64 v26; // x10
  signed __int64 v27; // x11
  signed __int64 v28; // x12
  signed __int64 v29; // x10
  signed __int64 v30; // x13
  unsigned __int64 v31; // x13
  unsigned __int64 v32; // x14
  signed __int64 v33; // x13
  char *v34; // x16
  unsigned __int64 v35; // x14
  unsigned __int64 v36; // x17
  bool v37; // w18
  bool v38; // w13
  bool v39; // w16
  signed __int64 v40; // x13
  double *v41; // x14
  const double *v42; // x15
  __int64 v43; // x9
  signed __int64 v44; // x13
  _QWORD *v45; // x11
  _QWORD *v46; // x12
  __int64 *v47; // x13
  __int64 v48; // x14
  __int64 v49; // x15
  __int64 v50; // x16
  __int64 v51; // x17
  __int64 v52; // x11
  __int64 v53; // x9
  __int64 *v54; // x8
  _QWORD *v55; // x9
  _QWORD *v56; // x10
  __int64 v57; // x11
  __int64 v58; // t1
  float64x2x4_t v59; // 0:q1.16,16:q2.16,32:q3.16,48:q4.16

  v3 = a3;
  v4 = *(_DWORD *)(a3 + 32);
  v5 = a2;
  v6 = a1;
  if ( !v4 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    return 1LL;
  }
  v7 = 2 * v4;
  result = bn_wexpand(a2, 2LL * v4);
  if ( result )
  {
    v9 = *(signed int *)(v5 + 8);
    v10 = *(_QWORD **)v5;
    *(_DWORD *)(v5 + 16) ^= *(_DWORD *)(v3 + 40);
    v11 = *(unsigned __int64 **)(v3 + 24);
    if ( v7 > (signed int)v9 && v7 != (_DWORD)v9 )
      memset(&v10[v9], 0, (signed __int64)((unsigned __int64)(unsigned int)(2 * v4 - v9) << 32) >> 29);
    v12 = 0LL;
    *(_DWORD *)(v5 + 8) = v7;
    if ( v4 >= 1 )
    {
      v13 = *(_QWORD *)(v3 + 48);
      v14 = v4;
      v15 = v4;
      do
      {
        v16 = sub_6A110(v10, v11, v4, *v10 * v13);
        v17 = v10[v14];
        v18 = v16 + v12 + v17;
        v10[v14] = v18;
        ++v10;
        v12 = ((v16 + v12 != 0) | (unsigned int)v12) & (unsigned __int64)(v18 <= v17);
        --v15;
      }
      while ( v15 );
    }
    result = bn_wexpand(v6, v4);
    if ( result )
    {
      *(_DWORD *)(v6 + 8) = v4;
      v19 = *(__int64 **)v6;
      *(_DWORD *)(v6 + 16) = *(_DWORD *)(v5 + 16);
      v20 = *(_QWORD **)v5;
      v21 = *(_QWORD *)v5 + 8LL * v4;
      v22 = sub_6A564(v19, (unsigned __int64 *)v21, v11, v4);
      v23 = (unsigned __int64)v19 & ~(v12 - v22) | v21 & (v12 - v22);
      if ( v4 < 5 )
      {
        v43 = 0LL;
        if ( v4 > 0 )
          goto LABEL_32;
        goto LABEL_34;
      }
      v24 = v4 - 4LL;
      v25 = 4LL;
      if ( v24 > 4 )
        v25 = v4 - 4LL;
      v26 = (unsigned __int64)(v25 - 1) >> 2;
      v27 = v26 + 1;
      if ( v26 != 0 && v26 < 0xFFFFFFFFFFFFFFFFLL && (v28 = v27 & 0x7FFFFFFFFFFFFFFELL) != 0 )
      {
        v29 = 0LL;
        v30 = 4LL;
        if ( v24 > 4 )
          v30 = v4 - 4LL;
        v31 = (v30 - 1) & 0xFFFFFFFFFFFFFFFCLL;
        v32 = v31 + v4;
        v33 = 8 * v31 + 32;
        v34 = (char *)v19 + v33;
        v35 = (unsigned __int64)&v20[v32 + 4];
        v36 = v23 + v33;
        v37 = v21 < (unsigned __int64)v19 + v33 && (unsigned __int64)v19 < v35;
        v38 = v21 < v23 + v33;
        v39 = v23 < (unsigned __int64)v34;
        if ( !v37 && (!v38 || v23 >= v35) && ((unsigned __int64)v19 >= v36 || !v39) )
        {
          v29 = 4 * v28;
          v40 = v27 & 0x7FFFFFFFFFFFFFFELL;
          v41 = (double *)v19;
          v42 = (const double *)((unsigned __int64)v19 & ~(v12 - v22) | v21 & (v12 - v22));
          do
          {
            v59 = vld4q_f64(v42);
            v42 += 8;
            *(_OWORD *)(v21 + 32) = 0uLL;
            *(_OWORD *)(v21 + 48) = 0uLL;
            *(_OWORD *)v21 = 0uLL;
            *(_OWORD *)(v21 + 16) = 0uLL;
            v21 += 64LL;
            v40 -= 2LL;
            vst4q_f64(v41, v59);
            v41 += 8;
          }
          while ( v40 );
          if ( v27 == v28 )
          {
LABEL_31:
            v43 = (v4 - 1) & 0xFFFFFFFC;
            if ( (signed int)v43 < v4 )
            {
LABEL_32:
              v52 = (signed int)v43;
              v53 = v43 << 32 >> 29;
              v54 = (__int64 *)(v23 + v53);
              v55 = (__int64 *)((char *)v19 + v53);
              v56 = &v20[v52 + v4];
              v57 = v4 - v52;
              do
              {
                v58 = *v54;
                ++v54;
                --v57;
                *v55 = v58;
                ++v55;
                *v56 = 0LL;
                ++v56;
              }
              while ( v57 );
            }
LABEL_34:
            bn_correct_top(v5);
            bn_correct_top(v6);
            return 1LL;
          }
        }
      }
      else
      {
        v29 = 0LL;
      }
      v44 = 8 * v29 + 16;
      v45 = &v20[v29 + 2 + v4];
      v46 = (__int64 *)((char *)v19 + v44);
      v47 = (__int64 *)(v23 + v44);
      do
      {
        v48 = *(v47 - 2);
        v49 = *(v47 - 1);
        v50 = *v47;
        *(v45 - 2) = 0LL;
        v51 = v47[1];
        v29 += 4LL;
        *(v45 - 1) = 0LL;
        v47 += 4;
        *(v46 - 2) = v48;
        *v45 = 0LL;
        *(v46 - 1) = v49;
        v45[1] = 0LL;
        v45 += 4;
        *v46 = v50;
        v46[1] = v51;
        v46 += 4;
      }
      while ( v29 < v24 );
      goto LABEL_31;
    }
  }
  return result;
}

//----- (000000000006C0A4) ----------------------------------------------------
unsigned __int64 __fastcall sub_6C0A4(__int64 **a1)
{
  __int64 *v1; // x8
  unsigned __int64 result; // x0
  signed __int64 v3; // x9
  signed __int64 v4; // x10
  __int64 v5; // x8
  signed __int64 v6; // x11

  v1 = *a1;
  result = 0LL;
  v3 = 1LL;
  v4 = 64LL;
  v5 = *v1;
  do
  {
    v6 = -(v3 & 1);
    result = v6 & 0x8000000000000000LL | (result >> 1) & 0x7FFFFFFFFFFFFFFFLL;
    v3 = (v5 & v6 & v3) + ((v5 & v6 ^ (unsigned __int64)v3) >> 1);
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (000000000006C0E8) ----------------------------------------------------
__int64 __fastcall sub_6C0E8(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // x19
  unsigned int v4; // w20
  __int64 v5; // x21
  unsigned int v6; // w22
  __int64 result; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  BN_zero(a1);
  v6 = BN_num_bits(v3);
  if ( v6 == 1 )
    return 1LL;
  result = BN_set_bit(v5, v6);
  if ( (_DWORD)result )
  {
    result = BN_usub(v5, v5, v3);
    if ( (_DWORD)result )
    {
      while ( v6 < v4 )
      {
        result = BN_lshift1(v5, v5);
        if ( !(_DWORD)result )
          return result;
        if ( !(BN_cmp(v5, v3) & 0x80000000) )
        {
          result = BN_usub(v5, v5, v3);
          if ( !(_DWORD)result )
            return result;
        }
        ++v6;
      }
      return 1LL;
    }
  }
  return result;
}

//----- (000000000006C19C) ----------------------------------------------------
__int64 __fastcall BN_mul(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // x23
  signed int v5; // w25
  __int64 v6; // x19
  _QWORD *v7; // x22
  __int64 v8; // x20
  signed int v9; // w24
  _QWORD *v10; // x21
  int v11; // w8
  unsigned int v12; // w20
  int v13; // w28
  signed int v14; // w8
  char v15; // w26
  __int64 **v16; // x0
  __int64 **v17; // x27
  signed int v18; // w26
  int v20; // [xsp+Ch] [xbp-54h]

  v4 = (_QWORD *)a2;
  v5 = *(_DWORD *)(a2 + 8);
  v6 = a4;
  v7 = (_QWORD *)a3;
  v8 = a1;
  if ( v5 )
  {
    v9 = *(_DWORD *)(a3 + 8);
    if ( v9 )
    {
      BN_CTX_start(a4);
      if ( (_QWORD *)v8 == v4 || (v10 = (_QWORD *)v8, (_QWORD *)v8 == v7) )
      {
        v10 = BN_CTX_get(v6);
        if ( !v10 )
          goto LABEL_31;
      }
      v11 = v5 - v9;
      *((_DWORD *)v10 + 4) = *((_DWORD *)v7 + 4) ^ *((_DWORD *)v4 + 4);
      if ( v5 != 8 || v5 != v9 )
      {
        v13 = v9 + v5;
        if ( v5 < 16 || v9 < 16 || (unsigned int)(v11 + 1) > 2 )
        {
          if ( !bn_wexpand((__int64)v10, v13) )
            goto LABEL_31;
          *((_DWORD *)v10 + 2) = v13;
          sub_6CD30((_QWORD *)*v10, (unsigned __int64 *)*v4, v5, (unsigned __int64 *)*v7, v9);
        }
        else
        {
          if ( v11 < 0 )
            v14 = v9;
          else
            v14 = v5;
          v15 = BN_num_bits_word(v14);
          v16 = (__int64 **)BN_CTX_get(v6);
          v17 = v16;
          if ( !v16 )
            goto LABEL_31;
          v18 = 1 << (v15 - 1);
          v20 = v5 - v18;
          if ( v5 > v18 || v9 > v18 )
          {
            if ( !bn_wexpand((__int64)v16, 8 * v18) || !bn_wexpand((__int64)v10, 8 * v18) )
              goto LABEL_31;
            sub_6C3EC(
              (unsigned __int64 *)*v10,
              (unsigned __int64 *)*v4,
              (unsigned __int64 *)*v7,
              v18,
              v20,
              v9 - v18,
              *v17);
            *((_DWORD *)v10 + 2) = v13;
          }
          else
          {
            if ( !bn_wexpand((__int64)v16, 4 * v18) || !bn_wexpand((__int64)v10, 4 * v18) )
              goto LABEL_31;
            sub_6C8BC((_QWORD *)*v10, (unsigned __int64 *)*v4, (unsigned __int64 *)*v7, v18, v20, v9 - v18, *v17);
            *((_DWORD *)v10 + 2) = v13;
          }
        }
      }
      else
      {
        if ( !bn_wexpand((__int64)v10, 0x10uLL) )
          goto LABEL_31;
        *((_DWORD *)v10 + 2) = 16;
        sub_6A684(*v10, *v4, *v7);
      }
      bn_correct_top((__int64)v10);
      if ( v10 == (_QWORD *)v8 || BN_copy(v8, (__int64)v10) )
      {
        v12 = 1;
LABEL_32:
        BN_CTX_end(v6);
        return v12;
      }
LABEL_31:
      v12 = 0;
      goto LABEL_32;
    }
  }
  BN_zero(a1);
  return 1;
}
// 6A684: using guessed type __int64 __fastcall sub_6A684(_QWORD, _QWORD, _QWORD);

//----- (000000000006C3EC) ----------------------------------------------------
unsigned __int64 __fastcall sub_6C3EC(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, signed int a4, int a5, int a6, __int64 *a7)
{
  __int64 *v7; // x21
  int v8; // w22
  signed int v9; // w23
  signed int v10; // w25
  unsigned __int64 *v11; // x27
  unsigned __int64 *v12; // x28
  unsigned __int64 *v13; // x19
  unsigned __int64 result; // x0
  signed __int64 v15; // x24
  signed int v16; // w26
  int v17; // w20
  unsigned __int64 *v18; // x2
  __int64 v19; // x26
  signed int v20; // w4
  unsigned __int64 *v21; // x1
  unsigned int v22; // w3
  unsigned __int64 *v23; // x1
  unsigned __int64 *v24; // x2
  unsigned int v25; // w3
  signed int v26; // w4
  __int64 v27; // x25
  __int64 *v28; // x24
  unsigned __int64 *v29; // x1
  unsigned int v30; // w28
  unsigned __int64 *v31; // x27
  __int64 *v32; // x24
  signed int v33; // w25
  int v34; // w8
  int v35; // w8
  signed int v36; // w20
  __int64 *v37; // x20
  signed int v38; // w8
  int v39; // w22
  int v40; // w20
  int v41; // w9
  unsigned __int64 v42; // x11
  signed __int64 *v43; // x8
  signed __int64 v44; // x9
  signed int v45; // [xsp+Ch] [xbp-74h]
  __int64 v46; // [xsp+10h] [xbp-70h]
  __int64 v47; // [xsp+18h] [xbp-68h]
  unsigned __int64 *v48; // [xsp+20h] [xbp-60h]
  unsigned __int64 *v49; // [xsp+28h] [xbp-58h]

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  if ( a4 <= 7 )
    return sub_6CD30(a1, a2, a5 + a4, a3, a6 + a4);
  v15 = (signed __int64)((unsigned __int64)(unsigned int)a4 << 32) >> 29;
  v16 = a4 - a5;
  v46 = (unsigned int)(2 * a4);
  v47 = a4;
  v49 = (unsigned __int64 *)((char *)a2 + v15);
  v17 = sub_657B8((__int64)a2, (__int64)a2 + v15, a5, a4 - a5);
  v48 = (unsigned __int64 *)((char *)v11 + v15);
  switch ( 3 * v17 + (unsigned int)sub_657B8((__int64)v11 + v15, (__int64)v11, v8, v8 - v10) + 4 )
  {
    case 0u:
      sub_6D40C(v7, v49, v12, v9, v9 - v10);
      v19 = v10;
      v24 = (unsigned __int64 *)((char *)v11 + v15);
      v26 = v10 - v8;
      v23 = v11;
      v25 = v8;
      goto LABEL_11;
    case 1u:
    case 2u:
      sub_6D40C(v7, v49, v12, v9, v9 - v10);
      v19 = v10;
      v21 = (unsigned __int64 *)((char *)v11 + v15);
      v18 = v11;
      v22 = v8;
      v20 = v8 - v10;
      goto LABEL_6;
    case 3u:
    case 4u:
    case 5u:
    case 6u:
      sub_6D40C(v7, v12, v49, v9, v16);
      v19 = v10;
      v18 = (unsigned __int64 *)((char *)v11 + v15);
      v20 = v10 - v8;
      v21 = v11;
      v22 = v8;
LABEL_6:
      sub_6D40C(&v7[v19], v21, v18, v22, v20);
      v45 = 1;
      if ( v10 != 8 )
        goto LABEL_15;
      goto LABEL_13;
    case 7u:
    case 8u:
      sub_6D40C(v7, v12, v49, v9, v16);
      v19 = v10;
      v23 = (unsigned __int64 *)((char *)v11 + v15);
      v24 = v11;
      v25 = v8;
      v26 = v8 - v10;
LABEL_11:
      sub_6D40C(&v7[v19], v23, v24, v25, v26);
      break;
    default:
      v19 = v10;
      break;
  }
  v45 = 0;
  if ( v10 == 8 )
  {
LABEL_13:
    v27 = v46 << 32 >> 29;
    v28 = (__int64 *)((char *)v7 + v27);
    sub_6A684((char *)v7 + v27, v7, &v7[v19]);
    v29 = v12;
    v30 = v46;
    sub_6A684(v13, v29, v11);
    v31 = (unsigned __int64 *)((char *)v13 + v27);
    sub_6CD30((unsigned __int64 *)((char *)v13 + v27), v49, v9, v48, v8);
    if ( (_DWORD)v46 - v9 != v8 )
      memset(
        &v13[(signed int)v46 + v9 + v8],
        0,
        (signed __int64)((unsigned __int64)(unsigned int)(v46 - v9 - v8) << 32) >> 29);
  }
  else
  {
LABEL_15:
    v32 = &v7[4 * v19];
    sub_6C8BC(&v7[(signed int)v46], (unsigned __int64 *)v7, (unsigned __int64 *)&v7[v19], v10, 0, 0, &v7[4 * v19]);
    sub_6C8BC(v13, v12, v11, v10, 0, 0, v32);
    v33 = (unsigned int)v10 >> 1;
    if ( v9 <= v8 )
      v34 = v8;
    else
      v34 = v9;
    v35 = v34 - v33;
    if ( !v35 )
    {
      v31 = &v13[(signed int)v46];
      sub_6C8BC(&v13[(signed int)v46], v49, v48, v33, v9 - v33, v8 - v33, v32);
      v30 = v46;
      if ( (_DWORD)v46 != 2 * v33 )
        memset(
          &v13[2 * v33 + (signed int)v46],
          0,
          (signed __int64)((unsigned __int64)(unsigned int)(v46 - 2 * v33) << 32) >> 29);
      v19 = v47;
      v36 = v45;
      v28 = &v7[(signed int)v46];
      goto LABEL_41;
    }
    v31 = &v13[(signed int)v46];
    if ( v35 < 1 )
    {
      v37 = &v7[4 * v19];
      memset(&v13[(signed int)v46], 0, 8LL * (signed int)v46);
      v30 = v46;
      v28 = &v7[(signed int)v46];
      if ( v9 > 15 )
      {
        v19 = v47;
LABEL_31:
        while ( 1 )
        {
          v38 = v33 >= 0 ? v33 : v33 + 1;
          v33 = v38 >> 1;
          if ( v38 >> 1 < v9 || v33 < v8 )
            break;
          if ( v33 == v9 || v33 == v8 )
          {
            sub_6C8BC(v31, v49, v48, v33, v9 - v33, v8 - v33, v37);
            goto LABEL_40;
          }
        }
        sub_6C3EC(v31, v49, v48, (unsigned int)v33, (unsigned int)(v9 - v33), (unsigned int)(v8 - v33), v37);
      }
      else
      {
        v19 = v47;
        if ( v8 >= 16 )
          goto LABEL_31;
        sub_6CD30(v31, v49, v9, v48, v8);
      }
    }
    else
    {
      sub_6C3EC(
        &v13[(signed int)v46],
        v49,
        v48,
        (unsigned int)v33,
        (unsigned int)(v9 - v33),
        (unsigned int)(v8 - v33),
        v32);
      v30 = v46;
      v28 = &v7[(signed int)v46];
      if ( (_DWORD)v46 - v9 != v8 )
        memset(
          &v13[(signed int)v46 + v9 + v8],
          0,
          (signed __int64)((unsigned __int64)(unsigned int)(v46 - v9 - v8) << 32) >> 29);
      v19 = v47;
    }
  }
LABEL_40:
  v36 = v45;
LABEL_41:
  v39 = sub_6A448(v7, v13, v31, v30);
  if ( v36 )
    v40 = v39 - (unsigned __int64)sub_6A564(v28, (unsigned __int64 *)v7, (unsigned __int64 *)v28, v30);
  else
    v40 = sub_6A448(v28, (unsigned __int64 *)v28, v7, v30) + v39;
  result = sub_6A448(&v13[v19], &v13[v19], v28, v30);
  v41 = result + v40;
  if ( (_DWORD)result + v40 )
  {
    v42 = v13[3 * v19];
    v13[3 * v19] = v42 + v41;
    if ( __CFADD__(v42, v41) )
    {
      v43 = (signed __int64 *)&v13[3 * v19 + 1];
      do
      {
        v44 = *v43 + 1;
        *v43 = v44;
        ++v43;
      }
      while ( !v44 );
    }
  }
  return result;
}
// 6A684: using guessed type __int64 __fastcall sub_6A684(_QWORD, _QWORD, _QWORD);

//----- (000000000006C8BC) ----------------------------------------------------
__int64 __fastcall sub_6C8BC(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, signed int a4, unsigned int a5, unsigned int a6, __int64 *a7)
{
  signed int v7; // w20
  unsigned int v8; // w27
  unsigned int v9; // w28
  unsigned __int64 *v10; // x23
  unsigned __int64 *v11; // x24
  _QWORD *v12; // x19
  int v13; // w22
  int v14; // w8
  __int64 result; // x0
  __int64 v16; // x8
  __int64 v17; // x26
  signed int v18; // w21
  int v19; // w19
  int v20; // w25
  int v21; // w8
  unsigned __int64 *v22; // x26
  char v23; // w8
  unsigned __int64 *v24; // x2
  unsigned int v25; // w3
  signed int v26; // w4
  __int64 *v27; // x0
  unsigned __int64 *v28; // x1
  unsigned __int64 *v29; // x1
  unsigned int v30; // w3
  unsigned __int64 *v31; // x2
  __int64 *v32; // x0
  signed int v33; // w4
  __int64 *v34; // x25
  unsigned int v35; // w22
  unsigned __int64 *v36; // x21
  unsigned __int64 *v37; // x1
  signed __int64 v38; // x26
  int v39; // w21
  int v40; // w21
  int v41; // w9
  __int64 v42; // x8
  __int64 v43; // x10
  __int64 v44; // x11
  signed __int64 *v45; // x8
  signed __int64 v46; // x9
  unsigned int v47; // [xsp+4h] [xbp-8Ch]
  unsigned __int64 *v48; // [xsp+8h] [xbp-88h]
  signed int v49; // [xsp+14h] [xbp-7Ch]
  unsigned int v50; // [xsp+18h] [xbp-78h]
  __int64 *v51; // [xsp+20h] [xbp-70h]
  unsigned __int64 *v52; // [xsp+28h] [xbp-68h]
  unsigned __int64 *v53; // [xsp+30h] [xbp-60h]
  __int64 v54; // [xsp+38h] [xbp-58h]

  v7 = a4;
  v8 = a6;
  v9 = a5;
  v10 = a3;
  v11 = a2;
  v12 = a1;
  v13 = a6 | a5;
  if ( a4 >= 0 )
    v14 = a4;
  else
    v14 = a4 + 1;
  if ( a4 == 8 && !v13 )
    return sub_6A684(a1, a2, a3);
  if ( a4 > 15 )
  {
    v16 = (unsigned int)(v14 >> 1);
    v17 = v16 << 32 >> 29;
    v18 = -a5;
    v48 = a1;
    v19 = v16 + a6;
    v50 = v16;
    v51 = a7;
    v53 = (unsigned __int64 *)((char *)a2 + v17);
    v54 = (signed int)v16;
    v47 = v16 + a5;
    v20 = sub_657B8((__int64)a2, (__int64)a2 + v17, (unsigned int)v16 + a5, -a5);
    v52 = (unsigned __int64 *)((char *)v10 + v17);
    v21 = 3 * v20 + (unsigned __int64)sub_657B8((__int64)v10 + v17, (__int64)v10, v19, v8) + 4;
    v22 = (unsigned __int64 *)v51;
    switch ( v21 )
    {
      case 0:
        sub_6D40C(v51, v53, v11, v47, v9);
        v24 = v52;
        v25 = v19;
        v26 = -v8;
        v27 = &v51[v54];
        v28 = v10;
        goto LABEL_18;
      case 1:
      case 3:
      case 4:
      case 5:
      case 7:
        v49 = 0;
        v23 = 1;
        goto LABEL_20;
      case 2:
        sub_6D40C(v51, v53, v11, v47, v9);
        v29 = v52;
        v30 = v19;
        v31 = v10;
        v32 = &v51[v54];
        v33 = v8;
        goto LABEL_16;
      case 6:
        sub_6D40C(v51, v11, v53, v47, v18);
        v31 = v52;
        v30 = v19;
        v33 = -v8;
        v32 = &v51[v54];
        v29 = v10;
LABEL_16:
        sub_6D40C(v32, v29, v31, v30, v33);
        v23 = 0;
        v49 = 1;
        goto LABEL_20;
      case 8:
        sub_6D40C(v51, v11, v53, v47, v18);
        v28 = v52;
        v25 = v19;
        v24 = v10;
        v27 = &v51[v54];
        v26 = v8;
LABEL_18:
        sub_6D40C(v27, v28, v24, v25, v26);
        break;
      default:
        v22 = (unsigned __int64 *)v51;
        break;
    }
    v49 = 0;
    v23 = 0;
LABEL_20:
    if ( (v7 & 0xFFFFFFFE) != 8 || v13 )
    {
      if ( (v7 & 0xFFFFFFFE) != 16 || v13 )
      {
        v37 = v22;
        v38 = (signed __int64)&v22[2 * v7];
        v34 = (__int64 *)&v37[v7];
        if ( v23 & 1 )
        {
          memset(&v37[v7], 0, 8LL * v7);
          v35 = v50;
        }
        else
        {
          v35 = v50;
          sub_6C8BC(&v37[v7], v37, &v37[v54], v50, 0LL, 0LL, v38);
        }
        sub_6C8BC(v48, v11, v10, v35, 0LL, 0LL, v38);
        v36 = &v48[v7];
        sub_6C8BC(&v48[v7], v53, v52, v35, v9, v8, v38);
        v22 = (unsigned __int64 *)v51;
      }
      else
      {
        v34 = (__int64 *)&v22[v7];
        if ( v23 & 1 )
          memset(&v22[v7], 0, 0x80uLL);
        else
          sub_6A684(&v22[v7], v22, &v22[v54]);
        v35 = v50;
        sub_6A684(v48, v11, v10);
        v36 = &v48[v7];
        sub_6A684(&v48[v7], v53, v52);
      }
    }
    else
    {
      v34 = (__int64 *)&v22[v7];
      if ( v23 & 1 )
      {
        v34[6] = 0LL;
        v34[7] = 0LL;
        v34[4] = 0LL;
        v34[5] = 0LL;
        v34[2] = 0LL;
        v34[3] = 0LL;
        *v34 = 0LL;
        v34[1] = 0LL;
      }
      else
      {
        sub_6AE9C(&v22[v7], v22, &v22[v54]);
      }
      v35 = v50;
      sub_6AE9C(v48, v11, v10);
      v36 = &v48[v7];
      sub_6AE9C(&v48[v7], v53, v52);
    }
    v39 = sub_6A448(v22, v48, v36, v7);
    if ( v49 )
      v40 = v39 - (unsigned __int64)sub_6A564(v34, v22, (unsigned __int64 *)v34, v7);
    else
      v40 = sub_6A448(v34, (unsigned __int64 *)v34, v22, v7) + v39;
    result = sub_6A448(&v48[v54], &v48[v54], v34, v7);
    v41 = result + v40;
    if ( (_DWORD)result + v40 )
    {
      v42 = v35 + v7;
      v43 = v42 << 32 >> 29;
      v44 = *(unsigned __int64 *)((char *)v48 + v43);
      *(unsigned __int64 *)((char *)v48 + v43) = v44 + v41;
      if ( __CFADD__(v44, v41) )
      {
        v45 = (signed __int64 *)&v48[(signed int)v42 + 1];
        do
        {
          v46 = *v45 + 1;
          *v45 = v46;
          ++v45;
        }
        while ( !v46 );
      }
    }
  }
  else
  {
    result = sub_6CD30(a1, a2, a5 + a4, a3, a6 + a4);
    if ( (v8 + v9) & 0x80000000 )
      result = (__int64)memset(&v12[v9 + 2 * v7 + v8], 0, (signed __int64)((unsigned __int64)-(v8 + v9) << 32) >> 29);
  }
  return result;
}
// 6A684: using guessed type __int64 __fastcall sub_6A684(_QWORD, _QWORD, _QWORD);

//----- (000000000006CD30) ----------------------------------------------------
unsigned __int64 __fastcall sub_6CD30(_QWORD *a1, unsigned __int64 *a2, signed int a3, unsigned __int64 *a4, signed int a5)
{
  signed int v5; // w22
  signed int v6; // w23
  _QWORD *v7; // x19
  signed int v8; // w8
  unsigned __int64 *v9; // x26
  signed int v10; // w24
  unsigned __int64 *v11; // x20
  __int64 v12; // x21
  unsigned __int64 result; // x0
  unsigned __int64 v14; // x24
  int v15; // w8
  signed __int64 v16; // x25
  int v17; // w22
  signed __int64 v18; // x23
  signed __int64 v19; // x28

  v5 = a5;
  v6 = a3;
  v7 = a1;
  if ( a3 >= a5 )
    v8 = a3;
  else
    v8 = a5;
  if ( a3 >= a5 )
    v9 = a4;
  else
    v9 = a2;
  if ( a3 >= a5 )
    v10 = a5;
  else
    v10 = a3;
  if ( a3 >= a5 )
    v11 = a2;
  else
    v11 = a4;
  v12 = v8;
  if ( v10 <= 0 )
    return sub_6A220(a1, v11, v12, 0LL);
  result = sub_6A220(a1, v11, v8, *v9);
  v7[v12] = result;
  if ( v10 != 1 )
  {
    v14 = 0LL;
    if ( ~v5 > ~v6 )
      v15 = !v5;
    else
      v15 = ~v6;
    v16 = (signed __int64)&v7[v12];
    v17 = -5 - v15;
    v18 = (signed __int64)(v9 + 2);
    do
    {
      result = sub_6A110(&v7[v14 / 8 + 1], v11, v12, *(_QWORD *)(v18 + v14 - 8));
      *(_QWORD *)(v16 + v14 + 8) = result;
      if ( v17 + 2 < 1 )
        break;
      result = sub_6A110(&v7[v14 / 8 + 2], v11, v12, *(_QWORD *)(v18 + v14));
      *(_QWORD *)(v16 + v14 + 16) = result;
      if ( v17 + 1 < 1 )
        break;
      result = sub_6A110(&v7[v14 / 8 + 3], v11, v12, *(_QWORD *)(v18 + v14 + 8));
      v19 = v16 + v14;
      *(_QWORD *)(v16 + v14 + 24) = result;
      if ( v17 < 1 )
        break;
      result = sub_6A110(&v7[v14 / 8 + 4], v11, v12, *(_QWORD *)(v18 + v14 + 16));
      v14 += 32LL;
      v17 -= 4;
      *(_QWORD *)(v19 + 32) = result;
    }
    while ( v17 != -3 );
  }
  return result;
}

//----- (000000000006CEAC) ----------------------------------------------------
__int64 __fastcall BN_mul_word(unsigned __int64 **a1, unsigned __int64 a2)
{
  __int64 v2; // x19
  unsigned int v3; // w2
  unsigned __int64 v4; // x20
  __int64 result; // x0
  __int64 v6; // x8
  __int64 v7; // x9

  v2 = (__int64)a1;
  v3 = *((_DWORD *)a1 + 2);
  if ( v3 )
  {
    if ( a2 )
    {
      v4 = sub_6A220(*a1, *a1, v3, a2);
      if ( v4 )
      {
        result = bn_wexpand(v2, *(signed int *)(v2 + 8) + 1LL);
        if ( !result )
          return result;
        v6 = *(signed int *)(v2 + 8);
        v7 = *(_QWORD *)v2;
        *(_DWORD *)(v2 + 8) = v6 + 1;
        *(_QWORD *)(v7 + 8 * v6) = v4;
      }
    }
    else
    {
      BN_zero((__int64)a1);
    }
  }
  return 1LL;
}

//----- (000000000006CF28) ----------------------------------------------------
__int64 __fastcall BN_sqr(__int64 result, __int64 a2, __int64 a3)
{
  unsigned __int64 **v3; // x21
  __int64 v4; // x19
  __int64 v5; // x20
  unsigned __int64 v6; // x22
  unsigned __int64 **v7; // x23
  double **v8; // x0
  double **v9; // x25
  unsigned int v10; // w24
  unsigned __int64 *v11; // x0
  unsigned __int64 *v12; // x1
  double *v13; // x3
  unsigned __int64 v14; // x8
  char v15; // [xsp+8h] [xbp-148h]
  __int64 v16; // [xsp+108h] [xbp-48h]

  v3 = (unsigned __int64 **)a2;
  v4 = a3;
  v5 = result;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = *(signed int *)(a2 + 8);
  if ( (signed int)v6 <= 0 )
  {
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 16) = 0;
    v10 = 1;
    goto LABEL_25;
  }
  BN_CTX_start(a3);
  v7 = (unsigned __int64 **)v5;
  if ( v3 == (unsigned __int64 **)v5 )
    v7 = (unsigned __int64 **)BN_CTX_get(v4);
  v8 = (double **)BN_CTX_get(v4);
  v9 = v8;
  v10 = 0;
  if ( v7 && v8 )
  {
    if ( !bn_wexpand((__int64)v7, 2 * v6) )
      goto LABEL_23;
    if ( (_DWORD)v6 == 8 )
    {
      sub_6B094(*v7, *v3);
    }
    else if ( (_DWORD)v6 == 4 )
    {
      sub_6B72C(*v7, *v3);
    }
    else
    {
      if ( (signed int)v6 > 15 )
      {
        if ( (_DWORD)v6 == 1 << ((unsigned __int64)BN_num_bits_word(v6) - 1) )
        {
          if ( !bn_wexpand((__int64)v9, 4 * (signed int)v6) )
            goto LABEL_23;
          sub_6D1F8(*v7, *v3, v6, *v9);
          goto LABEL_20;
        }
        if ( !bn_wexpand((__int64)v9, 2 * v6) )
          goto LABEL_23;
        v11 = *v7;
        v12 = *v3;
        v13 = *v9;
      }
      else
      {
        v11 = *v7;
        v12 = *v3;
        v13 = (double *)&v15;
      }
      sub_6D0FC(v11, v12, v6, v13);
    }
LABEL_20:
    *((_DWORD *)v7 + 4) = 0;
    v14 = (*v3)[(signed int)v6 - 1];
    *((_DWORD *)v7 + 2) = 2 * v6 - (v14 == (unsigned int)v14);
    if ( v7 == (unsigned __int64 **)v5 || BN_copy(v5, (__int64)v7) )
    {
      v10 = 1;
      goto LABEL_24;
    }
LABEL_23:
    v10 = 0;
  }
LABEL_24:
  result = BN_CTX_end(v4);
LABEL_25:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v16 )
    result = v10;
  return result;
}
// 6B094: using guessed type __int64 __fastcall sub_6B094(_QWORD, _QWORD);

//----- (000000000006D0FC) ----------------------------------------------------
unsigned __int64 __fastcall sub_6D0FC(unsigned __int64 *a1, unsigned __int64 *a2, signed int a3, double *a4)
{
  unsigned int v4; // w22
  unsigned int v5; // w20
  double *v6; // x19
  int8x16_t *v7; // x23
  unsigned __int64 *v8; // x21
  int v9; // w24
  __int64 v10; // x26
  _QWORD *v11; // x25

  v4 = a3;
  v5 = 2 * a3;
  v6 = a4;
  v7 = (int8x16_t *)a2;
  v8 = a1;
  a1[2 * a3 - 1] = 0LL;
  *a1 = 0LL;
  if ( a3 >= 2 )
  {
    v9 = a3 - 1;
    a1[a3 - 1 + 1] = sub_6A220(a1 + 1, a2 + 1, a3 - 1, *a2);
    if ( v4 != 2 )
    {
      v10 = 0LL;
      v11 = v8 + 3;
      do
      {
        v8[(signed int)(v4 - 2) + 3 + v10] = sub_6A110(v11, &v7[1].n128_u64[v10], --v9, v7->n128_u64[v10 + 1]);
        v11 += 2;
        ++v10;
      }
      while ( v9 > 1 );
    }
  }
  sub_6A448(v8, v8, v8, v5);
  sub_6A2FC(v6, v7, v4);
  return sub_6A448(v8, v8, v6, v5);
}

//----- (000000000006D1F8) ----------------------------------------------------
_QWORD *__fastcall sub_6D1F8(unsigned __int64 *a1, unsigned __int64 *a2, signed int a3, double *a4)
{
  __int64 v4; // x20
  double *v5; // x21
  unsigned __int64 *v6; // x23
  unsigned __int64 *v7; // x19
  signed int v8; // w8
  _QWORD *result; // x0
  signed int v10; // w22
  signed int v11; // w0
  __int64 *v12; // x0
  unsigned __int64 *v13; // x1
  unsigned __int64 *v14; // x2
  double *v15; // x26
  __int64 *v16; // x25
  __int64 v17; // x28
  size_t v18; // x2
  int v19; // w23
  int v20; // w21
  int v21; // w9
  __int64 v22; // x8
  __int64 v23; // x10
  __int64 v24; // x11
  signed __int64 *v25; // x8
  signed __int64 v26; // x9

  v4 = (unsigned int)a3;
  v5 = a4;
  v6 = a2;
  v7 = a1;
  if ( a3 >= 0 )
    v8 = a3;
  else
    v8 = a3 + 1;
  if ( a3 == 8 )
    return (_QWORD *)sub_6B094(a1, a2);
  if ( a3 == 4 )
    return sub_6B72C(a1, a2);
  if ( a3 <= 15 )
    return (_QWORD *)sub_6D0FC(a1, a2, a3, a4);
  v10 = v8 >> 1;
  v11 = sub_6575C((__int64)a2, (__int64)&a2[v8 >> 1], v8 >> 1);
  if ( v11 < 1 )
  {
    if ( !(v11 & 0x80000000) )
    {
      v18 = v4 << 32 >> 29;
      v16 = (__int64 *)((char *)v5 + v18);
      v17 = (signed int)v4;
      v15 = &v5[2 * (signed int)v4];
      memset((char *)v5 + v18, 0, v18);
      goto LABEL_15;
    }
    v12 = (__int64 *)v5;
    v13 = &v6[v10];
    v14 = v6;
  }
  else
  {
    v12 = (__int64 *)v5;
    v13 = v6;
    v14 = &v6[v10];
  }
  sub_6A564(v12, v13, v14, v10);
  v15 = &v5[2 * (signed int)v4];
  v16 = (__int64 *)&v5[(signed int)v4];
  v17 = (signed int)v4;
  sub_6D1F8((unsigned __int64 *)&v5[(signed int)v4], (unsigned __int64 *)v5, v10, &v5[2 * (signed int)v4]);
LABEL_15:
  sub_6D1F8(v7, v6, v10, v15);
  sub_6D1F8(&v7[v17], &v6[v10], v10, v15);
  v19 = sub_6A448(v5, v7, &v7[v17], v4);
  v20 = v19 - (unsigned __int64)sub_6A564(v16, (unsigned __int64 *)v5, (unsigned __int64 *)v16, v4);
  result = (_QWORD *)sub_6A448(&v7[v10], &v7[v10], v16, v4);
  v21 = v20 + (_DWORD)result;
  if ( v20 + (_DWORD)result )
  {
    v22 = (unsigned int)(v10 + v4);
    v23 = v22 << 32 >> 29;
    v24 = *(unsigned __int64 *)((char *)v7 + v23);
    *(unsigned __int64 *)((char *)v7 + v23) = v24 + v21;
    if ( __CFADD__(v24, v21) )
    {
      v25 = (signed __int64 *)&v7[(signed int)v22 + 1];
      do
      {
        v26 = *v25 + 1;
        *v25 = v26;
        ++v25;
      }
      while ( !v26 );
    }
  }
  return result;
}
// 6B094: using guessed type __int64 __fastcall sub_6B094(_QWORD, _QWORD);

//----- (000000000006D40C) ----------------------------------------------------
__int64 __fastcall sub_6D40C(__int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned int a4, signed int a5)
{
  signed int v5; // w19
  signed int v6; // w23
  unsigned __int64 *v7; // x20
  unsigned __int64 *v8; // x22
  __int64 *v9; // x21
  __int64 result; // x0
  __int64 *v11; // x8
  unsigned __int64 *v12; // x9
  bool v13; // zf
  __int64 v14; // x10
  unsigned __int64 v15; // x12
  __int64 v16; // x13
  unsigned __int64 v17; // x12
  unsigned __int64 v18; // x11
  int v19; // w10
  unsigned __int64 v20; // x10
  signed __int64 v21; // x9
  signed __int64 v22; // x12
  int v23; // w8
  signed __int64 v24; // x11
  signed __int64 *v25; // x9
  __int64 *v26; // x10
  __int64 v27; // x12
  signed __int64 v28; // x12
  __int64 v29; // x12
  signed __int64 v30; // x12
  __int64 v31; // x12
  __int64 v32; // x13
  __int64 v33; // t1
  signed __int64 v34; // x12
  int v35; // w10
  _QWORD *v36; // x8
  __int64 *v37; // x9
  __int64 v38; // t1

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  result = sub_6A564(a1, a2, a3, a4);
  if ( v5 )
  {
    v11 = &v9[v6];
    if ( v5 & 0x80000000 )
    {
      v20 = v7[v6];
      *v11 = -(signed __int64)(v20 + result);
      if ( v5 != -1 )
      {
        v21 = v6;
        v22 = (signed __int64)&v7[v21];
        v23 = v5 + 4;
        if ( v20 )
          v24 = 1LL;
        else
          v24 = result;
        v25 = &v9[v21 + 2];
        v26 = (__int64 *)(v22 + 32);
        do
        {
          v27 = *(v26 - 3);
          v13 = v27 == 0;
          v28 = -(v27 + v24);
          if ( !v13 )
            v24 = 1LL;
          *(v25 - 1) = v28;
          if ( !((v23 - 2) & 0x80000000) )
            break;
          v29 = *(v26 - 2);
          v13 = v29 == 0;
          v30 = -(v29 + v24);
          if ( !v13 )
            v24 = 1LL;
          *v25 = v30;
          if ( !((v23 - 1) & 0x80000000) )
            break;
          v31 = *(v26 - 1);
          v25[1] = -(v31 + v24);
          if ( !(v23 & 0x80000000) )
            break;
          v33 = *v26;
          v26 += 4;
          v32 = v33;
          if ( v31 )
            v24 = 1LL;
          v23 += 4;
          v34 = -(v32 + v24);
          if ( v32 )
            v24 = 1LL;
          v25[2] = v34;
          v25 += 4;
        }
        while ( v23 != 3 );
      }
    }
    else
    {
      v12 = &v8[v6];
      if ( result )
      {
        while ( 1 )
        {
          v13 = *v12 == 0;
          *v11 = *v12 - result;
          v14 = v13 ? result : 0LL;
          if ( v5 < 2 )
            break;
          v15 = v12[1];
          v16 = v15 - v14;
          if ( v15 )
            v14 = 0LL;
          v11[1] = v16;
          if ( v5 - 2 < 1 )
            break;
          v17 = v12[2];
          result = v17 ? 0LL : v14;
          v11[2] = v17 - v14;
          if ( v5 - 3 < 1 )
            break;
          v18 = v12[3];
          v11[3] = v18 - result;
          if ( v5 - 4 < 1 )
            break;
          v19 = v5 - 4;
          v12 += 4;
          v11 += 4;
          if ( result )
          {
            v5 -= 4;
            if ( !v18 )
              continue;
          }
          goto LABEL_38;
        }
      }
      else
      {
        v19 = v5;
LABEL_38:
        *v11 = *v12;
        if ( v19 != 1 )
        {
          v35 = v19 - 2;
          v36 = v11 + 2;
          v37 = (__int64 *)(v12 + 4);
          do
          {
            *(v36 - 1) = *(v37 - 3);
            if ( v35 < 1 )
              break;
            *v36 = *(v37 - 2);
            if ( v35 - 1 < 1 )
              break;
            v36[1] = *(v37 - 1);
            if ( v35 - 2 < 1 )
              break;
            v38 = *v37;
            v37 += 4;
            v35 -= 4;
            v36[2] = v38;
            v36 += 4;
          }
          while ( v35 != -1 );
        }
      }
    }
  }
  return result;
}

//----- (000000000006D614) ----------------------------------------------------
_QWORD *__fastcall BN_GENCB_set(_QWORD *result, __int64 a2, __int64 a3)
{
  *result = a3;
  result[1] = a2;
  return result;
}

//----- (000000000006D61C) ----------------------------------------------------
__int64 __fastcall BN_GENCB_call(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 result; // x0

  if ( a1 )
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(a1 + 8))(a2, a3, a1);
  else
    result = 1LL;
  return result;
}

//----- (000000000006D640) ----------------------------------------------------
void __fastcall BN_generate_prime_ex(__int64 *a1, signed int a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // x28
  __int64 v7; // x19
  __int64 v8; // x20
  signed int v9; // w22
  __int64 *v10; // x23
  signed int v11; // w21
  _BOOL4 v12; // w24
  _DWORD *v13; // x0
  _DWORD *v14; // x25
  unsigned int v15; // w24
  unsigned __int64 v16; // x20
  signed __int64 v17; // x19
  signed __int64 v18; // x0
  int v19; // w8
  unsigned __int64 v20; // x8
  __int64 v21; // x8
  unsigned __int64 v22; // x1
  signed __int64 v23; // x9
  unsigned __int64 v24; // x8
  signed __int64 v25; // x8
  unsigned __int64 v26; // x10
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  _QWORD *v29; // x0
  __int64 v30; // x20
  __int64 *v31; // x27
  _QWORD *v32; // x0
  __int64 v33; // x28
  __int64 v34; // x2
  signed __int64 v35; // x19
  unsigned __int64 v36; // x24
  signed __int64 v37; // x20
  signed __int64 v38; // x0
  signed __int64 v39; // x19
  unsigned __int64 v40; // x0
  unsigned int v41; // w20
  int v42; // w0
  int v43; // w0
  __int16 v44; // w4
  unsigned int v45; // [xsp+14h] [xbp-109Ch]
  __int64 v46; // [xsp+18h] [xbp-1098h]
  __int64 v47; // [xsp+30h] [xbp-1080h]
  _BOOL4 v48; // [xsp+3Ch] [xbp-1074h]
  __int64 v49; // [xsp+40h] [xbp-1070h]
  _QWORD *v50; // [xsp+50h] [xbp-1060h]
  char v51[4096]; // [xsp+58h] [xbp-1058h]
  __int64 v52; // [xsp+1058h] [xbp-58h]

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a2;
  v10 = a1;
  v52 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 > 1299 )
  {
    v11 = 2;
LABEL_21:
    v12 = a3 != 0;
    goto LABEL_22;
  }
  if ( a2 > 849 )
  {
    v11 = 3;
    goto LABEL_21;
  }
  if ( a2 > 649 )
  {
    v11 = 4;
    goto LABEL_21;
  }
  if ( a2 > 549 )
  {
    v11 = 5;
    goto LABEL_21;
  }
  if ( a2 > 449 )
  {
    v11 = 6;
    goto LABEL_21;
  }
  if ( a2 > 399 )
  {
    v11 = 7;
    goto LABEL_21;
  }
  if ( a2 > 349 )
  {
    v11 = 8;
    goto LABEL_21;
  }
  if ( a2 > 299 )
  {
    v11 = 9;
    goto LABEL_21;
  }
  if ( a2 > 249 )
  {
    v11 = 12;
    goto LABEL_21;
  }
  if ( a2 >= 200 )
  {
    v11 = 15;
    goto LABEL_21;
  }
  if ( a2 <= 1 )
  {
    v44 = 365;
LABEL_130:
    ERR_put_error(3, 0LL, 103, (__int64)"external/boringssl/src/crypto/bn/prime.c", v44);
    goto LABEL_120;
  }
  if ( a2 <= 149 )
    v11 = 27;
  else
    v11 = 18;
  v12 = a3 != 0;
  if ( a2 == 2 && a3 )
  {
    v44 = 369;
    goto LABEL_130;
  }
LABEL_22:
  v13 = BN_CTX_new();
  v14 = v13;
  if ( !v13 )
    goto LABEL_120;
  BN_CTX_start((__int64)v13);
  v50 = BN_CTX_get((__int64)v14);
  if ( !v50 )
    goto LABEL_119;
  v48 = v12;
  v15 = 0;
  v47 = v7;
  v49 = v8;
  if ( !v8 )
  {
LABEL_28:
    if ( (unsigned int)BN_rand((__int64)v10, v9, 1, 1u) )
    {
      v16 = -17864LL;
LABEL_30:
      v17 = 1LL;
      while ( 1 )
      {
        v18 = BN_mod_word(v10, word_D73A8[v17]);
        if ( v18 == -1 )
          break;
        *(_WORD *)&v51[2 * v17++] = v18;
        if ( v17 >= 2048 )
        {
          if ( v9 <= 64 )
          {
            v19 = *((_DWORD *)v10 + 2);
            if ( v9 == 64 )
            {
              if ( v19 == 1 )
                v20 = ~*(_QWORD *)*v10;
              else
                v20 = -1LL;
            }
            else
            {
              if ( v19 == 1 )
                v21 = *(_QWORD *)*v10;
              else
                v21 = 0LL;
              v20 = (1LL << v9) - 1 - v21;
            }
            if ( v20 < v16 )
              v16 = v20;
          }
          v22 = 0LL;
          while ( v9 >= 65 )
          {
            v25 = 1LL;
            while ( 1 )
            {
              v26 = *(unsigned __int16 *)&v51[2 * v25] + v22;
              if ( v26 - v26 / word_D73A8[v25] * word_D73A8[v25] <= 1 )
                break;
              if ( ++v25 > 2047 )
                goto LABEL_59;
            }
LABEL_57:
            v22 += 2LL;
            if ( v22 > v16 )
              goto LABEL_61;
          }
          if ( *((_DWORD *)v10 + 2) == 1 )
          {
            v23 = 1LL;
            v24 = *(_QWORD *)*v10;
          }
          else
          {
            v24 = 0LL;
            v23 = 1LL;
          }
          do
          {
            v27 = word_D73A8[v23];
            if ( v27 >= v24 )
              break;
            v28 = *(unsigned __int16 *)&v51[2 * v23] + v22;
            if ( v28 == v28 / v27 * v27 )
              goto LABEL_57;
            ++v23;
          }
          while ( v23 <= 2047 );
LABEL_59:
          if ( !(unsigned int)BN_add_word((__int64)v10, v22) )
            goto LABEL_119;
          if ( (unsigned int)BN_num_bits((__int64)v10) != v9 )
          {
LABEL_61:
            if ( (unsigned int)BN_rand((__int64)v10, v9, 1, 1u) )
              goto LABEL_30;
            goto LABEL_119;
          }
LABEL_102:
          if ( v6 )
          {
LABEL_103:
            if ( !(*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))(v6 + 8))(0LL, v15, v6) )
              goto LABEL_119;
          }
LABEL_104:
          if ( v48 )
          {
            if ( (unsigned int)BN_rshift1((__int64)v50, (__int64)v10) )
            {
              v41 = 0;
              while ( 1 )
              {
                v42 = BN_is_prime_fasttest_ex((__int64)v10, 1, v14, 0, 0LL);
                if ( v42 == -1 )
                  break;
                if ( !v42 )
                  goto LABEL_133;
                v43 = BN_is_prime_fasttest_ex((__int64)v50, 1, v14, 0, 0LL);
                if ( v43 == -1 )
                  goto LABEL_119;
                if ( !v43 )
                {
LABEL_133:
                  ++v15;
                  if ( v49 )
                    goto LABEL_64;
                  goto LABEL_28;
                }
                if ( (!v6 || (*(unsigned int (__fastcall **)(_QWORD, _QWORD, __int64))(v6 + 8))(v41, v15, v6))
                  && (signed int)++v41 < v11 )
                {
                  continue;
                }
                goto LABEL_119;
              }
            }
            goto LABEL_119;
          }
          ++v15;
          if ( (unsigned int)BN_is_prime_fasttest_ex((__int64)v10, v11, v14, 0, v6) )
            goto LABEL_119;
          if ( !v49 )
            goto LABEL_28;
          goto LABEL_64;
        }
      }
    }
    goto LABEL_119;
  }
LABEL_64:
  BN_CTX_start((__int64)v14);
  v29 = BN_CTX_get((__int64)v14);
  v30 = (__int64)v29;
  if ( !v48 )
  {
    if ( !v29
      || !(unsigned int)BN_rand((__int64)v10, v9, 0, 1u)
      || !(unsigned int)BN_div(0LL, v30, (__int64)v10, v49, (__int64)v14)
      || !(unsigned int)BN_sub((__int64)v10, (__int64)v10, v30) )
    {
      goto LABEL_118;
    }
    v34 = v47;
    if ( v47 )
    {
LABEL_96:
      if ( !(unsigned int)BN_add((__int64)v10, (__int64)v10, v34) )
        goto LABEL_118;
    }
    else if ( !(unsigned int)BN_add_word((__int64)v10, 1LL) )
    {
      goto LABEL_118;
    }
    v39 = 1LL;
    while ( 1 )
    {
      v40 = BN_mod_word(v10, word_D73A8[v39]);
      if ( v40 == -1LL )
        goto LABEL_118;
      if ( v40 <= 1 )
      {
        v34 = v49;
        goto LABEL_96;
      }
      if ( ++v39 > 2047 )
      {
        BN_CTX_end((__int64)v14);
        goto LABEL_102;
      }
    }
  }
  v45 = v15;
  v46 = v6;
  v31 = BN_CTX_get((__int64)v14);
  v32 = BN_CTX_get((__int64)v14);
  v33 = (__int64)v32;
  if ( !v32
    || !(unsigned int)BN_rshift1((__int64)v32, v49)
    || !(unsigned int)BN_rand((__int64)v31, v9 - 1, 0, 1u)
    || !(unsigned int)BN_div(0LL, v30, (__int64)v31, v33, (__int64)v14)
    || !(unsigned int)BN_sub((__int64)v31, (__int64)v31, v30) )
  {
    goto LABEL_118;
  }
  if ( v47 )
  {
    if ( !(unsigned int)BN_rshift1(v30, v47) || !(unsigned int)BN_add((__int64)v31, (__int64)v31, v30) )
      goto LABEL_118;
LABEL_82:
    if ( (unsigned int)BN_lshift1((__int64)v10, (__int64)v31) && (unsigned int)BN_add_word((__int64)v10, 1LL) )
    {
LABEL_84:
      v35 = 1LL;
      while ( 1 )
      {
        v36 = word_D73A8[v35];
        v37 = BN_mod_word(v10, v36);
        v38 = BN_mod_word(v31, v36);
        if ( v37 == -1 || v38 == -1 )
          break;
        if ( !v37 || !v38 )
        {
          if ( (unsigned int)BN_add((__int64)v10, (__int64)v10, v49)
            && (unsigned int)BN_add((__int64)v31, (__int64)v31, v33) )
          {
            goto LABEL_84;
          }
          goto LABEL_118;
        }
        if ( ++v35 > 2047 )
        {
          BN_CTX_end((__int64)v14);
          v6 = v46;
          v15 = v45;
          if ( v46 )
            goto LABEL_103;
          goto LABEL_104;
        }
      }
    }
    goto LABEL_118;
  }
  if ( (unsigned int)BN_add_word((__int64)v31, 1LL) )
    goto LABEL_82;
LABEL_118:
  BN_CTX_end((__int64)v14);
LABEL_119:
  BN_CTX_end((__int64)v14);
  BN_CTX_free((__int64)v14);
LABEL_120:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v52;
}
// 6D640: using guessed type char var_1058[4096];

//----- (000000000006DD14) ----------------------------------------------------
__int64 __fastcall BN_is_prime_fasttest_ex(__int64 a1, signed int a2, _DWORD *a3, int a4, __int64 a5)
{
  __int64 v5; // x20
  int v6; // w21
  _DWORD *v7; // x19
  signed int v8; // w22
  __int64 v9; // x23
  void **v10; // x0
  signed __int64 v11; // x21
  signed __int64 v12; // x0
  signed int v13; // w8
  unsigned int v14; // w28
  _DWORD *v15; // x21
  _QWORD *v16; // x0
  __int64 v17; // x24
  _QWORD *v19; // x25
  _QWORD *v20; // x26
  _QWORD *v21; // x27
  _DWORD *v22; // x23
  unsigned int v23; // w28
  _QWORD *v24; // x0
  int v25; // w0
  int v26; // [xsp+8h] [xbp-58h]
  unsigned int v27; // [xsp+Ch] [xbp-54h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = BN_value_one();
  if ( (signed int)BN_cmp(v9, (__int64)v10) < 1 )
  {
LABEL_44:
    v14 = 0;
  }
  else
  {
    if ( !v8 )
    {
      if ( (unsigned int)BN_num_bits(v9) <= 0x513 )
      {
        if ( (unsigned int)BN_num_bits(v9) <= 0x351 )
        {
          if ( (unsigned int)BN_num_bits(v9) <= 0x289 )
          {
            if ( (unsigned int)BN_num_bits(v9) <= 0x225 )
            {
              if ( (unsigned int)BN_num_bits(v9) <= 0x1C1 )
              {
                if ( (unsigned int)BN_num_bits(v9) <= 0x18F )
                {
                  if ( (unsigned int)BN_num_bits(v9) <= 0x15D )
                  {
                    if ( (unsigned int)BN_num_bits(v9) <= 0x12B )
                    {
                      if ( (unsigned int)BN_num_bits(v9) <= 0xF9 )
                      {
                        if ( (unsigned int)BN_num_bits(v9) <= 0xC7 )
                        {
                          if ( (unsigned int)BN_num_bits(v9) <= 0x95 )
                            v8 = 27;
                          else
                            v8 = 18;
                        }
                        else
                        {
                          v8 = 15;
                        }
                      }
                      else
                      {
                        v8 = 12;
                      }
                    }
                    else
                    {
                      v8 = 9;
                    }
                  }
                  else
                  {
                    v8 = 8;
                  }
                }
                else
                {
                  v8 = 7;
                }
              }
              else
              {
                v8 = 6;
              }
            }
            else
            {
              v8 = 5;
            }
          }
          else
          {
            v8 = 4;
          }
        }
        else
        {
          v8 = 3;
        }
      }
      else
      {
        v8 = 2;
      }
    }
    if ( !(unsigned int)BN_is_odd(v9) )
      return BN_is_word(v9, 2LL);
    if ( v6 )
    {
      v11 = 1LL;
      do
      {
        v12 = BN_mod_word((__int64 *)v9, word_D73A8[v11]);
        v13 = v12 == 0;
        if ( v12 == -1 )
          v13 = 5;
        if ( v13 )
        {
          if ( v13 != 5 )
            goto LABEL_44;
          goto LABEL_43;
        }
        ++v11;
      }
      while ( v11 < 2048 );
      if ( v5 )
      {
        v14 = -1;
        if ( !(*(unsigned int (__fastcall **)(signed __int64, signed __int64, __int64))(v5 + 8))(1LL, 0xFFFFFFFFLL, v5) )
          return v14;
      }
    }
    v15 = v7;
    if ( v7 || (v15 = BN_CTX_new()) != 0LL )
    {
      BN_CTX_start((__int64)v15);
      if ( *(_DWORD *)(v9 + 16) )
      {
        v16 = BN_CTX_get((__int64)v15);
        v17 = (__int64)v16;
        if ( !v16 || !BN_copy((__int64)v16, v9) )
          goto LABEL_51;
        *(_DWORD *)(v17 + 16) = 0;
      }
      else
      {
        v17 = v9;
      }
      v19 = BN_CTX_get((__int64)v15);
      v20 = BN_CTX_get((__int64)v15);
      v21 = BN_CTX_get((__int64)v15);
      if ( v21 && BN_copy((__int64)v19, v17) && (unsigned int)BN_sub_word((__int64)v19, 1uLL) )
      {
        if ( BN_is_zero((__int64)v19) )
        {
          v22 = 0LL;
          v14 = 0;
          goto LABEL_52;
        }
        v23 = 0;
        do
          ++v23;
        while ( !(unsigned int)BN_is_bit_set((__int64)v19, v23) );
        if ( (unsigned int)BN_rshift((__int64)v20, (__int64)v19, v23) )
        {
          v24 = BN_MONT_CTX_new();
          v22 = v24;
          if ( v24 && BN_MONT_CTX_set((__int64)v24, v17) )
          {
            if ( v8 >= 1 )
            {
              v27 = 0;
              v26 = -v23;
              while ( 1 )
              {
                if ( !(unsigned int)BN_rand_range((__int64)v21, (__int64)v19) )
                {
                  v14 = -1;
                  if ( v15 )
                    goto LABEL_52;
                  goto LABEL_54;
                }
                if ( !(unsigned int)BN_add_word((__int64)v21, 1LL)
                  || (BN_mod_exp_mont((__int64)v21, (__int64)v21, (__int64)v20, v17, (__int64)v15, (__int64)v22), !v25) )
                {
                  v14 = -1;
                  if ( v15 )
                    goto LABEL_52;
                  goto LABEL_54;
                }
                if ( !BN_is_one((__int64)v21) && (unsigned int)BN_cmp((__int64)v21, (__int64)v19) )
                  break;
LABEL_67:
                if ( v5 && !(*(unsigned int (__fastcall **)(signed __int64, _QWORD, __int64))(v5 + 8))(1LL, v27, v5) )
                {
                  v14 = -1;
                  goto LABEL_93;
                }
                v14 = 1;
                if ( (signed int)++v27 >= v8 )
                  goto LABEL_93;
              }
              v14 = v26;
              while ( ++v14 )
              {
                if ( !(unsigned int)BN_mod_mul((__int64)v21, (__int64)v21, (__int64)v21, v17, (__int64)v15) )
                {
                  v14 = -1;
                  if ( v15 )
                    goto LABEL_52;
                  goto LABEL_54;
                }
                if ( BN_is_one((__int64)v21) )
                {
                  v14 = 0;
                  if ( v15 )
                    goto LABEL_52;
                  goto LABEL_54;
                }
                if ( !(unsigned int)BN_cmp((__int64)v21, (__int64)v19) )
                  goto LABEL_67;
              }
LABEL_93:
              if ( v15 )
                goto LABEL_52;
              goto LABEL_54;
            }
            v14 = 1;
            if ( v15 )
              goto LABEL_52;
LABEL_54:
            if ( v22 )
              BN_MONT_CTX_free(v22);
            return v14;
          }
        }
        else
        {
          v22 = 0LL;
        }
        v14 = -1;
        if ( !v15 )
          goto LABEL_54;
LABEL_52:
        BN_CTX_end((__int64)v15);
        if ( !v7 )
          BN_CTX_free((__int64)v15);
        goto LABEL_54;
      }
LABEL_51:
      v22 = 0LL;
      v14 = -1;
      goto LABEL_52;
    }
LABEL_43:
    v14 = -1;
  }
  return v14;
}

//----- (000000000006E1B4) ----------------------------------------------------
signed __int64 __fastcall BN_primality_test(signed int *a1, __int64 a2, signed int a3, _DWORD *a4, int a5, __int64 a6)
{
  signed int *v6; // x19
  int v7; // w0
  signed int v8; // w8
  signed __int64 result; // x0

  v6 = a1;
  v7 = BN_is_prime_fasttest_ex(a2, a3, a4, a5, a6);
  if ( v7 )
  {
    if ( v7 == 1 )
    {
      v8 = 1;
      result = 1LL;
    }
    else
    {
      v8 = 0;
      result = 0LL;
    }
  }
  else
  {
    v8 = 0;
    result = 1LL;
  }
  *v6 = v8;
  return result;
}

//----- (000000000006E218) ----------------------------------------------------
__int64 __fastcall BN_is_prime_ex(__int64 a1, signed int a2, _DWORD *a3, __int64 a4)
{
  return BN_is_prime_fasttest_ex(a1, a2, a3, 0, a4);
}

//----- (000000000006E228) ----------------------------------------------------
__int64 __fastcall BN_rand(__int64 a1, signed int a2, int a3, unsigned int a4)
{
  unsigned int v4; // w22
  int v5; // w23
  signed int v6; // w24
  __int64 v7; // x19
  int v8; // w2
  __int16 v9; // w4
  __int64 v10; // x8
  int v11; // w25
  size_t v12; // x20
  int v13; // w26
  _BYTE *v14; // x0
  _BYTE *v15; // x21
  unsigned int v16; // w9
  signed int v17; // w10
  signed int v19; // w9
  _BYTE *v20; // x10

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a1 )
  {
    if ( (unsigned int)(a3 + 1) >= 3 )
    {
      v8 = 66;
      v9 = 131;
      goto LABEL_22;
    }
    if ( a4 >= 2 )
    {
      v8 = 66;
      v9 = 136;
LABEL_22:
      ERR_put_error(3, 0LL, v8, (__int64)"external/boringssl/src/crypto/bn/random.c", v9);
      LODWORD(v7) = 0;
      return (unsigned int)v7;
    }
    if ( a2 )
    {
      LODWORD(v10) = a2 + 7;
      v11 = a2 - 1;
      if ( a2 + 7 >= 0 )
        v10 = (unsigned int)v10;
      else
        v10 = (unsigned int)(a2 + 14);
      v12 = v10 << 32 >> 35;
      if ( v11 >= 0 )
        v13 = a2 - 1;
      else
        v13 = a2 + 6;
      v14 = malloc(v10 << 32 >> 35);
      v15 = v14;
      if ( !v14 )
      {
        v8 = 65;
        v9 = 151;
        goto LABEL_22;
      }
      if ( !(unsigned int)RAND_pseudo_bytes((signed __int64)v14, v12) )
      {
        LODWORD(v7) = 0;
LABEL_32:
        OPENSSL_cleanse(v15, v12);
        free(v15);
        return (unsigned int)v7;
      }
      v16 = v11 - (v13 & 0xFFFFFFF8);
      if ( v5 == -1 )
      {
LABEL_29:
        *v15 &= ~(unsigned __int8)(255 << (v11 - (v13 & 0xF8) + 1));
        if ( v4 == 1 )
          v15[v12 - 1] |= 1u;
        LODWORD(v7) = BN_bin2bn(v15, v12, v7) != 0;
        goto LABEL_32;
      }
      if ( v6 < 2 || v5 != 1 )
      {
        v17 = 1;
      }
      else
      {
        if ( v11 == (v13 & 0xFFFFFFF8) )
        {
          *v15 = 1;
          v20 = v15 + 1;
          LOBYTE(v19) = -128;
          goto LABEL_28;
        }
        LOBYTE(v16) = v16 - 1;
        v17 = 3;
      }
      v19 = v17 << v16;
      v20 = v15;
LABEL_28:
      *v20 |= v19;
      goto LABEL_29;
    }
    BN_zero(a1);
    LODWORD(v7) = 1;
  }
  return (unsigned int)v7;
}

//----- (000000000006E3F4) ----------------------------------------------------
__int64 __fastcall BN_rand_range_ex(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  __int64 v4; // x19
  unsigned __int64 v5; // x21
  signed int v6; // w22
  __int64 result; // x0
  int v8; // w2
  __int16 v9; // w4
  signed int v10; // w26

  v3 = a3;
  v4 = a1;
  v5 = a2;
  if ( (signed int)BN_cmp_word(a3, a2) <= 0 )
  {
    v8 = 108;
    v9 = 204;
LABEL_20:
    ERR_put_error(3, 0LL, v8, (__int64)"external/boringssl/src/crypto/bn/random.c", v9);
    return 0LL;
  }
  v6 = BN_num_bits(v3);
  if ( v6 != 1 )
  {
    v10 = -99;
    do
    {
      if ( (unsigned int)BN_is_bit_set(v3, v6 - 2) || (unsigned int)BN_is_bit_set(v3, v6 - 3) )
      {
        result = BN_rand(v4, v6, -1, 0);
        if ( !(_DWORD)result )
          return result;
      }
      else
      {
        result = BN_rand(v4, v6 + 1, -1, 0);
        if ( !(_DWORD)result )
          return result;
        if ( !(BN_cmp(v4, v3) & 0x80000000) )
        {
          result = BN_sub(v4, v4, v3);
          if ( !(_DWORD)result )
            return result;
          if ( !(BN_cmp(v4, v3) & 0x80000000) )
          {
            result = BN_sub(v4, v4, v3);
            if ( !(_DWORD)result )
              return result;
          }
        }
      }
      if ( !(BN_cmp_word(v4, v5) & 0x80000000) && BN_cmp(v4, v3) & 0x80000000 )
        return 1LL;
      ++v10;
    }
    while ( v10 );
    v8 = 115;
    v9 = 218;
    goto LABEL_20;
  }
  BN_zero(v4);
  return 1LL;
}

//----- (000000000006E574) ----------------------------------------------------
__int64 __fastcall BN_rand_range(__int64 a1, __int64 a2)
{
  return BN_rand_range_ex(a1, 0LL, a2);
}

//----- (000000000006E584) ----------------------------------------------------
void __fastcall BN_generate_dsa_nonce(__int64 a1, __int64 a2, __int64 *a3, unsigned __int64 *a4, size_t a5)
{
  __int64 v5; // x22
  __int64 v6; // x23
  size_t v7; // x20
  unsigned __int64 *v8; // x21
  __int64 *v9; // x26
  unsigned int v10; // w24
  int v11; // w28
  unsigned __int8 *v12; // x19
  __int64 v13; // x8
  signed __int64 v14; // x27
  int v15; // w2
  __int16 v16; // w4
  int v17; // w28
  __int64 v18; // x1
  __int64 v19; // x8
  size_t v20; // x26
  __int64 v21; // [xsp+10h] [xbp-220h]
  __int64 v22; // [xsp+18h] [xbp-218h]
  char v23[96]; // [xsp+20h] [xbp-210h]
  char v24; // [xsp+80h] [xbp-1B0h]
  char v25; // [xsp+C0h] [xbp-170h]
  char v26; // [xsp+100h] [xbp-130h]
  __int64 v27; // [xsp+1D8h] [xbp-58h]

  v5 = a2;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = BN_num_bytes(a2);
  v11 = BN_num_bits(v5);
  if ( v6 )
  {
    if ( BN_is_zero(v5) )
    {
      ERR_put_error(3, 0LL, 105, (__int64)"external/boringssl/src/crypto/bn/random.c", 284);
      v12 = 0LL;
    }
    else
    {
      v12 = (unsigned __int8 *)malloc(v10);
      if ( v12 )
      {
        v13 = *((signed int *)v9 + 2);
        v14 = 8 * v13;
        if ( (unsigned __int64)(8 * v13) < 0x61 )
        {
          v17 = -v11;
          if ( (_DWORD)v13 )
          {
            v18 = *v9;
            __memcpy_chk();
          }
          if ( 96 != v14 )
            memset(&v23[v14], 0, 96 - v14);
          v21 = 0LL;
          v22 = 0LL;
          if ( v10 )
          {
LABEL_18:
            while ( (unsigned int)RAND_pseudo_bytes((signed __int64)&v25, 0x40uLL) )
            {
              SHA512_Init(&v26);
              SHA512_Update((__int64)&v26, (unsigned __int64 *)&v21, 8uLL);
              SHA512_Update((__int64)&v26, (unsigned __int64 *)&v22, 8uLL);
              SHA512_Update((__int64)&v26, (unsigned __int64 *)v23, 0x60uLL);
              SHA512_Update((__int64)&v26, v8, v7);
              SHA512_Update((__int64)&v26, (unsigned __int64 *)&v25, 0x40uLL);
              SHA512_Final(&v24, (__int64)&v26);
              v19 = v22;
              if ( (unsigned __int64)v10 - v22 <= 0x40 )
                v20 = v10 - v22;
              else
                v20 = 64LL;
              if ( v20 )
              {
                memcpy(&v12[v22], &v24, v20);
                v19 = v22;
              }
              v22 = v19 + v20;
              if ( v19 + v20 >= v10 )
                goto LABEL_25;
            }
          }
          else
          {
LABEL_25:
            while ( 1 )
            {
              *v12 &= 0xFFu >> (v17 & 7);
              if ( !BN_bin2bn(v12, v10, v6) || BN_cmp(v6, v5) & 0x80000000 )
                break;
              ++v21;
              v22 = 0LL;
              if ( v10 )
                goto LABEL_18;
            }
          }
          goto LABEL_26;
        }
        v15 = 113;
        v16 = 301;
      }
      else
      {
        v15 = 65;
        v16 = 290;
      }
      ERR_put_error(3, 0LL, v15, (__int64)"external/boringssl/src/crypto/bn/random.c", v16);
    }
LABEL_26:
    free(v12);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v27;
}
// 6E584: using guessed type char var_210[96];

//----- (000000000006E808) ----------------------------------------------------
__int64 __fastcall BN_lshift(__int64 a1, __int64 *a2, unsigned int a3)
{
  char v3; // w21
  __int64 *v4; // x20
  __int64 v5; // x19
  unsigned int v6; // w23
  int v7; // w22
  __int64 result; // x0
  char *v9; // x0
  __int64 v10; // x8
  char v11; // w10
  __int64 v12; // x9
  char *v13; // x12
  char *v14; // x13
  unsigned __int64 v15; // x14
  char *v16; // x10
  __int64 v17; // x11

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 & 0x80000000 )
  {
    ERR_put_error(3, 0LL, 109, (__int64)"external/boringssl/src/crypto/bn/shift.c", 72);
    result = 0LL;
  }
  else
  {
    v6 = a3 >> 6;
    v7 = (a3 >> 6) + 1;
    *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
    result = bn_wexpand(a1, v7 + *((_DWORD *)a2 + 2));
    if ( result )
    {
      v9 = *(char **)v5;
      v10 = *v4;
      v11 = v3 & 0x3F;
      *(_QWORD *)(*(_QWORD *)v5 + 8LL * (signed int)(*((_DWORD *)v4 + 2) + v6)) = 0LL;
      v12 = *((signed int *)v4 + 2);
      if ( v3 & 0x3F )
      {
        if ( (signed int)v12 >= 1 )
        {
          v13 = &v9[8 * (signed int)(v12 + v6 - 1)];
          v14 = &v9[8 * (signed int)(v12 + v6)];
          do
          {
            v15 = *(_QWORD *)(v10 + 8 * v12-- - 8);
            *(_QWORD *)v14 |= v15 >> (64 - v11);
            v14 -= 8;
            *(_QWORD *)v13 = v15 << v11;
            v13 -= 8;
          }
          while ( v12 > 0 );
        }
      }
      else if ( (signed int)v12 >= 1 )
      {
        v16 = &v9[8 * (signed int)(v12 + v6 - 1)];
        do
        {
          v17 = *(_QWORD *)(v10 + 8 * v12-- - 8);
          *(_QWORD *)v16 = v17;
          v16 -= 8;
        }
        while ( v12 > 0 );
      }
      if ( v6 )
        memset(v9, 0, 8LL * v6);
      *(_DWORD *)(v5 + 8) = v7 + *((_DWORD *)v4 + 2);
      bn_correct_top(v5);
      result = 1LL;
    }
  }
  return result;
}

//----- (000000000006E950) ----------------------------------------------------
__int64 __fastcall BN_lshift1(__int64 a1, __int64 a2)
{
  _QWORD *v2; // x20
  __int64 v3; // x19
  _DWORD *v4; // x21
  __int64 result; // x0
  __int64 v6; // x9
  __int64 v7; // x10
  __int64 v8; // x8
  unsigned __int64 v9; // x11
  signed __int64 v10; // x12
  unsigned __int64 v11; // x13

  v2 = (_QWORD *)a2;
  v3 = a1;
  if ( a1 == a2 )
  {
    result = bn_wexpand(a1, *(signed int *)(a1 + 8) + 1LL);
    if ( !result )
      return result;
    v4 = v2 + 1;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    v4 = (_DWORD *)(a2 + 8);
    result = bn_wexpand(a1, *(signed int *)(a2 + 8) + 1LL);
    if ( !result )
      return result;
    *(_DWORD *)(v3 + 8) = *v4;
  }
  if ( *v4 < 1 )
    return 1LL;
  v6 = *(_QWORD *)v3;
  v7 = *v2;
  v8 = 0LL;
  v9 = 0LL;
  do
  {
    v10 = 8 * v8;
    v11 = *(_QWORD *)(v7 + 8 * v8++);
    *(_QWORD *)(v6 + v10) = v9 | 2 * v11;
    v9 = v11 >> 63;
  }
  while ( (signed int)v8 < *v4 );
  if ( (v11 & 0x8000000000000000LL) == 0LL )
    return 1LL;
  result = 1LL;
  *(_QWORD *)(v6 + 8 * v8) = 1LL;
  ++*(_DWORD *)(v3 + 8);
  return result;
}

//----- (000000000006EA24) ----------------------------------------------------
__int64 __fastcall BN_rshift(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // w20
  __int64 v4; // x21
  __int64 v5; // x19
  signed int v6; // w8
  unsigned int v7; // w22
  unsigned int v8; // w23
  __int64 result; // x0
  __int64 v10; // x13
  int v11; // w12
  __int64 *v12; // x8
  char v13; // w10
  __int64 *v14; // x9
  unsigned __int64 v15; // x9
  __int64 v16; // x15
  signed __int64 v17; // x14
  int v18; // w12
  signed __int64 v19; // x13
  unsigned __int64 *v20; // x14
  __int64 *v21; // x15
  unsigned __int64 v22; // t1
  __int64 v23; // x17
  int v24; // w10
  __int64 v25; // t1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 & 0x80000000 )
  {
    ERR_put_error(3, 0LL, 109, (__int64)"external/boringssl/src/crypto/bn/shift.c", 141);
    return 0LL;
  }
  v6 = *(_DWORD *)(a2 + 8);
  v7 = a3 >> 6;
  if ( (signed int)(a3 >> 6) >= v6 || !v6 )
  {
    BN_zero(a1);
    return 1LL;
  }
  v8 = (63 - a3 + (unsigned int)BN_num_bits(a2)) >> 6;
  if ( v5 == v4 )
  {
    if ( !v3 )
      return 1LL;
LABEL_10:
    v10 = *(_QWORD *)v4;
    v11 = *(_DWORD *)(v4 + 8);
    v12 = *(__int64 **)v5;
    v13 = v3 & 0x3F;
    v14 = (__int64 *)(*(_QWORD *)v4 + 8LL * v7);
    *(_DWORD *)(v5 + 8) = v8;
    if ( v3 & 0x3F )
    {
      v15 = (unsigned __int64)*v14 >> v13;
      if ( v11 - v7 != 1 )
      {
        v16 = v11 - 2 - v7;
        v17 = v10 + 8LL * v7;
        v18 = v7 + 1 - v11;
        v19 = v16 + 1;
        v20 = (unsigned __int64 *)(v17 + 8);
        v21 = v12;
        do
        {
          v22 = *v20;
          ++v20;
          ++v18;
          v23 = (v22 << (64 - v13)) | v15;
          v15 = v22 >> v13;
          *v21 = v23;
          ++v21;
        }
        while ( v18 );
        v12 += v19;
      }
      if ( v15 )
      {
        *v12 = v15;
        if ( !*(_DWORD *)(v5 + 8) )
          goto LABEL_22;
        return 1LL;
      }
    }
    else if ( v11 != v7 )
    {
      v24 = v7 - v11;
      do
      {
        v25 = *v14;
        ++v14;
        ++v24;
        *v12 = v25;
        ++v12;
      }
      while ( v24 );
    }
    if ( !*(_DWORD *)(v5 + 8) )
LABEL_22:
      *(_DWORD *)(v5 + 16) = 0;
    return 1LL;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v4 + 16);
  result = bn_wexpand(v5, v8);
  if ( result )
    goto LABEL_10;
  return result;
}

//----- (000000000006EB98) ----------------------------------------------------
__int64 __fastcall BN_rshift1(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v3; // x19
  __int64 v4; // x22
  __int64 v5; // x23
  signed __int64 v6; // x24
  unsigned __int64 v7; // x8
  _BOOL8 v8; // x9
  int v9; // w20
  __int64 result; // x0
  __int64 v11; // x9
  signed __int64 v12; // x10
  _QWORD *v13; // x9
  unsigned __int64 *v14; // x10
  unsigned __int64 v15; // t1
  __int128 v16; // t2

  v2 = a2;
  v3 = a1;
  if ( BN_is_zero(a2) )
  {
    BN_zero(v3);
  }
  else
  {
    v4 = *(signed int *)(v2 + 8);
    v5 = *(_QWORD *)v2;
    v6 = v4 - 1;
    v7 = *(_QWORD *)(*(_QWORD *)v2 + 8 * (v4 - 1));
    v8 = v7 == 1;
    v9 = v4 - v8;
    if ( v2 != v3 )
    {
      result = bn_wexpand(v3, v4 - v8);
      if ( !result )
        return result;
      *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 16);
      v7 = *(_QWORD *)(v5 + 8 * v6);
    }
    v11 = *(_QWORD *)v3;
    if ( v7 >> 1 )
      *(_QWORD *)(v11 + 8 * v6) = v7 >> 1;
    if ( (signed int)v4 >= 2 )
    {
      v12 = (signed __int64)((unsigned __int64)(unsigned int)(v4 - 2) << 32) >> 29;
      v13 = (_QWORD *)(v11 + v12);
      v14 = (unsigned __int64 *)(v5 + v12);
      do
      {
        v15 = *v14;
        --v14;
        --v4;
        *((_QWORD *)&v16 + 1) = v7;
        *(_QWORD *)&v16 = v15;
        *v13 = v16 >> 1;
        --v13;
        v7 = v15;
      }
      while ( v4 > 1 );
    }
    *(_DWORD *)(v3 + 8) = v9;
    if ( !v9 )
      *(_DWORD *)(v3 + 16) = 0;
  }
  return 1LL;
}

//----- (000000000006EC74) ----------------------------------------------------
__int64 __fastcall BN_set_bit(__int64 a1, unsigned int a2)
{
  char v2; // w19
  __int64 v3; // x20
  unsigned int v4; // w22
  __int64 result; // x0
  __int64 v6; // x8
  bool v7; // nf
  unsigned __int8 v8; // vf

  v2 = a2;
  v3 = a1;
  if ( a2 & 0x80000000 )
    return 0LL;
  v4 = a2 >> 6;
  if ( *(_DWORD *)(a1 + 8) <= (signed int)(a2 >> 6) )
  {
    result = bn_wexpand(a1, v4 + 1);
    if ( !result )
      return result;
    v6 = *(signed int *)(v3 + 8);
    if ( (signed int)v6 <= (signed int)v4 )
    {
      do
      {
        *(_QWORD *)(*(_QWORD *)v3 + 8 * v6) = 0LL;
        v8 = __OFSUB__(v6, v4);
        v7 = v6++ - v4 < 0;
      }
      while ( v7 ^ v8 );
    }
    *(_DWORD *)(v3 + 8) = v4 + 1;
  }
  result = 1LL;
  *(_QWORD *)(*(_QWORD *)v3 + 8LL * v4) |= 1LL << (v2 & 0x3F);
  return result;
}

//----- (000000000006ED1C) ----------------------------------------------------
__int64 __fastcall BN_clear_bit(__int64 a1, unsigned int a2)
{
  unsigned int v2; // w19

  if ( a2 & 0x80000000 || *(_DWORD *)(a1 + 8) <= (signed int)(a2 >> 6) )
  {
    v2 = 0;
  }
  else
  {
    v2 = 1;
    *(_QWORD *)(*(_QWORD *)a1 + 8LL * (a2 >> 6)) &= ~(1LL << (a2 & 0x3F));
    bn_correct_top(a1);
  }
  return v2;
}

//----- (000000000006ED7C) ----------------------------------------------------
signed __int64 __fastcall BN_is_bit_set(__int64 a1, unsigned int a2)
{
  if ( a2 & 0x80000000 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 8) <= (signed int)(a2 >> 6) )
    return 0LL;
  return (*(_QWORD *)(*(_QWORD *)a1 + 8LL * (a2 >> 6)) >> (a2 & 0x3F)) & 1LL;
}

//----- (000000000006EDB8) ----------------------------------------------------
signed __int64 __fastcall BN_mask_bits(__int64 a1, unsigned int a2)
{
  unsigned int v2; // w8
  __int64 v3; // x11

  if ( a2 & 0x80000000 )
    return 0LL;
  v2 = a2 >> 6;
  if ( (signed int)(a2 >> 6) >= *(_DWORD *)(a1 + 8) )
    return 0LL;
  if ( a2 & 0x3F )
  {
    v3 = *(_QWORD *)a1;
    *(_DWORD *)(a1 + 8) = v2 + 1;
    *(_QWORD *)(v3 + 8LL * v2) &= ~(-1LL << (a2 & 0x3F));
  }
  else
  {
    *(_DWORD *)(a1 + 8) = v2;
  }
  bn_correct_top(a1);
  return 1LL;
}

//----- (000000000006EE2C) ----------------------------------------------------
void **__fastcall BN_mod_sqrt(void **a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x22
  void **v5; // x20
  __int64 v6; // x19
  __int64 v7; // x28
  void **v8; // x21
  int v9; // w0
  _BOOL4 v10; // w0
  _QWORD *v11; // x23
  _QWORD *v12; // x21
  _QWORD *v13; // x24
  _QWORD *v14; // x25
  _QWORD *v15; // x26
  _QWORD *v16; // x27
  unsigned int v17; // w28
  int v18; // w0
  int v19; // w2
  __int16 v20; // w4
  int v21; // w0
  __int64 v22; // x26
  unsigned int v23; // w0
  __int64 (__fastcall *v24)(__int64, __int64, __int64); // x8
  int v25; // w0
  int v27; // w0
  int v28; // w0
  __int64 v29; // x0
  __int64 v30; // x2
  __int64 v31; // x1
  int v32; // w26
  unsigned int v33; // w24
  __int64 v34; // [xsp+10h] [xbp-60h]
  __int64 v35; // [xsp+18h] [xbp-58h]

  v4 = a3;
  v5 = a1;
  v6 = a4;
  v7 = a2;
  if ( (unsigned int)BN_is_odd(a3) && !BN_abs_is_word(v4, 1LL) )
  {
    if ( BN_is_zero(v7) || BN_is_one(v7) )
    {
      v8 = v5;
      if ( v5 || (v8 = (void **)BN_new()) != 0LL )
      {
        v10 = BN_is_one(v7);
        if ( (unsigned int)BN_set_word((__int64)v8, v10) )
          return v8;
        if ( v8 == v5 )
          return 0LL;
        goto LABEL_16;
      }
      goto LABEL_61;
    }
    BN_CTX_start(v6);
    v11 = BN_CTX_get(v6);
    v12 = BN_CTX_get(v6);
    v13 = BN_CTX_get(v6);
    v14 = BN_CTX_get(v6);
    v15 = BN_CTX_get(v6);
    v16 = BN_CTX_get(v6);
    if ( !v16 )
    {
LABEL_63:
      v8 = 0LL;
      goto LABEL_64;
    }
    v35 = (__int64)v12;
    v8 = v5;
    if ( !v5 )
    {
      v8 = (void **)BN_new();
      if ( !v8 )
        goto LABEL_61;
    }
    if ( !(unsigned int)BN_nnmod((__int64)v11, v7, v4, v6) )
      goto LABEL_61;
    v17 = 0;
    do
      ++v17;
    while ( !(unsigned int)BN_is_bit_set(v4, v17) );
    if ( v17 == 2 )
    {
      if ( !(unsigned int)BN_mod_lshift1_quick((__int64)v14, (__int64)v11, v4) )
        goto LABEL_61;
      if ( !(unsigned int)BN_rshift((__int64)v13, v4, 3u) )
        goto LABEL_61;
      *((_DWORD *)v13 + 4) = 0;
      BN_mod_exp_mont(v35, (__int64)v14, (__int64)v13, v4, v6, 0LL);
      if ( !v21
        || !(unsigned int)BN_mod_sqr((__int64)v16, v35, v4, v6)
        || !(unsigned int)BN_mod_mul((__int64)v14, (__int64)v14, (__int64)v16, v4, v6)
        || !(unsigned int)BN_sub_word((__int64)v14, 1uLL)
        || !(unsigned int)BN_mod_mul((__int64)v15, (__int64)v11, v35, v4, v6)
        || !(unsigned int)BN_mod_mul((__int64)v15, (__int64)v15, (__int64)v14, v4, v6) )
      {
        goto LABEL_61;
      }
      goto LABEL_40;
    }
    if ( v17 == 1 )
    {
      if ( (unsigned int)BN_rshift((__int64)v13, v4, 2u) )
      {
        *((_DWORD *)v13 + 4) = 0;
        if ( (unsigned int)BN_add_word((__int64)v13, 1LL) )
        {
          BN_mod_exp_mont((__int64)v8, (__int64)v11, (__int64)v13, v4, v6, 0LL);
          if ( v18 )
            goto LABEL_28;
        }
      }
      goto LABEL_61;
    }
    if ( !BN_copy((__int64)v13, v4) )
      goto LABEL_61;
    v34 = (__int64)v15;
    v22 = 2LL;
    *((_DWORD *)v13 + 4) = 0;
    while ( 1 )
    {
      if ( v22 <= 21 )
        goto LABEL_103;
      v23 = BN_num_bits(v4);
      if ( !(unsigned int)BN_pseudo_rand(v16, v23, 0LL, 0LL) )
        goto LABEL_61;
      if ( !(BN_ucmp((__int64)v16, v4) & 0x80000000) )
      {
        v24 = BN_sub;
        if ( *(_DWORD *)(v4 + 16) )
          v24 = BN_add;
        if ( !(unsigned int)v24((__int64)v16, (__int64)v16, v4) )
          goto LABEL_61;
      }
      if ( BN_is_zero((__int64)v16) )
      {
LABEL_103:
        if ( !(unsigned int)BN_set_word((__int64)v16, v22) )
          goto LABEL_61;
      }
      v25 = BN_kronecker((__int64)v16, (__int64)v13, v6);
      if ( (v25 + 1 < 0) ^ __OFADD__(v25, 1) )
        goto LABEL_61;
      if ( v25 != 1 )
        break;
      if ( ++v22 >= 82 )
        goto LABEL_59;
    }
    if ( v25 != -1 )
    {
      if ( !v25 )
      {
        v19 = 114;
        v20 = 262;
        goto LABEL_60;
      }
LABEL_59:
      v19 = 115;
      v20 = 273;
      goto LABEL_60;
    }
    if ( !(unsigned int)BN_rshift((__int64)v13, (__int64)v13, v17) )
      goto LABEL_61;
    BN_mod_exp_mont((__int64)v16, (__int64)v16, (__int64)v13, v4, v6, 0LL);
    if ( !v27 )
      goto LABEL_61;
    if ( BN_is_one((__int64)v16) )
    {
      v19 = 114;
      v20 = 288;
LABEL_60:
      ERR_put_error(3, 0LL, v19, (__int64)"external/boringssl/src/crypto/bn/sqrt.c", v20);
      goto LABEL_61;
    }
    if ( !(unsigned int)BN_rshift1((__int64)v14, (__int64)v13) )
      goto LABEL_61;
    if ( BN_is_zero((__int64)v14) )
    {
      if ( !(unsigned int)BN_nnmod((__int64)v14, (__int64)v11, v4, v6) )
        goto LABEL_61;
      if ( !BN_is_zero((__int64)v14) )
      {
        if ( !(unsigned int)BN_one(v34) )
          goto LABEL_61;
        goto LABEL_79;
      }
    }
    else
    {
      BN_mod_exp_mont(v34, (__int64)v11, (__int64)v14, v4, v6, 0LL);
      if ( !v28 )
        goto LABEL_61;
      if ( !BN_is_zero(v34) )
      {
LABEL_79:
        if ( !(unsigned int)BN_mod_sqr(v35, v34, v4, v6) || !(unsigned int)BN_mod_mul(v35, v35, (__int64)v11, v4, v6) )
          goto LABEL_61;
        v29 = v34;
        v30 = (__int64)v11;
        v31 = v34;
        while ( 2 )
        {
          if ( !(unsigned int)BN_mod_mul(v29, v31, v30, v4, v6) )
            goto LABEL_61;
          if ( !BN_is_one(v35) )
          {
            if ( (unsigned int)BN_mod_sqr((__int64)v14, v35, v4, v6) )
            {
              v32 = 0;
              v33 = v17;
              while ( !BN_is_one((__int64)v14) )
              {
                if ( v17 - 2 == v32 )
                {
                  v19 = 110;
                  v20 = 379;
                  goto LABEL_60;
                }
                ++v32;
                --v33;
                if ( !(unsigned int)BN_mod_mul((__int64)v14, (__int64)v14, (__int64)v14, v4, v6) )
                  goto LABEL_61;
              }
              if ( BN_copy((__int64)v14, (__int64)v16) )
              {
                v17 = v32 + 1;
                while ( (signed int)--v33 >= 2 )
                {
                  if ( !(unsigned int)BN_mod_sqr((__int64)v14, (__int64)v14, v4, v6) )
                    goto LABEL_61;
                }
                if ( (unsigned int)BN_mod_mul((__int64)v16, (__int64)v14, (__int64)v14, v4, v6)
                  && (unsigned int)BN_mod_mul(v34, v34, (__int64)v14, v4, v6) )
                {
                  v29 = v35;
                  v30 = (__int64)v16;
                  v31 = v35;
                  continue;
                }
              }
            }
            goto LABEL_61;
          }
          break;
        }
        v15 = (_QWORD *)v34;
LABEL_40:
        if ( BN_copy((__int64)v8, (__int64)v15) )
        {
LABEL_28:
          if ( !(unsigned int)BN_mod_sqr((__int64)v15, (__int64)v8, v4, v6) )
            goto LABEL_61;
          if ( !(unsigned int)BN_cmp((__int64)v15, (__int64)v11) )
          {
LABEL_64:
            BN_CTX_end(v6);
            return v8;
          }
          v19 = 110;
          v20 = 415;
          goto LABEL_60;
        }
LABEL_61:
        if ( v8 != v5 )
          BN_clear_free(v8);
        goto LABEL_63;
      }
    }
    BN_zero((__int64)v8);
    goto LABEL_64;
  }
  if ( !BN_abs_is_word(v4, 2LL) )
  {
    ERR_put_error(3, 0LL, 114, (__int64)"external/boringssl/src/crypto/bn/sqrt.c", 88);
    return 0LL;
  }
  v8 = v5;
  if ( !v5 )
  {
    v8 = (void **)BN_new();
    if ( !v8 )
      goto LABEL_61;
  }
  v9 = BN_is_bit_set(v7, 0);
  if ( !(unsigned int)BN_set_word((__int64)v8, v9) )
  {
    if ( v8 == v5 )
      return 0LL;
LABEL_16:
    BN_free(v8);
    v8 = 0LL;
  }
  return v8;
}
// 6E3F0: using guessed type __int64 __fastcall BN_pseudo_rand(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000006F4FC) ----------------------------------------------------
__int64 __fastcall BN_sqrt(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  __int64 v4; // x19
  __int64 v5; // x21
  _BOOL4 v6; // w20
  _QWORD *v7; // x22
  _QWORD *v8; // x23
  _QWORD *v9; // x26
  _QWORD *v10; // x0
  __int64 v11; // x24
  __int64 *v12; // x25
  unsigned int v13; // w0
  signed int v14; // w27
  _QWORD *v15; // x25
  int v16; // w2
  __int16 v17; // w4

  v3 = a2;
  v4 = a3;
  v5 = a1;
  if ( *(_DWORD *)(a2 + 16) )
  {
    ERR_put_error(3, 0LL, 109, (__int64)"external/boringssl/src/crypto/bn/sqrt.c", 436);
    return 0;
  }
  if ( BN_is_zero(a2) )
  {
    BN_zero(v5);
    return 1;
  }
  BN_CTX_start(v4);
  v7 = (_QWORD *)v5;
  if ( v5 == v3 )
    v7 = BN_CTX_get(v4);
  v8 = BN_CTX_get(v4);
  v9 = BN_CTX_get(v4);
  v10 = BN_CTX_get(v4);
  v11 = (__int64)v10;
  if ( v7 && v8 && v9 && v10 )
  {
    v12 = (__int64 *)BN_value_one();
    v13 = BN_num_bits(v3);
    if ( !(unsigned int)BN_lshift((__int64)v7, v12, v13 >> 1) )
      goto LABEL_24;
    if ( (unsigned int)BN_div(v8, 0LL, v3, (__int64)v7, v4) )
    {
      v14 = 0;
      do
      {
        v15 = v9;
        if ( !(unsigned int)BN_add((__int64)v8, (__int64)v8, (__int64)v7)
          || !(unsigned int)BN_rshift1((__int64)v7, (__int64)v8)
          || !(unsigned int)BN_sqr((__int64)v8, (__int64)v7, v4)
          || !(unsigned int)BN_sub(v11, v3, (__int64)v8) )
        {
          break;
        }
        *(_DWORD *)(v11 + 16) = 0;
        if ( v14 && !(BN_cmp(v11, (__int64)v9) & 0x80000000) )
        {
          if ( (unsigned int)BN_cmp((__int64)v8, v3) )
          {
            v16 = 110;
            v17 = 494;
            goto LABEL_23;
          }
          if ( v5 == v3 )
            v6 = BN_copy(v3, (__int64)v7) != 0;
          else
            v6 = 1;
          goto LABEL_25;
        }
        v14 = 1;
        v9 = (_QWORD *)v11;
        v11 = (__int64)v15;
      }
      while ( (unsigned int)BN_div(v8, 0LL, v3, (__int64)v7, v4) );
    }
    v16 = 3;
    v17 = 474;
  }
  else
  {
    v16 = 65;
    v17 = 454;
  }
LABEL_23:
  ERR_put_error(3, 0LL, v16, (__int64)"external/boringssl/src/crypto/bn/sqrt.c", v17);
LABEL_24:
  v6 = 0;
LABEL_25:
  BN_CTX_end(v4);
  return (unsigned int)v6;
}

//----- (000000000006F744) ----------------------------------------------------
signed __int64 __fastcall sub_6F744(__int64 a1, void **a2)
{
  void **v2; // x19
  __int64 *v3; // x20
  signed __int64 result; // x0
  char *v5; // x0
  size_t v6; // x8
  size_t v7; // [xsp+8h] [xbp-28h]
  void *v8; // [xsp+10h] [xbp-20h]
  __int64 v9; // [xsp+18h] [xbp-18h]

  v2 = a2;
  v3 = (__int64 *)a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_finish(a1, &v8, &v7) )
  {
    if ( v7 >> 31 )
    {
      free(v8);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      if ( v2 )
      {
        v5 = (char *)*v2;
        if ( *v2 )
        {
          if ( v7 )
          {
            memcpy(v5, v8, v7);
            v6 = v7;
            v5 = (char *)*v2;
          }
          else
          {
            v6 = 0LL;
          }
          *v2 = &v5[v6];
        }
        else
        {
          *v2 = v8;
          v8 = 0LL;
        }
      }
      free(v8);
      result = (unsigned int)v7;
    }
  }
  else
  {
    CBB_cleanup(v3);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000006F818) ----------------------------------------------------
signed __int64 __fastcall CBB_init(_QWORD *a1, size_t a2)
{
  size_t v2; // x20
  _QWORD *v3; // x19
  void *v4; // x0
  void *v5; // x21
  _QWORD *v6; // x8
  signed __int64 result; // x0

  v2 = a2;
  v3 = a1;
  a1[2] = 0LL;
  a1[3] = 0LL;
  *a1 = 0LL;
  a1[1] = 0LL;
  v4 = malloc(a2);
  v5 = v4;
  if ( !v2 || v4 )
  {
    v6 = malloc(0x20uLL);
    if ( v6 )
    {
      result = 1LL;
      *v6 = v5;
      v6[1] = 0LL;
      v6[2] = v2;
      *((_WORD *)v6 + 12) = 1;
      *v3 = v6;
      *((_BYTE *)v3 + 26) = 1;
      return result;
    }
    free(v5);
  }
  return 0LL;
}

//----- (000000000006F898) ----------------------------------------------------
__int64 __fastcall CBB_init_fixed(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // x19
  __int64 v4; // x20
  __int64 v5; // x21
  _QWORD *v6; // x0
  unsigned int v7; // w8

  v3 = a1;
  v4 = a3;
  v5 = a2;
  a1[2] = 0LL;
  a1[3] = 0LL;
  *a1 = 0LL;
  a1[1] = 0LL;
  v6 = malloc(0x20uLL);
  if ( v6 )
  {
    v7 = 1;
    *v6 = v5;
    v6[1] = 0LL;
    v6[2] = v4;
    *((_BYTE *)v6 + 25) = 0;
    *v3 = v6;
    *((_BYTE *)v3 + 26) = 1;
    *((_BYTE *)v6 + 24) = 0;
  }
  else
  {
    v7 = 0;
  }
  return v7;
}

//----- (000000000006F900) ----------------------------------------------------
void __fastcall CBB_cleanup(__int64 *a1)
{
  __int64 *v1; // x19
  __int64 v2; // x0

  v1 = a1;
  v2 = *a1;
  if ( v2 )
  {
    if ( *(_BYTE *)(v2 + 24) )
    {
      free(*(void **)v2);
      v2 = *v1;
    }
    free((void *)v2);
  }
  *v1 = 0LL;
}

//----- (000000000006F940) ----------------------------------------------------
signed __int64 __fastcall CBB_finish(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD **v3; // x19
  _QWORD *v4; // x20
  _QWORD *v5; // x21
  signed __int64 result; // x0
  _QWORD *v7; // x0

  v3 = (_QWORD **)a1;
  v4 = a3;
  v5 = a2;
  if ( !*(_BYTE *)(a1 + 26) )
    return 0LL;
  result = CBB_flush((_QWORD *)a1);
  if ( (_DWORD)result )
  {
    if ( !*((_BYTE *)*v3 + 24) || (result = 0LL, v5) && v4 )
    {
      if ( v5 )
        *v5 = **v3;
      if ( v4 )
        *v4 = (*v3)[1];
      **v3 = 0LL;
      v7 = *v3;
      if ( *v3 )
      {
        if ( *((_BYTE *)v7 + 24) )
        {
          free((void *)*v7);
          v7 = *v3;
        }
        free(v7);
      }
      result = 1LL;
      *v3 = 0LL;
    }
  }
  return result;
}

//----- (000000000006F9EC) ----------------------------------------------------
signed __int64 __fastcall CBB_flush(_QWORD *a1)
{
  _QWORD *v1; // x19
  signed __int64 result; // x0
  __int64 v3; // x0
  __int64 v4; // x20
  __int64 v5; // x21
  __int64 v6; // x8
  unsigned __int64 v7; // x23
  unsigned __int64 v8; // x10
  __int64 v9; // x22
  unsigned __int64 v10; // x9
  size_t v11; // x20
  char v12; // w24
  signed int v13; // w25
  __int64 v14; // x26
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x10
  bool v17; // cf
  size_t v18; // x21
  void *v19; // x0
  _BYTE *v20; // x9
  unsigned __int64 v21; // x9

  v1 = a1;
  if ( !*a1 || *(_BYTE *)(*a1 + 25LL) )
    return 0LL;
  v3 = a1[1];
  if ( !v3 )
    return 1LL;
  v4 = *(unsigned __int8 *)(v3 + 24);
  if ( !*(_BYTE *)(v3 + 24) )
    return 1LL;
  v5 = *(_QWORD *)(v3 + 16);
  if ( !(unsigned int)CBB_flush() )
    goto LABEL_44;
  v6 = v1[1];
  v7 = v5 + v4;
  v8 = *(_QWORD *)(v6 + 16);
  if ( v5 + v4 < v8 )
    goto LABEL_44;
  v9 = *v1;
  v10 = *(_QWORD *)(*v1 + 8LL);
  v11 = v10 - v7;
  if ( v10 < v7 )
    goto LABEL_44;
  if ( *(_BYTE *)(v6 + 25) )
  {
    if ( v11 > 0xFFFFFFFE )
      goto LABEL_44;
    if ( v11 >> 24 )
    {
      v12 = -124;
      v13 = 5;
      if ( !v9 )
        goto LABEL_44;
    }
    else if ( v11 >> 16 )
    {
      v12 = -125;
      v13 = 4;
      if ( !v9 )
        goto LABEL_44;
    }
    else if ( v11 <= 0xFF )
    {
      if ( v11 < 0x80 )
      {
        LOBYTE(v13) = 1;
        v12 = v10 - v7;
        v11 = 0LL;
        goto LABEL_39;
      }
      v12 = -127;
      v13 = 2;
      if ( !v9 )
        goto LABEL_44;
    }
    else
    {
      v12 = -126;
      v13 = 3;
      if ( !v9 )
        goto LABEL_44;
    }
    v14 = v13 - 1;
    v15 = v10 + v14;
    if ( !__CFADD__(v10, v14) )
    {
      v16 = *(_QWORD *)(v9 + 16);
      if ( v15 <= v16 )
      {
LABEL_37:
        *(_QWORD *)(v9 + 8) = v10 + v14;
        memmove((void *)(*(_QWORD *)*v1 + v7 + v14), (const void *)(*(_QWORD *)*v1 + v7), v11);
        v9 = *v1;
        v6 = v1[1];
        v8 = *(_QWORD *)(v6 + 16);
LABEL_39:
        v20 = *(_BYTE **)v9;
        *(_QWORD *)(v6 + 16) = v8 + 1;
        v20[v8] = v12;
        *(_BYTE *)(v1[1] + 24LL) = v13 - 1;
        v6 = v1[1];
        goto LABEL_40;
      }
      if ( *(_BYTE *)(v9 + 24) )
      {
        v17 = 2 * v16 >= v15 ? 2 * v16 >= v16 : 0;
        v18 = v17 ? 2 * v16 : v10 + v14;
        v19 = realloc(*(void **)v9, v18);
        if ( v19 )
        {
          v10 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)v9 = v19;
          *(_QWORD *)(v9 + 16) = v18;
          goto LABEL_37;
        }
      }
    }
    *(_BYTE *)(v9 + 25) = 1;
LABEL_44:
    result = 0LL;
    *(_BYTE *)(*v1 + 25LL) = 1;
    return result;
  }
LABEL_40:
  if ( *(_BYTE *)(v6 + 24) )
  {
    v21 = *(unsigned __int8 *)(v6 + 24) - 1LL;
    do
    {
      *(_BYTE *)(*(_QWORD *)*v1 + *(_QWORD *)(v6 + 16) + v21) = v11;
      v6 = v1[1];
      v11 >>= 8;
      --v21;
    }
    while ( v21 < *(unsigned __int8 *)(v6 + 24) );
  }
  if ( v11 )
    goto LABEL_44;
  *(_QWORD *)v6 = 0LL;
  v1[1] = 0LL;
  return 1LL;
}

//----- (000000000006FC00) ----------------------------------------------------
__int64 __fastcall CBB_data(__int64 a1)
{
  return **(_QWORD **)a1 + *(_QWORD *)(a1 + 16) + *(unsigned __int8 *)(a1 + 24);
}

//----- (000000000006FC1C) ----------------------------------------------------
__int64 __fastcall CBB_len(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 8LL) - *(_QWORD *)(a1 + 16) - *(unsigned __int8 *)(a1 + 24);
}

//----- (000000000006FC38) ----------------------------------------------------
signed __int64 __fastcall CBB_add_u8_length_prefixed(char ***a1, char **a2)
{
  char **v2; // x21
  char ***v3; // x20
  signed __int64 result; // x0
  char **v5; // x25
  unsigned __int64 v6; // x24
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  bool v9; // cf
  size_t v10; // x23
  char *v11; // x0
  char *v12; // x8

  v2 = a2;
  v3 = a1;
  result = CBB_flush(a1);
  if ( (_DWORD)result )
  {
    v5 = *v3;
    if ( *v3 )
    {
      v6 = (unsigned __int64)v5[1];
      v7 = v6 + 1;
      if ( v6 >= 0xFFFFFFFFFFFFFFFFLL )
      {
LABEL_4:
        result = 0LL;
        *((_BYTE *)v5 + 25) = 1;
        return result;
      }
      v8 = (unsigned __int64)v5[2];
      if ( v7 <= v8 )
      {
        v11 = *v5;
        v12 = v5[1];
      }
      else
      {
        if ( !*((_BYTE *)v5 + 24) )
          goto LABEL_4;
        v9 = 2 * v8 >= v7 ? 2 * v8 >= v8 : 0;
        v10 = v9 ? 2 * v8 : v6 + 1;
        v11 = (char *)realloc(*v5, v10);
        if ( !v11 )
          goto LABEL_4;
        v12 = v5[1];
        *v5 = v11;
        v5[2] = (char *)v10;
      }
      v5[1] = v12 + 1;
      memset(&v12[(_QWORD)v11], 0, 1uLL);
      v2[2] = 0LL;
      v2[3] = 0LL;
      *v2 = 0LL;
      v2[1] = 0LL;
      result = 1LL;
      *v2 = (char *)*v3;
      v3[1] = v2;
      v2[2] = (char *)v6;
      *((_BYTE *)v3[1] + 24) = 1;
      *((_BYTE *)v3[1] + 25) = 0;
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (000000000006FD4C) ----------------------------------------------------
void CBB_add_u16_length_prefixed()
{
  JUMPOUT(&loc_6FC40);
}

//----- (000000000006FD54) ----------------------------------------------------
void CBB_add_u24_length_prefixed()
{
  JUMPOUT(&loc_6FC40);
}

//----- (000000000006FD5C) ----------------------------------------------------
signed __int64 __fastcall CBB_add_asn1(__int64 *a1, __int64 *a2, unsigned int a3)
{
  char v3; // w21
  __int64 *v4; // x20
  __int64 *v5; // x19
  signed __int64 result; // x0
  __int64 v7; // x21

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 > 0xFF || (a3 & 0x1F) == 31 )
  {
    result = 0LL;
    *(_BYTE *)(*v5 + 25) = 1;
  }
  else
  {
    result = CBB_flush(a1);
    if ( (_DWORD)result )
    {
      result = CBB_add_u8(v5, v3);
      if ( (_DWORD)result )
      {
        v7 = *(_QWORD *)(*v5 + 8);
        result = CBB_add_u8(v5, 0);
        if ( (_DWORD)result )
        {
          v4[2] = 0LL;
          v4[3] = 0LL;
          *v4 = 0LL;
          v4[1] = 0LL;
          result = 1LL;
          *v4 = *v5;
          v5[1] = (__int64)v4;
          v4[2] = v7;
          *(_BYTE *)(v5[1] + 24) = 1;
          *(_BYTE *)(v5[1] + 25) = 1;
        }
      }
    }
  }
  return result;
}

//----- (000000000006FE10) ----------------------------------------------------
signed __int64 __fastcall CBB_add_u8(__int64 *a1, char a2)
{
  char v2; // w19
  __int64 *v3; // x20
  signed __int64 result; // x0
  __int64 v5; // x21
  __int64 v6; // x8
  unsigned __int64 v7; // x10
  bool v8; // cf
  size_t v9; // x20
  _BYTE *v10; // x0

  v2 = a2;
  v3 = a1;
  result = CBB_flush(a1);
  if ( (_DWORD)result )
  {
    v5 = *v3;
    if ( !*v3 )
      return 0LL;
    v6 = *(_QWORD *)(v5 + 8);
    if ( v6 != -1 )
    {
      v7 = *(_QWORD *)(v5 + 16);
      if ( v6 + 1 <= v7 )
      {
        v10 = *(_BYTE **)v5;
        goto LABEL_17;
      }
      if ( *(_BYTE *)(v5 + 24) )
      {
        v8 = 2 * v7 >= v6 + 1 ? 2 * v7 >= v7 : 0;
        v9 = v8 ? 2 * v7 : v6 + 1;
        v10 = realloc(*(void **)v5, v9);
        if ( v10 )
        {
          v6 = *(_QWORD *)(v5 + 8);
          *(_QWORD *)v5 = v10;
          *(_QWORD *)(v5 + 16) = v9;
LABEL_17:
          *(_QWORD *)(v5 + 8) = v6 + 1;
          v10[v6] = v2;
          return 1LL;
        }
      }
    }
    result = 0LL;
    *(_BYTE *)(v5 + 25) = 1;
  }
  return result;
}

//----- (000000000006FEC8) ----------------------------------------------------
signed __int64 __fastcall CBB_add_bytes(char ***a1, const void *a2, size_t a3)
{
  size_t v3; // x19
  const void *v4; // x20
  char ***v5; // x21
  signed __int64 result; // x0
  char **v7; // x22
  char *v8; // x8
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x10
  bool v11; // cf
  size_t v12; // x21
  char *v13; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  result = CBB_flush(a1);
  if ( !(_DWORD)result )
    return result;
  v7 = *v5;
  if ( !*v5 )
    return 0LL;
  v8 = v7[1];
  v9 = (unsigned __int64)&v8[v3];
  if ( __CFADD__(v8, v3) )
    goto LABEL_23;
  v10 = (unsigned __int64)v7[2];
  if ( v9 <= v10 )
  {
    v13 = *v7;
    goto LABEL_18;
  }
  if ( !*((_BYTE *)v7 + 24)
    || (2 * v10 >= v9 ? (v11 = 2 * v10 >= v10) : (v11 = 0),
        v11 ? (v12 = 2 * v10) : (v12 = (size_t)&v8[v3]),
        (v13 = (char *)realloc(*v7, v12)) == 0LL) )
  {
LABEL_23:
    result = 0LL;
    *((_BYTE *)v7 + 25) = 1;
    return result;
  }
  v8 = v7[1];
  *v7 = v13;
  v7[2] = (char *)v12;
LABEL_18:
  v7[1] = &v8[v3];
  if ( v3 )
    memcpy(&v8[(_QWORD)v13], v4, v3);
  return 1LL;
}

//----- (000000000006FF90) ----------------------------------------------------
signed __int64 __fastcall CBB_add_space(__int64 *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x19
  _QWORD *v4; // x20
  __int64 *v5; // x21
  signed __int64 result; // x0
  __int64 v7; // x22
  __int64 v8; // x8
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x9
  bool v11; // cf
  size_t v12; // x21
  void *v13; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  result = CBB_flush(a1);
  if ( !(_DWORD)result )
    return result;
  v7 = *v5;
  if ( !*v5 )
    return 0LL;
  v8 = *(_QWORD *)(v7 + 8);
  v11 = __CFADD__(v8, v3);
  v9 = v8 + v3;
  if ( v11 )
    goto LABEL_5;
  v10 = *(_QWORD *)(v7 + 16);
  if ( v9 > v10 )
  {
    if ( *(_BYTE *)(v7 + 24) )
    {
      v11 = 2 * v10 >= v9 ? 2 * v10 >= v10 : 0;
      v12 = v11 ? 2 * v10 : v9;
      v13 = realloc(*(void **)v7, v12);
      if ( v13 )
      {
        *(_QWORD *)v7 = v13;
        *(_QWORD *)(v7 + 16) = v12;
        goto LABEL_17;
      }
    }
LABEL_5:
    result = 0LL;
    *(_BYTE *)(v7 + 25) = 1;
    return result;
  }
LABEL_17:
  if ( v4 )
    *v4 = *(_QWORD *)v7 + *(_QWORD *)(v7 + 8);
  result = 1LL;
  *(_QWORD *)(v7 + 8) += v3;
  return result;
}

//----- (000000000007004C) ----------------------------------------------------
signed __int64 __fastcall CBB_reserve(__int64 *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x20
  _QWORD *v4; // x19
  __int64 *v5; // x21
  signed __int64 result; // x0
  __int64 v7; // x21
  __int64 v8; // x8
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x9
  bool v11; // cf
  size_t v12; // x20
  void *v13; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  result = CBB_flush(a1);
  if ( (_DWORD)result )
  {
    v7 = *v5;
    if ( !v7 )
      return 0LL;
    v8 = *(_QWORD *)(v7 + 8);
    v11 = __CFADD__(v8, v3);
    v9 = v8 + v3;
    if ( !v11 )
    {
      v10 = *(_QWORD *)(v7 + 16);
      if ( v9 <= v10 )
        goto LABEL_17;
      if ( *(_BYTE *)(v7 + 24) )
      {
        v11 = 2 * v10 >= v9 ? 2 * v10 >= v10 : 0;
        v12 = v11 ? 2 * v10 : v9;
        v13 = realloc(*(void **)v7, v12);
        if ( v13 )
        {
          *(_QWORD *)v7 = v13;
          *(_QWORD *)(v7 + 16) = v12;
LABEL_17:
          if ( !v4 )
            return 1LL;
          result = 1LL;
          *v4 = *(_QWORD *)v7 + *(_QWORD *)(v7 + 8);
          return result;
        }
      }
    }
    result = 0LL;
    *(_BYTE *)(v7 + 25) = 1;
  }
  return result;
}

//----- (0000000000070104) ----------------------------------------------------
signed __int64 __fastcall CBB_did_write(__int64 *a1, __int64 a2)
{
  __int64 v2; // x9
  __int64 v3; // x11
  signed __int64 result; // x0
  __int64 v5; // x8
  unsigned __int8 v6; // cf
  unsigned __int64 v7; // x8
  char v8; // w10

  v2 = *a1;
  v3 = a1[1];
  result = 0LL;
  v5 = *(_QWORD *)(v2 + 8);
  v6 = __CFADD__(v5, a2);
  v7 = v5 + a2;
  if ( v6 )
    v8 = 1;
  else
    v8 = 0;
  if ( !v3 && !(v8 & 1) )
  {
    if ( v7 <= *(_QWORD *)(v2 + 16) )
    {
      result = 1LL;
      *(_QWORD *)(v2 + 8) = v7;
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000070144) ----------------------------------------------------
signed __int64 __fastcall CBB_add_u16(char ***a1, __int16 a2)
{
  __int16 v2; // w19
  char ***v3; // x20
  signed __int64 result; // x0
  char **v5; // x21
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x10
  bool v8; // cf
  size_t v9; // x20
  char *v10; // x0
  char *v11; // x9

  v2 = a2;
  v3 = a1;
  result = CBB_flush(a1);
  if ( (_DWORD)result )
  {
    v5 = *v3;
    if ( *v3 )
    {
      v6 = (unsigned __int64)v5[1];
      if ( v6 > 0xFFFFFFFFFFFFFFFDLL )
      {
LABEL_4:
        result = 0LL;
        *((_BYTE *)v5 + 25) = 1;
        return result;
      }
      v7 = (unsigned __int64)v5[2];
      if ( v6 + 2 <= v7 )
      {
        v10 = *v5;
      }
      else
      {
        if ( !*((_BYTE *)v5 + 24) )
          goto LABEL_4;
        v8 = 2 * v7 >= v6 + 2 ? 2 * v7 >= v7 : 0;
        v9 = v8 ? 2 * v7 : v6 + 2;
        v10 = (char *)realloc(*v5, v9);
        if ( !v10 )
          goto LABEL_4;
        v6 = (unsigned __int64)v5[1];
        *v5 = v10;
        v5[2] = (char *)v9;
      }
      v11 = &v10[v6];
      result = 1LL;
      v5[1] = (char *)(v6 + 2);
      v11[1] = v2;
      *v11 = HIBYTE(v2);
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000070208) ----------------------------------------------------
signed __int64 __fastcall CBB_add_u24(char ***a1, unsigned int a2)
{
  unsigned int v2; // w19
  char ***v3; // x20
  signed __int64 result; // x0
  char **v5; // x21
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x10
  bool v8; // cf
  size_t v9; // x20
  char *v10; // x0
  char *v11; // x9

  v2 = a2;
  v3 = a1;
  result = CBB_flush(a1);
  if ( (_DWORD)result )
  {
    v5 = *v3;
    if ( !*v3 )
      return 0LL;
    v6 = (unsigned __int64)v5[1];
    if ( v6 > 0xFFFFFFFFFFFFFFFCLL )
    {
LABEL_4:
      result = 0LL;
      *((_BYTE *)v5 + 25) = 1;
      return result;
    }
    v7 = (unsigned __int64)v5[2];
    if ( v6 + 3 <= v7 )
    {
      v10 = *v5;
    }
    else
    {
      if ( !*((_BYTE *)v5 + 24) )
        goto LABEL_4;
      v8 = 2 * v7 >= v6 + 3 ? 2 * v7 >= v7 : 0;
      v9 = v8 ? 2 * v7 : v6 + 3;
      v10 = (char *)realloc(*v5, v9);
      if ( !v10 )
        goto LABEL_4;
      v6 = (unsigned __int64)v5[1];
      *v5 = v10;
      v5[2] = (char *)v9;
    }
    v11 = &v10[v6];
    result = 1LL;
    v5[1] = (char *)(v6 + 3);
    v11[2] = v2;
    v11[1] = BYTE1(v2);
    *v11 = BYTE2(v2);
    if ( v2 >> 24 )
    {
      *((_BYTE *)v5 + 25) = 1;
      return 0LL;
    }
  }
  return result;
}

//----- (00000000000702DC) ----------------------------------------------------
signed __int64 __fastcall CBB_add_u32(char ***a1, int a2)
{
  int v2; // w19
  char ***v3; // x20
  signed __int64 result; // x0
  char **v5; // x21
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x10
  bool v8; // cf
  size_t v9; // x20
  char *v10; // x0
  char *v11; // x9

  v2 = a2;
  v3 = a1;
  result = CBB_flush(a1);
  if ( (_DWORD)result )
  {
    v5 = *v3;
    if ( *v3 )
    {
      v6 = (unsigned __int64)v5[1];
      if ( v6 > 0xFFFFFFFFFFFFFFFBLL )
      {
LABEL_4:
        result = 0LL;
        *((_BYTE *)v5 + 25) = 1;
        return result;
      }
      v7 = (unsigned __int64)v5[2];
      if ( v6 + 4 <= v7 )
      {
        v10 = *v5;
      }
      else
      {
        if ( !*((_BYTE *)v5 + 24) )
          goto LABEL_4;
        v8 = 2 * v7 >= v6 + 4 ? 2 * v7 >= v7 : 0;
        v9 = v8 ? 2 * v7 : v6 + 4;
        v10 = (char *)realloc(*v5, v9);
        if ( !v10 )
          goto LABEL_4;
        v6 = (unsigned __int64)v5[1];
        *v5 = v10;
        v5[2] = (char *)v9;
      }
      v11 = &v10[v6];
      result = 1LL;
      v5[1] = (char *)(v6 + 4);
      v11[3] = v2;
      v11[2] = BYTE1(v2);
      v11[1] = BYTE2(v2);
      *v11 = HIBYTE(v2);
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000703B0) ----------------------------------------------------
_QWORD *__fastcall CBB_discard_child(_QWORD *result)
{
  __int64 v1; // x8

  v1 = result[1];
  if ( v1 )
  {
    *(_QWORD *)(*result + 8LL) = *(_QWORD *)(v1 + 16);
    *(_QWORD *)result[1] = 0LL;
    result[1] = 0LL;
  }
  return result;
}

//----- (00000000000703D4) ----------------------------------------------------
signed __int64 __fastcall CBB_add_asn1_uint64(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x20
  __int64 *v3; // x19
  signed __int64 result; // x0
  unsigned __int64 v5; // x22
  signed int v6; // w8
  char v7; // w23
  signed int v8; // w24
  unsigned __int64 v9; // x21
  _BOOL4 v10; // w9
  char v11; // [xsp+8h] [xbp-58h]
  __int64 v12; // [xsp+28h] [xbp-38h]

  v2 = a2;
  v3 = a1;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = CBB_add_asn1(a1, (__int64 *)&v11, 2u);
  if ( !(_DWORD)result )
    goto LABEL_18;
  v5 = 0LL;
  v6 = 0;
  v7 = 56;
  do
  {
    v9 = v2 >> v7;
    v8 = v6;
    if ( !v6 )
    {
      v6 = (unsigned __int8)(v2 >> v7);
      if ( !(unsigned __int8)(v2 >> v7) )
      {
        v8 = 4;
        goto LABEL_13;
      }
      if ( v9 & 0x80 )
      {
        v8 = 1;
        if ( !(unsigned int)CBB_add_u8((__int64 *)&v11, 0) )
        {
          v6 = 0;
          goto LABEL_13;
        }
      }
      else
      {
        v8 = 1;
      }
    }
    v10 = (unsigned __int64)CBB_add_u8((__int64 *)&v11, v9) == 0;
    v6 = v8;
    v8 = v10;
LABEL_13:
    if ( ((v8 | 4) & 7) != 4 )
    {
      result = 0LL;
      goto LABEL_18;
    }
    ++v5;
    v7 -= 8;
  }
  while ( v5 < 8 );
  if ( v6 || (result = CBB_add_u8((__int64 *)&v11, 0), (_DWORD)result) )
    result = CBB_flush(v3);
LABEL_18:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000704F8) ----------------------------------------------------
char *DSA_new()
{
  char *v0; // x0
  char *v1; // x19

  v0 = (char *)malloc(0xA0uLL);
  v1 = v0;
  if ( v0 )
  {
    memset(v0, 0, 0xA0uLL);
    *((_DWORD *)v1 + 36) = 1;
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v1 + 72));
    CRYPTO_new_ex_data((_QWORD *)v1 + 19);
  }
  else
  {
    ERR_put_error(10, 0LL, 65, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", 90);
  }
  return v1;
}

//----- (000000000007056C) ----------------------------------------------------
void __fastcall DSA_free(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  if ( a1 )
  {
    if ( (unsigned int)CRYPTO_refcount_dec_and_test_zero((int *)(a1 + 144)) )
    {
      CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_107198, v1, (unsigned __int64 **)(v1 + 152));
      BN_clear_free(*(void ***)(v1 + 8));
      BN_clear_free(*(void ***)(v1 + 16));
      BN_clear_free(*(void ***)(v1 + 24));
      BN_clear_free(*(void ***)(v1 + 32));
      BN_clear_free(*(void ***)(v1 + 40));
      BN_clear_free(*(void ***)(v1 + 48));
      BN_clear_free(*(void ***)(v1 + 56));
      BN_MONT_CTX_free(*(_DWORD **)(v1 + 128));
      BN_MONT_CTX_free(*(_DWORD **)(v1 + 136));
      CRYPTO_MUTEX_cleanup(v1 + 72);
      free((void *)v1);
    }
  }
}
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);

//----- (000000000007060C) ----------------------------------------------------
signed __int64 __fastcall DSA_up_ref(__int64 a1)
{
  CRYPTO_refcount_inc((_DWORD *)(a1 + 144));
  return 1LL;
}

//----- (0000000000070628) ----------------------------------------------------
void __fastcall DSA_generate_parameters_ex(_DWORD **a1, unsigned int a2, __int64 a3, unsigned __int64 a4, signed int *a5, _QWORD *a6, __int64 a7)
{
  __int64 v7; // x24
  _QWORD *v8; // x21
  signed int *v9; // x25
  unsigned __int64 v10; // x19
  __int64 v11; // x22
  unsigned int v12; // w20
  _DWORD **v13; // x26
  void *v14; // x0
  __int64 v15; // x27
  unsigned int v16; // w0
  unsigned int v17; // w28
  unsigned __int64 v18; // x2
  _DWORD *v19; // x0
  _DWORD *v20; // x19
  _QWORD *v21; // x23
  _QWORD *v22; // x0
  __int64 v23; // x24
  __int64 *v24; // x0
  unsigned int v25; // w20
  __int64 v26; // x23
  unsigned int v27; // w25
  int8x16_t *v28; // x10
  int8x16_t *v29; // x9
  unsigned int v30; // w8
  int v31; // w11
  int v32; // w0
  int v33; // w0
  unsigned __int64 v34; // x10
  unsigned __int64 v35; // x8
  int8x16_t v36; // q0
  int8x16_t v37; // q1
  int8x16_t v38; // q1
  char *v39; // x8
  char *v40; // x9
  unsigned __int64 v41; // x10
  char v42; // t1
  int v43; // w0
  __int64 v44; // x22
  unsigned int v45; // w8
  __int64 v46; // x0
  unsigned int v47; // w23
  int v48; // w0
  int v49; // w22
  unsigned int v50; // w8
  __int64 v51; // x9
  char v52; // w10
  int v53; // w0
  bool v54; // nf
  unsigned __int8 v55; // vf
  void **v56; // x0
  int v57; // w0
  void **v58; // x0
  int v59; // w0
  unsigned int v60; // w20
  void **v61; // x0
  int v62; // w0
  signed int *v63; // x0
  _DWORD *v64; // x8
  signed int v65; // [xsp+14h] [xbp-17Ch]
  signed int *v66; // [xsp+18h] [xbp-178h]
  unsigned int v67; // [xsp+40h] [xbp-150h]
  __int64 v68; // [xsp+48h] [xbp-148h]
  signed int *v69; // [xsp+70h] [xbp-120h]
  _QWORD *v70; // [xsp+78h] [xbp-118h]
  signed int *v71; // [xsp+80h] [xbp-110h]
  _QWORD *v72; // [xsp+88h] [xbp-108h]
  __int64 *v73; // [xsp+90h] [xbp-100h]
  _QWORD *v74; // [xsp+98h] [xbp-F8h]
  __int64 v75; // [xsp+A8h] [xbp-E8h]
  signed int *v76; // [xsp+B0h] [xbp-E0h]
  char v77[32]; // [xsp+B8h] [xbp-D8h]
  char v78[32]; // [xsp+C8h] [xbp-C8h]
  char v79[32]; // [xsp+D8h] [xbp-B8h]
  char v80[32]; // [xsp+F8h] [xbp-98h]
  char v81[32]; // [xsp+108h] [xbp-88h]
  char v82; // [xsp+118h] [xbp-78h]
  __int64 v83; // [xsp+138h] [xbp-58h]

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  v83 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 < 0x800 )
    v14 = EVP_sha1();
  else
    v14 = EVP_sha256();
  v15 = (__int64)v14;
  v16 = X509_TRUST_get_flags((__int64)v14);
  v17 = v16;
  if ( v12 < 0x200 )
    v12 = 512;
  if ( !v11 )
  {
LABEL_13:
    v19 = BN_CTX_new();
    v20 = v19;
    if ( v19 )
    {
      BN_CTX_start((__int64)v19);
      v21 = BN_MONT_CTX_new();
      if ( v21 )
      {
        v73 = BN_CTX_get((__int64)v20);
        v69 = (signed int *)BN_CTX_get((__int64)v20);
        v74 = BN_CTX_get((__int64)v20);
        v76 = (signed int *)BN_CTX_get((__int64)v20);
        v72 = BN_CTX_get((__int64)v20);
        v70 = BN_CTX_get((__int64)v20);
        v71 = (signed int *)BN_CTX_get((__int64)v20);
        v22 = BN_CTX_get((__int64)v20);
        if ( v22
          && (v75 = v7,
              v23 = (__int64)v22,
              v24 = (__int64 *)BN_value_one(),
              v25 = ((v12 + 63) & 0xFFFFFFC0) - 1,
              (unsigned int)BN_lshift(v23, v24, v25)) )
        {
          v68 = (__int64)v21;
          v26 = v75;
          v66 = v9;
          v27 = 0;
          v67 = v25 / 0xA0;
          while ( 1 )
          {
LABEL_22:
            if ( !(unsigned int)BN_GENCB_call(v26, 0, v27)
              || !v11 && !(unsigned int)RAND_pseudo_bytes((signed __int64)&v82, v17) )
            {
              goto LABEL_90;
            }
            if ( v17 )
            {
              __memcpy_chk();
              __memcpy_chk();
            }
            if ( v17 )
            {
              v30 = v17 - 1;
              do
              {
                v31 = ((unsigned __int8)v79[v30]++ + 1) & 0xFF;
                if ( v31 )
                  break;
                --v30;
              }
              while ( v30 < v17 );
            }
            EVP_Digest((__int64)&v82, v17, (__int64)v80, 0LL, v15);
            if ( !v32 )
              goto LABEL_90;
            EVP_Digest((__int64)v79, v17, (__int64)v77, 0LL, v15);
            if ( !v33 )
              goto LABEL_90;
            if ( v17 )
            {
              v34 = 0LL;
              if ( v17 < 0x20uLL )
                goto LABEL_97;
              if ( v17 == (unsigned __int64)(v17 & 0x1F) )
                goto LABEL_97;
              v35 = v17 - (unsigned __int64)(v17 & 0x1F);
              v29 = (int8x16_t *)v81;
              v28 = (int8x16_t *)v78;
              do
              {
                v36 = v28[-1];
                v37 = *v28;
                v28 += 2;
                v35 -= 32LL;
                v38 = veorq_s8(*v29, v37);
                v29[-1] = veorq_s8(v29[-1], v36);
                *v29 = v38;
                v29 += 2;
              }
              while ( v35 );
              v34 = v17 - (unsigned __int64)(v17 & 0x1F);
              if ( v17 & 0x1F )
              {
LABEL_97:
                v39 = &v77[v34];
                v40 = &v80[v34];
                v41 = v17 - v34;
                do
                {
                  v42 = *v39++;
                  --v41;
                  *v40 ^= v42;
                  ++v40;
                }
                while ( v41 );
              }
            }
            v80[0] |= 0x80u;
            v80[v17 - 1] |= 1u;
            if ( !BN_bin2bn((unsigned __int8 *)v80, v17, (__int64)v76) )
              goto LABEL_90;
            v26 = v75;
            ++v27;
            v43 = BN_is_prime_fasttest_ex((__int64)v76, 50, v20, v11 == 0, v75);
            if ( v43 > 0 )
              break;
            v11 = 0LL;
            if ( v43 )
              goto LABEL_90;
          }
          if ( (unsigned int)BN_GENCB_call(v75, 2u, 0) && (unsigned int)BN_GENCB_call(v75, 3u, 0) )
          {
            v44 = (__int64)v74;
            v45 = 0;
            while ( 2 )
            {
              if ( !v45 )
                goto LABEL_98;
              v46 = v26;
              v47 = v45;
              v48 = BN_GENCB_call(v46, 0, v45);
              v45 = v47;
              if ( v48 )
              {
LABEL_98:
                v65 = v45;
                BN_zero(v44);
                v49 = 0;
                do
                {
                  v50 = v17 - 1;
                  do
                  {
                    if ( v50 >= v17 )
                      break;
                    v51 = v50;
                    v52 = v79[v50--];
                    v79[v51] = ++v52;
                  }
                  while ( !v52 );
                  EVP_Digest((__int64)v79, v17, (__int64)v80, 0LL, v15);
                  if ( !v53
                    || !BN_bin2bn((unsigned __int8 *)v80, v17, (__int64)v73)
                    || !(unsigned int)BN_lshift((__int64)v73, v73, 8 * v17 * v49)
                    || !(unsigned int)BN_add((__int64)v74, (__int64)v74, (__int64)v73) )
                  {
                    goto LABEL_90;
                  }
                  v55 = __OFSUB__(v49, v67);
                  v54 = (signed int)(v49++ - v67) < 0;
                }
                while ( v54 ^ v55 );
                if ( !(unsigned int)BN_mask_bits((__int64)v74, v25) )
                  break;
                if ( !BN_copy((__int64)v72, (__int64)v74) )
                  break;
                if ( !(unsigned int)BN_add((__int64)v72, (__int64)v72, v23) )
                  break;
                if ( !(unsigned int)BN_lshift1((__int64)v73, (__int64)v76) )
                  break;
                if ( !(unsigned int)BN_div(0LL, (__int64)v70, (__int64)v72, (__int64)v73, (__int64)v20) )
                  break;
                v56 = BN_value_one();
                if ( !(unsigned int)BN_sub((__int64)v73, (__int64)v70, (__int64)v56)
                  || !(unsigned int)BN_sub((__int64)v71, (__int64)v72, (__int64)v73) )
                {
                  break;
                }
                v44 = (__int64)v74;
                v26 = v75;
                if ( BN_cmp((__int64)v71, v23) & 0x80000000 )
                {
LABEL_69:
                  v45 = v65 + 1;
                  if ( v65 <= 4094 )
                    continue;
                  v11 = 0LL;
                  goto LABEL_22;
                }
                v57 = BN_is_prime_fasttest_ex((__int64)v71, 50, v20, 1, v75);
                if ( v57 <= 0 )
                {
                  if ( v57 )
                    break;
                  goto LABEL_69;
                }
                if ( (unsigned int)BN_GENCB_call(v75, 2u, 1u) )
                {
                  v58 = BN_value_one();
                  if ( (unsigned int)BN_sub(v23, (__int64)v71, (__int64)v58) )
                  {
                    if ( (unsigned int)BN_div(v73, 0LL, v23, (__int64)v76, (__int64)v20) )
                    {
                      if ( (unsigned int)BN_set_word(v23, 2LL) )
                      {
                        if ( BN_MONT_CTX_set(v68, (__int64)v71) )
                        {
                          BN_mod_exp_mont((__int64)v69, v23, (__int64)v73, (__int64)v71, (__int64)v20, v68);
                          if ( v59 )
                          {
                            v21 = (_QWORD *)v68;
                            v60 = 2;
                            while ( BN_is_one((__int64)v69) )
                            {
                              v61 = BN_value_one();
                              if ( !(unsigned int)BN_add(v23, v23, (__int64)v61) )
                                goto LABEL_90;
                              ++v60;
                              BN_mod_exp_mont((__int64)v69, v23, (__int64)v73, (__int64)v71, (__int64)v20, v68);
                              if ( !v62 )
                                goto LABEL_91;
                            }
                            if ( (unsigned int)BN_GENCB_call(v75, 3u, 1u) )
                            {
                              BN_free(v13[1]);
                              BN_free(v13[2]);
                              BN_free(v13[3]);
                              v13[1] = BN_dup(v71);
                              v13[2] = BN_dup(v76);
                              v63 = BN_dup(v69);
                              v64 = v13[1];
                              v13[3] = v63;
                              if ( v64 )
                              {
                                if ( v63 )
                                {
                                  v21 = (_QWORD *)v68;
                                  if ( !v13[2] )
                                    goto LABEL_91;
                                  if ( v66 )
                                    *v66 = v65;
                                  if ( v8 )
                                    *v8 = v60;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;
            }
          }
LABEL_90:
          v21 = (_QWORD *)v68;
LABEL_91:
          if ( !v20 )
            goto LABEL_93;
        }
        else if ( !v20 )
        {
          goto LABEL_93;
        }
      }
      BN_CTX_end((__int64)v20);
      BN_CTX_free((__int64)v20);
    }
    else
    {
      v21 = 0LL;
    }
LABEL_93:
    BN_MONT_CTX_free(v21);
    goto LABEL_94;
  }
  if ( v16 <= v10 )
  {
    if ( v16 >= v10 )
      v18 = v10;
    else
      v18 = v16;
    if ( v18 )
      __memcpy_chk();
    goto LABEL_13;
  }
LABEL_94:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 70628: using guessed type char var_D8[32];
// 70628: using guessed type char var_98[32];
// 70628: using guessed type char var_B8[32];

//----- (0000000000070D9C) ----------------------------------------------------
__int64 __fastcall DSAparams_dup(signed int **a1)
{
  signed int **v1; // x20
  void *v2; // x0
  __int64 v3; // x19
  signed int *v4; // x0
  __int64 v5; // x8

  v1 = a1;
  v2 = malloc(0xA0uLL);
  v3 = (__int64)v2;
  if ( v2 )
  {
    memset(v2, 0, 0xA0uLL);
    *(_DWORD *)(v3 + 144) = 1;
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v3 + 72));
    CRYPTO_new_ex_data((_QWORD *)(v3 + 152));
    *(_QWORD *)(v3 + 8) = BN_dup(v1[1]);
    *(_QWORD *)(v3 + 16) = BN_dup(v1[2]);
    v4 = BN_dup(v1[3]);
    v5 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 24) = v4;
    if ( !v5 || !v4 || !*(_QWORD *)(v3 + 16) )
    {
      DSA_free(v3);
      v3 = 0LL;
    }
  }
  else
  {
    ERR_put_error(10, 0LL, 65, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", 90);
  }
  return v3;
}

//----- (0000000000070E58) ----------------------------------------------------
__int64 __fastcall DSA_generate_key(__int64 a1)
{
  __int64 v1; // x20
  _DWORD *v2; // x19
  _QWORD *v3; // x21
  _QWORD *v4; // x22
  int v5; // w0
  unsigned int v6; // w23

  v1 = a1;
  v2 = BN_CTX_new();
  if ( v2 )
  {
    v3 = *(_QWORD **)(v1 + 40);
    if ( (v3 || (v3 = BN_new()) != 0LL) && (unsigned int)BN_rand_range_ex((__int64)v3, 1uLL, *(_QWORD *)(v1 + 16)) )
    {
      v4 = *(_QWORD **)(v1 + 32);
      if ( (v4 || (v4 = BN_new()) != 0LL)
        && sub_6BAC4((__int64 *)(v1 + 128), (pthread_rwlock_t *)(v1 + 72), *(_QWORD *)(v1 + 8))
        && (BN_mod_exp_mont_consttime(
              (__int64)v4,
              *(_QWORD *)(v1 + 24),
              (__int64)v3,
              *(_QWORD *)(v1 + 8),
              (__int64)v2,
              *(_QWORD *)(v1 + 128)),
            v5) )
      {
        v6 = 1;
        *(_QWORD *)(v1 + 32) = v4;
        *(_QWORD *)(v1 + 40) = v3;
        if ( *(_QWORD *)(v1 + 32) )
          goto LABEL_17;
      }
      else
      {
        v6 = 0;
        if ( *(_QWORD *)(v1 + 32) )
          goto LABEL_17;
      }
    }
    else
    {
      v6 = 0;
      v4 = 0LL;
      if ( *(_QWORD *)(v1 + 32) )
        goto LABEL_17;
    }
  }
  else
  {
    v6 = 0;
    v4 = 0LL;
    v3 = 0LL;
    if ( *(_QWORD *)(v1 + 32) )
      goto LABEL_17;
  }
  BN_free(v4);
LABEL_17:
  if ( !*(_QWORD *)(v1 + 40) )
    BN_free(v3);
  BN_CTX_free((__int64)v2);
  return v6;
}

//----- (0000000000070F74) ----------------------------------------------------
_QWORD *ENGINE_new()
{
  _QWORD *result; // x0

  result = malloc(0x10uLL);
  if ( result )
  {
    *result = 0LL;
    result[1] = 0LL;
  }
  return result;
}

//----- (0000000000070F94) ----------------------------------------------------
void __fastcall ECDSA_SIG_free(_DWORD **a1)
{
  _DWORD **v1; // x19

  v1 = a1;
  if ( a1 )
  {
    BN_free(*a1);
    BN_free(v1[1]);
    free(v1);
  }
}

//----- (0000000000070FD4) ----------------------------------------------------
void __fastcall DSA_do_sign(unsigned __int8 *a1, unsigned __int64 a2, _QWORD *a3)
{
  unsigned __int8 *v3; // x22
  _QWORD *v4; // x21
  unsigned __int64 v5; // x23
  _QWORD *v6; // x20
  _DWORD *v7; // x19
  __int64 v8; // x8
  signed int v9; // w26
  int v10; // w0
  _DWORD *v11; // x24
  void **v12; // x25
  int v13; // w2
  _QWORD *v14; // x0
  void *v15[3]; // [xsp+8h] [xbp-88h]
  void *v16[3]; // [xsp+20h] [xbp-70h]
  _DWORD *v17; // [xsp+38h] [xbp-58h]
  void **v18; // [xsp+40h] [xbp-50h]
  __int64 v19; // [xsp+48h] [xbp-48h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  v18 = 0LL;
  BN_init(v16);
  BN_init(v15);
  if ( !v4[1] || !v4[2] || !v4[3] )
  {
    v12 = 0LL;
    v11 = 0LL;
    v6 = 0LL;
    v7 = 0LL;
    v13 = 101;
    goto LABEL_24;
  }
  v6 = BN_new();
  if ( !v6 )
  {
    v12 = 0LL;
    v11 = 0LL;
    v7 = 0LL;
    v13 = 3;
    goto LABEL_24;
  }
  v7 = BN_CTX_new();
  if ( !v7 )
  {
    v12 = 0LL;
    v11 = 0LL;
    v13 = 3;
    goto LABEL_24;
  }
  while ( 1 )
  {
    v8 = v4[6];
    if ( v8 && v4[7] )
    {
      v9 = 1;
      v17 = (_DWORD *)v4[7];
      v18 = (void **)v8;
      *((_OWORD *)v4 + 3) = 0u;
    }
    else
    {
      DSA_sign_setup(v4, v7, &v18, (void ***)&v17);
      if ( !v10 )
        goto LABEL_28;
      v9 = 0;
    }
    if ( v5 > (unsigned int)BN_num_bytes(v4[2]) )
      v5 = (unsigned int)BN_num_bytes(v4[2]);
    if ( !BN_bin2bn(v3, v5, (__int64)v16)
      || (v11 = v17, !(unsigned int)BN_mod_mul((__int64)v15, v4[5], (__int64)v17, v4[2], (__int64)v7))
      || !(unsigned int)BN_add((__int64)v6, (__int64)v15, (__int64)v16)
      || (signed int)BN_cmp((__int64)v6, v4[2]) >= 1 && !(unsigned int)BN_sub((__int64)v6, (__int64)v6, v4[2])
      || (v12 = v18, !(unsigned int)BN_mod_mul((__int64)v6, (__int64)v6, (__int64)v18, v4[2], (__int64)v7)) )
    {
LABEL_28:
      v13 = 3;
      goto LABEL_29;
    }
    if ( !BN_is_zero((__int64)v11) && !BN_is_zero((__int64)v6) )
      break;
    if ( v9 )
    {
      v13 = 103;
LABEL_29:
      v11 = v17;
      v12 = v18;
      goto LABEL_24;
    }
  }
  v14 = malloc(0x10uLL);
  if ( v14 )
  {
    *v14 = v11;
    v14[1] = v6;
    goto LABEL_25;
  }
  v13 = 3;
LABEL_24:
  ERR_put_error(10, 0LL, v13, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", 591);
  BN_free(v11);
  BN_free(v6);
LABEL_25:
  BN_CTX_free((__int64)v7);
  BN_clear_free(v16);
  BN_clear_free(v15);
  BN_clear_free(v12);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v19;
}

//----- (0000000000071244) ----------------------------------------------------
void __fastcall DSA_sign_setup(_QWORD *a1, _DWORD *a2, void ***a3, void ***a4)
{
  _QWORD *v4; // x24
  void ***v5; // x22
  void ***v6; // x23
  _DWORD *v7; // x19
  _DWORD *v8; // x20
  void **v9; // x21
  unsigned int v10; // w25
  int v11; // w0
  void **v12; // x0
  void **v13; // x25
  void *v14[3]; // [xsp+8h] [xbp-78h]
  void *v15[3]; // [xsp+20h] [xbp-60h]
  __int64 v16; // [xsp+38h] [xbp-48h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a2;
  if ( a1[1] && a1[2] && a1[3] )
  {
    BN_init(v15);
    BN_init(v14);
    v8 = v7;
    if ( v7 || (v8 = BN_CTX_new()) != 0LL )
    {
      v9 = (void **)BN_new();
      if ( v9 )
      {
        if ( (unsigned int)BN_rand_range_ex((__int64)v15, 1uLL, v4[2])
          && sub_6BAC4(v4 + 16, (pthread_rwlock_t *)(v4 + 9), v4[1])
          && sub_6BAC4(v4 + 17, (pthread_rwlock_t *)(v4 + 9), v4[2])
          && BN_copy((__int64)v14, (__int64)v15)
          && (unsigned int)BN_add((__int64)v14, (__int64)v14, v4[2])
          && ((v10 = BN_num_bits((__int64)v14), v10 > (unsigned int)BN_num_bits(v4[2]))
           || (unsigned int)BN_add((__int64)v14, (__int64)v14, v4[2]))
          && (BN_mod_exp_mont_consttime((__int64)v9, v4[3], (__int64)v14, v4[1], (__int64)v8, v4[16]), v11)
          && (unsigned int)BN_div(0LL, (__int64)v9, (__int64)v9, v4[2], (__int64)v8) )
        {
          v12 = (void **)BN_new();
          v13 = v12;
          if ( v12 && (unsigned int)sub_69FB8((__int64)v12, (__int64)v15, v4[2], (__int64)v8, v4[17]) )
          {
            BN_clear_free(*v6);
            *v6 = v13;
            BN_clear_free(*v5);
            v13 = 0LL;
            *v5 = v9;
            if ( !v7 )
              goto LABEL_25;
            goto LABEL_26;
          }
        }
        else
        {
          v13 = 0LL;
        }
        ERR_put_error(10, 0LL, 3, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", 895);
        BN_clear_free(v9);
        if ( !v7 )
          goto LABEL_25;
        goto LABEL_26;
      }
    }
    ERR_put_error(10, 0LL, 3, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", 895);
    v13 = 0LL;
    if ( !v7 )
LABEL_25:
      BN_CTX_free((__int64)v8);
LABEL_26:
    BN_clear_free(v15);
    BN_clear_free(v14);
    BN_clear_free(v13);
    goto LABEL_27;
  }
  ERR_put_error(10, 0LL, 101, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", 818);
LABEL_27:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000714C8) ----------------------------------------------------
signed __int64 __fastcall DSA_do_verify(unsigned __int8 *a1, unsigned __int64 a2, __int64 *a3, _QWORD *a4)
{
  unsigned __int64 v4; // x19
  __int64 v5; // x9
  int v6; // w0
  signed __int64 result; // x0
  unsigned int v8; // [xsp+4h] [xbp-1Ch]
  __int64 v9; // [xsp+8h] [xbp-18h]

  v4 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v9 = *(_QWORD *)(v4 + 40);
  DSA_do_check_signature(&v8, a1, a2, a3, a4);
  v5 = *(_QWORD *)(v4 + 40);
  if ( v6 )
    result = v8;
  else
    result = 1LL;
  return result;
}

//----- (000000000007153C) ----------------------------------------------------
void __fastcall DSA_do_check_signature(_DWORD *a1, unsigned __int8 *a2, unsigned __int64 a3, __int64 *a4, _QWORD *a5)
{
  _DWORD *v5; // x19
  _QWORD *v6; // x22
  __int64 *v7; // x20
  unsigned __int64 v8; // x23
  unsigned __int8 *v9; // x24
  __int64 v10; // x0
  unsigned int v11; // w25
  int v12; // w2
  __int16 v13; // w4
  _DWORD *v14; // x21
  __int64 v15; // x0
  __int64 v16; // x1
  int v17; // w0
  __int64 v18; // [xsp+0h] [xbp-90h]
  _QWORD v19[3]; // [xsp+18h] [xbp-78h]
  _QWORD v20[3]; // [xsp+30h] [xbp-60h]
  __int64 v21; // [xsp+48h] [xbp-48h]

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *a1 = 0;
  v8 = a3;
  v9 = a2;
  if ( !a5[1] || (v10 = a5[2]) == 0 || !a5[3] )
  {
    v12 = 101;
    v13 = 622;
    goto LABEL_10;
  }
  v11 = BN_num_bits(v10);
  if ( v11 != 160 && v11 != 224 && v11 != 256 )
  {
    v12 = 100;
    v13 = 629;
    goto LABEL_10;
  }
  if ( (unsigned int)BN_num_bits(v6[1]) < 0x2711 )
  {
    BN_init(v20);
    BN_init(v19);
    BN_init(&v18);
    v14 = BN_CTX_new();
    if ( !v14 )
      goto LABEL_37;
    if ( BN_is_zero(*v7)
      || BN_is_negative(*v7)
      || !(BN_ucmp(*v7, v6[2]) & 0x80000000)
      || BN_is_zero(v7[1])
      || BN_is_negative(v7[1])
      || !(BN_ucmp(v7[1], v6[2]) & 0x80000000) )
    {
      goto LABEL_34;
    }
    BN_mod_inverse(v19, (signed int *)v7[1], v6[2], (__int64)v14);
    if ( v15
      && (v11 >> 3 >= v8 ? (v16 = v8) : (v16 = v11 >> 3),
          BN_bin2bn(v9, v16, (__int64)v20)
       && (unsigned int)BN_mod_mul((__int64)v20, (__int64)v20, (__int64)v19, v6[2], (__int64)v14)
       && (unsigned int)BN_mod_mul((__int64)v19, *v7, (__int64)v19, v6[2], (__int64)v14)
       && sub_6BAC4(v6 + 16, (pthread_rwlock_t *)(v6 + 9), v6[1])
       && (BN_mod_exp2_mont((__int64)&v18, v6[3], (__int64)v20, v6[4], (__int64)v19, v6[1], (__int64)v14, v6[16]), v17)
       && (unsigned int)BN_div(0LL, (__int64)v20, (__int64)&v18, v6[2], (__int64)v14)) )
    {
      *v5 = (unsigned __int64)BN_ucmp((__int64)v20, *v7) == 0;
    }
    else
    {
LABEL_37:
      ERR_put_error(10, 0LL, 3, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", 710);
    }
LABEL_34:
    BN_CTX_free((__int64)v14);
    BN_free(v20);
    BN_free(v19);
    BN_free(&v18);
    goto LABEL_11;
  }
  v12 = 102;
  v13 = 634;
LABEL_10:
  ERR_put_error(10, 0LL, v12, (__int64)"external/boringssl/src/crypto/dsa/dsa.c", v13);
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v21;
}

//----- (000000000007181C) ----------------------------------------------------
signed __int64 __fastcall DSA_sign(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, __int64 a4, _DWORD *a5, _QWORD *a6)
{
  _DWORD *v6; // x19
  __int64 *v7; // x0
  __int64 *v8; // x20
  signed __int64 result; // x0
  __int64 v10; // [xsp+0h] [xbp-20h]
  __int64 v11; // [xsp+8h] [xbp-18h]

  v6 = a5;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = a4;
  DSA_do_sign(a2, a3, a6);
  v8 = v7;
  if ( v7 )
  {
    *v6 = i2d_DSA_SIG(v7, (void **)&v10);
    BN_free((_DWORD *)*v8);
    BN_free((_DWORD *)v8[1]);
    free(v8);
    result = 1LL;
  }
  else
  {
    result = 0LL;
    *v6 = 0;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000718B8) ----------------------------------------------------
signed __int64 __fastcall DSA_verify(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, char *a4, size_t a5, _QWORD *a6)
{
  unsigned __int64 v6; // x19
  __int64 v7; // x9
  int v8; // w0
  signed __int64 result; // x0
  unsigned int v10; // [xsp+4h] [xbp-1Ch]
  __int64 v11; // [xsp+8h] [xbp-18h]

  v6 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v11 = *(_QWORD *)(v6 + 40);
  DSA_check_signature(&v10, a2, a3, a4, a5, a6);
  v7 = *(_QWORD *)(v6 + 40);
  if ( v8 )
    result = v10;
  else
    result = 1LL;
  return result;
}

//----- (000000000007190C) ----------------------------------------------------
void __fastcall DSA_check_signature(_DWORD *a1, unsigned __int8 *a2, unsigned __int64 a3, char *a4, size_t a5, _QWORD *a6)
{
  _DWORD *v6; // x22
  _QWORD *v7; // x19
  size_t v8; // x23
  char *v9; // x24
  unsigned __int64 v10; // x20
  unsigned __int8 *v11; // x21
  __int64 *v12; // x0
  __int64 v13; // x0
  __int64 *v14; // x19
  int v15; // w0
  char *v16; // [xsp+0h] [xbp-60h]
  void *v17; // [xsp+8h] [xbp-58h]
  __int64 *v18; // [xsp+10h] [xbp-50h]
  __int64 v19; // [xsp+18h] [xbp-48h]

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  v18 = 0LL;
  v12 = (__int64 *)malloc(0x10uLL);
  if ( v12 )
  {
    *v12 = 0LL;
    v12[1] = 0LL;
    v18 = v12;
    v16 = v9;
    d2i_DSA_SIG((_DWORD ***)&v18, (__int64 *)&v16, v8);
    if ( v13 )
    {
      if ( v16 == &v9[v8] )
      {
        v15 = i2d_DSA_SIG(v18, &v17);
        if ( !(v15 & 0x80000000) && v15 == v8 && (!v8 || !(unsigned int)memcmp(v9, v17, v8)) )
          DSA_do_check_signature(v6, v11, v10, v18, v7);
      }
    }
  }
  else
  {
    v18 = 0LL;
  }
  free(v17);
  v14 = v18;
  if ( v18 )
  {
    BN_free((_DWORD *)*v18);
    BN_free((_DWORD *)v14[1]);
    free(v14);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v19;
}

//----- (0000000000071A54) ----------------------------------------------------
__int64 __fastcall DSA_size(__int64 a1)
{
  unsigned int v1; // w0
  unsigned __int64 v2; // x10
  signed __int64 v3; // x9
  unsigned __int64 v4; // x9
  __int64 result; // x0
  unsigned __int64 v6; // x8
  signed __int64 v7; // x9
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x9

  v1 = BN_num_bytes(*(_QWORD *)(a1 + 16));
  v2 = v1 + 1LL;
  v3 = 1LL;
  if ( v2 >= 0x80 )
  {
    do
    {
      ++v3;
      v2 >>= 8;
    }
    while ( v2 );
  }
  v4 = v1 + v3 + 2;
  if ( v4 < v1 )
    return 0LL;
  v6 = 2 * v4;
  if ( 2 * v4 < v4 )
    return 0LL;
  v7 = 1LL;
  if ( v6 >= 0x80 )
  {
    v8 = v6;
    do
    {
      ++v7;
      v8 >>= 8;
    }
    while ( v8 );
  }
  v9 = (v6 | 1) + v7;
  if ( v9 >= v6 )
    result = (unsigned int)v9;
  else
    result = 0LL;
  return result;
}

//----- (0000000000071AEC) ----------------------------------------------------
signed __int64 __fastcall DSA_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // x19
  int v6; // w0
  __int64 v7; // x9
  signed __int64 result; // x0
  unsigned int v9; // [xsp+4h] [xbp-1Ch]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = *(_QWORD *)(v5 + 40);
  v6 = CRYPTO_get_ex_new_index((pthread_rwlock_t *)&unk_107198, &v9, a1, a2, a4, a5);
  v7 = *(_QWORD *)(v5 + 40);
  if ( v6 )
    result = v9;
  else
    result = 1LL;
  return result;
}

//----- (0000000000071B68) ----------------------------------------------------
signed __int64 __fastcall DSA_set_ex_data(__int64 a1, int a2, __int64 a3)
{
  return CRYPTO_set_ex_data((unsigned __int64 **)(a1 + 152), a2, a3);
}

//----- (0000000000071B70) ----------------------------------------------------
unsigned __int64 *__fastcall DSA_get_ex_data(__int64 a1, int a2)
{
  return CRYPTO_get_ex_data((unsigned __int64 **)(a1 + 152), a2);
}

//----- (0000000000071B78) ----------------------------------------------------
char *__fastcall DSA_dup_DH(__int64 a1)
{
  __int64 v1; // x20
  char *v2; // x19
  __int64 v3; // x0
  signed int *v4; // x0
  signed int *v5; // x0
  signed int *v6; // x0
  signed int *v7; // x0
  signed int *v8; // x0
  signed int *v9; // x0
  signed int *v10; // x0
  signed int *v11; // x0
  signed int *v12; // x0

  v1 = a1;
  if ( !a1 )
  {
    v2 = 0LL;
LABEL_15:
    DH_free((__int64)v2);
    return 0LL;
  }
  v2 = DH_new();
  if ( !v2 )
    goto LABEL_15;
  v3 = *(_QWORD *)(v1 + 16);
  if ( v3 )
  {
    *((_DWORD *)v2 + 8) = BN_num_bits(v3);
    v4 = BN_dup(*(signed int **)(v1 + 16));
    *((_QWORD *)v2 + 13) = v4;
    if ( !v4 )
      goto LABEL_15;
  }
  v5 = *(signed int **)(v1 + 8);
  if ( v5 )
  {
    v6 = BN_dup(v5);
    *(_QWORD *)v2 = v6;
    if ( !v6 )
      goto LABEL_15;
  }
  v7 = *(signed int **)(v1 + 24);
  if ( v7 )
  {
    v8 = BN_dup(v7);
    *((_QWORD *)v2 + 1) = v8;
    if ( !v8 )
      goto LABEL_15;
  }
  v9 = *(signed int **)(v1 + 32);
  if ( v9 )
  {
    v10 = BN_dup(v9);
    *((_QWORD *)v2 + 2) = v10;
    if ( !v10 )
      goto LABEL_15;
  }
  v11 = *(signed int **)(v1 + 40);
  if ( v11 )
  {
    v12 = BN_dup(v11);
    *((_QWORD *)v2 + 3) = v12;
    if ( !v12 )
      goto LABEL_15;
  }
  return v2;
}

//----- (0000000000071C2C) ----------------------------------------------------
void __fastcall DSA_SIG_parse(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // x20
  _QWORD *v2; // x19
  _QWORD *v3; // x8
  _QWORD *v4; // x8
  unsigned __int8 *v5[2]; // [xsp+8h] [xbp-28h]
  __int64 v6; // [xsp+18h] [xbp-18h]

  v1 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = ENGINE_new();
  if ( v2 )
  {
    if ( !(unsigned int)CBS_get_asn1(v1, (char *)v5, 48)
      || (v3 = BN_new(), (*v2 = v3) == 0LL)
      || !BN_parse_asn1_unsigned(v5, (__int64)v3)
      || (v4 = BN_new(), (v2[1] = v4) == 0LL)
      || !BN_parse_asn1_unsigned(v5, (__int64)v4)
      || EVP_CIPHER_CTX_get_app_data((__int64)v5) )
    {
      ERR_put_error(10, 0LL, 105, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 95);
      ECDSA_SIG_free((_DWORD **)v2);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000071D0C) ----------------------------------------------------
signed __int64 __fastcall DSA_SIG_marshal(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // x20
  __int64 *v3; // x19
  __int64 v4; // x1
  signed __int64 result; // x0
  char v6; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBB_add_asn1(a1, (__int64 *)&v6, 0x30u) )
    goto LABEL_9;
  v4 = *v2;
  if ( !*v2 )
    goto LABEL_13;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
  {
LABEL_9:
    ERR_put_error(10, 0LL, 106, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 108);
    result = 0LL;
    goto LABEL_10;
  }
  v4 = v2[1];
  if ( !v4 )
  {
LABEL_13:
    ERR_put_error(10, v4, 67, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 79);
    goto LABEL_9;
  }
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) || !(unsigned int)CBB_flush(v3) )
    goto LABEL_9;
  result = 1LL;
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000071DDC) ----------------------------------------------------
void __fastcall DSA_parse_public_key(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // x20
  char *v2; // x19
  _QWORD *v3; // x8
  _QWORD *v4; // x8
  _QWORD *v5; // x8
  _QWORD *v6; // x8
  unsigned __int8 *v7[2]; // [xsp+8h] [xbp-28h]
  __int64 v8; // [xsp+18h] [xbp-18h]

  v1 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = DSA_new();
  if ( v2 )
  {
    if ( !(unsigned int)CBS_get_asn1(v1, (char *)v7, 48) )
      goto LABEL_16;
    v3 = BN_new();
    *((_QWORD *)v2 + 4) = v3;
    if ( !v3
      || !BN_parse_asn1_unsigned(v7, (__int64)v3)
      || (v4 = BN_new(), (*((_QWORD *)v2 + 1) = v4) == 0LL)
      || !BN_parse_asn1_unsigned(v7, (__int64)v4)
      || (v5 = BN_new(), (*((_QWORD *)v2 + 2) = v5) == 0LL)
      || !BN_parse_asn1_unsigned(v7, (__int64)v5)
      || (v6 = BN_new(), (*((_QWORD *)v2 + 3) = v6) == 0LL)
      || !BN_parse_asn1_unsigned(v7, (__int64)v6)
      || EVP_CIPHER_CTX_get_app_data((__int64)v7) )
    {
LABEL_16:
      ERR_put_error(10, 0LL, 105, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 126);
      DSA_free((__int64)v2);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000071EFC) ----------------------------------------------------
signed __int64 __fastcall DSA_marshal_public_key(__int64 *a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  __int64 *v3; // x19
  __int64 v4; // x1
  signed __int64 result; // x0
  char v6; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBB_add_asn1(a1, (__int64 *)&v6, 0x30u) )
    goto LABEL_13;
  v4 = v2[4];
  if ( !v4 )
    goto LABEL_12;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
    goto LABEL_13;
  v4 = v2[1];
  if ( !v4 )
  {
LABEL_12:
    ERR_put_error(10, v4, 67, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 79);
    goto LABEL_13;
  }
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
  {
LABEL_13:
    ERR_put_error(10, 0LL, 106, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 141);
    result = 0LL;
    goto LABEL_14;
  }
  v4 = v2[2];
  if ( !v4 )
    goto LABEL_12;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
    goto LABEL_13;
  v4 = v2[3];
  if ( !v4 )
    goto LABEL_12;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) || !(unsigned int)CBB_flush(v3) )
    goto LABEL_13;
  result = 1LL;
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000071FF4) ----------------------------------------------------
void __fastcall DSA_parse_parameters(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // x20
  char *v2; // x19
  _QWORD *v3; // x8
  _QWORD *v4; // x8
  _QWORD *v5; // x8
  unsigned __int8 *v6[2]; // [xsp+8h] [xbp-28h]
  __int64 v7; // [xsp+18h] [xbp-18h]

  v1 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = DSA_new();
  if ( v2 )
  {
    if ( !(unsigned int)CBS_get_asn1(v1, (char *)v6, 48)
      || (v3 = BN_new(), (*((_QWORD *)v2 + 1) = v3) == 0LL)
      || !BN_parse_asn1_unsigned(v6, (__int64)v3)
      || (v4 = BN_new(), (*((_QWORD *)v2 + 2) = v4) == 0LL)
      || !BN_parse_asn1_unsigned(v6, (__int64)v4)
      || (v5 = BN_new(), (*((_QWORD *)v2 + 3) = v5) == 0LL)
      || !BN_parse_asn1_unsigned(v6, (__int64)v5)
      || EVP_CIPHER_CTX_get_app_data((__int64)v6) )
    {
      ERR_put_error(10, 0LL, 105, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 158);
      DSA_free((__int64)v2);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000720F4) ----------------------------------------------------
signed __int64 __fastcall DSA_marshal_parameters(__int64 *a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  __int64 *v3; // x19
  __int64 v4; // x1
  signed __int64 result; // x0
  char v6; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBB_add_asn1(a1, (__int64 *)&v6, 0x30u) )
    goto LABEL_11;
  v4 = v2[1];
  if ( !v4 )
    goto LABEL_10;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
    goto LABEL_11;
  v4 = v2[2];
  if ( !v4 )
  {
LABEL_10:
    ERR_put_error(10, v4, 67, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 79);
    goto LABEL_11;
  }
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
  {
LABEL_11:
    ERR_put_error(10, 0LL, 106, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 172);
    result = 0LL;
    goto LABEL_12;
  }
  v4 = v2[3];
  if ( !v4 )
    goto LABEL_10;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) || !(unsigned int)CBB_flush(v3) )
    goto LABEL_11;
  result = 1LL;
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000721D8) ----------------------------------------------------
void __fastcall DSA_parse_private_key(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // x20
  char *v2; // x19
  int v3; // w2
  __int16 v4; // w4
  _QWORD *v5; // x8
  _QWORD *v6; // x8
  _QWORD *v7; // x8
  _QWORD *v8; // x8
  _QWORD *v9; // x8
  __int64 v10; // [xsp+0h] [xbp-30h]
  unsigned __int8 *v11[2]; // [xsp+8h] [xbp-28h]
  __int64 v12; // [xsp+18h] [xbp-18h]

  v1 = a1;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = DSA_new();
  if ( v2 )
  {
    if ( !(unsigned int)CBS_get_asn1(v1, (char *)v11, 48)
      || !(unsigned int)CBS_get_asn1_uint64(v11, (unsigned __int64 *)&v10) )
    {
      v3 = 105;
      v4 = 188;
      goto LABEL_7;
    }
    if ( v10 )
    {
      v3 = 104;
      v4 = 193;
LABEL_7:
      ERR_put_error(10, 0LL, v3, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", v4);
      DSA_free((__int64)v2);
      goto LABEL_8;
    }
    v5 = BN_new();
    *((_QWORD *)v2 + 1) = v5;
    if ( !v5 )
      goto LABEL_24;
    if ( !BN_parse_asn1_unsigned(v11, (__int64)v5) )
      goto LABEL_24;
    v6 = BN_new();
    *((_QWORD *)v2 + 2) = v6;
    if ( !v6
      || !BN_parse_asn1_unsigned(v11, (__int64)v6)
      || (v7 = BN_new(), (*((_QWORD *)v2 + 3) = v7) == 0LL)
      || !BN_parse_asn1_unsigned(v11, (__int64)v7)
      || (v8 = BN_new(), (*((_QWORD *)v2 + 4) = v8) == 0LL)
      || !BN_parse_asn1_unsigned(v11, (__int64)v8)
      || (v9 = BN_new(), (*((_QWORD *)v2 + 5) = v9) == 0LL)
      || !BN_parse_asn1_unsigned(v11, (__int64)v9)
      || EVP_CIPHER_CTX_get_app_data((__int64)v11) )
    {
LABEL_24:
      v3 = 105;
      v4 = 203;
      goto LABEL_7;
    }
  }
LABEL_8:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v12;
}

//----- (0000000000072360) ----------------------------------------------------
signed __int64 __fastcall DSA_marshal_private_key(__int64 *a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  __int64 *v3; // x19
  __int64 v4; // x1
  signed __int64 result; // x0
  char v6; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBB_add_asn1(a1, (__int64 *)&v6, 0x30u) || !(unsigned int)CBB_add_asn1_uint64((__int64 *)&v6, 0LL) )
    goto LABEL_16;
  v4 = v2[1];
  if ( !v4 )
    goto LABEL_15;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
    goto LABEL_16;
  v4 = v2[2];
  if ( !v4 )
  {
LABEL_15:
    ERR_put_error(10, v4, 67, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 79);
    goto LABEL_16;
  }
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
  {
LABEL_16:
    ERR_put_error(10, 0LL, 106, (__int64)"external/boringssl/src/crypto/dsa/dsa_asn1.c", 223);
    result = 0LL;
    goto LABEL_17;
  }
  v4 = v2[3];
  if ( !v4 )
    goto LABEL_15;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
    goto LABEL_16;
  v4 = v2[4];
  if ( !v4 )
    goto LABEL_15;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) )
    goto LABEL_16;
  v4 = v2[5];
  if ( !v4 )
    goto LABEL_15;
  if ( !(unsigned int)BN_marshal_asn1((__int64 *)&v6, v4) || !(unsigned int)CBB_flush(v3) )
    goto LABEL_16;
  result = 1LL;
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000007247C) ----------------------------------------------------
void __fastcall d2i_DSA_SIG(_DWORD ***a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  _DWORD ***v4; // x21
  _DWORD **v5; // x0
  _DWORD **v6; // x20
  unsigned __int8 *v7[2]; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(a3 & 0x8000000000000000LL) )
  {
    CBS_init(v7, *a2, a3);
    DSA_SIG_parse(v7);
    v6 = v5;
    if ( v5 )
    {
      if ( v4 )
      {
        ECDSA_SIG_free(*v4);
        *v4 = v6;
      }
      *v3 = lh_num_items((__int64)v7);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000072518) ----------------------------------------------------
signed __int64 __fastcall i2d_DSA_SIG(__int64 *a1, void **a2)
{
  void **v2; // x19
  __int64 *v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v5, 0LL) && (unsigned int)DSA_SIG_marshal(v5, v3) )
  {
    result = sub_6F744((__int64)v5, v2);
  }
  else
  {
    CBB_cleanup(v5);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000725A0) ----------------------------------------------------
void __fastcall d2i_DSAPublicKey(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  __int64 *v4; // x21
  __int64 v5; // x0
  __int64 v6; // x20
  unsigned __int8 *v7[2]; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(a3 & 0x8000000000000000LL) )
  {
    CBS_init(v7, *a2, a3);
    DSA_parse_public_key(v7);
    v6 = v5;
    if ( v5 )
    {
      if ( v4 )
      {
        DSA_free(*v4);
        *v4 = v6;
      }
      *v3 = lh_num_items((__int64)v7);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000007263C) ----------------------------------------------------
signed __int64 __fastcall i2d_DSAPublicKey(_QWORD *a1, void **a2)
{
  void **v2; // x19
  _QWORD *v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v5, 0LL) && (unsigned int)DSA_marshal_public_key(v5, v3) )
  {
    result = sub_6F744((__int64)v5, v2);
  }
  else
  {
    CBB_cleanup(v5);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000726C4) ----------------------------------------------------
void __fastcall d2i_DSAPrivateKey(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  __int64 *v4; // x21
  __int64 v5; // x0
  __int64 v6; // x20
  unsigned __int8 *v7[2]; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(a3 & 0x8000000000000000LL) )
  {
    CBS_init(v7, *a2, a3);
    DSA_parse_private_key(v7);
    v6 = v5;
    if ( v5 )
    {
      if ( v4 )
      {
        DSA_free(*v4);
        *v4 = v6;
      }
      *v3 = lh_num_items((__int64)v7);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000072760) ----------------------------------------------------
signed __int64 __fastcall i2d_DSAPrivateKey(_QWORD *a1, void **a2)
{
  void **v2; // x19
  _QWORD *v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v5, 0LL) && (unsigned int)DSA_marshal_private_key(v5, v3) )
  {
    result = sub_6F744((__int64)v5, v2);
  }
  else
  {
    CBB_cleanup(v5);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000727E8) ----------------------------------------------------
void __fastcall d2i_DSAparams(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  __int64 *v4; // x21
  __int64 v5; // x0
  __int64 v6; // x20
  unsigned __int8 *v7[2]; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(a3 & 0x8000000000000000LL) )
  {
    CBS_init(v7, *a2, a3);
    DSA_parse_parameters(v7);
    v6 = v5;
    if ( v5 )
    {
      if ( v4 )
      {
        DSA_free(*v4);
        *v4 = v6;
      }
      *v3 = lh_num_items((__int64)v7);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000072884) ----------------------------------------------------
signed __int64 __fastcall i2d_DSAparams(_QWORD *a1, void **a2)
{
  void **v2; // x19
  _QWORD *v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v5, 0LL) && (unsigned int)DSA_marshal_parameters(v5, v3) )
  {
    result = sub_6F744((__int64)v5, v2);
  }
  else
  {
    CBB_cleanup(v5);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000007290C) ----------------------------------------------------
_QWORD *__fastcall sub_7290C(_QWORD *a1)
{
  unsigned int (__fastcall **v1)(_QWORD *); // x20
  _QWORD *v2; // x0
  _QWORD *v3; // x19
  int v4; // w2
  __int16 v5; // w4

  v1 = (unsigned int (__fastcall **)(_QWORD *))a1;
  if ( !a1 )
  {
    v4 = 121;
    v5 = 339;
LABEL_8:
    ERR_put_error(15, 0LL, v4, (__int64)"external/boringssl/src/crypto/ec/ec.c", v5);
    goto LABEL_9;
  }
  if ( !*a1 )
  {
    v4 = 66;
    v5 = 344;
    goto LABEL_8;
  }
  v2 = malloc(0xA8uLL);
  v3 = v2;
  if ( !v2 )
  {
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/ec.c", 350);
    return v3;
  }
  memset(v2 + 1, 0, 0xA0uLL);
  *v3 = v1;
  BN_init(v3 + 2);
  if ( !(*v1)(v3) )
  {
    free(v3);
LABEL_9:
    v3 = 0LL;
  }
  return v3;
}

//----- (00000000000729D8) ----------------------------------------------------
_QWORD *EC_GROUP_new_curve_GFp()
{
  _QWORD *v0; // x0
  _QWORD *v1; // x19
  unsigned int (*v2)(void); // x8
  void (__fastcall *v3)(_QWORD *); // x8
  void *v4; // x20

  v0 = sub_7290C(off_F8158);
  v1 = v0;
  if ( v0 )
  {
    v2 = *(unsigned int (**)(void))(*v0 + 24LL);
    if ( !v2 )
    {
      ERR_put_error(15, 0LL, 66, (__int64)"external/boringssl/src/crypto/ec/ec.c", 374);
      return 0LL;
    }
    if ( !v2() )
    {
      v3 = *(void (__fastcall **)(_QWORD *))(*v1 + 8LL);
      if ( v3 )
        v3(v1);
      v4 = (void *)v1[1];
      if ( v4 )
      {
        sub_82778(v1[1]);
        free(v4);
      }
      BN_free((_DWORD *)v1 + 4);
      free(v1);
      return 0LL;
    }
  }
  return v1;
}
// F8158: using guessed type __int64 (__fastcall *off_F8158[18])();

//----- (0000000000072AB0) ----------------------------------------------------
void __fastcall EC_GROUP_free(__int64 a1)
{
  __int64 v1; // x19
  void (*v2)(void); // x8
  void *v3; // x20

  v1 = a1;
  if ( a1 )
  {
    v2 = *(void (**)(void))(*(_QWORD *)a1 + 8LL);
    if ( v2 )
      v2();
    v3 = *(void **)(v1 + 8);
    if ( v3 )
    {
      sub_82778(*(_QWORD *)(v1 + 8));
      free(v3);
    }
    BN_free((_DWORD *)(v1 + 16));
    free((void *)v1);
  }
}

//----- (0000000000072B14) ----------------------------------------------------
__int64 __fastcall EC_GROUP_set_generator(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // x20
  __int64 v5; // x19
  _QWORD *v6; // x21
  __int64 result; // x0
  int v8; // w2
  __int16 v9; // w4

  v4 = (_QWORD *)a1;
  v5 = a3;
  v6 = a2;
  if ( *(_DWORD *)(a1 + 40) || *(_QWORD *)(a1 + 8) )
    return 0LL;
  if ( !BN_is_one(a4) )
  {
    v8 = 131;
    v9 = 394;
    goto LABEL_8;
  }
  result = (__int64)EC_POINT_new(v4);
  v4[1] = result;
  if ( !result )
    return result;
  if ( *(_QWORD *)result != *v6 )
  {
    v8 = 106;
    v9 = 644;
LABEL_8:
    ERR_put_error(15, 0LL, v8, (__int64)"external/boringssl/src/crypto/ec/ec.c", v9);
    return 0LL;
  }
  if ( (_QWORD *)result == v6 || (result = sub_827D8(result, (__int64)v6), (_DWORD)result) )
    result = BN_copy((__int64)(v4 + 2), v5) != 0;
  return result;
}

//----- (0000000000072BE0) ----------------------------------------------------
void *__fastcall EC_POINT_new(_QWORD *a1)
{
  _QWORD *v1; // x20
  _QWORD *v2; // x0
  void *v3; // x19

  v1 = a1;
  if ( !a1 )
  {
    ERR_put_error(15, 0LL, 67, (__int64)"external/boringssl/src/crypto/ec/ec.c", 601);
    goto LABEL_6;
  }
  v2 = malloc(0x50uLL);
  v3 = v2;
  if ( !v2 )
  {
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/ec.c", 607);
    return v3;
  }
  *v2 = *v1;
  if ( !(unsigned int)sub_82740((__int64)v2) )
  {
    free(v3);
LABEL_6:
    v3 = 0LL;
  }
  return v3;
}

//----- (0000000000072C74) ----------------------------------------------------
bool __fastcall EC_POINT_copy(_QWORD *a1, _QWORD *a2)
{
  _BOOL8 result; // x0

  if ( *a1 == *a2 )
  {
    if ( a1 == a2 )
      result = 1LL;
    else
      result = sub_827D8((__int64)a1, (__int64)a2);
  }
  else
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 644);
    result = 0LL;
  }
  return result;
}

//----- (0000000000072CC8) ----------------------------------------------------
_QWORD *__fastcall EC_GROUP_new_by_curve_name(signed int a1)
{
  signed int v1; // w19
  signed __int64 v2; // x27
  _DWORD *v3; // x20
  __int64 v4; // x23
  __int64 v5; // x28
  _DWORD *v6; // x21
  _DWORD *v7; // x22
  _QWORD *v8; // x0
  _QWORD *v9; // x24
  _QWORD *v10; // x0
  _QWORD *v11; // x25
  _DWORD *v12; // x25
  _DWORD *v13; // x26
  _DWORD *v14; // x23
  __int64 v16; // x28
  int v17; // w2
  __int16 v18; // w4
  void (__fastcall *v19)(_QWORD *); // x8
  void *v20; // x27
  _QWORD *v21; // [xsp+0h] [xbp-60h]
  __int64 v22; // [xsp+8h] [xbp-58h]

  v1 = a1;
  if ( a1 > 714 )
  {
    if ( a1 == 716 )
    {
      v2 = 0LL;
    }
    else
    {
      if ( a1 != 715 )
        goto LABEL_31;
      v2 = 1LL;
    }
  }
  else
  {
    if ( a1 != 415 )
    {
      if ( a1 == 713 )
      {
        v2 = 3LL;
        goto LABEL_10;
      }
LABEL_31:
      ERR_put_error(15, 0LL, 123, (__int64)"external/boringssl/src/crypto/ec/ec.c", 494);
      return 0LL;
    }
    v2 = 2LL;
  }
LABEL_10:
  v3 = BN_CTX_new();
  if ( !v3 )
  {
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/ec.c", 413);
    v9 = 0LL;
    v14 = 0LL;
    v12 = 0LL;
    v13 = 0LL;
    v7 = 0LL;
    v6 = 0LL;
    goto LABEL_29;
  }
  v4 = *(_QWORD *)&dword_F7C68[8 * v2 + 4];
  v5 = *(unsigned __int8 *)(v4 + 8);
  v6 = (_DWORD *)BN_bin2bn((unsigned __int8 *)(v4 + 9), v5, 0LL);
  if ( !v6 )
  {
    v7 = 0LL;
LABEL_27:
    ERR_put_error(15, 0LL, 3, (__int64)"external/boringssl/src/crypto/ec/ec.c", 424);
    v9 = 0LL;
    v14 = 0LL;
LABEL_28:
    v12 = 0LL;
    v13 = 0LL;
    goto LABEL_29;
  }
  v7 = (_DWORD *)BN_bin2bn((unsigned __int8 *)(v4 + v5 + 9), v5, 0LL);
  if ( !v7 )
    goto LABEL_27;
  v22 = BN_bin2bn((unsigned __int8 *)(v4 + 2 * v5 + 9), v5, 0LL);
  if ( !v22 )
    goto LABEL_27;
  v8 = sub_7290C(*(_QWORD **)&dword_F7C68[8 * v2 + 6]);
  v9 = v8;
  if ( !v8 )
  {
    ERR_put_error(15, 0LL, 15, (__int64)"external/boringssl/src/crypto/ec/ec.c", 431);
    v14 = (_DWORD *)v22;
    goto LABEL_28;
  }
  if ( !(*(unsigned int (**)(void))(*v8 + 24LL))() )
  {
    ERR_put_error(15, 0LL, 15, (__int64)"external/boringssl/src/crypto/ec/ec.c", 431);
    v21 = 0LL;
    v16 = 0LL;
    v13 = 0LL;
    v12 = 0LL;
LABEL_42:
    v14 = (_DWORD *)v22;
    goto LABEL_43;
  }
  v10 = malloc(0x50uLL);
  v11 = v10;
  if ( v10 )
  {
    *v10 = *v9;
    if ( (unsigned int)sub_82740((__int64)v10) )
    {
      v21 = v11;
      v12 = (_DWORD *)BN_bin2bn((unsigned __int8 *)(v4 + 3 * v5 + 9), v5, 0LL);
      if ( v12 && (v13 = (_DWORD *)BN_bin2bn((unsigned __int8 *)(v4 + 4 * v5 + 9), v5, 0LL)) != 0LL )
      {
        if ( (unsigned int)EC_POINT_set_affine_coordinates_GFp(v9, v21, (__int64)v12, (__int64)v13, v3) )
        {
          if ( BN_bin2bn((unsigned __int8 *)(v4 + 5 * v5 + 9), v5, (__int64)(v9 + 2)) )
          {
            CRYPTO_once((pthread_once_t *)&unk_1071E0, (void (*)(void))sub_738AC);
            v14 = (_DWORD *)v22;
            if ( qword_1071E8 )
              v9[6] = *(_QWORD *)(qword_1071E8 + 8 * v2);
            v9[1] = v21;
            goto LABEL_29;
          }
          v17 = 3;
          v18 = 451;
        }
        else
        {
          v17 = 15;
          v18 = 447;
        }
        ERR_put_error(15, 0LL, v17, (__int64)"external/boringssl/src/crypto/ec/ec.c", v18);
        v16 = (__int64)v21;
      }
      else
      {
        ERR_put_error(15, 0LL, 3, (__int64)"external/boringssl/src/crypto/ec/ec.c", 442);
        v16 = (__int64)v21;
        v13 = 0LL;
      }
      goto LABEL_42;
    }
    free(v11);
  }
  else
  {
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/ec.c", 607);
  }
  v14 = (_DWORD *)v22;
  ERR_put_error(15, 0LL, 15, (__int64)"external/boringssl/src/crypto/ec/ec.c", 436);
  v21 = 0LL;
  v16 = 0LL;
  v13 = 0LL;
  v12 = 0LL;
LABEL_43:
  v19 = *(void (__fastcall **)(_QWORD *))(*v9 + 8LL);
  if ( v19 )
    v19(v9);
  v20 = (void *)v9[1];
  if ( v20 )
  {
    sub_82778(v9[1]);
    free(v20);
  }
  BN_free((_DWORD *)v9 + 4);
  free(v9);
  if ( v16 )
  {
    sub_82778(v16);
    free(v21);
  }
  v9 = 0LL;
LABEL_29:
  BN_CTX_free((__int64)v3);
  BN_free(v6);
  BN_free(v7);
  BN_free(v14);
  BN_free(v12);
  BN_free(v13);
  if ( !v9 )
    goto LABEL_31;
  *((_DWORD *)v9 + 10) = v1;
  return v9;
}
// F7C68: using guessed type int dword_F7C68[];
// 1071E8: using guessed type __int64 qword_1071E8;

//----- (0000000000073108) ----------------------------------------------------
void __fastcall EC_POINT_free(__int64 a1)
{
  void *v1; // x19

  v1 = (void *)a1;
  if ( a1 )
  {
    sub_82778(a1);
    free(v1);
  }
}

//----- (0000000000073140) ----------------------------------------------------
__int64 __fastcall sub_73140(__int64 a1)
{
  return *(_QWORD *)(a1 + 48);
}

//----- (0000000000073148) ----------------------------------------------------
_QWORD *__fastcall EC_GROUP_dup(_QWORD **a1)
{
  _QWORD **v1; // x20
  _QWORD *v2; // x0
  _QWORD *v3; // x0
  _QWORD *v4; // x19
  _QWORD *v5; // x0
  _QWORD *v6; // x0
  void (__fastcall *v7)(_QWORD *); // x8
  void *v8; // x20

  v1 = a1;
  if ( !a1 )
    return 0LL;
  v2 = *a1;
  if ( !(*v1)[2] )
  {
    ERR_put_error(15, 0LL, 66, (__int64)"external/boringssl/src/crypto/ec/ec.c", 527);
    return 0LL;
  }
  v3 = sub_7290C(v2);
  v4 = v3;
  if ( v3 )
  {
    if ( (v3[6] = v1[6], *((_DWORD *)v3 + 10) = *((_DWORD *)v1 + 10), (v5 = v1[1]) != 0LL)
      && (v6 = EC_POINT_dup(v5, v4), (v4[1] = v6) == 0LL)
      || !BN_copy((__int64)(v4 + 2), (__int64)(v1 + 2))
      || !(*(unsigned int (__fastcall **)(_QWORD *, _QWORD **))(*v4 + 16LL))(v4, v1) )
    {
      v7 = *(void (__fastcall **)(_QWORD *))(*v4 + 8LL);
      if ( v7 )
        v7(v4);
      v8 = (void *)v4[1];
      if ( v8 )
      {
        sub_82778(v4[1]);
        free(v8);
      }
      BN_free((_DWORD *)v4 + 4);
      free(v4);
      return 0LL;
    }
  }
  return v4;
}

//----- (0000000000073234) ----------------------------------------------------
_QWORD *__fastcall EC_POINT_dup(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  _QWORD *v3; // x0
  void *v4; // x19

  v2 = a1;
  if ( a1 )
  {
    v3 = EC_POINT_new(a2);
    v4 = v3;
    if ( v3 )
    {
      if ( *v3 == *v2 )
      {
        if ( v3 == v2 )
          return v2;
        if ( sub_827D8((__int64)v3, (__int64)v2) )
          return v4;
      }
      else
      {
        ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 644);
      }
      sub_82778((__int64)v4);
      free(v4);
    }
    v2 = 0LL;
  }
  return v2;
}

//----- (00000000000732C8) ----------------------------------------------------
signed __int64 __fastcall EC_GROUP_cmp(__int64 a1, __int64 a2)
{
  int v2; // w8
  signed __int64 result; // x0

  v2 = *(_DWORD *)(a1 + 40);
  if ( v2 )
    result = (*(_DWORD *)(a2 + 40) == 0) | (unsigned int)(v2 != *(_DWORD *)(a2 + 40));
  else
    result = 1LL;
  return result;
}

//----- (00000000000732F4) ----------------------------------------------------
signed __int64 __fastcall EC_GROUP_get0_order(__int64 a1)
{
  return a1 + 16;
}

//----- (00000000000732FC) ----------------------------------------------------
bool __fastcall EC_GROUP_get_order(__int64 a1, __int64 a2)
{
  return BN_copy(a2, a1 + 16) != 0;
}

//----- (0000000000073324) ----------------------------------------------------
__int64 __fastcall EC_GROUP_get_cofactor(__int64 a1, __int64 a2)
{
  return BN_set_word(a2, 1LL);
}

//----- (000000000007333C) ----------------------------------------------------
void __fastcall EC_POINT_clear_free(__int64 a1)
{
  void *v1; // x19

  v1 = (void *)a1;
  if ( a1 )
  {
    sub_827A8(a1);
    OPENSSL_cleanse(v1, 0x50uLL);
    free(v1);
  }
}

//----- (0000000000073380) ----------------------------------------------------
signed __int64 __fastcall EC_POINT_set_to_infinity(_QWORD *a1, _QWORD *a2)
{
  signed __int64 result; // x0

  if ( *a1 == *a2 )
  {
    BN_zero((__int64)(a2 + 7));
    result = 1LL;
  }
  else
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 670);
    result = 0LL;
  }
  return result;
}

//----- (00000000000733C4) ----------------------------------------------------
bool __fastcall EC_POINT_is_at_infinity(_QWORD *a1, _QWORD *a2)
{
  if ( *a1 == *a2 )
    return BN_is_zero((__int64)(a2 + 7));
  ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 678);
  return 0LL;
}

//----- (0000000000073408) ----------------------------------------------------
__int64 __fastcall EC_POINT_is_on_curve(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  if ( *a1 == *a2 )
    return sub_834FC(a1, a2, a3);
  ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 687);
  return 0LL;
}

//----- (000000000007344C) ----------------------------------------------------
signed __int64 __fastcall EC_POINT_cmp(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  __int64 v5; // x19
  _QWORD *v6; // x21
  _QWORD *v7; // x23
  _QWORD *v8; // x22
  _BOOL4 v9; // w20
  _BOOL4 v10; // w0
  unsigned int v11; // w21
  signed __int64 v12; // x24
  int v13; // w25
  int v14; // w27
  unsigned int (__fastcall *v15)(_QWORD *, _QWORD *, _QWORD *, signed __int64, __int64); // x28
  _DWORD *v16; // x0
  _QWORD *v17; // x20
  _QWORD *v18; // x28
  unsigned int v19; // w0
  __int64 v20; // x8
  __int64 v21; // x20
  __int64 v22; // x27
  unsigned int v23; // w0
  unsigned int (__fastcall *v24)(_QWORD *, _QWORD *, _QWORD *, signed __int64, __int64); // x23
  unsigned int v25; // w0
  __int64 v26; // x1
  _QWORD *v27; // [xsp+10h] [xbp-90h]
  _QWORD *v28; // [xsp+18h] [xbp-88h]
  _QWORD *v29; // [xsp+20h] [xbp-80h]
  unsigned int (__fastcall *v30)(_QWORD *, _QWORD *, _QWORD *, signed __int64, __int64); // [xsp+28h] [xbp-78h]
  unsigned int (__fastcall *v31)(_QWORD *, _QWORD *, _QWORD *, __int64); // [xsp+30h] [xbp-70h]
  __int64 v32; // [xsp+30h] [xbp-70h]
  _DWORD *v33; // [xsp+38h] [xbp-68h]

  if ( *a1 != *a2 || *a1 != *a3 )
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 696);
    return 0xFFFFFFFFLL;
  }
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = EC_POINT_is_at_infinity(a1, a2);
  v10 = EC_POINT_is_at_infinity(v8, v6);
  if ( !v9 )
  {
    if ( v10 )
      return 1;
    v12 = (signed __int64)(v7 + 7);
    v13 = BN_cmp((__int64)(v7 + 7), (__int64)(v8 + 18));
    v14 = BN_cmp((__int64)(v6 + 7), (__int64)(v8 + 18));
    if ( !(v14 | v13) )
    {
      if ( (unsigned int)BN_cmp((__int64)(v7 + 1), (__int64)(v6 + 1)) )
        v11 = 1;
      else
        v11 = (unsigned __int64)BN_cmp((__int64)(v7 + 4), (__int64)(v6 + 4)) != 0;
      return v11;
    }
    v15 = *(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, signed __int64, __int64))(*v8 + 48LL);
    v31 = *(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, __int64))(*v8 + 56LL);
    if ( v5 )
    {
      v16 = 0LL;
    }
    else
    {
      v16 = BN_CTX_new();
      v5 = (__int64)v16;
      if ( !v16 )
        return (unsigned int)-1;
    }
    v33 = v16;
    v30 = v15;
    BN_CTX_start(v5);
    v17 = BN_CTX_get(v5);
    v29 = BN_CTX_get(v5);
    v28 = BN_CTX_get(v5);
    v18 = BN_CTX_get(v5);
    if ( !v18 )
      goto LABEL_32;
    if ( v14 )
    {
      if ( !v31(v8, v18, v6 + 7, v5) )
        goto LABEL_32;
      v27 = v17;
      if ( !v30(v8, v17, v7 + 1, (signed __int64)v18, v5) )
        goto LABEL_32;
    }
    else
    {
      v27 = v17;
      v17 = v7 + 1;
    }
    if ( v13 )
    {
      if ( !v31(v8, v28, v7 + 7, v5) )
        goto LABEL_32;
      v19 = v30(v8, v29, v6 + 1, (signed __int64)v28, v5);
      v20 = (__int64)v29;
      if ( !v19 )
        goto LABEL_32;
    }
    else
    {
      v20 = (__int64)(v6 + 1);
    }
    v32 = v20;
    if ( (unsigned int)BN_cmp((__int64)v17, v20) )
    {
      v21 = (__int64)v33;
      v11 = 1;
LABEL_34:
      BN_CTX_end(v5);
      BN_CTX_free(v21);
      return v11;
    }
    if ( v14 )
    {
      v22 = (__int64)v17;
      if ( !v30(v8, v18, v18, (signed __int64)(v6 + 7), v5)
        || (v23 = v30(v8, v27, v7 + 4, (signed __int64)v18, v5), v24 = v30, !v23) )
      {
LABEL_32:
        v21 = (__int64)v33;
LABEL_33:
        v11 = -1;
        goto LABEL_34;
      }
    }
    else
    {
      v22 = (__int64)(v7 + 4);
      v24 = v30;
    }
    v21 = (__int64)v33;
    if ( v13 )
    {
      if ( !v24(v8, v28, v28, v12, v5) )
        goto LABEL_33;
      v25 = v24(v8, v29, v6 + 4, (signed __int64)v28, v5);
      v26 = v32;
      if ( !v25 )
        goto LABEL_33;
    }
    else
    {
      v26 = (__int64)(v6 + 4);
    }
    v11 = (unsigned __int64)BN_cmp(v22, v26) != 0;
    goto LABEL_34;
  }
  return v10 == 0;
}

//----- (000000000007349C) ----------------------------------------------------
__int64 __fastcall EC_POINT_make_affine(_QWORD *a1, _QWORD *a2, _DWORD *a3)
{
  _QWORD *v4; // x23
  _QWORD *v5; // x24
  __int64 v6; // x21
  __int64 v7; // x22
  _DWORD *v8; // x19
  unsigned int v9; // w21
  _DWORD *v10; // x20
  _QWORD *v11; // x25
  _QWORD *v12; // x26

  if ( *a1 != *a2 )
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 704);
    return 0LL;
  }
  v4 = a2;
  v5 = a1;
  v6 = (__int64)(a2 + 7);
  v7 = (__int64)(a1 + 18);
  v8 = a3;
  if ( (unsigned int)BN_cmp((__int64)(a2 + 7), (__int64)(a1 + 18)) && !EC_POINT_is_at_infinity(v5, v4) )
  {
    if ( v8 )
    {
      v10 = 0LL;
    }
    else
    {
      v10 = BN_CTX_new();
      v8 = v10;
      if ( !v10 )
        return 0;
    }
    BN_CTX_start((__int64)v8);
    v11 = BN_CTX_get((__int64)v8);
    v12 = BN_CTX_get((__int64)v8);
    if ( v12
      && (unsigned int)EC_POINT_get_affine_coordinates_GFp((__int64)v5, v4)
      && (unsigned int)EC_POINT_set_affine_coordinates_GFp(v5, v4, (__int64)v11, (__int64)v12, v8) )
    {
      if ( !(unsigned int)BN_cmp(v6, v7) )
      {
        v9 = 1;
        goto LABEL_15;
      }
      ERR_put_error(15, 0LL, 68, (__int64)"external/boringssl/src/crypto/ec/simple.c", 951);
    }
    v9 = 0;
LABEL_15:
    BN_CTX_end((__int64)v8);
    BN_CTX_free((__int64)v10);
    return v9;
  }
  return 1;
}

//----- (00000000000734E0) ----------------------------------------------------
void __fastcall EC_POINTs_make_affine(_QWORD *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  __int64 v6; // x21
  __int64 v7; // x22
  __int64 v8; // x23
  __int64 v9; // x24
  __int64 v10; // x25
  __int64 v11; // x26
  __int64 v12; // x27
  __int64 v13; // x28
  __int64 v14; // x29
  __int64 v15; // x30
  __int64 v16; // x9
  __int64 v17; // x20
  _QWORD *v18; // x23
  unsigned __int64 v19; // x19
  _QWORD *v20; // x24
  _DWORD *v21; // x21
  _QWORD *v22; // x25
  _QWORD *v23; // x0
  __int64 v24; // x26
  __int64 *v25; // x22
  __int64 *v26; // x28
  __int64 *v27; // x0
  __int64 v28; // x27
  _QWORD *v29; // x0
  __int64 v30; // x1
  signed __int64 v31; // x28
  signed __int64 v32; // x27
  _DWORD *v33; // x23
  signed __int64 v34; // x21
  __int64 v35; // x0
  int v36; // w0
  unsigned __int64 v37; // x8
  signed __int64 v38; // x27
  unsigned int (__fastcall *v39)(_QWORD *, _QWORD *, _QWORD *, __int64); // x8
  signed __int64 v40; // x28
  __int64 v41; // x0
  unsigned __int64 v42; // x28
  __int64 v43; // x26
  unsigned __int64 v44; // x20
  void **v45; // x0
  _QWORD *v46; // [xsp+8h] [xbp-78h]
  char v47; // [xsp+14h] [xbp-6Ch]
  __int64 v48; // [xsp+18h] [xbp-68h]
  __int64 v49; // [xsp+20h] [xbp-60h]
  __int64 v50; // [xsp+28h] [xbp-58h]
  __int64 v51; // [xsp+30h] [xbp-50h]
  __int64 v52; // [xsp+38h] [xbp-48h]
  __int64 v53; // [xsp+40h] [xbp-40h]
  __int64 v54; // [xsp+48h] [xbp-38h]
  __int64 v55; // [xsp+50h] [xbp-30h]
  __int64 v56; // [xsp+58h] [xbp-28h]
  __int64 v57; // [xsp+60h] [xbp-20h]
  __int64 v58; // [xsp+68h] [xbp-18h]
  __int64 v59; // [xsp+70h] [xbp-10h]
  __int64 v60; // [xsp+78h] [xbp-8h]

  if ( !a2 )
  {
LABEL_7:
    v49 = v13;
    v50 = v12;
    v51 = v11;
    v52 = v10;
    v53 = v9;
    v54 = v8;
    v55 = v7;
    v56 = v6;
    v57 = v5;
    v58 = v4;
    v59 = v14;
    v60 = v15;
    v17 = a4;
    v18 = a3;
    v19 = a2;
    v20 = a1;
    v48 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    if ( a2 )
    {
      if ( a4 )
      {
        v21 = 0LL;
        goto LABEL_12;
      }
      v21 = BN_CTX_new();
      v17 = (__int64)v21;
      if ( v21 )
      {
LABEL_12:
        BN_CTX_start(v17);
        v22 = BN_CTX_get(v17);
        v23 = BN_CTX_get(v17);
        v24 = (__int64)v23;
        v25 = 0LL;
        if ( v22 )
        {
          v26 = 0LL;
          if ( !v23 )
            goto LABEL_57;
          v27 = (__int64 *)malloc(8 * v19);
          v25 = v27;
          if ( v27 )
          {
            if ( 8 * v19 )
              memset(v27, 0, 8 * v19);
            v28 = 0LL;
            while ( 1 )
            {
              v29 = BN_new();
              v25[v28] = (__int64)v29;
              if ( !v29 )
                break;
              if ( ++v28 >= v19 )
              {
                if ( BN_is_zero(*v18 + 56LL) )
                  v30 = (__int64)(v20 + 18);
                else
                  v30 = *v18 + 56LL;
                if ( BN_copy(*v25, v30) )
                {
                  v46 = v18;
                  if ( v19 >= 2 )
                  {
                    v31 = 0LL;
                    v32 = (signed __int64)(v18 + 1);
                    do
                    {
                      v33 = v21;
                      v34 = v31;
                      if ( BN_is_zero(*(_QWORD *)(v32 + 8 * v31) + 56LL) )
                      {
                        v35 = BN_copy(v25[v34 + 1], v25[v34]);
                        v21 = v33;
                        if ( !v35 )
                          goto LABEL_56;
                      }
                      else
                      {
                        v36 = (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64, signed __int64, __int64))(*v20 + 48LL))(
                                v20,
                                v25[v34 + 1],
                                v25[v34],
                                *(_QWORD *)(v32 + 8 * v31) + 56LL,
                                v17);
                        v21 = v33;
                        if ( !v36 )
                          goto LABEL_56;
                      }
                      v37 = v31++ + 2;
                    }
                    while ( v37 < v19 );
                  }
                  v38 = v19 - 1;
                  if ( (unsigned int)sub_69844((__int64)v22, &v47, v25[v19 - 1], (__int64)(v20 + 7), v17) )
                  {
                    v39 = *(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, __int64))(*v20 + 64LL);
                    if ( !v39
                      || v39(v20, v22, v22, v17)
                      && (*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, __int64))(*v20 + 64LL))(
                           v20,
                           v22,
                           v22,
                           v17) )
                    {
                      if ( v19 == 1 )
                      {
LABEL_44:
                        if ( BN_is_zero(*v46 + 56LL) || BN_copy(*v46 + 56LL, (__int64)v22) )
                        {
                          v42 = 0LL;
                          do
                          {
                            v43 = v46[v42];
                            if ( !BN_is_zero(v43 + 56)
                              && (!(*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, __int64, __int64))(*v20 + 56LL))(
                                     v20,
                                     v22,
                                     v43 + 56,
                                     v17)
                               || !(*(unsigned int (__fastcall **)(_QWORD *, __int64, __int64, _QWORD *, __int64))(*v20 + 48LL))(
                                     v20,
                                     v43 + 8,
                                     v43 + 8,
                                     v22,
                                     v17)
                               || !(*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, __int64, __int64))(*v20 + 48LL))(
                                     v20,
                                     v22,
                                     v22,
                                     v43 + 56,
                                     v17)
                               || !(*(unsigned int (__fastcall **)(_QWORD *, __int64, __int64, _QWORD *, __int64))(*v20 + 48LL))(
                                     v20,
                                     v43 + 32,
                                     v43 + 32,
                                     v22,
                                     v17)
                               || !BN_copy(v43 + 56, (__int64)(v20 + 18))) )
                            {
                              break;
                            }
                            ++v42;
                          }
                          while ( v42 < v19 );
                        }
                      }
                      else
                      {
                        while ( 1 )
                        {
                          while ( BN_is_zero(v46[v38] + 56LL) )
                          {
                            if ( !--v38 )
                              goto LABEL_44;
                          }
                          if ( !(*(unsigned int (__fastcall **)(_QWORD *, __int64, __int64, _QWORD *, __int64))(*v20 + 48LL))(
                                  v20,
                                  v24,
                                  v25[v38 - 1],
                                  v22,
                                  v17) )
                            break;
                          if ( !(*(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, signed __int64, __int64))(*v20 + 48LL))(
                                  v20,
                                  v22,
                                  v22,
                                  v46[v38] + 56LL,
                                  v17) )
                            break;
                          v41 = BN_copy(v46[v38] + 56LL, v24);
                          v40 = v38-- - 1;
                          if ( !v41 )
                            break;
                          if ( !v40 )
                            goto LABEL_44;
                        }
                      }
                    }
                  }
                  else
                  {
                    ERR_put_error(15, 0LL, 3, (__int64)"external/boringssl/src/crypto/ec/simple.c", 1036);
                  }
                }
                break;
              }
            }
          }
        }
LABEL_56:
        v26 = v25;
LABEL_57:
        BN_CTX_end(v17);
        BN_CTX_free((__int64)v21);
        if ( v26 )
        {
          v44 = 0LL;
          do
          {
            v45 = (void **)v26[v44];
            if ( !v45 )
              break;
            BN_clear_free(v45);
            ++v44;
          }
          while ( v44 < v19 );
          free(v25);
        }
        goto LABEL_62;
      }
    }
LABEL_62:
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    return;
  }
  v16 = 0LL;
  while ( *a1 == *(_QWORD *)a3[v16] )
  {
    if ( ++v16 >= a2 )
      goto LABEL_7;
  }
  v59 = v14;
  v60 = v15;
  ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 714);
}

//----- (000000000007353C) ----------------------------------------------------
__int64 __fastcall EC_POINT_get_affine_coordinates_GFp(__int64 a1, _QWORD *a2)
{
  __int64 (*v2)(void); // x5
  int v3; // w2
  __int16 v4; // w4

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 32LL);
  if ( !v2 )
  {
    v3 = 66;
    v4 = 725;
    goto LABEL_5;
  }
  if ( *(_QWORD *)a1 != *a2 )
  {
    v3 = 106;
    v4 = 729;
LABEL_5:
    ERR_put_error(15, 0LL, v3, (__int64)"external/boringssl/src/crypto/ec/ec.c", v4);
    return 0LL;
  }
  return v2();
}

//----- (00000000000735A4) ----------------------------------------------------
__int64 __fastcall EC_POINT_set_affine_coordinates_GFp(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  _QWORD *v5; // x20
  _QWORD *v6; // x21
  __int64 v7; // x19
  int v8; // w2
  __int16 v9; // w4
  __int64 result; // x0

  v5 = a2;
  v6 = a1;
  v7 = (__int64)a5;
  if ( *a1 != *a2 )
  {
    v8 = 106;
    v9 = 739;
LABEL_7:
    ERR_put_error(15, 0LL, v8, (__int64)"external/boringssl/src/crypto/ec/ec.c", v9);
    return 0LL;
  }
  result = sub_829D8(a1, a2, a3, a4, a5);
  if ( !(_DWORD)result )
    return result;
  if ( *v6 != *v5 )
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 687);
LABEL_6:
    v8 = 120;
    v9 = 747;
    goto LABEL_7;
  }
  if ( !(unsigned int)sub_834FC(v6, v5, v7) )
    goto LABEL_6;
  return 1LL;
}

//----- (0000000000073674) ----------------------------------------------------
__int64 __fastcall EC_POINT_add(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, __int64 a5)
{
  __int64 v5; // x8
  __int64 v7; // x19
  _QWORD *v8; // x27
  _QWORD *v9; // x26
  _QWORD *v10; // x21
  _QWORD *v11; // x22
  _QWORD *v12; // x0
  _QWORD *v13; // x1
  unsigned int (__fastcall *v14)(_QWORD *, __int64, _QWORD *, __int64); // x20
  unsigned int (__fastcall *v15)(_QWORD *, _QWORD *, _QWORD *, __int64, __int64); // x25
  _DWORD *v16; // x24
  _QWORD *v17; // x20
  _QWORD *v18; // x28
  _QWORD *v19; // x0
  int v20; // w20
  unsigned int v21; // w20
  int v22; // w24
  signed __int64 v23; // x2
  __int64 v24; // x27
  __int64 v25; // x1
  __int64 v26; // x20
  __int64 v27; // x1
  signed __int64 v28; // [xsp+10h] [xbp-C0h]
  signed __int64 v29; // [xsp+18h] [xbp-B8h]
  int v30; // [xsp+24h] [xbp-ACh]
  __int64 v31; // [xsp+28h] [xbp-A8h]
  _QWORD *v32; // [xsp+38h] [xbp-98h]
  _QWORD *v33; // [xsp+40h] [xbp-90h]
  __int64 v34; // [xsp+48h] [xbp-88h]
  _QWORD *v35; // [xsp+50h] [xbp-80h]
  _DWORD *v36; // [xsp+58h] [xbp-78h]
  _QWORD *v37; // [xsp+60h] [xbp-70h]
  unsigned int (__fastcall *v38)(_QWORD *, __int64, _QWORD *, __int64); // [xsp+68h] [xbp-68h]

  v5 = *a1;
  if ( *a1 != *a2 || v5 != *a3 || v5 != *a4 )
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 758);
    return 0LL;
  }
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  if ( a3 == a4 )
    return EC_POINT_dbl(a1, a2, a3, a5);
  if ( EC_POINT_is_at_infinity(a1, a3) )
  {
    v12 = v10;
    v13 = v8;
    return EC_POINT_copy(v12, v13);
  }
  if ( EC_POINT_is_at_infinity(v11, v8) )
  {
    v12 = v10;
    v13 = v9;
    return EC_POINT_copy(v12, v13);
  }
  v15 = *(unsigned int (__fastcall **)(_QWORD *, _QWORD *, _QWORD *, __int64, __int64))(*v11 + 48LL);
  v14 = *(unsigned int (__fastcall **)(_QWORD *, __int64, _QWORD *, __int64))(*v11 + 56LL);
  if ( v7 )
  {
    v16 = 0LL;
    goto LABEL_15;
  }
  v16 = BN_CTX_new();
  v7 = (__int64)v16;
  if ( v16 )
  {
LABEL_15:
    v38 = v14;
    BN_CTX_start(v7);
    v17 = BN_CTX_get(v7);
    v18 = BN_CTX_get(v7);
    v37 = BN_CTX_get(v7);
    v35 = BN_CTX_get(v7);
    v33 = BN_CTX_get(v7);
    v32 = BN_CTX_get(v7);
    v19 = BN_CTX_get(v7);
    if ( !v19 )
    {
      v21 = 0;
LABEL_68:
      BN_CTX_end(v7);
      goto LABEL_69;
    }
    v31 = (__int64)v19;
    v36 = v16;
    v34 = (__int64)v17;
    v20 = BN_cmp((__int64)(v8 + 7), (__int64)(v11 + 18));
    if ( v20 )
    {
      if ( !v38(v11, v34, v8 + 7, v7)
        || !v15(v11, v18, v9 + 1, v34, v7)
        || !v15(v11, (_QWORD *)v34, (_QWORD *)v34, (__int64)(v8 + 7), v7)
        || !v15(v11, v37, v9 + 4, v34, v7) )
      {
        goto LABEL_66;
      }
    }
    else if ( !BN_copy((__int64)v18, (__int64)(v9 + 1)) || !BN_copy((__int64)v37, (__int64)(v9 + 4)) )
    {
      goto LABEL_66;
    }
    v28 = (signed __int64)(v8 + 7);
    v22 = BN_cmp((__int64)(v9 + 7), (__int64)(v11 + 18));
    if ( v22 )
    {
      v30 = v20;
      if ( !v38(v11, v34, v9 + 7, v7) )
        goto LABEL_66;
      v29 = (signed __int64)(v9 + 7);
      if ( !v15(v11, v35, v8 + 1, v34, v7) )
        goto LABEL_66;
      if ( !v15(v11, (_QWORD *)v34, (_QWORD *)v34, v29, v7) )
        goto LABEL_66;
      v23 = (signed __int64)(v8 + 4);
      v24 = (__int64)v33;
      if ( !v15(v11, v33, (_QWORD *)v23, v34, v7) )
        goto LABEL_66;
    }
    else
    {
      v29 = (signed __int64)(v9 + 7);
      if ( !BN_copy((__int64)v35, (__int64)(v8 + 1)) )
        goto LABEL_66;
      v25 = (__int64)(v8 + 4);
      v24 = (__int64)v33;
      v30 = v20;
      if ( !BN_copy((__int64)v33, v25) )
        goto LABEL_66;
    }
    if ( !(unsigned int)BN_mod_sub_quick((__int64)v32, (__int64)v18, (__int64)v35, (__int64)(v11 + 7))
      || !(unsigned int)BN_mod_sub_quick(v31, (__int64)v37, v24, (__int64)(v11 + 7)) )
    {
      goto LABEL_66;
    }
    if ( BN_is_zero((__int64)v32) )
    {
      if ( BN_is_zero(v31) )
      {
        BN_CTX_end(v7);
        v16 = v36;
        v21 = EC_POINT_dbl(v11, v10, v9, v7);
LABEL_69:
        BN_CTX_free((__int64)v16);
        return v21;
      }
      BN_zero((__int64)(v10 + 7));
      v21 = 1;
      goto LABEL_67;
    }
    if ( !(unsigned int)BN_mod_add_quick((__int64)v18, (__int64)v18, (__int64)v35, (__int64)(v11 + 7))
      || !(unsigned int)BN_mod_add_quick((__int64)v37, (__int64)v37, v24, (__int64)(v11 + 7)) )
    {
      goto LABEL_66;
    }
    if ( !(v22 | v30) )
    {
      v26 = v34;
      if ( !BN_copy((__int64)(v10 + 7), (__int64)v32) )
        goto LABEL_66;
LABEL_53:
      if ( v38(v11, v26, (_QWORD *)v31, v7)
        && v38(v11, (__int64)v33, v32, v7)
        && v15(v11, v35, v18, (__int64)v33, v7)
        && (unsigned int)BN_mod_sub_quick((__int64)(v10 + 1), v34, (__int64)v35, (__int64)(v11 + 7))
        && (unsigned int)BN_mod_lshift1_quick(v34, (__int64)(v10 + 1), (__int64)(v11 + 7))
        && (unsigned int)BN_mod_sub_quick(v34, (__int64)v35, v34, (__int64)(v11 + 7))
        && v15(v11, (_QWORD *)v34, (_QWORD *)v34, v31, v7)
        && v15(v11, v32, v33, (__int64)v32, v7)
        && v15(v11, v18, v37, (__int64)v32, v7)
        && (unsigned int)BN_mod_sub_quick(v34, v34, (__int64)v18, (__int64)(v11 + 7))
        && (!(unsigned int)BN_is_odd(v34) || (unsigned int)BN_add(v34, v34, (__int64)(v11 + 7))) )
      {
        v21 = (unsigned __int64)BN_rshift1((__int64)(v10 + 4), v34) != 0;
LABEL_67:
        v16 = v36;
        goto LABEL_68;
      }
LABEL_66:
      v21 = 0;
      goto LABEL_67;
    }
    if ( v22 )
    {
      if ( v30 )
      {
        v26 = v34;
        if ( !v15(v11, (_QWORD *)v34, (_QWORD *)v29, v28, v7) )
          goto LABEL_66;
LABEL_52:
        if ( !v15(v11, v10 + 7, (_QWORD *)v26, (__int64)v32, v7) )
          goto LABEL_66;
        goto LABEL_53;
      }
      v26 = v34;
      v27 = v29;
    }
    else
    {
      v26 = v34;
      v27 = v28;
    }
    if ( !BN_copy(v26, v27) )
      goto LABEL_66;
    goto LABEL_52;
  }
  return 0;
}

//----- (00000000000736D0) ----------------------------------------------------
__int64 __fastcall EC_POINT_dbl(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  _QWORD *v5; // x28
  _QWORD *v6; // x21
  __int64 v7; // x19
  _DWORD *v8; // x23
  _BOOL4 v9; // w20
  unsigned int (__fastcall *v10)(_DWORD *, _QWORD *, _QWORD *, _QWORD *, __int64); // x20
  unsigned int (__fastcall *v11)(_DWORD *, _QWORD *, _QWORD *, __int64); // x27
  _DWORD *v12; // x25
  _QWORD *v13; // x24
  _QWORD *v14; // x26
  _QWORD *v15; // x0
  __int64 v16; // x20
  __int64 v17; // x2
  __int64 v18; // x0
  __int64 v19; // x1
  __int64 v20; // [xsp+10h] [xbp-80h]
  unsigned int (__fastcall *v21)(_DWORD *, _QWORD *, _QWORD *, _QWORD *, __int64); // [xsp+18h] [xbp-78h]
  _QWORD *v22; // [xsp+20h] [xbp-70h]

  if ( *a1 != *a2 || *a1 != *a3 )
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 768);
    return 0LL;
  }
  v5 = a3;
  v6 = a2;
  v7 = a4;
  v8 = a1;
  if ( !EC_POINT_is_at_infinity(a1, a3) )
  {
    v10 = *(unsigned int (__fastcall **)(_DWORD *, _QWORD *, _QWORD *, _QWORD *, __int64))(*(_QWORD *)v8 + 48LL);
    v11 = *(unsigned int (__fastcall **)(_DWORD *, _QWORD *, _QWORD *, __int64))(*(_QWORD *)v8 + 56LL);
    if ( v7 )
    {
      v12 = 0LL;
    }
    else
    {
      v12 = BN_CTX_new();
      v7 = (__int64)v12;
      if ( !v12 )
        return 0;
    }
    BN_CTX_start(v7);
    v13 = BN_CTX_get(v7);
    v14 = BN_CTX_get(v7);
    v22 = BN_CTX_get(v7);
    v15 = BN_CTX_get(v7);
    if ( !v15 )
      goto LABEL_35;
    v20 = (__int64)v15;
    v21 = v10;
    v16 = (__int64)(v8 + 36);
    if ( (unsigned int)BN_cmp((__int64)(v5 + 7), (__int64)(v8 + 36)) )
    {
      if ( v8[32] )
      {
        if ( !v11(v8, v14, v5 + 7, v7) )
          goto LABEL_35;
        if ( !(unsigned int)BN_mod_add_quick((__int64)v13, (__int64)(v5 + 1), (__int64)v14, (__int64)(v8 + 14)) )
          goto LABEL_35;
        if ( !(unsigned int)BN_mod_sub_quick((__int64)v22, (__int64)(v5 + 1), (__int64)v14, (__int64)(v8 + 14)) )
          goto LABEL_35;
        if ( !v21(v8, v14, v13, v22, v7) )
          goto LABEL_35;
        if ( !(unsigned int)BN_mod_lshift1_quick((__int64)v13, (__int64)v14, (__int64)(v8 + 14)) )
          goto LABEL_35;
        v16 = (__int64)(v8 + 36);
        if ( !(unsigned int)BN_mod_add_quick((__int64)v14, (__int64)v13, (__int64)v14, (__int64)(v8 + 14)) )
          goto LABEL_35;
LABEL_24:
        if ( (unsigned int)BN_cmp((__int64)(v5 + 7), v16) )
        {
          if ( !v21(v8, v13, v5 + 4, v5 + 7, v7) )
            goto LABEL_35;
        }
        else if ( !BN_copy((__int64)v13, (__int64)(v5 + 4)) )
        {
          goto LABEL_35;
        }
        if ( (unsigned int)BN_mod_lshift1_quick((__int64)(v6 + 7), (__int64)v13, (__int64)(v8 + 14))
          && v11(v8, (_QWORD *)v20, v5 + 4, v7)
          && v21(v8, v22, v5 + 1, (_QWORD *)v20, v7)
          && (unsigned int)BN_mod_lshift_quick((__int64)v22, (__int64)v22, 2, (__int64)(v8 + 14))
          && (unsigned int)BN_mod_lshift1_quick((__int64)v13, (__int64)v22, (__int64)(v8 + 14))
          && v11(v8, v6 + 1, v14, v7)
          && (unsigned int)BN_mod_sub_quick((__int64)(v6 + 1), (__int64)(v6 + 1), (__int64)v13, (__int64)(v8 + 14))
          && v11(v8, v13, (_QWORD *)v20, v7)
          && (unsigned int)BN_mod_lshift_quick(v20, (__int64)v13, 3, (__int64)(v8 + 14))
          && (unsigned int)BN_mod_sub_quick((__int64)v13, (__int64)v22, (__int64)(v6 + 1), (__int64)(v8 + 14))
          && v21(v8, v13, v14, v13, v7) )
        {
          v9 = (unsigned __int64)BN_mod_sub_quick((__int64)(v6 + 4), (__int64)v13, v20, (__int64)(v8 + 14)) != 0;
          goto LABEL_36;
        }
LABEL_35:
        v9 = 0;
LABEL_36:
        BN_CTX_end(v7);
        BN_CTX_free((__int64)v12);
        return (unsigned int)v9;
      }
      if ( !v11(v8, v13, v5 + 1, v7)
        || !(unsigned int)BN_mod_lshift1_quick((__int64)v14, (__int64)v13, (__int64)(v8 + 14))
        || !(unsigned int)BN_mod_add_quick((__int64)v13, (__int64)v13, (__int64)v14, (__int64)(v8 + 14))
        || !v11(v8, v14, v5 + 7, v7)
        || !v11(v8, v14, v14, v7)
        || !v21(v8, v14, v14, (_QWORD *)v8 + 10, v7) )
      {
        goto LABEL_35;
      }
      v18 = (__int64)v14;
      v19 = (__int64)v14;
      v17 = (__int64)v13;
    }
    else
    {
      if ( !v11(v8, v13, v5 + 1, v7)
        || !(unsigned int)BN_mod_lshift1_quick((__int64)v14, (__int64)v13, (__int64)(v8 + 14))
        || !(unsigned int)BN_mod_add_quick((__int64)v13, (__int64)v13, (__int64)v14, (__int64)(v8 + 14)) )
      {
        goto LABEL_35;
      }
      v17 = (__int64)(v8 + 20);
      v18 = (__int64)v14;
      v19 = (__int64)v13;
    }
    if ( !(unsigned int)BN_mod_add_quick(v18, v19, v17, (__int64)(v8 + 14)) )
      goto LABEL_35;
    goto LABEL_24;
  }
  BN_zero((__int64)(v6 + 7));
  return 1;
}

//----- (0000000000073720) ----------------------------------------------------
__int64 __fastcall EC_POINT_invert(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // x0
  _QWORD *v3; // x20
  _QWORD *v4; // x19
  __int64 v5; // x20

  if ( *a1 == *a2 )
  {
    v3 = a2;
    v4 = a1;
    if ( EC_POINT_is_at_infinity(a1, a2) || (v5 = (__int64)(v3 + 4), BN_is_zero(v5)) )
      result = 1LL;
    else
      result = BN_usub(v5, (__int64)(v4 + 7), v5);
  }
  else
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 777);
    result = 0LL;
  }
  return result;
}

//----- (0000000000073764) ----------------------------------------------------
__int64 __fastcall EC_POINT_mul(__int64 *a1, _QWORD *a2, __int64 a3, _QWORD *a4, __int64 a5)
{
  __int64 v5; // x8
  int v6; // w2
  __int16 v7; // w4

  if ( !(a3 | a5) || (a4 == 0LL) ^ (a5 == 0) )
  {
    v6 = 67;
    v7 = 790;
    goto LABEL_6;
  }
  v5 = *a1;
  if ( *a1 != *a2 || a4 && v5 != *a4 )
  {
    v6 = 106;
    v7 = 796;
LABEL_6:
    ERR_put_error(15, 0LL, v6, (__int64)"external/boringssl/src/crypto/ec/ec.c", v7);
    return 0LL;
  }
  return (*(__int64 (**)(void))(v5 + 40))();
}

//----- (00000000000737F8) ----------------------------------------------------
__int64 __fastcall sub_737F8(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6)
{
  _DWORD *v7; // x21
  __int64 v8; // x20
  __int64 v9; // x24
  __int64 v10; // x25
  _QWORD *v11; // x23
  __int64 v12; // x22
  __int64 v13; // x19
  _BOOL4 v14; // w20

  if ( *a1 != *a2 )
  {
    ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/ec.c", 807);
    return 0LL;
  }
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  v12 = (__int64)a1;
  if ( a6 )
  {
    v13 = 0LL;
    goto LABEL_6;
  }
  v7 = BN_CTX_new();
  v13 = (__int64)v7;
  if ( v7 )
  {
LABEL_6:
    if ( (unsigned int)sub_8291C(v12, (__int64)(v11 + 1), v10, (__int64)v7)
      && (unsigned int)sub_8291C(v12, (__int64)(v11 + 4), v9, (__int64)v7) )
    {
      v14 = (unsigned __int64)sub_8291C(v12, (__int64)(v11 + 7), v8, (__int64)v7) != 0;
    }
    else
    {
      v14 = 0;
    }
    BN_CTX_free(v13);
    return (unsigned int)v14;
  }
  return 0;
}

//----- (000000000007383C) ----------------------------------------------------
signed __int64 EC_METHOD_get_field_type()
{
  return 406LL;
}

//----- (0000000000073844) ----------------------------------------------------
void __fastcall EC_GROUP_set_point_conversion_form(__int64 a1, int a2)
{
  if ( a2 != 4 )
    abort();
}

//----- (000000000007385C) ----------------------------------------------------
signed __int64 __fastcall EC_get_builtin_curves(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // x8
  char **v3; // x9
  unsigned __int64 v4; // x10
  bool v5; // cf

  if ( a2 )
  {
    v2 = (_QWORD *)(a1 + 8);
    v3 = &off_F7C78;
    v4 = 1LL;
    do
    {
      *v2 = *(_QWORD *)*v3;
      *((_DWORD *)v2 - 2) = *((_DWORD *)v3 - 4);
      if ( v4 > 3 )
        break;
      v2 += 2;
      v5 = v4++ >= a2;
      v3 += 4;
    }
    while ( !v5 );
  }
  return 4LL;
}
// F7C78: using guessed type char *off_F7C78;

//----- (00000000000738AC) ----------------------------------------------------
void sub_738AC()
{
  _QWORD *v0; // x19
  _DWORD *v1; // x0
  __int64 v2; // x20
  _QWORD *v3; // x21

  qword_1071E8 = (__int64)malloc(0x20uLL);
  if ( qword_1071E8 )
  {
    v0 = BN_new();
    v1 = BN_CTX_new();
    v2 = (__int64)v1;
    v3 = 0LL;
    if ( v0
      && v1
      && (v3 = BN_MONT_CTX_new()) != 0LL
      && BN_bin2bn((unsigned __int8 *)&unk_F7E5B, 66LL, (__int64)v0)
      && BN_MONT_CTX_set((__int64)v3, (__int64)v0)
      && (*(_QWORD *)qword_1071E8 = v3, (v3 = BN_MONT_CTX_new()) != 0LL)
      && BN_bin2bn((unsigned __int8 *)&unk_F7F99, 48LL, (__int64)v0)
      && BN_MONT_CTX_set((__int64)v3, (__int64)v0)
      && (*(_QWORD *)(qword_1071E8 + 8) = v3, (v3 = BN_MONT_CTX_new()) != 0LL)
      && BN_bin2bn((unsigned __int8 *)&unk_F8079, 32LL, (__int64)v0)
      && BN_MONT_CTX_set((__int64)v3, (__int64)v0)
      && (*(_QWORD *)(qword_1071E8 + 16) = v3, (v3 = BN_MONT_CTX_new()) != 0LL)
      && BN_bin2bn((unsigned __int8 *)&unk_F8135, 28LL, (__int64)v0)
      && BN_MONT_CTX_set((__int64)v3, (__int64)v0) )
    {
      *(_QWORD *)(qword_1071E8 + 24) = v3;
    }
    else
    {
      BN_MONT_CTX_free(v3);
      free((void *)qword_1071E8);
      qword_1071E8 = 0LL;
    }
    BN_free(v0);
    BN_CTX_free(v2);
  }
}
// 1071E8: using guessed type __int64 qword_1071E8;

//----- (0000000000073A40) ----------------------------------------------------
void __fastcall EC_KEY_parse_private_key(unsigned __int8 **a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x0
  __int64 v4; // x19
  __int64 *v5; // x21
  int v6; // w2
  __int16 v7; // w4
  __int64 *v8; // x0
  unsigned __int8 *v9; // x22
  __int64 v10; // x0
  void *v11; // x0
  __int64 v12; // x22
  __int64 v13; // x0
  int v14; // w2
  __int16 v15; // w4
  _QWORD *v16; // x22
  unsigned __int8 *v17; // x23
  __int64 v18; // x0
  char v19; // [xsp+Ch] [xbp-84h]
  char v20; // [xsp+10h] [xbp-80h]
  unsigned __int8 *v21[2]; // [xsp+20h] [xbp-70h]
  __int64 v22; // [xsp+30h] [xbp-60h]
  char v23; // [xsp+38h] [xbp-58h]
  unsigned __int8 *v24[2]; // [xsp+48h] [xbp-48h]
  __int64 v25; // [xsp+58h] [xbp-38h]

  v2 = a2;
  v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a1, (char *)v24, 48)
    && (unsigned int)CBS_get_asn1_uint64(v24, (unsigned __int64 *)&v22)
    && v22 == 1
    && (unsigned int)CBS_get_asn1(v24, &v23, 4) )
  {
    if ( CBS_peek_asn1_tag(v24, 160) )
    {
      if ( !(unsigned int)CBS_get_asn1(v24, (char *)v21, 160) )
      {
        ERR_put_error(15, 0LL, 128, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", 96);
        v4 = 0LL;
        v2 = 0LL;
LABEL_42:
        EC_KEY_free(v2);
        EC_GROUP_free(v4);
        goto LABEL_12;
      }
      v3 = EC_KEY_parse_parameters(v21);
      v4 = (__int64)v3;
      if ( !v3 )
      {
LABEL_26:
        v2 = 0LL;
        goto LABEL_42;
      }
      v5 = v3;
      if ( v2 )
      {
        v5 = (__int64 *)v2;
        if ( (unsigned int)EC_GROUP_cmp(v2, (__int64)v3) )
        {
          v6 = 130;
          v7 = 107;
LABEL_25:
          ERR_put_error(15, 0LL, v6, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v7);
          goto LABEL_26;
        }
      }
      if ( EVP_CIPHER_CTX_get_app_data((__int64)v21) )
      {
        v6 = 128;
        v7 = 111;
        goto LABEL_25;
      }
    }
    else
    {
      if ( !v2 )
      {
        ERR_put_error(15, 0LL, 114, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", 117);
        v4 = 0LL;
        goto LABEL_42;
      }
      v4 = 0LL;
      v5 = (__int64 *)v2;
    }
    v8 = EC_KEY_new();
    v2 = (__int64)v8;
    if ( !v8 )
      goto LABEL_42;
    if ( !(unsigned int)EC_KEY_set_group(v8, (_QWORD **)v5) )
      goto LABEL_42;
    v9 = (unsigned __int8 *)lh_num_items((__int64)&v23);
    v10 = EVP_CIPHER_CTX_get_app_data((__int64)&v23);
    *(_QWORD *)(v2 + 16) = BN_bin2bn(v9, v10, 0LL);
    v11 = EC_POINT_new(v5);
    *(_QWORD *)(v2 + 8) = v11;
    if ( !v11 )
      goto LABEL_42;
    v12 = *(_QWORD *)(v2 + 16);
    if ( !v12 )
      goto LABEL_42;
    v13 = EC_GROUP_get0_order((__int64)v5);
    if ( !(BN_cmp(v12, v13) & 0x80000000) )
    {
      v14 = 125;
      v15 = 137;
LABEL_41:
      ERR_put_error(15, 0LL, v14, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v15);
      goto LABEL_42;
    }
    if ( CBS_peek_asn1_tag(v24, 161) )
    {
      if ( !(unsigned int)CBS_get_asn1(v24, (char *)v21, 161)
        || !(unsigned int)CBS_get_asn1(v21, &v20, 3)
        || !(unsigned int)CBS_get_u8((__int64)&v20, &v19)
        || v19
        || !EVP_CIPHER_CTX_get_app_data((__int64)&v20)
        || (v16 = *(_QWORD **)(v2 + 8),
            v17 = (unsigned __int8 *)lh_num_items((__int64)&v20),
            v18 = EVP_CIPHER_CTX_get_app_data((__int64)&v20),
            !(unsigned int)EC_POINT_oct2point(v5, v16, v17, v18, 0LL))
        || EVP_CIPHER_CTX_get_app_data((__int64)v21) )
      {
        v14 = 128;
        v15 = 156;
        goto LABEL_41;
      }
      *(_DWORD *)(v2 + 28) = *(_BYTE *)lh_num_items((__int64)&v20) & 0xFE;
    }
    else
    {
      if ( !(unsigned int)EC_POINT_mul(v5, *(_QWORD **)(v2 + 8), *(_QWORD *)(v2 + 16), 0LL, 0LL) )
        goto LABEL_42;
      *(_DWORD *)(v2 + 24) |= 2u;
    }
    if ( !EVP_CIPHER_CTX_get_app_data((__int64)v24) )
    {
      if ( (unsigned int)EC_KEY_check_key((__int64 *)v2) )
      {
        EC_GROUP_free(v4);
        goto LABEL_12;
      }
      goto LABEL_42;
    }
    v14 = 128;
    v15 = 174;
    goto LABEL_41;
  }
  ERR_put_error(15, 0LL, 128, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", 82);
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v25;
}

//----- (0000000000073DC4) ----------------------------------------------------
_QWORD *__fastcall EC_KEY_parse_parameters(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // x19
  const void *v2; // x0
  int v3; // w2
  __int16 v4; // w4
  __int64 v5; // x23
  __int64 v6; // x19
  __int64 v7; // x8
  int *v8; // x22
  unsigned int v9; // w21
  _QWORD *result; // x0
  int v11; // w8
  int v12; // w8
  __int64 v13; // x19
  __int64 v14; // x0
  __int64 v15; // x0
  __int128 v16; // [xsp+8h] [xbp-F8h]
  __int128 v17; // [xsp+18h] [xbp-E8h]
  __int128 v18; // [xsp+28h] [xbp-D8h]
  __int128 v19; // [xsp+38h] [xbp-C8h]
  __int128 v20; // [xsp+48h] [xbp-B8h]
  __int128 v21; // [xsp+58h] [xbp-A8h]
  char v22; // [xsp+6Ch] [xbp-94h]
  __int64 v23; // [xsp+70h] [xbp-90h]
  char v24; // [xsp+78h] [xbp-88h]
  unsigned __int8 *v25[2]; // [xsp+88h] [xbp-78h]
  char v26; // [xsp+98h] [xbp-68h]
  unsigned __int8 *v27[2]; // [xsp+A8h] [xbp-58h]
  unsigned __int8 *v28[2]; // [xsp+B8h] [xbp-48h]
  __int64 v29; // [xsp+C8h] [xbp-38h]

  v1 = a1;
  v29 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !CBS_peek_asn1_tag(a1, 48) )
  {
    result = EC_KEY_parse_curve_name(v1);
    goto LABEL_21;
  }
  if ( (unsigned int)CBS_get_asn1(v1, (char *)v28, 48)
    && (unsigned int)CBS_get_asn1_uint64(v28, (unsigned __int64 *)&v23)
    && v23 == 1
    && (unsigned int)CBS_get_asn1(v28, (char *)v27, 48)
    && (unsigned int)CBS_get_asn1(v27, &v26, 6)
    && EVP_CIPHER_CTX_get_app_data((__int64)&v26) == 7
    && (v2 = (const void *)lh_num_items((__int64)&v26), !(unsigned int)memcmp(v2, &unk_D83A8, 7uLL))
    && (unsigned int)CBS_get_asn1(v27, (char *)&v21, 2)
    && EVP_CIPHER_CTX_get_app_data((__int64)&v21)
    && (v11 = *(char *)lh_num_items((__int64)&v21), !(v11 & 0x80000000))
    && (v11
     || (unsigned __int64)EVP_CIPHER_CTX_get_app_data((__int64)&v21) < 2
     || *(char *)(lh_num_items((__int64)&v21) + 1) & 0x80000000)
    && !EVP_CIPHER_CTX_get_app_data((__int64)v27)
    && (unsigned int)CBS_get_asn1(v28, (char *)v25, 48)
    && (unsigned int)CBS_get_asn1(v25, (char *)&v20, 4)
    && (unsigned int)CBS_get_asn1(v25, (char *)&v19, 4)
    && (unsigned int)CBS_get_asn1(v28, &v24, 4)
    && (unsigned int)CBS_get_asn1(v28, (char *)&v16, 2)
    && EVP_CIPHER_CTX_get_app_data((__int64)&v16)
    && (v12 = *(char *)lh_num_items((__int64)&v16), !(v12 & 0x80000000))
    && (v12
     || (unsigned __int64)EVP_CIPHER_CTX_get_app_data((__int64)&v16) < 2
     || *(char *)(lh_num_items((__int64)&v16) + 1) & 0x80000000) )
  {
    if ( (unsigned int)CBS_get_u8((__int64)&v24, &v22) && v22 == 4 )
    {
      if ( !(EVP_CIPHER_CTX_get_app_data((__int64)&v24) & 1) )
      {
        v13 = (unsigned __int64)EVP_CIPHER_CTX_get_app_data((__int64)&v24) >> 1;
        v14 = lh_num_items((__int64)&v24);
        CBS_init(&v18, v14, v13);
        v15 = lh_num_items((__int64)&v24);
        CBS_init(&v17, v15 + v13, v13);
        v7 = 0LL;
        v9 = 1;
        v8 = dword_F7C68;
        while ( 1 )
        {
          v5 = *(_QWORD *)&dword_F7C68[8 * v7 + 4];
          v6 = *(unsigned __int8 *)(v5 + 8);
          if ( sub_74588(&v21, (_BYTE *)(v5 + 9), v6)
            && sub_74588(&v20, (_BYTE *)(v5 + v6 + 9), v6)
            && sub_74588(&v19, (_BYTE *)(v5 + 2 * v6 + 9), v6)
            && sub_74588(&v18, (_BYTE *)(v5 + 3 * v6 + 9), v6)
            && sub_74588(&v17, (_BYTE *)(v5 + 4 * v6 + 9), v6)
            && sub_74588(&v16, (_BYTE *)(v5 + 5 * v6 + 9), v6) )
          {
            break;
          }
          v7 = v9;
          v8 = &dword_F7C68[8 * v9++];
          if ( !*v8 )
          {
            ERR_put_error(15, 0LL, 123, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", 405);
            goto LABEL_19;
          }
        }
        result = EC_GROUP_new_by_curve_name(*v8);
        goto LABEL_21;
      }
      v3 = 128;
      v4 = 302;
    }
    else
    {
      v3 = 111;
      v4 = 297;
    }
  }
  else
  {
    v3 = 128;
    v4 = 286;
  }
  ERR_put_error(15, 0LL, v3, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v4);
LABEL_19:
  result = 0LL;
LABEL_21:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v29;
  return result;
}
// F7C68: using guessed type int dword_F7C68[];

//----- (000000000007417C) ----------------------------------------------------
signed __int64 __fastcall EC_KEY_marshal_private_key(__int64 *a1, _QWORD *a2, char a3)
{
  char v3; // w21
  _QWORD **v4; // x20
  __int64 *v5; // x19
  __int64 v6; // x0
  unsigned int v7; // w0
  signed __int64 result; // x0
  int v9; // w2
  __int16 v10; // w4
  char v11; // [xsp+8h] [xbp-A8h]
  char v12; // [xsp+28h] [xbp-88h]
  char v13; // [xsp+48h] [xbp-68h]
  __int64 v14[4]; // [xsp+68h] [xbp-48h]
  __int64 v15; // [xsp+88h] [xbp-28h]

  v3 = a3;
  v4 = (_QWORD **)a2;
  v5 = a1;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 || !*a2 || !a2[2] )
  {
    v9 = 67;
    v10 = 195;
LABEL_23:
    ERR_put_error(15, 0LL, v9, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v10);
    result = 0LL;
    goto LABEL_24;
  }
  if ( !(unsigned int)CBB_add_asn1(a1, v14, 0x30u)
    || !(unsigned int)CBB_add_asn1_uint64(v14, 1uLL)
    || !(unsigned int)CBB_add_asn1(v14, (__int64 *)&v13, 4u)
    || (v6 = EC_GROUP_get0_order((__int64)*v4),
        v7 = BN_num_bytes(v6),
        !(unsigned int)BN_bn2cbb_padded((__int64 *)&v13, v7, (__int64)v4[2])) )
  {
    v9 = 129;
    v10 = 206;
    goto LABEL_23;
  }
  if ( !(v3 & 1)
    && (!(unsigned int)CBB_add_asn1(v14, (__int64 *)&v12, 0xA0u)
     || !(unsigned int)EC_KEY_marshal_curve_name((__int64 *)&v12, (__int64)*v4)
     || !(unsigned int)CBB_flush(v14)) )
  {
    v9 = 129;
    v10 = 215;
    goto LABEL_23;
  }
  if ( !(v3 & 2)
    && v4[1]
    && (!(unsigned int)CBB_add_asn1(v14, (__int64 *)&v12, 0xA1u)
     || !(unsigned int)CBB_add_asn1((__int64 *)&v12, (__int64 *)&v11, 3u)
     || !(unsigned int)CBB_add_u8((__int64 *)&v11, 0)
     || !(unsigned int)EC_POINT_point2cbb((__int64 *)&v11, (__int64)*v4, v4[1], *((_DWORD *)v4 + 7), 0LL)
     || !(unsigned int)CBB_flush(v14)) )
  {
    v9 = 129;
    v10 = 231;
    goto LABEL_23;
  }
  if ( !(unsigned int)CBB_flush(v5) )
  {
    v9 = 129;
    v10 = 237;
    goto LABEL_23;
  }
  result = 1LL;
LABEL_24:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v15;
  return result;
}

//----- (0000000000074370) ----------------------------------------------------
signed __int64 __fastcall EC_KEY_marshal_curve_name(__int64 *a1, __int64 a2)
{
  __int64 *v2; // x19
  int v3; // w0
  int v4; // w9
  __int64 v5; // x21
  unsigned int v6; // w8
  __int16 v7; // w4
  signed __int64 result; // x0
  char **v9[4]; // [xsp+8h] [xbp-48h]
  __int64 v10; // [xsp+28h] [xbp-28h]

  v2 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = X509_VERIFY_PARAM_get_depth(a2);
  if ( v3 )
  {
    v4 = 716;
    v5 = 0LL;
    v6 = 1;
    while ( v4 != v3 )
    {
      v5 = v6;
      v4 = dword_F7C68[8 * v6++];
      if ( !v4 )
      {
        v7 = 366;
        goto LABEL_7;
      }
    }
    result = CBB_add_asn1(v2, (__int64 *)v9, 6u);
    if ( (_DWORD)result )
    {
      result = CBB_add_bytes(v9, &dword_F7C68[8 * v5 + 1], LOBYTE(dword_F7C68[8 * v5 + 3]));
      if ( (_DWORD)result )
        result = (unsigned int)CBB_flush(v2) != 0;
    }
  }
  else
  {
    v7 = 351;
LABEL_7:
    ERR_put_error(15, 0LL, 123, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v7);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v10;
  return result;
}
// F7C68: using guessed type int dword_F7C68[];

//----- (0000000000074478) ----------------------------------------------------
_QWORD *__fastcall EC_KEY_parse_curve_name(unsigned __int8 **a1)
{
  signed int v1; // w19
  __int64 v2; // x23
  unsigned int v3; // w22
  __int64 v4; // x0
  __int64 v5; // x24
  size_t v6; // x20
  const void *v7; // x0
  int v8; // w2
  __int16 v9; // w4
  _QWORD *result; // x0
  char v11; // [xsp+8h] [xbp-48h]
  __int64 v12; // [xsp+18h] [xbp-38h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a1, &v11, 6) )
  {
    v1 = 716;
    v2 = 0LL;
    v3 = 1;
    while ( 1 )
    {
      v4 = EVP_CIPHER_CTX_get_app_data((__int64)&v11);
      v5 = LOBYTE(dword_F7C68[8 * v2 + 3]);
      v6 = v4;
      if ( v4 == v5 )
      {
        v7 = (const void *)lh_num_items((__int64)&v11);
        if ( !(_DWORD)v5 || !(unsigned int)memcmp(v7, &dword_F7C68[8 * v2 + 1], v6) )
          break;
      }
      v2 = v3;
      v1 = dword_F7C68[8 * v3++];
      if ( !v1 )
      {
        v8 = 123;
        v9 = 344;
        goto LABEL_9;
      }
    }
    result = EC_GROUP_new_by_curve_name(v1);
  }
  else
  {
    v8 = 128;
    v9 = 330;
LABEL_9:
    ERR_put_error(15, 0LL, v8, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v9);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v12;
  return result;
}
// F7C68: using guessed type int dword_F7C68[];

//----- (0000000000074588) ----------------------------------------------------
bool __fastcall sub_74588(__int128 *a1, _BYTE *a2, __int64 a3)
{
  __int64 v3; // x20
  _BYTE *v4; // x19
  _BOOL8 result; // x0
  __int128 i; // [xsp+0h] [xbp-30h]
  __int64 v7; // [xsp+18h] [xbp-18h]

  v3 = a3;
  v4 = a2;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  for ( i = *a1;
        EVP_CIPHER_CTX_get_app_data((__int64)&i) && !*(_BYTE *)lh_num_items((__int64)&i);
        CBS_skip((__int64 *)&i, 1uLL) )
  {
    ;
  }
  for ( ; v3; --v3 )
  {
    if ( *v4 )
      break;
    ++v4;
  }
  result = CBS_mem_equal((__int64 *)&i, (__int64)v4, v3);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000074630) ----------------------------------------------------
void __fastcall d2i_ECPrivateKey(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // x21
  __int64 *v4; // x19
  __int64 *v5; // x20
  __int64 v6; // x0
  __int64 v7; // x22
  __int64 v8; // x0
  __int64 v9; // x21
  unsigned __int8 *v10[2]; // [xsp+8h] [xbp-38h]
  __int64 v11; // [xsp+18h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 && (v6 = *a1, *v5) )
  {
    v7 = lh_num_items(v6);
    if ( v3 & 0x8000000000000000LL )
      goto LABEL_10;
  }
  else
  {
    v7 = 0LL;
    if ( a3 & 0x8000000000000000LL )
    {
LABEL_10:
      ERR_put_error(15, 0LL, 128, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", 418);
      goto LABEL_11;
    }
  }
  CBS_init(v10, *v4, v3);
  EC_KEY_parse_private_key(v10, v7);
  v9 = v8;
  if ( v8 )
  {
    if ( v5 )
    {
      EC_KEY_free(*v5);
      *v5 = v9;
    }
    *v4 = lh_num_items((__int64)v10);
  }
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000074714) ----------------------------------------------------
signed __int64 __fastcall i2d_ECPrivateKey(_QWORD *a1, void **a2)
{
  void **v2; // x19
  _QWORD *v3; // x20
  char v4; // w0
  signed __int64 result; // x0
  __int64 v6[4]; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v6, 0LL)
    && (v4 = EVP_CIPHER_CTX_key_length((__int64)v3), (unsigned int)EC_KEY_marshal_private_key(v6, v3, v4)) )
  {
    result = sub_6F744((__int64)v6, v2);
  }
  else
  {
    CBB_cleanup(v6);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000747A8) ----------------------------------------------------
void __fastcall d2i_ECParameters(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  __int64 *v4; // x21
  _QWORD *v5; // x22
  __int64 *v6; // x0
  __int64 v7; // x20
  unsigned __int8 *v8[2]; // [xsp+8h] [xbp-38h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(a3 & 0x8000000000000000LL) )
  {
    CBS_init(v8, *a2, a3);
    v5 = EC_KEY_parse_parameters(v8);
    if ( v5 )
    {
      v6 = EC_KEY_new();
      v7 = (__int64)v6;
      if ( v6 && (unsigned int)EC_KEY_set_group(v6, (_QWORD **)v5) )
      {
        EC_GROUP_free((__int64)v5);
        if ( v4 )
        {
          EC_KEY_free(*v4);
          *v4 = v7;
        }
        *v3 = lh_num_items((__int64)v8);
      }
      else
      {
        EC_GROUP_free((__int64)v5);
        EC_KEY_free(v7);
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000074878) ----------------------------------------------------
signed __int64 __fastcall i2d_ECParameters(__int64 *a1, void **a2)
{
  void **v2; // x19
  __int64 *v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 || !*a1 )
  {
    ERR_put_error(15, 0LL, 67, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", 475);
LABEL_8:
    result = 0xFFFFFFFFLL;
    goto LABEL_9;
  }
  if ( !(unsigned int)CBB_init(v5, 0LL) || !(unsigned int)EC_KEY_marshal_curve_name(v5, *v3) )
  {
    CBB_cleanup(v5);
    goto LABEL_8;
  }
  result = sub_6F744((__int64)v5, v2);
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000007492C) ----------------------------------------------------
__int64 __fastcall o2i_ECPublicKey(__int64 *a1, unsigned __int8 **a2, __int64 a3)
{
  __int64 v3; // x21
  unsigned __int8 **v4; // x20
  __int64 v5; // x19
  _QWORD *v6; // x0
  _QWORD *v7; // x1
  int v8; // w2
  __int16 v9; // w4

  v3 = a3;
  v4 = a2;
  if ( !a1 || (v5 = *a1) == 0 || (v6 = *(_QWORD **)v5) == 0LL )
  {
    v8 = 67;
    v9 = 492;
LABEL_10:
    ERR_put_error(15, 0LL, v8, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v9);
    return 0LL;
  }
  v7 = *(_QWORD **)(v5 + 8);
  if ( !v7 )
  {
    v7 = EC_POINT_new(v6);
    *(_QWORD *)(v5 + 8) = v7;
    if ( !v7 )
    {
      v8 = 65;
      v9 = 498;
      goto LABEL_10;
    }
    v6 = *(_QWORD **)v5;
  }
  if ( !(unsigned int)EC_POINT_oct2point(v6, v7, *v4, v3, 0LL) )
  {
    v8 = 15;
    v9 = 502;
    goto LABEL_10;
  }
  *(_DWORD *)(v5 + 28) = **v4 & 0xFE;
  *v4 += v3;
  return v5;
}

//----- (0000000000074A0C) ----------------------------------------------------
__int64 __fastcall i2o_ECPublicKey(__int64 a1, void **a2)
{
  void **v2; // x19
  __int64 v3; // x21
  unsigned __int64 v4; // x0
  unsigned __int64 v5; // x20
  char *v6; // x3
  signed int v7; // w22
  int v8; // w2
  __int16 v9; // w4

  v2 = a2;
  v3 = a1;
  if ( !a1 )
  {
    v8 = 67;
    v9 = 516;
LABEL_7:
    ERR_put_error(15, 0LL, v8, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", v9);
LABEL_8:
    LODWORD(v5) = 0;
    return (unsigned int)v5;
  }
  v4 = EC_POINT_point2oct(*(_QWORD **)a1, *(_QWORD **)(a1 + 8), *(_DWORD *)(a1 + 28), 0LL, 0LL, 0LL);
  v5 = v4;
  if ( !v2 || !v4 )
    return (unsigned int)v5;
  v6 = (char *)*v2;
  if ( *v2 )
  {
    v7 = 0;
    goto LABEL_12;
  }
  v6 = (char *)malloc(v4);
  *v2 = v6;
  if ( !v6 )
  {
    v8 = 65;
    v9 = 531;
    goto LABEL_7;
  }
  v7 = 1;
LABEL_12:
  if ( !EC_POINT_point2oct(*(_QWORD **)v3, *(_QWORD **)(v3 + 8), *(_DWORD *)(v3 + 28), v6, v5, 0LL) )
  {
    ERR_put_error(15, 0LL, 15, (__int64)"external/boringssl/src/crypto/ec/ec_asn1.c", 538);
    if ( v7 )
    {
      free(*v2);
      LODWORD(v5) = 0;
      *v2 = 0LL;
      return (unsigned int)v5;
    }
    goto LABEL_8;
  }
  if ( !v7 )
    *v2 = (char *)*v2 + v5;
  return (unsigned int)v5;
}

//----- (0000000000074B20) ----------------------------------------------------
_QWORD *EC_KEY_new()
{
  return EC_KEY_new_method(0LL);
}

//----- (0000000000074B28) ----------------------------------------------------
_QWORD *__fastcall EC_KEY_new_method(__int64 a1)
{
  __int64 v1; // x20
  _QWORD *v2; // x0
  _QWORD *v3; // x19
  __int64 v4; // x0
  __int64 v5; // x8
  unsigned int (__fastcall *v6)(_QWORD *); // x8
  __int64 v7; // x0

  v1 = a1;
  v2 = malloc(0x38uLL);
  v3 = v2;
  if ( v2 )
  {
    v2[5] = 0LL;
    v2[6] = 0LL;
    v2[3] = 0LL;
    v2[4] = 0LL;
    v2[1] = 0LL;
    v2[2] = 0LL;
    *v2 = 0LL;
    if ( v1 )
    {
      v4 = EVP_CIPHER_CTX_get_app_data(v1);
      v3[5] = v4;
      if ( v4 )
        std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(v4);
    }
    *(_QWORD *)((char *)v3 + 28) = 4294967300LL;
    CRYPTO_new_ex_data(v3 + 6);
    v5 = v3[5];
    if ( v5 )
    {
      v6 = *(unsigned int (__fastcall **)(_QWORD *))(v5 + 16);
      if ( v6 )
      {
        if ( !v6(v3) )
        {
          CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_1071F0, (__int64)v3, (unsigned __int64 **)v3 + 6);
          v7 = v3[5];
          if ( v7 )
            std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(v7);
          free(v3);
          v3 = 0LL;
        }
      }
    }
  }
  else
  {
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 90);
  }
  return v3;
}
// 34D44: using guessed type __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(_QWORD);

//----- (0000000000074C00) ----------------------------------------------------
_QWORD *__fastcall EC_KEY_new_by_curve_name(signed int a1)
{
  signed int v1; // w20
  _QWORD *v2; // x19
  _QWORD *v3; // x0

  v1 = a1;
  v2 = EC_KEY_new_method(0LL);
  if ( v2 )
  {
    v3 = EC_GROUP_new_by_curve_name(v1);
    *v2 = v3;
    if ( !v3 )
    {
      EC_KEY_free((__int64)v2);
      v2 = 0LL;
    }
  }
  else
  {
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 123);
  }
  return v2;
}

//----- (0000000000074C6C) ----------------------------------------------------
void __fastcall EC_KEY_free(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x0
  void (__fastcall *v3)(__int64); // x8

  v1 = a1;
  if ( a1 && (unsigned int)CRYPTO_refcount_dec_and_test_zero((int *)(a1 + 32)) )
  {
    v2 = *(_QWORD *)(v1 + 40);
    if ( v2 )
    {
      v3 = *(void (__fastcall **)(__int64))(v2 + 24);
      if ( v3 )
      {
        v3(v1);
        v2 = *(_QWORD *)(v1 + 40);
      }
      std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(v2);
    }
    EC_GROUP_free(*(_QWORD *)v1);
    EC_POINT_free(*(_QWORD *)(v1 + 8));
    BN_clear_free(*(void ***)(v1 + 16));
    CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_1071F0, v1, (unsigned __int64 **)(v1 + 48));
    OPENSSL_cleanse((void *)v1, 0x38uLL);
    free((void *)v1);
  }
}
// 34D44: using guessed type __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(_QWORD);

//----- (0000000000074D00) ----------------------------------------------------
__int64 __fastcall EC_KEY_copy(__int64 *a1, _QWORD *a2)
{
  _QWORD **v2; // x20
  __int64 v3; // x19
  _QWORD *v4; // x0
  _QWORD *v5; // x0
  __int64 v6; // x1
  _QWORD *v7; // x0
  _QWORD *v8; // x0

  v2 = (_QWORD **)a2;
  v3 = (__int64)a1;
  if ( !a1 || !a2 )
  {
    ERR_put_error(15, 0LL, 67, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 162);
    return 0LL;
  }
  if ( *a2 )
  {
    EC_GROUP_free(*a1);
    v4 = EC_GROUP_dup((_QWORD **)*v2);
    *(_QWORD *)v3 = v4;
    if ( !v4 )
      return 0LL;
  }
  if ( v2[1] )
  {
    if ( *v2 )
    {
      EC_POINT_free(*(_QWORD *)(v3 + 8));
      v5 = EC_POINT_dup(v2[1], (_QWORD **)*v2);
      *(_QWORD *)(v3 + 8) = v5;
      if ( !v5 )
        return 0LL;
    }
  }
  v6 = (__int64)v2[2];
  if ( !v6 )
    goto LABEL_13;
  v7 = *(_QWORD **)(v3 + 16);
  if ( !v7 )
  {
    v7 = BN_new();
    *(_QWORD *)(v3 + 16) = v7;
    if ( !v7 )
      return 0LL;
    v6 = (__int64)v2[2];
  }
  if ( !BN_copy((__int64)v7, v6) )
    return 0LL;
LABEL_13:
  if ( v2[5] )
  {
    std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(*(_QWORD *)(v3 + 40));
    v8 = v2[5];
    *(_QWORD *)(v3 + 40) = v8;
    std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(v8);
  }
  CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_1071F0, v3, (unsigned __int64 **)(v3 + 48));
  if ( !(unsigned int)CRYPTO_dup_ex_data((pthread_rwlock_t *)&unk_1071F0, (unsigned __int64 **)(v3 + 48), v2 + 6) )
    return 0LL;
  *(_DWORD *)(v3 + 24) = *((_DWORD *)v2 + 6);
  *(_DWORD *)(v3 + 28) = *((_DWORD *)v2 + 7);
  return v3;
}
// 34D44: using guessed type __int64 __fastcall std::__1::basic_streambuf<char,std::__1::char_traits<char>>::setbuf(_QWORD);

//----- (0000000000074E24) ----------------------------------------------------
__int64 __fastcall EC_KEY_dup(_QWORD *a1)
{
  _QWORD *v1; // x20
  __int64 *v2; // x0
  __int64 v3; // x19

  v1 = a1;
  v2 = EC_KEY_new_method(0LL);
  v3 = (__int64)v2;
  if ( v2 && !EC_KEY_copy(v2, v1) )
  {
    EC_KEY_free(v3);
    v3 = 0LL;
  }
  return v3;
}

//----- (0000000000074E70) ----------------------------------------------------
signed __int64 __fastcall EC_KEY_up_ref(__int64 a1)
{
  CRYPTO_refcount_inc((_DWORD *)(a1 + 32));
  return 1LL;
}

//----- (0000000000074E8C) ----------------------------------------------------
__int64 __fastcall EC_KEY_is_opaque(__int64 a1)
{
  __int64 v1; // x8
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 40);
  if ( v1 )
    result = *(_BYTE *)(v1 + 56) & 1;
  else
    result = 0LL;
  return result;
}

//----- (0000000000074EA8) ----------------------------------------------------
__int64 __fastcall EC_KEY_set_group(__int64 *a1, _QWORD **a2)
{
  __int64 *v2; // x20
  _QWORD **v3; // x19
  __int64 result; // x0
  __int64 v5; // x20
  __int64 v6; // x0

  v2 = a1;
  v3 = a2;
  EC_GROUP_free(*a1);
  result = (__int64)EC_GROUP_dup(v3);
  *v2 = result;
  if ( result )
  {
    v5 = v2[2];
    result = 1;
    if ( v5 )
    {
      v6 = EC_GROUP_get0_order((__int64)v3);
      if ( !(BN_cmp(v5, v6) & 0x80000000) )
        result = 0;
    }
  }
  return result;
}

//----- (0000000000074F0C) ----------------------------------------------------
bool __fastcall EC_KEY_set_private_key(__int64 *a1, signed int *a2)
{
  __int64 *v2; // x19
  __int64 v3; // x0
  signed int *v4; // x20
  __int64 v5; // x0
  _BOOL8 result; // x0
  signed int *v7; // x0

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  if ( !v3 || (v5 = EC_GROUP_get0_order(v3), BN_cmp((__int64)v4, v5) & 0x80000000) )
  {
    BN_clear_free((void **)v2[2]);
    v7 = BN_dup(v4);
    v2[2] = (__int64)v7;
    result = v7 != 0LL;
  }
  else
  {
    ERR_put_error(15, 0LL, 125, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 262);
    result = 0LL;
  }
  return result;
}

//----- (0000000000074F88) ----------------------------------------------------
bool __fastcall EC_KEY_set_public_key(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x19
  _QWORD *v3; // x20
  _QWORD *v4; // x0

  v2 = a1;
  v3 = a2;
  EC_POINT_free(*(_QWORD *)(a1 + 8));
  v4 = EC_POINT_dup(v3, *(_QWORD **)v2);
  *(_QWORD *)(v2 + 8) = v4;
  return v4 != 0LL;
}

//----- (0000000000074FCC) ----------------------------------------------------
__int64 __fastcall EC_KEY_set_enc_flags(__int64 result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

//----- (0000000000074FD4) ----------------------------------------------------
__int64 __fastcall EC_KEY_get_conv_form(__int64 a1)
{
  return *(unsigned int *)(a1 + 28);
}

//----- (0000000000074FDC) ----------------------------------------------------
__int64 __fastcall EC_KEY_set_conv_form(__int64 result, int a2)
{
  *(_DWORD *)(result + 28) = a2;
  return result;
}

//----- (0000000000074FE4) ----------------------------------------------------
__int64 __fastcall EC_KEY_check_key(__int64 *a1)
{
  __int64 *v1; // x21
  _QWORD *v2; // x0
  _QWORD *v3; // x1
  unsigned int v4; // w21
  _DWORD *v5; // x19
  _QWORD *v6; // x20
  __int64 v7; // x0
  int v8; // w2
  __int16 v9; // w4
  int v11; // w2
  __int16 v12; // w4

  v1 = a1;
  if ( a1 )
  {
    v2 = (_QWORD *)*a1;
    if ( *v1 )
    {
      v3 = (_QWORD *)v1[1];
      if ( v3 )
      {
        if ( EC_POINT_is_at_infinity(v2, v3) )
        {
          ERR_put_error(15, 0LL, 119, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 305);
          v4 = 0;
          v5 = 0LL;
        }
        else
        {
          v5 = BN_CTX_new();
          if ( v5 )
          {
            if ( (unsigned int)EC_POINT_is_on_curve((_QWORD *)*v1, (_QWORD *)v1[1], (__int64)v5) )
            {
              v6 = (_QWORD *)v1[2];
              if ( !v6 )
              {
                v4 = 1;
                goto LABEL_16;
              }
              v7 = EC_GROUP_get0_order(*v1);
              if ( BN_cmp((__int64)v6, v7) & 0x80000000 )
              {
                v6 = EC_POINT_new((_QWORD *)*v1);
                if ( v6 && (unsigned int)EC_POINT_mul((__int64 *)*v1, v6, v1[2], 0LL, 0LL) )
                {
                  if ( !(unsigned int)EC_POINT_cmp((_QWORD *)*v1, v6, (_QWORD *)v1[1], (__int64)v5) )
                  {
                    v4 = 1;
                    goto LABEL_16;
                  }
                  v11 = 113;
                  v12 = 336;
                }
                else
                {
                  v11 = 15;
                  v12 = 332;
                }
                ERR_put_error(15, 0LL, v11, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", v12);
                v4 = 0;
LABEL_16:
                BN_CTX_free((__int64)v5);
                EC_POINT_free((__int64)v6);
                return v4;
              }
              v8 = 125;
              v9 = 326;
            }
            else
            {
              v8 = 120;
              v9 = 317;
            }
            ERR_put_error(15, 0LL, v8, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", v9);
          }
          v4 = 0;
        }
        v6 = 0LL;
        goto LABEL_16;
      }
    }
  }
  ERR_put_error(15, 0LL, 67, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 300);
  return 0;
}

//----- (000000000007518C) ----------------------------------------------------
__int64 __fastcall EC_KEY_set_public_key_affine_coordinates(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x22
  __int64 v4; // x23
  __int64 *v5; // x21
  _DWORD *v6; // x0
  _DWORD *v7; // x19
  _QWORD *v8; // x20
  _QWORD *v9; // x26
  _QWORD *v10; // x0
  __int64 v11; // x24
  _BOOL4 v12; // w25
  _QWORD *v14; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 || !a3 || !a2 || !*a1 )
  {
    ERR_put_error(15, 0LL, 67, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 356);
    goto LABEL_17;
  }
  v6 = BN_CTX_new();
  v7 = v6;
  if ( !v6 )
LABEL_17:
    return 0;
  BN_CTX_start((__int64)v6);
  v8 = EC_POINT_new((_QWORD *)*v5);
  if ( v8 )
  {
    v9 = BN_CTX_get((__int64)v7);
    v10 = BN_CTX_get((__int64)v7);
    v11 = (__int64)v10;
    v12 = 0;
    if ( !v9 || !v10 )
      goto LABEL_15;
    if ( (unsigned int)EC_POINT_set_affine_coordinates_GFp((_QWORD *)*v5, v8, v4, v3, v7)
      && (unsigned int)EC_POINT_get_affine_coordinates_GFp(*v5, v8) )
    {
      if ( (unsigned int)BN_cmp(v4, (__int64)v9) || (unsigned int)BN_cmp(v3, v11) )
      {
        ERR_put_error(15, 0LL, 101, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 387);
      }
      else
      {
        EC_POINT_free(v5[1]);
        v14 = EC_POINT_dup(v8, (_QWORD *)*v5);
        v5[1] = (__int64)v14;
        if ( v14 )
        {
          v12 = (unsigned __int64)EC_KEY_check_key(v5) != 0;
          goto LABEL_15;
        }
      }
    }
  }
  v12 = 0;
LABEL_15:
  BN_CTX_end((__int64)v7);
  BN_CTX_free((__int64)v7);
  EC_POINT_free((__int64)v8);
  return (unsigned int)v12;
}

//----- (000000000007530C) ----------------------------------------------------
__int64 __fastcall EC_KEY_generate_key(__int64 *a1)
{
  __int64 *v1; // x19
  __int64 v2; // x0
  _QWORD *v3; // x20
  __int64 v4; // x0
  _QWORD *v5; // x21
  unsigned int v6; // w22

  v1 = a1;
  if ( !a1 || (v2 = *a1, !*v1) )
  {
    ERR_put_error(15, 0LL, 67, (__int64)"external/boringssl/src/crypto/ec/ec_key.c", 414);
    return 0;
  }
  v3 = (_QWORD *)v1[2];
  if ( !v3 )
  {
    v3 = BN_new();
    if ( !v3 )
      goto LABEL_13;
    v2 = *v1;
  }
  v4 = EC_GROUP_get0_order(v2);
  if ( !(unsigned int)BN_rand_range_ex((__int64)v3, 1uLL, v4) )
  {
LABEL_13:
    v6 = 0;
    v5 = 0LL;
    if ( v1[1] )
      goto LABEL_17;
    goto LABEL_16;
  }
  v5 = (_QWORD *)v1[1];
  if ( (v5 || (v5 = EC_POINT_new((_QWORD *)*v1)) != 0LL)
    && (unsigned int)EC_POINT_mul((__int64 *)*v1, v5, (__int64)v3, 0LL, 0LL) )
  {
    v6 = 1;
    v1[1] = (__int64)v5;
    v1[2] = (__int64)v3;
    if ( v1[1] )
      goto LABEL_17;
  }
  else
  {
    v6 = 0;
    if ( v1[1] )
      goto LABEL_17;
  }
LABEL_16:
  EC_POINT_free((__int64)v5);
LABEL_17:
  if ( !v1[2] )
    BN_free(v3);
  return v6;
}

//----- (0000000000075418) ----------------------------------------------------
signed __int64 __fastcall EC_KEY_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // x19
  int v6; // w0
  __int64 v7; // x9
  signed __int64 result; // x0
  unsigned int v9; // [xsp+4h] [xbp-1Ch]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = *(_QWORD *)(v5 + 40);
  v6 = CRYPTO_get_ex_new_index((pthread_rwlock_t *)&unk_1071F0, &v9, a1, a2, a4, a5);
  v7 = *(_QWORD *)(v5 + 40);
  if ( v6 )
    result = v9;
  else
    result = 1LL;
  return result;
}

//----- (0000000000075494) ----------------------------------------------------
signed __int64 __fastcall EC_KEY_set_ex_data(__int64 a1, int a2, __int64 a3)
{
  return CRYPTO_set_ex_data((unsigned __int64 **)(a1 + 48), a2, a3);
}

//----- (000000000007549C) ----------------------------------------------------
unsigned __int64 *__fastcall EC_KEY_get_ex_data(__int64 a1, int a2)
{
  return CRYPTO_get_ex_data((unsigned __int64 **)(a1 + 48), a2);
}

//----- (00000000000754A4) ----------------------------------------------------
signed __int64 __fastcall sub_754A4(__int64 a1)
{
  __int64 v1; // x19
  signed __int64 result; // x0

  v1 = a1;
  result = sub_82314(a1);
  *(_QWORD *)(v1 + 136) = 0LL;
  return result;
}

//----- (00000000000754C8) ----------------------------------------------------
void __fastcall sub_754C8(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  BN_MONT_CTX_free(*(_DWORD **)(a1 + 136));
  *(_QWORD *)(v1 + 136) = 0LL;
  sub_82358((_DWORD *)v1);
}

//----- (00000000000754F4) ----------------------------------------------------
signed __int64 __fastcall sub_754F4(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  signed __int64 result; // x0

  v2 = a1;
  v3 = a2;
  BN_MONT_CTX_free(*(_DWORD **)(a1 + 136));
  *(_QWORD *)(v2 + 136) = 0LL;
  result = sub_82390(v2, v3);
  if ( (_DWORD)result )
  {
    if ( !*(_QWORD *)(v3 + 136) )
      goto LABEL_9;
    result = (signed __int64)BN_MONT_CTX_new();
    *(_QWORD *)(v2 + 136) = result;
    if ( !result )
      return result;
    if ( !BN_MONT_CTX_copy(result, *(_QWORD *)(v3 + 136)) )
    {
      BN_MONT_CTX_free(*(_DWORD **)(v2 + 136));
      result = 0LL;
      *(_QWORD *)(v2 + 136) = 0LL;
    }
    else
    {
LABEL_9:
      result = 1LL;
    }
  }
  return result;
}

//----- (0000000000075568) ----------------------------------------------------
__int64 __fastcall sub_75568(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  __int64 v5; // x20
  _DWORD *v6; // x24
  __int64 v7; // x22
  __int64 v8; // x23
  __int64 v9; // x25
  __int64 v10; // x19
  _QWORD *v11; // x0
  _DWORD *v12; // x21
  unsigned int v13; // w22

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  BN_MONT_CTX_free(*(_DWORD **)(a1 + 136));
  v10 = 0LL;
  *(_QWORD *)(v5 + 136) = 0LL;
  if ( v6 || (v6 = BN_CTX_new(), (v10 = (__int64)v6) != 0) )
  {
    v11 = BN_MONT_CTX_new();
    v12 = v11;
    if ( v11 )
    {
      if ( BN_MONT_CTX_set((__int64)v11, v9) )
      {
        *(_QWORD *)(v5 + 136) = v12;
        v13 = sub_823FC((_DWORD *)v5, v9, v8, v7, v6);
        if ( v13 )
        {
          v12 = 0LL;
        }
        else
        {
          BN_MONT_CTX_free(*(_DWORD **)(v5 + 136));
          v12 = 0LL;
          *(_QWORD *)(v5 + 136) = 0LL;
        }
      }
      else
      {
        ERR_put_error(15, 0LL, 3, (__int64)"external/boringssl/src/crypto/ec/ec_montgomery.c", 139);
        v13 = 0;
      }
    }
    else
    {
      v13 = 0;
    }
    BN_CTX_free(v10);
    BN_MONT_CTX_free(v12);
  }
  else
  {
    v13 = 0;
  }
  return v13;
}

//----- (0000000000075674) ----------------------------------------------------
__int64 __fastcall sub_75674(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x8

  v5 = *(_QWORD *)(a1 + 136);
  if ( v5 )
    return BN_mod_mul_montgomery(a2, a3, a4, v5, a5);
  ERR_put_error(15, 0LL, 117, (__int64)"external/boringssl/src/crypto/ec/ec_montgomery.c", 162);
  return 0LL;
}

//----- (00000000000756C0) ----------------------------------------------------
__int64 __fastcall sub_756C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x3

  v4 = a4;
  v5 = *(_QWORD *)(a1 + 136);
  if ( v5 )
    return BN_mod_mul_montgomery(a2, a3, a3, v5, v4);
  ERR_put_error(15, 0LL, 117, (__int64)"external/boringssl/src/crypto/ec/ec_montgomery.c", 172);
  return 0LL;
}

//----- (000000000007570C) ----------------------------------------------------
__int64 __fastcall sub_7570C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x8

  v4 = *(_QWORD *)(a1 + 136);
  if ( v4 )
    return BN_to_montgomery(a2, a3, v4, a4);
  ERR_put_error(15, 0LL, 117, (__int64)"external/boringssl/src/crypto/ec/ec_montgomery.c", 182);
  return 0LL;
}

//----- (0000000000075754) ----------------------------------------------------
__int64 __fastcall sub_75754(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x8

  v4 = *(_QWORD *)(a1 + 136);
  if ( v4 )
    return BN_from_montgomery(a2, a3, v4, a4);
  ERR_put_error(15, 0LL, 117, (__int64)"external/boringssl/src/crypto/ec/ec_montgomery.c", 192);
  return 0LL;
}

//----- (000000000007579C) ----------------------------------------------------
__int64 __fastcall sub_7579C(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x19
  __int64 v6; // x21
  __int64 v7; // x24
  _QWORD *v8; // x22
  _QWORD *v9; // x23
  unsigned int v10; // w28
  _DWORD *v11; // x20
  _QWORD *v12; // x26
  _QWORD *v13; // x27
  _QWORD *v14; // x0
  __int64 v15; // x28

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( !EC_POINT_is_at_infinity(a1, a2) )
  {
    if ( v5 )
    {
      v11 = 0LL;
    }
    else
    {
      v11 = BN_CTX_new();
      v5 = (__int64)v11;
      if ( !v11 )
        return 0;
    }
    BN_CTX_start(v5);
    if ( (unsigned int)BN_cmp((__int64)(v8 + 7), (__int64)(v9 + 18)) )
    {
      v12 = BN_CTX_get(v5);
      v13 = BN_CTX_get(v5);
      v14 = BN_CTX_get(v5);
      v10 = 0;
      if ( !v12 || !v13 || !v14 )
        goto LABEL_28;
      v15 = (__int64)v14;
      if ( !(unsigned int)BN_from_montgomery((__int64)v12, (__int64)(v8 + 7), v9[17], v5)
        || !(unsigned int)BN_from_montgomery((__int64)v12, (__int64)v12, v9[17], v5)
        || !(unsigned int)sub_69FB8((__int64)v12, (__int64)v12, (__int64)(v9 + 7), v5, v9[17])
        || !(unsigned int)BN_mod_mul_montgomery((__int64)v13, (__int64)v12, (__int64)v12, v9[17], v5)
        || !(unsigned int)BN_from_montgomery((__int64)v13, (__int64)v13, v9[17], v5)
        || v7 && !(unsigned int)BN_mod_mul_montgomery(v7, (__int64)(v8 + 1), (__int64)v13, v9[17], v5)
        || v6
        && (!(unsigned int)BN_mod_mul_montgomery(v15, (__int64)v13, (__int64)v12, v9[17], v5)
         || !(unsigned int)BN_mod_mul_montgomery(v6, (__int64)(v8 + 4), v15, v9[17], v5)) )
      {
        goto LABEL_27;
      }
    }
    else if ( v7 && !(unsigned int)BN_from_montgomery(v7, (__int64)(v8 + 1), v9[17], v5)
           || v6 && !(unsigned int)BN_from_montgomery(v6, (__int64)(v8 + 4), v9[17], v5) )
    {
LABEL_27:
      v10 = 0;
      goto LABEL_28;
    }
    v10 = 1;
LABEL_28:
    BN_CTX_end(v5);
    BN_CTX_free((__int64)v11);
    return v10;
  }
  ERR_put_error(15, 0LL, 119, (__int64)"external/boringssl/src/crypto/ec/ec_montgomery.c", 204);
  return 0;
}

//----- (00000000000759BC) ----------------------------------------------------
__int64 __fastcall EC_POINT_oct2point(_QWORD *a1, _QWORD *a2, unsigned __int8 *a3, __int64 a4, _DWORD *a5)
{
  _QWORD *v5; // x21
  _DWORD *v6; // x22
  _DWORD *v7; // x19
  __int64 v8; // x20
  unsigned __int8 *v9; // x24
  int v10; // w2
  __int16 v11; // w4
  unsigned int v12; // w28
  int v14; // w27
  int v15; // w26
  __int64 v16; // x25
  _DWORD *v17; // x0
  _QWORD *v18; // x20
  _QWORD *v19; // x0
  unsigned __int8 *v20; // x24
  __int64 v21; // x28
  int v22; // w2
  __int16 v23; // w4
  __int64 v24; // [xsp+8h] [xbp-58h]

  v5 = a2;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  if ( *a1 == *a2 )
  {
    if ( !a4 )
    {
      v10 = 100;
      v11 = 183;
      goto LABEL_3;
    }
    v14 = *a3;
    v15 = v14 & 0xFE;
    if ( v15 != 4 && v15 != 2 || v14 == 5 )
    {
      v10 = 109;
      v11 = 192;
      goto LABEL_3;
    }
    v16 = (unsigned int)BN_num_bytes((__int64)(a1 + 7));
    if ( (v16 << (v15 != 2)) + 1 != v8 )
    {
      v10 = 109;
      v11 = 201;
      goto LABEL_3;
    }
    if ( v7 )
    {
      v17 = 0LL;
    }
    else
    {
      v17 = BN_CTX_new();
      v7 = v17;
      if ( !v17 )
        return 0;
    }
    v24 = (__int64)v17;
    BN_CTX_start((__int64)v7);
    v18 = BN_CTX_get((__int64)v7);
    v19 = BN_CTX_get((__int64)v7);
    v12 = 0;
    if ( !v18 || !v19 )
    {
LABEL_24:
      BN_CTX_end((__int64)v7);
      BN_CTX_free(v24);
      return v12;
    }
    v20 = v9 + 1;
    v21 = (__int64)v19;
    if ( !BN_bin2bn(v20, v16, (__int64)v18) )
    {
LABEL_23:
      v12 = 0;
      goto LABEL_24;
    }
    if ( !(BN_ucmp((__int64)v18, (__int64)(v6 + 14)) & 0x80000000) )
    {
      v22 = 109;
      v23 = 223;
LABEL_22:
      ERR_put_error(15, 0LL, v22, (__int64)"external/boringssl/src/crypto/ec/oct.c", v23);
      goto LABEL_23;
    }
    if ( v15 == 2 )
    {
      if ( *(_QWORD *)v6 != *v5 )
      {
        v22 = 106;
        v23 = 412;
        goto LABEL_22;
      }
      if ( !(unsigned int)sub_75F58(v6, v5, (__int64)v18, v14 & 1, v7) )
        goto LABEL_23;
    }
    else
    {
      if ( !BN_bin2bn(&v20[v16], v16, v21) )
        goto LABEL_23;
      if ( !(BN_ucmp(v21, (__int64)(v6 + 14)) & 0x80000000) )
      {
        v22 = 109;
        v23 = 236;
        goto LABEL_22;
      }
      if ( !(unsigned int)EC_POINT_set_affine_coordinates_GFp(v6, v5, (__int64)v18, v21, v7) )
        goto LABEL_23;
    }
    v12 = 1;
    goto LABEL_24;
  }
  v10 = 106;
  v11 = 256;
LABEL_3:
  ERR_put_error(15, 0LL, v10, (__int64)"external/boringssl/src/crypto/ec/oct.c", v11);
  return 0;
}

//----- (0000000000075C30) ----------------------------------------------------
unsigned __int64 __fastcall EC_POINT_point2oct(_QWORD *a1, _QWORD *a2, int a3, char *a4, unsigned __int64 a5, __int64 a6)
{
  _QWORD *v6; // x25
  __int64 v7; // x26
  __int64 v8; // x19
  unsigned __int64 v9; // x20
  char *v10; // x22
  int v11; // w23
  int v12; // w2
  __int16 v13; // w4
  _DWORD *v14; // x20
  unsigned __int64 v15; // x21
  size_t v17; // x24
  _QWORD *v18; // x28
  _QWORD *v19; // x27
  char v20; // w8
  signed __int64 v21; // x25
  __int16 v22; // w4

  v6 = a2;
  v7 = (__int64)a1;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  if ( *a1 == *a2 )
  {
    if ( a3 != 2 && a3 != 4 )
    {
      v12 = 111;
      v13 = 89;
      goto LABEL_8;
    }
    if ( EC_POINT_is_at_infinity(a1, a2) )
    {
      v12 = 119;
      v13 = 94;
LABEL_8:
      ERR_put_error(15, 0LL, v12, (__int64)"external/boringssl/src/crypto/ec/oct.c", v13);
      v14 = 0LL;
LABEL_9:
      BN_CTX_free((__int64)v14);
      return 0LL;
    }
    v17 = (unsigned int)BN_num_bytes(v7 + 56);
    v15 = (v17 << (v11 != 2)) + 1;
    if ( !v10 )
    {
      v14 = 0LL;
LABEL_16:
      BN_CTX_free((__int64)v14);
      return v15;
    }
    if ( v15 > v9 )
    {
      v12 = 100;
      v13 = 106;
      goto LABEL_8;
    }
    if ( v8 )
    {
      v14 = 0LL;
    }
    else
    {
      v14 = BN_CTX_new();
      v8 = (__int64)v14;
      if ( !v14 )
        goto LABEL_9;
    }
    BN_CTX_start(v8);
    v18 = BN_CTX_get(v8);
    v19 = BN_CTX_get(v8);
    if ( !v19 || !(unsigned int)EC_POINT_get_affine_coordinates_GFp(v7, v6) )
    {
LABEL_36:
      BN_CTX_end(v8);
      goto LABEL_9;
    }
    v20 = v11;
    if ( v11 == 2 )
    {
      if ( (unsigned int)BN_is_odd((__int64)v19) )
        v20 = 3;
      else
        v20 = 2;
    }
    *v10 = v20;
    if ( (unsigned int)BN_bn2bin_padded(v10 + 1, v17, (__int64)v18) )
    {
      v21 = v17 + 1;
      if ( v11 != 4 )
      {
LABEL_30:
        if ( v21 == v15 )
        {
          BN_CTX_end(v8);
          goto LABEL_16;
        }
        v22 = 152;
        goto LABEL_35;
      }
      if ( (unsigned int)BN_bn2bin_padded(&v10[v21], v17, (__int64)v19) )
      {
        v21 += v17;
        goto LABEL_30;
      }
      v22 = 145;
    }
    else
    {
      v22 = 138;
    }
LABEL_35:
    ERR_put_error(15, 0LL, 68, (__int64)"external/boringssl/src/crypto/ec/oct.c", v22);
    goto LABEL_36;
  }
  ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/oct.c", 266);
  return 0LL;
}

//----- (0000000000075E8C) ----------------------------------------------------
signed __int64 __fastcall EC_POINT_point2cbb(__int64 *a1, _QWORD *a2, _QWORD *a3, int a4, __int64 a5)
{
  __int64 v5; // x19
  int v6; // w20
  _QWORD *v7; // x21
  _QWORD *v8; // x22
  __int64 *v9; // x24
  unsigned __int64 v10; // x23
  signed __int64 result; // x0
  char *v12; // [xsp+0h] [xbp-40h]
  __int64 v13; // [xsp+8h] [xbp-38h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = EC_POINT_point2oct(a2, a3, a4, 0LL, 0LL, a5);
  if ( v10 )
  {
    result = CBB_add_space(v9, &v12, v10);
    if ( (_DWORD)result )
      result = EC_POINT_point2oct(v8, v7, v6, v12, v10, v5) == v10;
  }
  else
  {
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000075F58) ----------------------------------------------------
__int64 __fastcall sub_75F58(_DWORD *a1, _QWORD *a2, __int64 a3, int a4, _DWORD *a5)
{
  __int64 v5; // x21
  _DWORD *v6; // x23
  _DWORD *v7; // x19
  int v8; // w25
  _QWORD *v9; // x22
  _BOOL4 v10; // w21
  _DWORD *v12; // x20
  _BOOL4 v13; // w28
  _QWORD *v14; // x26
  _QWORD *v15; // x27
  void **v16; // x25
  unsigned int (__fastcall *v17)(_DWORD *, _QWORD *, _DWORD *, _DWORD *); // x8
  __int64 v18; // x2
  unsigned int (__fastcall *v19)(_DWORD *, _QWORD *, __int64, _DWORD *); // x8
  __int64 v20; // x0
  __int64 v21; // x1
  int v22; // w2
  __int16 v23; // w4

  v5 = a3;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a2;
  if ( !BN_is_negative(a3) && BN_cmp(v5, (__int64)(v6 + 14)) & 0x80000000 )
  {
    ERR_clear_error();
    if ( v7 )
    {
      v12 = 0LL;
    }
    else
    {
      v12 = BN_CTX_new();
      v7 = v12;
      if ( !v12 )
        goto LABEL_4;
    }
    v13 = v8 != 0;
    BN_CTX_start((__int64)v7);
    v14 = BN_CTX_get((__int64)v7);
    v15 = BN_CTX_get((__int64)v7);
    v16 = (void **)BN_CTX_get((__int64)v7);
    if ( !v16 )
      goto LABEL_43;
    if ( *(_QWORD *)(*(_QWORD *)v6 + 72LL) )
    {
      if ( !(unsigned int)BN_mod_sqr((__int64)v15, v5, (__int64)(v6 + 14), (__int64)v7)
        || !(unsigned int)BN_mod_mul((__int64)v14, (__int64)v15, v5, (__int64)(v6 + 14), (__int64)v7) )
      {
        goto LABEL_43;
      }
    }
    else if ( !(*(unsigned int (__fastcall **)(_DWORD *, _QWORD *, __int64, _DWORD *))(*(_QWORD *)v6 + 56LL))(
                 v6,
                 v15,
                 v5,
                 v7)
           || !(*(unsigned int (__fastcall **)(_DWORD *, _QWORD *, _QWORD *, __int64, _DWORD *))(*(_QWORD *)v6 + 48LL))(
                 v6,
                 v14,
                 v15,
                 v5,
                 v7) )
    {
      goto LABEL_43;
    }
    if ( v6[32] )
    {
      if ( !(unsigned int)BN_mod_lshift1_quick((__int64)v15, v5, (__int64)(v6 + 14))
        || !(unsigned int)BN_mod_add_quick((__int64)v15, (__int64)v15, v5, (__int64)(v6 + 14))
        || !(unsigned int)BN_mod_sub_quick((__int64)v14, (__int64)v14, (__int64)v15, (__int64)(v6 + 14)) )
      {
        goto LABEL_43;
      }
    }
    else
    {
      v17 = *(unsigned int (__fastcall **)(_DWORD *, _QWORD *, _DWORD *, _DWORD *))(*(_QWORD *)v6 + 72LL);
      if ( v17 )
      {
        if ( !v17(v6, v15, v6 + 20, v7)
          || !(unsigned int)BN_mod_mul((__int64)v15, (__int64)v15, v5, (__int64)(v6 + 14), (__int64)v7) )
        {
          goto LABEL_43;
        }
      }
      else if ( !(*(unsigned int (__fastcall **)(_DWORD *, _QWORD *, _DWORD *, __int64, _DWORD *))(*(_QWORD *)v6 + 48LL))(
                   v6,
                   v15,
                   v6 + 20,
                   v5,
                   v7) )
      {
        goto LABEL_43;
      }
      if ( !(unsigned int)BN_mod_add_quick((__int64)v14, (__int64)v14, (__int64)v15, (__int64)(v6 + 14)) )
        goto LABEL_43;
    }
    v18 = (__int64)(v6 + 26);
    v19 = *(unsigned int (__fastcall **)(_DWORD *, _QWORD *, __int64, _DWORD *))(*(_QWORD *)v6 + 72LL);
    if ( v19 )
    {
      if ( !v19(v6, v15, v18, v7) )
        goto LABEL_43;
      v20 = (__int64)v14;
      v21 = (__int64)v14;
      v18 = (__int64)v15;
    }
    else
    {
      v20 = (__int64)v14;
      v21 = (__int64)v14;
    }
    if ( (unsigned int)BN_mod_add_quick(v20, v21, v18, (__int64)(v6 + 14)) )
    {
      if ( BN_mod_sqrt(v16, (__int64)v14, (__int64)(v6 + 14), (__int64)v7) )
      {
        if ( v13 == (unsigned int)BN_is_odd((__int64)v16) )
        {
LABEL_34:
          if ( v13 == (unsigned int)BN_is_odd((__int64)v16) )
          {
            v10 = (unsigned __int64)EC_POINT_set_affine_coordinates_GFp(v6, v9, v5, (__int64)v16, v7) != 0;
LABEL_44:
            BN_CTX_end((__int64)v7);
            BN_CTX_free((__int64)v12);
            return (unsigned int)v10;
          }
          v22 = 68;
          v23 = 392;
          goto LABEL_42;
        }
        if ( !BN_is_zero((__int64)v16) )
        {
          if ( !(unsigned int)BN_usub((__int64)v16, (__int64)(v6 + 14), (__int64)v16) )
            goto LABEL_43;
          goto LABEL_34;
        }
        v22 = 108;
        v23 = 384;
      }
      else if ( (ERR_peek_last_error() & 0xFF000FFF) == 50331758 )
      {
        ERR_clear_error();
        v22 = 107;
        v23 = 375;
      }
      else
      {
        v22 = 3;
        v23 = 377;
      }
LABEL_42:
      ERR_put_error(15, 0LL, v22, (__int64)"external/boringssl/src/crypto/ec/oct.c", v23);
    }
LABEL_43:
    v10 = 0;
    goto LABEL_44;
  }
  ERR_put_error(15, 0LL, 107, (__int64)"external/boringssl/src/crypto/ec/oct.c", 287);
LABEL_4:
  return 0;
}

//----- (00000000000762F0) ----------------------------------------------------
__int64 __fastcall EC_POINT_set_compressed_coordinates_GFp(_DWORD *a1, _QWORD *a2, __int64 a3, int a4, _DWORD *a5)
{
  if ( *(_QWORD *)a1 == *a2 )
    return sub_75F58(a1, a2, a3, a4, a5);
  ERR_put_error(15, 0LL, 106, (__int64)"external/boringssl/src/crypto/ec/oct.c", 412);
  return 0LL;
}

//----- (0000000000076334) ----------------------------------------------------
#error "76334: too complex function (funcsize=779)"

//----- (0000000000076F60) ----------------------------------------------------
#error "76F60: too complex function (funcsize=1170)"

//----- (00000000000781A8) ----------------------------------------------------
signed __int64 __fastcall sub_781A8(__int64 *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x19
  __int16 v4; // w4
  signed __int64 result; // x0
  unsigned __int64 v6; // x0
  unsigned __int64 v7; // x8
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // x10
  __int64 v11; // x12
  char *v12; // x9
  int8x16_t *v13; // x10
  unsigned __int64 v14; // x11
  int8x16_t v15; // q1
  int8x16_t v16; // q2
  signed __int64 v17; // x9
  char *v18; // x8
  char v19; // w11
  char v20[32]; // [xsp+8h] [xbp-58h]
  __int64 v21; // [xsp+28h] [xbp-38h]
  __int64 v22; // [xsp+30h] [xbp-30h]
  __int64 v23; // [xsp+38h] [xbp-28h]
  __int64 v24; // [xsp+40h] [xbp-20h]
  __int64 v25; // [xsp+48h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !BN_is_negative(a2) )
  {
    v23 = 0LL;
    v24 = 0LL;
    v21 = 0LL;
    v22 = 0LL;
    if ( (unsigned int)BN_num_bytes(v2) >= 0x21 )
    {
      v4 = 114;
      goto LABEL_5;
    }
    v6 = BN_bn2bin(v2, v20);
    if ( !v6 )
    {
      v8 = 0LL;
      v9 = 0LL;
      v10 = 0LL;
      v11 = 0LL;
LABEL_19:
      result = 1LL;
      *v3 = v11;
      v3[1] = 0LL;
      v3[2] = v10;
      v3[3] = 0LL;
      v3[4] = v9;
      v3[5] = 0LL;
      v3[6] = v8;
      v3[7] = 0LL;
      goto LABEL_6;
    }
    if ( v6 >= 0x20 )
    {
      v7 = v6 & 0xFFFFFFFFFFFFFFE0LL;
      if ( v6 & 0xFFFFFFFFFFFFFFE0LL )
      {
        v12 = &v20[v6 - 16];
        v13 = (int8x16_t *)&v23;
        v14 = v6 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v16 = *((int8x16_t *)v12 - 1);
          v15 = *(int8x16_t *)v12;
          v12 -= 32;
          v14 -= 32LL;
          v13[-1] = vqtbl1q_s8(v15, (int8x16_t)xmmword_D1120);
          *v13 = vqtbl1q_s8(v16, (int8x16_t)xmmword_D1120);
          v13 += 2;
        }
        while ( v14 );
        if ( v6 == v7 )
          goto LABEL_18;
      }
    }
    else
    {
      v7 = 0LL;
    }
    v17 = v6 - 1 - v7;
    v18 = (char *)&v21 + v7;
    do
    {
      v19 = v20[v17--];
      *v18++ = v19;
    }
    while ( v17 != -1 );
LABEL_18:
    v11 = v21;
    v10 = v22;
    v9 = v23;
    v8 = v24;
    goto LABEL_19;
  }
  v4 = 105;
LABEL_5:
  ERR_put_error(15, 0LL, 126, (__int64)"external/boringssl/src/crypto/ec/p256-64.c", v4);
  result = 0LL;
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v25;
  return result;
}
// D1120: using guessed type __int128 xmmword_D1120;
// 781A8: using guessed type char var_58[32];

//----- (0000000000078324) ----------------------------------------------------
#error "78324: too complex function (funcsize=5133)"

//----- (000000000007D358) ----------------------------------------------------
_QWORD *__fastcall sub_7D358(_QWORD *result, __int64 a2)
{
  unsigned __int64 v2; // xzr
  __int64 v3; // x8
  unsigned __int64 v4; // x11
  unsigned __int128 v5; // kr10_16
  unsigned __int64 v6; // x12
  unsigned __int64 v7; // x11
  unsigned __int128 v8; // kr30_16
  signed __int64 v9; // x12
  signed __int64 v10; // x14
  unsigned __int128 v11; // kr70_16
  signed __int64 v12; // x16
  signed __int64 v13; // x15
  unsigned __int8 v14; // cf
  unsigned __int64 v15; // x8
  __int64 v16; // x16
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x13
  unsigned __int64 v19; // x11
  signed __int64 v20; // x16
  unsigned __int64 v21; // x13
  unsigned __int64 v22; // x11
  signed __int64 v23; // x16
  signed __int64 v24; // x9
  signed __int64 v25; // x11
  signed __int64 v26; // x9
  signed __int64 v27; // x15
  signed __int64 v28; // x18
  signed __int64 v29; // x9
  signed __int64 v30; // x9
  unsigned __int64 v31; // kr90_8

  v3 = *(_QWORD *)(a2 + 32);
  v4 = (*(_OWORD *)(a2 + 48) + *(_QWORD *)(a2 + 40) + 0xFFFFFFFF00000000LL) >> 64;
  v5 = (unsigned __int64)(*(_QWORD *)(a2 + 48) + *(_QWORD *)(a2 + 40) - 0x100000000LL)
     - __PAIR__(-4294967296LL, v4)
     + (v4 << 32);
  v6 = (v4 >> 32) + *((_QWORD *)&v5 + 1);
  v7 = v6 + v4;
  v8 = (unsigned __int64)v5 - __PAIR__(0x400000000000LL, v6) + (v6 << 32);
  v9 = -(signed __int64)((v6 >> 32) + *((_QWORD *)&v8 + 1)) | ((signed __int64)((9223372032559808512LL
                                                                               - (v8 & 0x7FFFFFFFFFFFFFFFLL)) & v8) >> 63);
  v10 = *(_QWORD *)a2 + v7 - 1 - v9;
  v12 = (-2 - v10) & ((-2 - v10) << 32) & (((-2 - v10) & ((-2 - v10) << 32)) << 16);
  v11 = *(_OWORD *)(a2 + 16)
      + __PAIR__(0x400000000000LL, 0xFFFFFFFFLL)
      - __PAIR__(v7 >> 32, v7 << 32)
      - (unsigned int)v9
      + (unsigned __int64)((__PAIR__((*(_QWORD *)a2 + v7 >= 1) + ((*(_OWORD *)a2 + v7) >> 64), *(_QWORD *)a2 + v7 - 1)
                          - (unsigned __int64)v9) >> 64);
  v13 = v12 & (v12 << 8);
  v14 = __CFADD__(v3, *((_QWORD *)&v11 + 1));
  v15 = v3 + *((_QWORD *)&v11 + 1);
  v16 = v14;
  v14 = __CFADD__(v15, -70368744177664LL);
  v15 -= 0x400000000000LL;
  v17 = v8 - (v9 & 0xFFFFFFFF00000001LL) + v14 + v16;
  v18 = ((v17 ^ 0xFFFFFFFF00000001LL) - 1) & (((v17 ^ 0xFFFFFFFF00000001LL) - 1) << 32);
  v19 = ((v11 ^ 0xFFFFFFFF) - 1) & ((((unsigned __int64)v11 ^ 0xFFFFFFFF) - 1) << 32);
  v20 = (v15 - 1) & ((v15 - 1) << 32) & (((v15 - 1) & ((v15 - 1) << 32)) << 16);
  v21 = v18 & (v18 << 16) & ((v18 & (v18 << 16)) << 8);
  v22 = v19 & (v19 << 16) & ((v19 & (v19 << 16)) << 8);
  v23 = v20 & (v20 << 8) & 16 * (v20 & (v20 << 8));
  v24 = v21 & 16 * v21 & 4 * (v21 & 16 * v21);
  v25 = v22 & 16 * v22 & 4 * (v22 & 16 * v22);
  v26 = v24 & 2 * v24;
  v27 = v13 & 16 * v13 & 4 * (v13 & 16 * v13);
  v28 = (0x400000000000LL - (v2 < v15)) & (v26 >> 63);
  v29 = v23 & 4 * v23 & 2 * (v23 & 4 * v23) & v26;
  v30 = -(signed __int64)(v21 + ((unsigned __int64)v11 > 0xFFFFFFFF)) & (v29 >> 63) | v28 | -(signed __int64)(v15 - 1 + (v17 > 0xFFFFFFFF00000001LL)) | ((v27 & 2 * v27 & v25 & 2 * v25 & v29) >> 63);
  v31 = v11 - ((((unsigned __int64)v10 - __PAIR__((unsigned __int64)v10, v30)) >> 64) & 1);
  *result = v10 - v30;
  result[1] = v31 - (unsigned int)v30;
  result[2] = v15
            - ((((unsigned __int64)v11 - ((((unsigned __int64)v10 - __PAIR__((unsigned __int64)v10, v30)) >> 64) & 1)) >> 64) & 1)
            - (((v31 - __PAIR__(v31, (unsigned int)v30)) >> 64) & 1);
  result[3] = v17
            - (((v15
               - ((((unsigned __int64)v11 - ((((unsigned __int64)v10 - __PAIR__((unsigned __int64)v10, v30)) >> 64) & 1)) >> 64) & 1)) >> 64) & 1)
            - (v30 & 0xFFFFFFFF00000001LL)
            - (((v15
               - ((((unsigned __int64)v11 - ((((unsigned __int64)v10 - __PAIR__((unsigned __int64)v10, v30)) >> 64) & 1)) >> 64) & 1)
               - __PAIR__(
                   ((v31 - __PAIR__(v31, (unsigned int)v30)) >> 64) & 1,
                   ((v31 - __PAIR__(v31, (unsigned int)v30)) >> 64) & 1)) >> 64) & 1);
  return result;
}

//----- (000000000007D534) ----------------------------------------------------
__int64 __fastcall sub_7D534(__int64 a1, __int64 *a2)
{
  unsigned __int64 v2; // x19
  __int64 v3; // x11
  __int64 result; // x0
  char v5; // [xsp+8h] [xbp-58h]
  char v6; // [xsp+9h] [xbp-57h]
  char v7; // [xsp+Ah] [xbp-56h]
  char v8; // [xsp+Bh] [xbp-55h]
  char v9; // [xsp+Ch] [xbp-54h]
  char v10; // [xsp+Dh] [xbp-53h]
  char v11; // [xsp+Eh] [xbp-52h]
  char v12; // [xsp+Fh] [xbp-51h]
  char v13; // [xsp+10h] [xbp-50h]
  char v14; // [xsp+11h] [xbp-4Fh]
  char v15; // [xsp+12h] [xbp-4Eh]
  char v16; // [xsp+13h] [xbp-4Dh]
  char v17; // [xsp+14h] [xbp-4Ch]
  char v18; // [xsp+15h] [xbp-4Bh]
  char v19; // [xsp+16h] [xbp-4Ah]
  char v20; // [xsp+17h] [xbp-49h]
  char v21; // [xsp+18h] [xbp-48h]
  char v22; // [xsp+19h] [xbp-47h]
  char v23; // [xsp+1Ah] [xbp-46h]
  char v24; // [xsp+1Bh] [xbp-45h]
  char v25; // [xsp+1Ch] [xbp-44h]
  char v26; // [xsp+1Dh] [xbp-43h]
  char v27; // [xsp+1Eh] [xbp-42h]
  char v28; // [xsp+1Fh] [xbp-41h]
  char v29; // [xsp+20h] [xbp-40h]
  char v30; // [xsp+21h] [xbp-3Fh]
  char v31; // [xsp+22h] [xbp-3Eh]
  char v32; // [xsp+23h] [xbp-3Dh]
  char v33; // [xsp+24h] [xbp-3Ch]
  char v34; // [xsp+25h] [xbp-3Bh]
  char v35; // [xsp+26h] [xbp-3Ah]
  char v36; // [xsp+27h] [xbp-39h]
  __int64 v37; // [xsp+28h] [xbp-38h]
  __int64 v38; // [xsp+30h] [xbp-30h]
  __int64 v39; // [xsp+38h] [xbp-28h]
  __int64 v40; // [xsp+40h] [xbp-20h]
  __int64 v41; // [xsp+48h] [xbp-18h]

  v2 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v41 = *(_QWORD *)(v2 + 40);
  v37 = *a2;
  v38 = a2[1];
  v39 = a2[2];
  v3 = a2[3];
  v20 = v39;
  v5 = HIBYTE(v3);
  v6 = BYTE6(v3);
  v7 = BYTE5(v3);
  v8 = BYTE4(v3);
  v9 = BYTE3(v3);
  v10 = BYTE2(v3);
  v40 = v3;
  v12 = v3;
  v13 = HIBYTE(v39);
  v14 = BYTE6(v39);
  v15 = BYTE5(v39);
  v16 = BYTE4(v39);
  v17 = BYTE3(v39);
  v18 = BYTE2(v39);
  v11 = BYTE1(v3);
  v19 = BYTE1(v39);
  v23 = BYTE5(v38);
  v21 = HIBYTE(v38);
  v22 = BYTE6(v38);
  v24 = BYTE4(v38);
  v25 = BYTE3(v38);
  v26 = BYTE2(v38);
  v27 = BYTE1(v38);
  v28 = v38;
  v29 = HIBYTE(v37);
  v30 = BYTE6(v37);
  v31 = BYTE5(v37);
  v32 = BYTE4(v37);
  v33 = BYTE3(v37);
  v34 = BYTE2(v37);
  v35 = BYTE1(v37);
  v36 = v37;
  result = BN_bin2bn((unsigned __int8 *)&v5, 32LL, a1);
  *(_QWORD *)(v2 + 40);
  return result;
}

//----- (000000000007D6A0) ----------------------------------------------------
_QWORD *__fastcall sub_7D6A0(_QWORD *result, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x10
  unsigned __int64 v4; // kr00_8
  __int128 v5; // kr10_16
  unsigned __int64 v6; // x9
  __int64 v7; // x11
  unsigned __int8 v8; // cf
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x10
  __int64 v11; // x13
  __int64 v12; // x8
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x11
  __int64 v15; // x12
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // kr20_8
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x11
  __int64 v20; // x13
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // kr30_8
  __int64 v23; // x10
  __int64 v24; // x11
  unsigned __int64 v25; // x12
  __int64 v26; // x14
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x11
  __int64 v29; // x12
  unsigned __int64 v30; // x9
  unsigned __int64 v31; // kr40_8
  unsigned __int64 v32; // x10
  unsigned __int64 v33; // x11
  __int64 v34; // x13
  unsigned __int64 v35; // x9
  unsigned __int64 v36; // kr50_8
  unsigned __int64 v37; // x10
  unsigned __int64 v38; // x11
  unsigned __int64 v39; // x12
  unsigned __int64 v40; // x13
  unsigned __int64 v41; // x9
  unsigned __int64 v42; // kr60_8
  unsigned __int128 v43; // kr70_16
  unsigned __int64 v44; // x12
  unsigned __int64 v45; // x14
  unsigned __int64 v46; // x10
  unsigned __int64 v47; // x11
  __int64 v48; // x12
  unsigned __int64 v49; // x8
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x10
  unsigned __int64 v52; // x11
  __int64 v53; // x13
  unsigned __int64 v54; // x9
  unsigned __int64 v55; // krA0_8
  __int64 v56; // x10
  __int64 v57; // x11
  unsigned __int64 v58; // x12
  unsigned __int64 v59; // x13
  __int64 v60; // x14
  __int64 v61; // x8
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x10
  unsigned __int64 v64; // x11
  __int64 v65; // x12
  unsigned __int64 v66; // x9
  unsigned __int64 v67; // krB0_8
  unsigned __int64 v68; // x10
  unsigned __int64 v69; // x11
  __int64 v70; // x13
  __int64 v71; // x8
  __int64 v72; // x9
  unsigned __int64 v73; // x10
  unsigned __int64 v74; // x11
  __int64 v75; // x12
  unsigned __int64 v76; // x10

  v4 = *a3;
  v5 = *a2;
  v3 = (unsigned __int128)*a3 * v5 >> 64;
  *result = *a3 * *a2;
  result[1] = 0LL;
  result[2] = v3;
  result[3] = 0LL;
  v6 = a3[1];
  v7 = v6 * (unsigned __int128)*a2 >> 64;
  v8 = __CFADD__(v6 * *a2, v3);
  v9 = __PAIR__(v6, v4) * v5 >> 64;
  result[4] = v7;
  result[5] = 0LL;
  result[2] = v9;
  result[3] = v8;
  v10 = a2[1];
  v11 = *a3 * (unsigned __int128)v10 >> 64;
  *((_OWORD *)result + 1) = __PAIR__(v8, *a3 * v10) + v9;
  v12 = v7 + v11;
  v13 = __CFADD__(v7, v11);
  result[4] = v7 + v11;
  result[5] = v13;
  v14 = a3[2];
  v15 = v14 * (unsigned __int128)*a2 >> 64;
  v17 = v14 * *a2 + v12;
  v16 = (__PAIR__(v13, v14 * *a2) + (unsigned __int64)v12) >> 64;
  result[6] = v15;
  result[7] = 0LL;
  *((_OWORD *)result + 2) = __PAIR__(v16, v17);
  v18 = a2[1];
  v19 = a3[1];
  v20 = v19 * (unsigned __int128)v18 >> 64;
  v22 = v19 * v18 + v17;
  v21 = (__PAIR__(v16, v19 * v18) + v17) >> 64;
  v23 = v15 + v20;
  v24 = __CFADD__(v15, v20);
  *((_OWORD *)result + 2) = __PAIR__(v21, v22);
  result[6] = v15 + v20;
  result[7] = v24;
  v25 = a2[2];
  v26 = *a3 * (unsigned __int128)v25 >> 64;
  *((_OWORD *)result + 2) = __PAIR__(v21, *a3 * v25) + v22;
  v27 = __CFADD__(v23, v26) + v24;
  result[6] = v23 + v26;
  result[7] = v27;
  v28 = a3[3];
  v29 = v28 * (unsigned __int128)*a2 >> 64;
  v31 = v28 * *a2 + v23 + v26;
  v30 = (__PAIR__(v27, v28 * *a2) + (unsigned __int64)(v23 + v26)) >> 64;
  result[8] = v29;
  result[9] = 0LL;
  *((_OWORD *)result + 3) = __PAIR__(v30, v31);
  v32 = a2[1];
  v33 = a3[2];
  v34 = v33 * (unsigned __int128)v32 >> 64;
  v36 = v33 * v32 + v31;
  v35 = (__PAIR__(v30, v33 * v32) + v31) >> 64;
  v37 = v29 + v34;
  v38 = __CFADD__(v29, v34);
  *((_OWORD *)result + 3) = __PAIR__(v35, v36);
  result[8] = v29 + v34;
  result[9] = v38;
  v39 = a2[2];
  v40 = a3[1];
  v42 = v40 * v39 + v36;
  v41 = (__PAIR__(v35, v40 * v39) + v36) >> 64;
  v43 = __PAIR__(v38, v37) + (unsigned __int64)(v40 * (unsigned __int128)v39 >> 64);
  *((_OWORD *)result + 3) = __PAIR__(v41, v42);
  *((_OWORD *)result + 4) = v43;
  v44 = a2[3];
  v45 = *a3 * (unsigned __int128)v44 >> 64;
  *((_OWORD *)result + 3) = __PAIR__(v41, *a3 * v44) + v42;
  *((_OWORD *)result + 4) = v43 + v45;
  v46 = a2[1];
  v47 = a3[3];
  v48 = v47 * (unsigned __int128)v46 >> 64;
  v50 = (v43 + v45 + v47 * v46) >> 64;
  v49 = v43 + v45 + v47 * v46;
  result[10] = v48;
  result[11] = 0LL;
  *((_OWORD *)result + 4) = v43 + v45 + v47 * v46;
  v51 = a2[2];
  v52 = a3[2];
  v53 = v52 * (unsigned __int128)v51 >> 64;
  v55 = v52 * v51 + v49;
  v54 = (__PAIR__(v50, v52 * v51) + v49) >> 64;
  v56 = v48 + v53;
  v57 = __CFADD__(v48, v53);
  *((_OWORD *)result + 4) = __PAIR__(v54, v55);
  result[10] = v48 + v53;
  result[11] = v57;
  v58 = a2[3];
  v59 = a3[1];
  v60 = v59 * (unsigned __int128)v58 >> 64;
  *((_OWORD *)result + 4) = __PAIR__(v54, v59 * v58) + v55;
  v61 = v56 + v60;
  v62 = __CFADD__(v56, v60) + v57;
  result[10] = v56 + v60;
  result[11] = v62;
  v63 = a2[2];
  v64 = a3[3];
  v65 = v64 * (unsigned __int128)v63 >> 64;
  v67 = v64 * v63 + v61;
  v66 = (__PAIR__(v62, v64 * v63) + (unsigned __int64)v61) >> 64;
  result[12] = v65;
  result[13] = 0LL;
  *((_OWORD *)result + 5) = __PAIR__(v66, v67);
  v68 = a2[3];
  v69 = a3[2];
  v70 = v69 * (unsigned __int128)v68 >> 64;
  *((_OWORD *)result + 5) = __PAIR__(v66, v69 * v68) + v67;
  v71 = v65 + v70;
  v72 = __CFADD__(v65, v70);
  result[12] = v65 + v70;
  result[13] = v72;
  v73 = a2[3];
  v74 = a3[3];
  v75 = v74 * (unsigned __int128)v73 >> 64;
  v76 = v74 * v73;
  result[12] = v76 + v71;
  result[13] = __CFADD__(v76, v71) + v72;
  result[14] = v75;
  result[15] = 0LL;
  return result;
}

//----- (000000000007D8E4) ----------------------------------------------------
#error "7D8E4: too complex function (funcsize=3170)"

//----- (0000000000080A6C) ----------------------------------------------------
#error "80A6C: too complex function (funcsize=1494)"

//----- (00000000000821C4) ----------------------------------------------------
unsigned __int64 __fastcall sub_821C4(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // x19
  __int64 v5; // x22
  __int64 v6; // x20
  unsigned __int64 v7; // x21
  unsigned __int64 result; // x0
  __int64 v9; // x9
  __int64 v10; // x10
  __int64 v11; // x11
  __int64 v12; // x12
  __int64 v13; // x13
  __int64 v14; // x14
  __int64 v15; // x15
  __int64 v16; // x16
  __int64 v17; // x17
  __int64 v18; // x18
  __int64 v19; // x1
  __int64 v20; // x8
  _QWORD *v21; // x2
  unsigned int v22; // w3
  signed __int64 v23; // x3
  __int64 v24; // x4

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  result = (unsigned __int64)memset(a4, 0, 0x60uLL);
  if ( v6 )
  {
    v9 = *v4;
    v10 = v4[1];
    v11 = v4[2];
    v12 = v4[3];
    v13 = v4[4];
    v14 = v4[5];
    v15 = v4[6];
    v16 = v4[7];
    v17 = v4[8];
    v18 = v4[9];
    result = v4[10];
    v19 = v4[11];
    v20 = 0LL;
    v21 = (_QWORD *)(v5 + 48);
    do
    {
      v22 = ((v20 ^ v7 | ((v20 ^ v7) >> 4)) >> 2) | v20 ^ v7 | ((v20 ^ v7) >> 4);
      v23 = (((unsigned __int8)v22 | (unsigned __int8)(v22 >> 1)) & 1) - 1LL;
      v9 |= *(v21 - 6) & v23;
      *v4 = v9;
      ++v20;
      v10 |= *(v21 - 5) & v23;
      v4[1] = v10;
      v11 |= *(v21 - 4) & v23;
      v4[2] = v11;
      v12 |= *(v21 - 3) & v23;
      v4[3] = v12;
      v13 |= *(v21 - 2) & v23;
      v4[4] = v13;
      v14 |= *(v21 - 1) & v23;
      v4[5] = v14;
      v15 |= *v21 & v23;
      v4[6] = v15;
      v16 |= v21[1] & v23;
      v4[7] = v16;
      v17 |= v21[2] & v23;
      v4[8] = v17;
      v18 |= v21[3] & v23;
      v4[9] = v18;
      result |= v21[4] & v23;
      v4[10] = result;
      v24 = v21[5];
      v21 += 12;
      v19 |= v24 & v23;
      v4[11] = v19;
    }
    while ( v6 != v20 );
  }
  return result;
}

//----- (0000000000082314) ----------------------------------------------------
signed __int64 __fastcall sub_82314(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  BN_init((_QWORD *)(a1 + 56));
  BN_init((_QWORD *)(v1 + 80));
  BN_init((_QWORD *)(v1 + 104));
  BN_init((_QWORD *)(v1 + 144));
  *(_DWORD *)(v1 + 128) = 0;
  return 1LL;
}

//----- (0000000000082358) ----------------------------------------------------
void __fastcall sub_82358(_DWORD *a1)
{
  _DWORD *v1; // x19

  v1 = a1;
  BN_free(a1 + 14);
  BN_free(v1 + 20);
  BN_free(v1 + 26);
  BN_free(v1 + 36);
}

//----- (0000000000082390) ----------------------------------------------------
__int64 __fastcall sub_82390(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 result; // x0

  v2 = a2;
  v3 = a1;
  result = BN_copy(a1 + 56, a2 + 56);
  if ( result )
  {
    result = BN_copy(v3 + 80, v2 + 80);
    if ( result )
    {
      result = BN_copy(v3 + 104, v2 + 104);
      if ( result )
      {
        result = BN_copy(v3 + 144, v2 + 144);
        if ( result )
        {
          result = 1LL;
          *(_DWORD *)(v3 + 128) = *(_DWORD *)(v2 + 128);
        }
      }
    }
  }
  return result;
}

//----- (00000000000823FC) ----------------------------------------------------
__int64 __fastcall sub_823FC(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  __int64 v5; // x23
  _DWORD *v6; // x21
  _DWORD *v7; // x19
  __int64 v8; // x22
  __int64 v9; // x26
  __int64 v10; // x20
  unsigned int v11; // w21
  _QWORD *v12; // x24
  unsigned int (__fastcall *v13)(_DWORD *, _DWORD *, _QWORD *, _DWORD *); // x8
  unsigned int (__fastcall *v15)(_DWORD *, _DWORD *, _DWORD *, _DWORD *); // x8
  int v16; // w0
  __int64 v17; // x8
  unsigned int (__fastcall *v18)(_DWORD *, _DWORD *, void **, _DWORD *); // x23
  void **v19; // x2

  v5 = a2;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  if ( (unsigned int)BN_num_bits(a2) >= 3 && (unsigned int)BN_is_odd(v5) )
  {
    if ( v7 )
    {
      v10 = 0LL;
    }
    else
    {
      v7 = BN_CTX_new();
      v10 = (__int64)v7;
      if ( !v7 )
        return 0;
    }
    BN_CTX_start((__int64)v7);
    v12 = BN_CTX_get((__int64)v7);
    if ( !v12 || !BN_copy((__int64)(v6 + 14), v5) )
      goto LABEL_12;
    BN_set_negative((__int64)(v6 + 14), 0);
    if ( !(unsigned int)BN_nnmod((__int64)v12, v9, v5, (__int64)v7) )
    {
      v11 = 0;
      goto LABEL_13;
    }
    v13 = *(unsigned int (__fastcall **)(_DWORD *, _DWORD *, _QWORD *, _DWORD *))(*(_QWORD *)v6 + 64LL);
    if ( v13 )
    {
      if ( !v13(v6, v6 + 20, v12, v7) )
      {
LABEL_12:
        v11 = 0;
LABEL_13:
        BN_CTX_end((__int64)v7);
        BN_CTX_free(v10);
        return v11;
      }
    }
    else if ( !BN_copy((__int64)(v6 + 20), (__int64)v12) )
    {
LABEL_24:
      v11 = 0;
      goto LABEL_13;
    }
    if ( !(unsigned int)BN_nnmod((__int64)(v6 + 26), v8, v5, (__int64)v7) )
      goto LABEL_24;
    v15 = *(unsigned int (__fastcall **)(_DWORD *, _DWORD *, _DWORD *, _DWORD *))(*(_QWORD *)v6 + 64LL);
    if ( v15 )
    {
      if ( !v15(v6, v6 + 26, v6 + 26, v7) )
        goto LABEL_24;
    }
    if ( !(unsigned int)BN_add_word((__int64)v12, 3LL) )
      goto LABEL_24;
    v16 = BN_cmp((__int64)v12, (__int64)(v6 + 14));
    v17 = *(_QWORD *)v6;
    v6[32] = v16 == 0;
    v18 = *(unsigned int (__fastcall **)(_DWORD *, _DWORD *, void **, _DWORD *))(v17 + 64);
    v19 = BN_value_one();
    if ( v18 )
    {
      if ( !v18(v6, v6 + 36, v19, v7) )
        goto LABEL_24;
    }
    else if ( !BN_copy((__int64)(v6 + 36), (__int64)v19) )
    {
      v11 = 0;
      goto LABEL_13;
    }
    v11 = 1;
    goto LABEL_13;
  }
  ERR_put_error(15, 0LL, 110, (__int64)"external/boringssl/src/crypto/ec/simple.c", 128);
  return 0;
}

//----- (0000000000082604) ----------------------------------------------------
__int64 __fastcall EC_GROUP_get_curve_GFp_0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  _DWORD *v5; // x22
  __int64 v6; // x19
  __int64 v7; // x23
  __int64 v8; // x21
  __int64 v9; // x20
  unsigned int v10; // w19

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  if ( !a2 || BN_copy(a2, a1 + 56) )
  {
    if ( v7 | v6 )
    {
      if ( *(_QWORD *)(*(_QWORD *)v8 + 72LL) )
      {
        if ( v5 )
        {
          v9 = 0LL;
          if ( !v7 )
            goto LABEL_21;
        }
        else
        {
          v5 = BN_CTX_new();
          v9 = (__int64)v5;
          if ( !v5 )
            return 0;
          if ( !v7 )
          {
LABEL_21:
            if ( v6
              && !(*(unsigned int (__fastcall **)(__int64, __int64, __int64, _DWORD *))(*(_QWORD *)v8 + 72LL))(
                    v8,
                    v6,
                    v8 + 104,
                    v5) )
            {
              goto LABEL_23;
            }
LABEL_15:
            v10 = 1;
LABEL_16:
            BN_CTX_free(v9);
            return v10;
          }
        }
        if ( (*(unsigned int (__fastcall **)(__int64, __int64, __int64, _DWORD *))(*(_QWORD *)v8 + 72LL))(
               v8,
               v7,
               v8 + 80,
               v5) )
        {
          goto LABEL_21;
        }
LABEL_23:
        v10 = 0;
        goto LABEL_16;
      }
      if ( v7 && !BN_copy(v7, v8 + 80) )
      {
        v10 = 0;
        v9 = 0LL;
        goto LABEL_16;
      }
      if ( v6 )
      {
        v9 = 0LL;
        if ( BN_copy(v6, v8 + 104) )
          goto LABEL_15;
        goto LABEL_23;
      }
    }
    v9 = 0LL;
    goto LABEL_15;
  }
  return 0;
}

//----- (0000000000082738) ----------------------------------------------------
__int64 __fastcall EC_GROUP_get_degree_0(__int64 a1)
{
  return BN_num_bits(a1 + 56);
}

//----- (0000000000082740) ----------------------------------------------------
signed __int64 __fastcall sub_82740(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  BN_init((_QWORD *)(a1 + 8));
  BN_init((_QWORD *)(v1 + 32));
  BN_init((_QWORD *)(v1 + 56));
  return 1LL;
}

//----- (0000000000082778) ----------------------------------------------------
void __fastcall sub_82778(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  BN_free((_DWORD *)(a1 + 8));
  BN_free((_DWORD *)(v1 + 32));
  BN_free((_DWORD *)(v1 + 56));
}

//----- (00000000000827A8) ----------------------------------------------------
void __fastcall sub_827A8(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  BN_clear_free((void **)(a1 + 8));
  BN_clear_free((void **)(v1 + 32));
  BN_clear_free((void **)(v1 + 56));
}

//----- (00000000000827D8) ----------------------------------------------------
bool __fastcall sub_827D8(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  _BOOL8 result; // x0

  v2 = a2;
  v3 = a1;
  if ( BN_copy(a1 + 8, a2 + 8) && BN_copy(v3 + 32, v2 + 32) )
    result = BN_copy(v3 + 56, v2 + 56) != 0;
  else
    result = 0LL;
  return result;
}

//----- (000000000008291C) ----------------------------------------------------
__int64 __fastcall sub_8291C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x20
  __int64 v5; // x19
  __int64 v6; // x21
  __int64 v7; // x22
  __int64 result; // x0
  __int64 (__fastcall *v9)(__int64, __int64, __int64, __int64); // x4

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a3 )
    return 1LL;
  if ( !BN_is_negative(a3) && BN_cmp(v5, v7 + 56) & 0x80000000 )
  {
    v9 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v7 + 64LL);
    if ( v9 )
      result = v9(v7, v6, v5, v4);
    else
      result = BN_copy(v6, v5) != 0;
  }
  else
  {
    ERR_put_error(15, 0LL, 101, (__int64)"external/boringssl/src/crypto/ec/simple.c", 281);
    result = 0LL;
  }
  return result;
}

//----- (00000000000829D8) ----------------------------------------------------
__int64 __fastcall sub_829D8(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  _DWORD *v5; // x19
  __int64 v6; // x20
  __int64 v7; // x21
  _QWORD *v8; // x22
  _QWORD *v9; // x23
  void **v10; // x0
  __int64 result; // x0

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a3 && a4 )
  {
    v10 = BN_value_one();
    result = sub_737F8(v9, v8, v7, v6, (__int64)v10, v5);
  }
  else
  {
    ERR_put_error(15, 0LL, 67, (__int64)"external/boringssl/src/crypto/ec/simple.c", 364);
    result = 0LL;
  }
  return result;
}

//----- (00000000000834FC) ----------------------------------------------------
__int64 __fastcall sub_834FC(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x19
  _QWORD *v4; // x22
  _DWORD *v5; // x21
  _BOOL4 v6; // w21
  unsigned int (__fastcall *v7)(_DWORD *, _QWORD *, _QWORD *, __int64); // x20
  unsigned int (__fastcall *v8)(_DWORD *, _QWORD *, _QWORD *, _QWORD *, __int64); // x24
  _DWORD *v9; // x25
  _QWORD *v10; // x24
  _QWORD *v11; // x27
  _QWORD *v12; // x28
  _QWORD *v13; // x26
  __int64 v14; // x2
  __int64 v15; // x0
  __int64 v16; // x1
  unsigned int (__fastcall *v18)(_DWORD *, _QWORD *, _QWORD *, _QWORD *, __int64); // [xsp+18h] [xbp-58h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !EC_POINT_is_at_infinity(a1, a2) )
  {
    v8 = *(unsigned int (__fastcall **)(_DWORD *, _QWORD *, _QWORD *, _QWORD *, __int64))(*(_QWORD *)v5 + 48LL);
    v7 = *(unsigned int (__fastcall **)(_DWORD *, _QWORD *, _QWORD *, __int64))(*(_QWORD *)v5 + 56LL);
    if ( v3 )
    {
      v9 = 0LL;
    }
    else
    {
      v9 = BN_CTX_new();
      v3 = (__int64)v9;
      if ( !v9 )
        return 0;
    }
    v18 = v8;
    BN_CTX_start(v3);
    v10 = BN_CTX_get(v3);
    v11 = BN_CTX_get(v3);
    v12 = BN_CTX_get(v3);
    v13 = BN_CTX_get(v3);
    if ( !v13 || !v7(v5, v10, v4 + 1, v3) )
      goto LABEL_30;
    if ( (unsigned int)BN_cmp((__int64)(v4 + 7), (__int64)(v5 + 36)) )
    {
      if ( v7(v5, v11, v4 + 7, v3) )
      {
        if ( !v7(v5, v12, v11, v3) || !v18(v5, v13, v12, v11, v3) )
          goto LABEL_30;
        if ( v5[32] )
        {
          if ( !(unsigned int)BN_mod_lshift1_quick((__int64)v11, (__int64)v12, (__int64)(v5 + 14))
            || !(unsigned int)BN_mod_add_quick((__int64)v11, (__int64)v11, (__int64)v12, (__int64)(v5 + 14))
            || !(unsigned int)BN_mod_sub_quick((__int64)v10, (__int64)v10, (__int64)v11, (__int64)(v5 + 14)) )
          {
            goto LABEL_30;
          }
        }
        else if ( !v18(v5, v11, v12, (_QWORD *)v5 + 10, v3)
               || !(unsigned int)BN_mod_add_quick((__int64)v10, (__int64)v10, (__int64)v11, (__int64)(v5 + 14)) )
        {
          goto LABEL_30;
        }
        if ( !v18(v5, v10, v10, v4 + 1, v3) || !v18(v5, v11, (_QWORD *)v5 + 13, v13, v3) )
          goto LABEL_30;
        v15 = (__int64)v10;
        v16 = (__int64)v10;
        v14 = (__int64)v11;
LABEL_21:
        if ( (unsigned int)BN_mod_add_quick(v15, v16, v14, (__int64)(v5 + 14)) && v7(v5, v11, v4 + 4, v3) )
        {
          v6 = (unsigned __int64)BN_ucmp((__int64)v11, (__int64)v10) == 0;
LABEL_31:
          BN_CTX_end(v3);
          BN_CTX_free((__int64)v9);
          return (unsigned int)v6;
        }
LABEL_30:
        v6 = 0;
        goto LABEL_31;
      }
    }
    else if ( (unsigned int)BN_mod_add_quick((__int64)v10, (__int64)v10, (__int64)(v5 + 20), (__int64)(v5 + 14)) )
    {
      if ( !v18(v5, v10, v10, v4 + 1, v3) )
        goto LABEL_30;
      v14 = (__int64)(v5 + 26);
      v15 = (__int64)v10;
      v16 = (__int64)v10;
      goto LABEL_21;
    }
    v6 = 0;
    goto LABEL_31;
  }
  return 1;
}

//----- (0000000000084028) ----------------------------------------------------
__int64 __fastcall sub_84028(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  return BN_mod_mul(a2, a3, a4, a1 + 56, a5);
}

//----- (0000000000084040) ----------------------------------------------------
__int64 __fastcall sub_84040(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return BN_mod_sqr(a2, a3, a1 + 56, a4);
}

//----- (0000000000084054) ----------------------------------------------------
_BYTE *__fastcall sub_84054(_BYTE *result, _BYTE *a2, unsigned __int8 a3)
{
  unsigned int v3; // w8

  v3 = -(a3 >> 5) & (319 - a3) & 0xFF | a3 & ~-(a3 >> 5);
  *result = (a3 >> 5) & 1;
  *a2 = (v3 & 1) + (v3 >> 1);
  return result;
}

//----- (0000000000084090) ----------------------------------------------------
__int64 __fastcall sub_84090(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6)
{
  _DWORD *v6; // x24
  __int64 v7; // x19
  __int64 v8; // x22
  _QWORD *v9; // x23
  __int64 v10; // x20
  _DWORD *v11; // x28
  _BOOL8 v12; // x26
  __int64 *v13; // x21
  __int64 *v14; // x8
  __int64 v15; // x0
  unsigned __int64 v16; // x21
  _QWORD *v17; // x22
  char *v18; // x25
  void **v19; // x20
  _QWORD *v20; // x27
  unsigned __int64 v21; // x23
  __int64 *v22; // x20
  unsigned __int64 v23; // x24
  unsigned __int64 v24; // x19
  void **v25; // x19
  __int64 *v26; // x24
  unsigned int v27; // w20
  _QWORD *v28; // x26
  unsigned int v29; // w0
  size_t v30; // x20
  void *v31; // x26
  signed int v32; // w20
  int v33; // w28
  unsigned __int64 v34; // x8
  signed __int64 v35; // x25
  int v36; // w19
  int v37; // w9
  signed __int64 v38; // x22
  __int64 v39; // x0
  unsigned int v40; // w0
  signed __int64 v41; // x27
  __int64 v42; // x24
  _BYTE *v43; // x0
  signed __int64 v44; // x9
  signed int v45; // w20
  __int64 *v46; // x0
  __int64 *v47; // x22
  unsigned __int64 v48; // x19
  unsigned __int64 v49; // x26
  void *v50; // x0
  __int16 v51; // w4
  void *v52; // t1
  __int64 v53; // t1
  __int16 v55; // w4
  unsigned __int64 v56; // x19
  _QWORD **v57; // x24
  _QWORD *v58; // x0
  _DWORD *v59; // x22
  unsigned __int64 v60; // x27
  __int64 v61; // x28
  unsigned __int64 v62; // x27
  unsigned __int64 v63; // x8
  int v64; // w0
  _BOOL4 v65; // w19
  unsigned __int64 v66; // x22
  bool v67; // w8
  __int64 v68; // x24
  unsigned int v69; // w8
  int v70; // w27
  int v71; // w9
  bool v72; // zf
  bool v73; // nf
  int v74; // w2
  __int16 v75; // w4
  unsigned __int64 v76; // [xsp+10h] [xbp-100h]
  _QWORD *v77; // [xsp+18h] [xbp-F8h]
  unsigned __int64 v78; // [xsp+20h] [xbp-F0h]
  _DWORD *v79; // [xsp+28h] [xbp-E8h]
  __int64 v80; // [xsp+30h] [xbp-E0h]
  _BOOL8 v81; // [xsp+38h] [xbp-D8h]
  _BOOL8 v82; // [xsp+38h] [xbp-D8h]
  char *v83; // [xsp+40h] [xbp-D0h]
  unsigned __int64 v84; // [xsp+50h] [xbp-C0h]
  _QWORD *v85; // [xsp+58h] [xbp-B8h]
  _QWORD *v86; // [xsp+60h] [xbp-B0h]
  __int64 *v87; // [xsp+68h] [xbp-A8h]
  _QWORD *v88; // [xsp+78h] [xbp-98h]
  __int64 *v89; // [xsp+80h] [xbp-90h]
  unsigned __int64 v90; // [xsp+88h] [xbp-88h]
  __int64 v91; // [xsp+90h] [xbp-80h]
  _QWORD *v92; // [xsp+98h] [xbp-78h]
  __int64 *v93; // [xsp+A0h] [xbp-70h]
  bool v94; // [xsp+A0h] [xbp-70h]
  void **v95; // [xsp+A8h] [xbp-68h]
  __int64 v96; // [xsp+B0h] [xbp-60h]
  __int64 v97; // [xsp+B8h] [xbp-58h]

  v6 = a6;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = a1;
  v96 = a5;
  v97 = a4;
  if ( a6 )
  {
    v11 = 0LL;
  }
  else
  {
    v11 = BN_CTX_new();
    v6 = v11;
    if ( !v11 )
    {
      v16 = 0LL;
      v17 = 0LL;
      v93 = 0LL;
      v95 = 0LL;
      v25 = 0LL;
      v18 = 0LL;
      v21 = 0LL;
      v26 = 0LL;
      v20 = 0LL;
      goto LABEL_28;
    }
  }
  v12 = v7 != 0;
  if ( v7 )
    v13 = &v97;
  else
    v13 = 0LL;
  if ( v7 )
    v14 = &v96;
  else
    v14 = 0LL;
  v89 = v14;
  if ( v8 )
  {
    v15 = EVP_CIPHER_CTX_get_app_data(v10);
    if ( !v15 )
    {
      ERR_put_error(15, 0LL, 122, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", 279);
      v17 = 0LL;
      v93 = 0LL;
      v95 = 0LL;
      v25 = 0LL;
      v18 = 0LL;
      v21 = 0LL;
      v26 = 0LL;
      v20 = 0LL;
      v27 = 0;
      v16 = v12;
      v28 = 0LL;
      goto LABEL_97;
    }
    v86 = (_QWORD *)v15;
    v87 = v13;
    if ( v7 )
      v16 = 2LL;
    else
      v16 = 1LL;
    v91 = v8;
    v88 = (_QWORD *)v10;
  }
  else
  {
    v91 = 0LL;
    v86 = 0LL;
    v87 = v13;
    v88 = (_QWORD *)v10;
    v16 = v7 != 0;
  }
  v17 = malloc(8 * v16);
  v18 = (char *)malloc(8 * v16);
  v19 = (void **)malloc(8 * v16);
  v20 = malloc(8 * v16);
  v95 = v19;
  if ( !v19 )
    goto LABEL_162;
  if ( v16 )
    memset(v19, 0, 8 * v16);
  if ( !v17 || !v18 || !v20 )
  {
LABEL_162:
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", 298);
    v25 = v19;
    v21 = 0LL;
    v93 = 0LL;
    v26 = 0LL;
LABEL_28:
    v27 = 0;
    v28 = 0LL;
    goto LABEL_97;
  }
  v77 = v9;
  v21 = 0LL;
  v85 = v20;
  v83 = v18;
  v80 = (__int64)v6;
  v92 = v17;
  if ( v16 )
  {
    v22 = v89;
    v23 = 0LL;
    v24 = 0LL;
    v81 = v12;
    while ( 1 )
    {
      v39 = v91;
      if ( v24 < v12 )
        v39 = v22[v24];
      v40 = BN_num_bits(v39);
      v84 = v23;
      if ( v40 <= 0x7CF )
      {
        if ( v40 <= 0x31F )
        {
          if ( v40 <= 0x12B )
          {
            if ( v40 <= 0x45 )
            {
              if ( v40 <= 0x13 )
                v41 = 1LL;
              else
                v41 = 2LL;
            }
            else
            {
              v41 = 3LL;
            }
          }
          else
          {
            v41 = 4LL;
          }
        }
        else
        {
          v41 = 5LL;
        }
      }
      else
      {
        v41 = 6LL;
      }
      v42 = v91;
      v21 += 1LL << ((unsigned __int8)v41 - 1);
      v17[v24] = v41;
      if ( v24 < v12 )
        v42 = v22[v24];
      if ( !BN_is_zero(v42) )
        break;
      v43 = malloc(1uLL);
      v20 = v85;
      v31 = v43;
      if ( !v43 )
      {
        v74 = 65;
        v75 = 104;
        goto LABEL_148;
      }
      v34 = 1LL;
      *v43 = 0;
LABEL_71:
      v23 = v84;
      v44 = v24++;
      v95[v44] = v31;
      v12 = v81;
      if ( v34 > v84 )
        v23 = v34;
      *(_QWORD *)&v18[v44 * 8] = v34;
      if ( v24 >= v16 )
      {
        v45 = v23 - 1;
        goto LABEL_76;
      }
    }
    if ( (unsigned int)(v41 - 1) >= 7 )
    {
      v55 = 114;
    }
    else
    {
      v94 = BN_is_negative(v42) == 0;
      if ( *(_QWORD *)v42 && *(_DWORD *)(v42 + 8) )
      {
        v29 = BN_num_bits(v42);
        v30 = v29 + 1LL;
        v90 = v29;
        v31 = malloc(v30);
        if ( !v31 )
        {
          ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", 136);
          goto LABEL_94;
        }
        v76 = v30;
        v78 = v24;
        v79 = v11;
        v32 = 1 << v41;
        v33 = 2 * (1 << v41);
        v34 = 0LL;
        v35 = v41 + 1;
        v36 = **(_DWORD **)v42 & (v33 - 1);
        while ( v36 )
        {
          if ( !(v36 & 1) )
            goto LABEL_48;
          v37 = v36;
          if ( v36 & v32 )
          {
            v37 = v36 - v33;
            if ( v35 + v34 >= v90 )
              v37 = v36 & ((v33 - 1) >> 1);
          }
          if ( v37 >= v32 || v37 <= -(1 << v41) || !(v37 & 1) )
          {
            v51 = 168;
LABEL_93:
            ERR_put_error(15, 0LL, 68, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", v51);
            v24 = v78;
            v11 = v79;
LABEL_94:
            v20 = v85;
LABEL_95:
            free(v31);
            v93 = 0LL;
            v26 = 0LL;
            v27 = 0;
            v28 = 0LL;
            v95[v24] = 0LL;
            v25 = v95;
            goto LABEL_96;
          }
          v36 -= v37;
          if ( v36 != v32 && v36 && v36 != v33 )
          {
            v51 = 177;
            goto LABEL_93;
          }
LABEL_49:
          v38 = v34 + 1;
          *((_BYTE *)v31 + v34) = v37 * v94;
          v36 = ((unsigned int)BN_is_bit_set(v42, (signed int)v35 + (signed int)v34) << v41) + (v36 >> 1);
          v34 = v38;
          if ( v36 > v33 )
          {
            v51 = 188;
            goto LABEL_93;
          }
        }
        if ( v35 + v34 >= v90 )
        {
          v24 = v78;
          v11 = v79;
          v20 = v85;
          v17 = v92;
          if ( v34 <= v76 )
          {
            v18 = v83;
            v22 = v89;
            goto LABEL_71;
          }
          v74 = 68;
          v75 = 194;
LABEL_148:
          ERR_put_error(15, 0LL, v74, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", v75);
          goto LABEL_95;
        }
        v36 = 0;
LABEL_48:
        LOBYTE(v37) = 0;
        goto LABEL_49;
      }
      v55 = 126;
    }
    ERR_put_error(15, 0LL, 68, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", v55);
    v20 = v85;
    v31 = 0LL;
    goto LABEL_95;
  }
  v45 = -1;
LABEL_76:
  v46 = (__int64 *)malloc(8 * v21);
  v47 = v46;
  if ( !v46 )
  {
    v26 = 0LL;
    ERR_put_error(15, 0LL, 65, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", 325);
    v93 = 0LL;
    goto LABEL_90;
  }
  if ( 8 * v21 )
    memset(v46, 0, 8 * v21);
  v82 = v12;
  v93 = v47;
  if ( v16 )
  {
    v48 = 0LL;
    do
    {
      v49 = 0LL;
      v20[v48] = v47;
      do
      {
        v50 = EC_POINT_new(v88);
        *v47 = (__int64)v50;
        if ( !v50 )
        {
          v27 = 0;
          v28 = 0LL;
LABEL_88:
          v26 = v93;
          v25 = v95;
          goto LABEL_96;
        }
        ++v47;
        ++v49;
      }
      while ( v49 < 1LL << ((unsigned __int8)v92[v48] - 1) );
      ++v48;
    }
    while ( v48 < v16 );
  }
  v26 = v93;
  if ( v47 != &v93[v21] )
  {
    ERR_put_error(15, 0LL, 68, (__int64)"external/boringssl/src/crypto/ec/wnaf.c", 343);
LABEL_90:
    v27 = 0;
    v28 = 0LL;
    goto LABEL_91;
  }
  v28 = EC_POINT_new(v88);
  if ( !v28 )
    goto LABEL_159;
  if ( v16 )
  {
    v56 = 0LL;
    do
    {
      v57 = (_QWORD **)v20[v56];
      v58 = *v57;
      if ( v56 >= v82 )
      {
        if ( !EC_POINT_copy(v58, v86) )
        {
LABEL_154:
          v27 = 0;
          goto LABEL_88;
        }
      }
      else if ( !EC_POINT_copy(v58, (_QWORD *)v87[v56]) )
      {
        goto LABEL_154;
      }
      v59 = v11;
      v60 = v92[v56];
      if ( v60 >= 2 )
      {
        if ( (unsigned int)EC_POINT_dbl(v88, v28, *v57, v80) )
        {
          v61 = 0LL;
          v62 = 1LL << ((unsigned __int8)v60 - 1);
          while ( (unsigned int)EC_POINT_add(v88, v57[v61 + 1], v57[v61], v28, v80) )
          {
            v63 = v61++ + 2;
            if ( v63 >= v62 )
              goto LABEL_119;
          }
        }
        v26 = v93;
        v25 = v95;
        v20 = v85;
        v27 = 0;
        v11 = v59;
        goto LABEL_96;
      }
LABEL_119:
      v20 = v85;
      ++v56;
      v11 = v59;
    }
    while ( v56 < v16 );
  }
  v26 = v93;
  EC_POINTs_make_affine(v88, v21, v93, v80);
  if ( !v64 )
    goto LABEL_159;
  if ( v45 & 0x80000000 )
    goto LABEL_145;
  v65 = 0;
  v66 = v45;
  v67 = 1;
  v27 = 1;
  while ( 1 )
  {
    if ( !v67 )
    {
      v27 = 0;
      if ( !(unsigned int)EC_POINT_dbl(v88, v77, v77, v80) )
        goto LABEL_91;
    }
    if ( v16 )
      break;
LABEL_142:
    v26 = v93;
    v67 = v27 != 0;
    v72 = v66 == 0;
    v73 = (v66-- & 0x8000000000000000LL) != 0LL;
    if ( v73 || v72 )
    {
      if ( v27 )
      {
LABEL_145:
        if ( (unsigned int)EC_POINT_set_to_infinity(v88, v77) )
          goto LABEL_146;
LABEL_159:
        v27 = 0;
      }
      else
      {
        if ( v65 && !(unsigned int)EC_POINT_invert(v88, v77) )
          goto LABEL_159;
LABEL_146:
        v27 = 1;
      }
LABEL_91:
      v25 = v95;
      goto LABEL_96;
    }
  }
  v68 = 0LL;
  while ( 1 )
  {
    if ( *(_QWORD *)&v83[8 * v68] <= v66 )
      goto LABEL_141;
    v69 = *((char *)v95[v68] + v66);
    if ( !*((_BYTE *)v95[v68] + v66) )
      goto LABEL_141;
    v70 = (v69 & 0x80000000) == 0 ? *((char *)v95[v68] + v66) : !v69;
    if ( ((v69 >> 7) & 1) != v65 )
      break;
LABEL_136:
    v71 = v70 >> 1;
    if ( v27 )
    {
      v27 = 0;
      if ( !EC_POINT_copy(v77, *(_QWORD **)(v85[v68] + 8LL * v71)) )
        goto LABEL_156;
    }
    else if ( !(unsigned int)EC_POINT_add(v88, v77, v77, *(_QWORD **)(v85[v68] + 8LL * v71), v80) )
    {
      goto LABEL_156;
    }
    v20 = v85;
LABEL_141:
    if ( ++v68 >= v16 )
      goto LABEL_142;
  }
  if ( v27 || (unsigned int)EC_POINT_invert(v88, v77) )
  {
    v65 = v65 == 0;
    goto LABEL_136;
  }
  v27 = 0;
LABEL_156:
  v26 = v93;
  v25 = v95;
  v20 = v85;
LABEL_96:
  v17 = v92;
  v18 = v83;
LABEL_97:
  BN_CTX_free((__int64)v11);
  EC_POINT_free((__int64)v28);
  free(v17);
  free(v18);
  if ( v25 )
  {
    for ( ; v16; --v16 )
    {
      v52 = *v25;
      ++v25;
      free(v52);
    }
    free(v95);
  }
  if ( v26 )
  {
    for ( ; v21; --v21 )
    {
      v53 = *v26;
      ++v26;
      EC_POINT_clear_free(v53);
    }
    free(v93);
  }
  free(v20);
  return v27;
}

//----- (00000000000849B8) ----------------------------------------------------
void __fastcall ECDH_compute_key(void *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, __int64 (__fastcall *a5)(void *, size_t, void *, unsigned __int64 *))
{
  __int64 v5; // x20
  size_t v6; // x21
  void *v7; // x23
  __int64 (__fastcall *v8)(void *, size_t, void *, unsigned __int64 *); // x24
  _QWORD *v9; // x25
  __int64 v10; // x26
  _DWORD *v11; // x0
  __int64 v12; // x19
  __int64 *v13; // x22
  _QWORD *v14; // x20
  _QWORD *v15; // x25
  size_t v16; // x26
  _BYTE *v17; // x0
  void *v18; // x22
  int v19; // w2
  __int16 v20; // w4
  int v21; // w2
  __int16 v22; // w4
  unsigned __int64 v23; // [xsp+0h] [xbp-50h]
  __int64 v24; // [xsp+8h] [xbp-48h]

  v5 = a4;
  v6 = a2;
  v7 = a1;
  v8 = a5;
  v9 = a3;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v23 = a2;
  v10 = X509_TRUST_get0_name(a4);
  if ( !v10 )
  {
    ERR_put_error(27, 0LL, 101, (__int64)"external/boringssl/src/crypto/ecdh/ecdh.c", 86);
    goto LABEL_21;
  }
  v11 = BN_CTX_new();
  v12 = (__int64)v11;
  if ( v11 )
  {
    BN_CTX_start((__int64)v11);
    v13 = (__int64 *)lh_num_items(v5);
    v14 = EC_POINT_new(v13);
    if ( v14 )
    {
      if ( (unsigned int)EC_POINT_mul(v13, v14, 0LL, v9, v10) )
      {
        v15 = BN_CTX_get(v12);
        if ( v15 )
        {
          if ( (unsigned int)EC_POINT_get_affine_coordinates_GFp((__int64)v13, v14) )
          {
            v16 = ((unsigned int)EC_GROUP_get_degree(v13) + 7) >> 3;
            v17 = malloc(v16);
            v18 = v17;
            if ( v17 )
            {
              if ( (unsigned int)BN_bn2bin_padded(v17, v16, (__int64)v15) )
              {
                if ( !v8 )
                {
                  if ( v16 < v6 )
                  {
                    v6 = v16;
                    v23 = v16;
                  }
                  if ( !v6 )
                    goto LABEL_20;
                  memcpy(v7, v18, v6);
                  if ( !(v6 >> 31) )
                    goto LABEL_20;
LABEL_29:
                  v21 = 69;
                  v22 = 149;
                  goto LABEL_31;
                }
                if ( !v8(v18, v16, v7, &v23) )
                {
                  v21 = 100;
                  v22 = 137;
                  goto LABEL_31;
                }
                if ( v23 >> 31 )
                  goto LABEL_29;
LABEL_20:
                free(v18);
                EC_POINT_free((__int64)v14);
                BN_CTX_end(v12);
                BN_CTX_free(v12);
                goto LABEL_21;
              }
              v21 = 68;
              v22 = 131;
            }
            else
            {
              v21 = 65;
              v22 = 126;
            }
LABEL_31:
            ERR_put_error(27, 0LL, v21, (__int64)"external/boringssl/src/crypto/ecdh/ecdh.c", v22);
            goto LABEL_20;
          }
          v19 = 102;
          v20 = 119;
        }
        else
        {
          v19 = 65;
          v20 = 114;
        }
      }
      else
      {
        v19 = 102;
        v20 = 108;
      }
    }
    else
    {
      v19 = 65;
      v20 = 103;
    }
    ERR_put_error(27, 0LL, v19, (__int64)"external/boringssl/src/crypto/ecdh/ecdh.c", v20);
    v18 = 0LL;
    goto LABEL_20;
  }
LABEL_21:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v24;
}
// 73338: using guessed type __int64 __fastcall EC_GROUP_get_degree(_QWORD);

//----- (0000000000084C5C) ----------------------------------------------------
void __fastcall ECDSA_sign(__int64 a1, unsigned __int8 *a2, size_t a3, __int64 a4, int *a5, __int64 a6)
{
  __int64 v6; // x8
  __int64 v7; // x9
  void (__fastcall *v8)(unsigned __int8 *, size_t, __int64, int *, __int64); // x5

  v6 = a6;
  v7 = *(_QWORD *)(a6 + 40);
  if ( v7 && (v8 = *(void (__fastcall **)(unsigned __int8 *, size_t, __int64, int *, __int64))(v7 + 40)) != 0LL )
    v8(a2, a3, a4, a5, v6);
  else
    ECDSA_sign_ex(a1, a2, a3, a4, a5, 0LL, 0LL, v6);
}

//----- (0000000000084C98) ----------------------------------------------------
void __fastcall ECDSA_sign_ex(__int64 a1, unsigned __int8 *a2, size_t a3, __int64 a4, int *a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v8; // x22
  int *v9; // x19
  __int64 v10; // x21
  __int64 v11; // x8
  int v12; // w8
  __int64 *v13; // x20
  __int64 *v14; // x0
  __int64 v15; // x0
  int v16; // [xsp+0h] [xbp-50h]
  __int64 v17[4]; // [xsp+8h] [xbp-48h]
  __int64 v18; // [xsp+28h] [xbp-28h]

  v8 = a8;
  v9 = a5;
  v10 = a4;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = *(_QWORD *)(a8 + 40);
  if ( !v11 || !*(_QWORD *)(v11 + 40) )
  {
    ECDSA_do_sign_ex(a2, a3, a6, a7, a8);
    v13 = v14;
    if ( v14 )
    {
      EVP_MD_CTX_init(v17);
      v15 = ECDSA_size(v8);
      if ( (unsigned int)CBB_init_fixed(v17, v10, v15)
        && (unsigned int)ECDSA_SIG_marshal(v17, v13)
        && (unsigned int)CBB_finish((__int64)v17, 0LL, &v16) )
      {
        v12 = v16;
        goto LABEL_11;
      }
      ERR_put_error(26, 0LL, 105, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 468);
      CBB_cleanup(v17);
    }
    v12 = 0;
    goto LABEL_11;
  }
  ERR_put_error(26, 0LL, 103, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 451);
  v12 = 0;
  v13 = 0LL;
LABEL_11:
  *v9 = v12;
  ECDSA_SIG_free((_DWORD **)v13);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000084DDC) ----------------------------------------------------
void __fastcall ECDSA_verify(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  size_t v6; // x23
  const void *v7; // x24
  unsigned __int8 *v8; // x22
  __int64 v9; // x20
  __int64 v10; // x21
  __int64 *v11; // x0
  __int64 *v12; // x19
  __int64 v13; // [xsp+8h] [xbp-48h]
  void *v14; // [xsp+10h] [xbp-40h]
  __int64 v15; // [xsp+18h] [xbp-38h]

  v6 = a5;
  v7 = (const void *)a4;
  v8 = a2;
  v9 = a6;
  v10 = a3;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v14 = 0LL;
  ECDSA_SIG_from_bytes(a4, a5);
  v12 = v11;
  if ( v11 )
  {
    if ( !(unsigned int)ECDSA_SIG_to_bytes(&v14, &v13, v11) || v13 != v6 || v6 && (unsigned int)memcmp(v7, v14, v6) )
      ERR_put_error(26, 0LL, 68, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 96);
    else
      ECDSA_do_verify(v8, v10, v12, v9);
  }
  free(v14);
  ECDSA_SIG_free((_DWORD **)v12);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v15;
}

//----- (0000000000084EE4) ----------------------------------------------------
void __fastcall ECDSA_do_verify(unsigned __int8 *a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // x19
  unsigned __int8 *v5; // x27
  __int64 *v6; // x20
  __int64 v7; // x26
  __int64 *v8; // x21
  __int64 v9; // x0
  _QWORD *v10; // x23
  _DWORD *v11; // x0
  __int64 v12; // x19
  _QWORD *v13; // x22
  _QWORD *v14; // x25
  _QWORD *v15; // x28
  _QWORD *v16; // x0
  __int64 v17; // x24
  int v18; // w2
  __int16 v19; // w4
  int v20; // w2
  __int16 v21; // w4
  _QWORD *v22; // x26
  _BOOL4 v23; // w20
  int v24; // w2
  __int16 v25; // w4
  __int64 v26; // [xsp+8h] [xbp-68h]
  char v27; // [xsp+14h] [xbp-5Ch]
  __int64 v28; // [xsp+18h] [xbp-58h]

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = (__int64 *)lh_num_items(a4);
  if ( v8 && (v9 = EVP_CIPHER_CTX_get_app_data(v4), v10 = (_QWORD *)v9, v6) && v9 )
  {
    v11 = BN_CTX_new();
    v12 = (__int64)v11;
    if ( v11 )
    {
      BN_CTX_start((__int64)v11);
      v13 = BN_CTX_get(v12);
      v14 = BN_CTX_get(v12);
      v15 = BN_CTX_get(v12);
      v16 = BN_CTX_get(v12);
      v17 = (__int64)v16;
      if ( v13 && v14 && v15 && v16 )
      {
        v26 = EC_GROUP_get0_order((__int64)v8);
        if ( BN_is_zero(*v6)
          || BN_is_negative(*v6)
          || !(BN_ucmp(*v6, v26) & 0x80000000)
          || BN_is_zero(v6[1])
          || BN_is_negative(v6[1])
          || !(BN_ucmp(v6[1], v26) & 0x80000000) )
        {
          v18 = 100;
          v19 = 177;
        }
        else if ( (unsigned int)sub_69844((__int64)v14, &v27, v6[1], v26, v12) )
        {
          if ( !(unsigned int)sub_85618((__int64)v15, v5, v7, v26) )
            goto LABEL_23;
          if ( (unsigned int)BN_mod_mul((__int64)v13, (__int64)v15, (__int64)v14, v26, v12) )
          {
            if ( (unsigned int)BN_mod_mul((__int64)v14, *v6, (__int64)v14, v26, v12) )
            {
              v22 = EC_POINT_new(v8);
              if ( v22 )
              {
                if ( (unsigned int)EC_POINT_mul(v8, v22, (__int64)v13, v10, (__int64)v14) )
                {
                  if ( (unsigned int)EC_POINT_get_affine_coordinates_GFp((__int64)v8, v22) )
                  {
                    if ( (unsigned int)BN_nnmod((__int64)v13, v17, v26, v12) )
                    {
                      v23 = (unsigned __int64)BN_ucmp((__int64)v13, *v6) == 0;
                      goto LABEL_24;
                    }
                    v24 = 3;
                    v25 = 215;
                  }
                  else
                  {
                    v24 = 15;
                    v25 = 211;
                  }
                }
                else
                {
                  v24 = 15;
                  v25 = 207;
                }
              }
              else
              {
                v24 = 65;
                v25 = 203;
              }
              ERR_put_error(26, 0LL, v24, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v25);
              goto LABEL_24;
            }
            v18 = 3;
            v19 = 197;
          }
          else
          {
            v18 = 3;
            v19 = 192;
          }
        }
        else
        {
          v18 = 3;
          v19 = 184;
        }
      }
      else
      {
        v18 = 3;
        v19 = 169;
      }
      ERR_put_error(26, 0LL, v18, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v19);
LABEL_23:
      v22 = 0LL;
LABEL_24:
      BN_CTX_end(v12);
      BN_CTX_free(v12);
      EC_POINT_free((__int64)v22);
      goto LABEL_18;
    }
    v20 = 65;
    v21 = 160;
  }
  else
  {
    v20 = 101;
    v21 = 154;
  }
  ERR_put_error(26, 0LL, v20, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v21);
LABEL_18:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v28;
}

//----- (0000000000085260) ----------------------------------------------------
void __fastcall ECDSA_do_sign(unsigned __int8 *a1, size_t a2, __int64 a3)
{
  ECDSA_do_sign_ex(a1, a2, 0LL, 0LL, a3);
}

//----- (0000000000085274) ----------------------------------------------------
void __fastcall ECDSA_do_sign_ex(unsigned __int8 *a1, size_t a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x24
  __int64 v6; // x25
  __int64 v7; // x26
  __int64 v8; // x8
  size_t v9; // x27
  unsigned __int8 *v10; // x28
  int v11; // w2
  __int16 v12; // w4
  __int64 v13; // x21
  __int64 v14; // x0
  __int64 v15; // x23
  void ***v16; // x0
  void ***v17; // x19
  __int64 v18; // x22
  _DWORD *v19; // x20
  void **v20; // x22
  __int64 v21; // x21
  void **v22; // x21
  int v23; // w2
  __int16 v24; // w4
  void **v25; // x23
  __int64 v26; // [xsp+8h] [xbp-A8h]
  __int64 v27; // [xsp+10h] [xbp-A0h]
  __int64 v28; // [xsp+20h] [xbp-90h]
  __int64 v29; // [xsp+38h] [xbp-78h]
  void **v30; // [xsp+40h] [xbp-70h]
  __int64 v31; // [xsp+48h] [xbp-68h]
  void **v32; // [xsp+50h] [xbp-60h]
  __int64 v33; // [xsp+58h] [xbp-58h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v33 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v32 = 0LL;
  v8 = *(_QWORD *)(a5 + 40);
  v9 = a2;
  v10 = a1;
  if ( v8 && *(_QWORD *)(v8 + 40) )
  {
    v11 = 103;
    v12 = 359;
LABEL_24:
    ERR_put_error(26, 0LL, v11, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v12);
    goto LABEL_30;
  }
  v13 = lh_num_items(a5);
  v14 = X509_TRUST_get0_name(v5);
  v15 = v14;
  if ( !v13 || !v14 )
  {
    v11 = 67;
    v12 = 367;
    goto LABEL_24;
  }
  v16 = (void ***)ECDSA_SIG_new();
  v17 = v16;
  if ( !v16 )
  {
    ERR_put_error(26, 0LL, 65, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 373);
    goto LABEL_30;
  }
  v18 = (__int64)v16[1];
  v19 = BN_CTX_new();
  if ( !v19 || (v30 = (void **)BN_new()) == 0LL )
  {
    v22 = 0LL;
LABEL_26:
    ERR_put_error(26, 0LL, 65, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 381);
    v25 = 0LL;
    v20 = 0LL;
    goto LABEL_27;
  }
  v26 = v18;
  v20 = (void **)BN_new();
  if ( !v20 )
  {
    v22 = v30;
    goto LABEL_26;
  }
  v21 = EC_GROUP_get0_order(v13);
  if ( !(unsigned int)sub_85618((__int64)v20, v10, v9, v21) )
  {
    v25 = 0LL;
LABEL_34:
    v22 = v30;
    goto LABEL_27;
  }
  v27 = 0LL;
  v28 = v21;
  v22 = v30;
  v31 = (__int64)v19;
  while ( v7 == 0 || v6 == 0 )
  {
    if ( !(unsigned int)sub_856F4(v5, v19, &v32, v17, (unsigned __int64 *)v10, v9) )
    {
      ERR_put_error(26, 0LL, 26, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 393);
      v25 = v32;
      goto LABEL_34;
    }
    v27 = (__int64)v32;
    v29 = (__int64)v32;
LABEL_17:
    if ( !(unsigned int)BN_mod_mul((__int64)v30, v15, (__int64)*v17, v28, v31) )
    {
      ERR_put_error(26, 0LL, 3, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 406);
      v19 = (_DWORD *)v31;
      goto LABEL_43;
    }
    if ( !(unsigned int)BN_mod_add_quick(v26, (__int64)v30, (__int64)v20, v28) )
    {
      ERR_put_error(26, 0LL, 3, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 410);
      v19 = (_DWORD *)v31;
      goto LABEL_42;
    }
    v19 = (_DWORD *)v31;
    if ( !(unsigned int)BN_mod_mul(v26, v26, v29, v28, v31) )
    {
      v23 = 3;
      v24 = 414;
      goto LABEL_41;
    }
    if ( !BN_is_zero(v26) )
    {
      v22 = v30;
      v25 = (void **)v27;
      goto LABEL_28;
    }
    if ( v7 != 0 && v6 != 0 )
    {
      v23 = 102;
      v24 = 421;
      goto LABEL_41;
    }
  }
  if ( BN_copy((__int64)*v17, v6) )
  {
    v29 = v7;
    goto LABEL_17;
  }
  v23 = 65;
  v24 = 400;
LABEL_41:
  ERR_put_error(26, 0LL, v23, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v24);
LABEL_42:
  v22 = v30;
LABEL_43:
  v25 = (void **)v27;
LABEL_27:
  ECDSA_SIG_free((_DWORD **)v17);
LABEL_28:
  BN_CTX_free((__int64)v19);
  BN_clear_free(v20);
  BN_clear_free(v22);
  BN_clear_free(v25);
LABEL_30:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v33;
}

//----- (0000000000085618) ----------------------------------------------------
signed __int64 __fastcall sub_85618(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  unsigned __int8 *v6; // x21
  unsigned int v7; // w0
  unsigned __int64 v8; // x22
  __int16 v10; // w4

  v4 = a1;
  v5 = a3;
  v6 = a2;
  v7 = BN_num_bits(a4);
  v8 = v7;
  if ( 8 * v5 > (unsigned __int64)v7 )
    v5 = ((unsigned __int64)v7 + 7) >> 3;
  if ( BN_bin2bn(v6, v5, v4) )
  {
    if ( 8 * v5 <= v8 )
      return 1LL;
    if ( (unsigned int)BN_rshift(v4, v4, 8 - (unsigned int)(v8 & 7)) )
      return 1LL;
    v10 = 129;
  }
  else
  {
    v10 = 122;
  }
  ERR_put_error(26, 0LL, 3, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v10);
  return 0LL;
}

//----- (00000000000856E8) ----------------------------------------------------
__int64 __fastcall ECDSA_sign_setup(__int64 a1, _DWORD *a2, void ***a3, void ***a4)
{
  return sub_856F4(a1, a2, a3, a4, 0LL, 0LL);
}

//----- (00000000000856F4) ----------------------------------------------------
__int64 __fastcall sub_856F4(__int64 a1, _DWORD *a2, void ***a3, void ***a4, unsigned __int64 *a5, size_t a6)
{
  size_t v6; // x27
  unsigned __int64 *v7; // x28
  void ***v8; // x26
  void ***v9; // x23
  _DWORD *v10; // x19
  __int64 v11; // x21
  _DWORD *v12; // x20
  void **v13; // x22
  void **v14; // x24
  void **v15; // x0
  void **v16; // x25
  __int64 *v17; // x23
  _QWORD *v18; // x26
  __int64 v19; // x24
  __int64 *v20; // x0
  int v21; // w0
  unsigned int v22; // w25
  __int64 v23; // x0
  unsigned int v24; // w21
  int v25; // w2
  __int16 v26; // w4
  int v27; // w2
  __int16 v28; // w4
  void ***v30; // [xsp+8h] [xbp-78h]
  void ***v31; // [xsp+10h] [xbp-70h]
  __int64 v32; // [xsp+18h] [xbp-68h]
  __int64 v33; // [xsp+20h] [xbp-60h]
  __int64 *v34; // [xsp+28h] [xbp-58h]

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  if ( !a1 || (v34 = (__int64 *)lh_num_items(a1)) == 0LL )
  {
    v25 = 67;
    v26 = 238;
LABEL_26:
    ERR_put_error(26, 0LL, v25, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v26);
    return 0;
  }
  v12 = v10;
  if ( !v10 )
  {
    v12 = BN_CTX_new();
    if ( !v12 )
    {
      v25 = 65;
      v26 = 244;
      goto LABEL_26;
    }
  }
  v13 = (void **)BN_new();
  v14 = (void **)BN_new();
  v15 = (void **)BN_new();
  v16 = v15;
  if ( !v13 || !v14 || !v15 )
  {
    ERR_put_error(26, 0LL, 65, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 255);
    v18 = 0LL;
    goto LABEL_31;
  }
  v30 = v8;
  v31 = v9;
  v17 = v34;
  v18 = EC_POINT_new(v34);
  if ( !v18 )
  {
    ERR_put_error(26, 0LL, 15, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 260);
    goto LABEL_31;
  }
  v33 = (__int64)v14;
  v19 = EC_GROUP_get0_order((__int64)v34);
  v32 = (__int64)v16;
  while ( 1 )
  {
    if ( v6 )
    {
      while ( 1 )
      {
        v20 = (__int64 *)X509_TRUST_get0_name(v11);
        BN_generate_dsa_nonce((__int64)v13, v19, v20, v7, v6);
        if ( !v21 )
          break;
        if ( !BN_is_zero((__int64)v13) )
          goto LABEL_15;
      }
      v27 = 104;
      v28 = 274;
      goto LABEL_29;
    }
    if ( !(unsigned int)BN_rand_range_ex((__int64)v13, 1uLL, v19) )
    {
      v27 = 104;
      v28 = 279;
      goto LABEL_29;
    }
LABEL_15:
    if ( !(unsigned int)BN_add((__int64)v13, (__int64)v13, v19) )
    {
      v14 = (void **)v33;
      goto LABEL_31;
    }
    v22 = BN_num_bits((__int64)v13);
    if ( v22 <= (unsigned int)BN_num_bits(v19) && !(unsigned int)BN_add((__int64)v13, (__int64)v13, v19) )
      goto LABEL_38;
    if ( !(unsigned int)EC_POINT_mul(v17, v18, (__int64)v13, 0LL, 0LL) )
      break;
    v16 = (void **)v32;
    if ( !(unsigned int)EC_POINT_get_affine_coordinates_GFp((__int64)v17, v18) )
    {
      v27 = 15;
      v28 = 303;
      goto LABEL_29;
    }
    if ( !(unsigned int)BN_nnmod(v33, v32, v19, (__int64)v12) )
    {
      ERR_put_error(26, 0LL, 3, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 308);
      v14 = (void **)v33;
      v16 = (void **)v32;
      goto LABEL_31;
    }
    v16 = (void **)v32;
    v17 = v34;
    if ( !BN_is_zero(v33) )
    {
      v23 = sub_73140((__int64)v34);
      if ( (unsigned int)sub_69FB8((__int64)v13, (__int64)v13, v19, (__int64)v12, v23) )
      {
        BN_clear_free(*v30);
        BN_clear_free(*v31);
        *v30 = (void **)v33;
        *v31 = v13;
        v24 = 1;
        if ( v10 )
          goto LABEL_33;
        goto LABEL_32;
      }
      v27 = 3;
      v28 = 317;
LABEL_29:
      ERR_put_error(26, 0LL, v27, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", v28);
      v14 = (void **)v33;
      goto LABEL_31;
    }
  }
  ERR_put_error(26, 0LL, 15, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa.c", 298);
LABEL_38:
  v16 = (void **)v32;
  v14 = (void **)v33;
LABEL_31:
  BN_clear_free(v13);
  BN_clear_free(v14);
  v24 = 0;
  if ( !v10 )
LABEL_32:
    BN_CTX_free((__int64)v12);
LABEL_33:
  EC_POINT_free((__int64)v18);
  BN_clear_free(v16);
  return v24;
}

//----- (0000000000085AA8) ----------------------------------------------------
__int64 __fastcall ECDSA_size(__int64 result)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x8
  unsigned __int64 v3; // x0
  __int64 v4; // x0
  unsigned __int64 v5; // x9
  signed __int64 v6; // x8
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x8
  signed __int64 v9; // x9
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x9

  if ( result )
  {
    v1 = *(_QWORD *)(result + 40);
    if ( v1 && (v2 = *(__int64 (**)(void))(v1 + 32)) != 0LL )
    {
      v3 = v2();
    }
    else
    {
      result = lh_num_items(result);
      if ( !result )
        return result;
      v4 = EC_GROUP_get0_order(result);
      v3 = (unsigned int)BN_num_bytes(v4);
    }
    v5 = v3 + 1;
    v6 = 1LL;
    if ( v3 + 1 >= 0x80 )
    {
      do
      {
        ++v6;
        v5 >>= 8;
      }
      while ( v5 );
    }
    v7 = v3 + v6 + 2;
    if ( v7 >= v3 )
    {
      v8 = 2 * v7;
      if ( 2 * v7 >= v7 )
      {
        v9 = 1LL;
        if ( v8 >= 0x80 )
        {
          v10 = v8;
          do
          {
            ++v9;
            v10 >>= 8;
          }
          while ( v10 );
        }
        v11 = v9 + (v8 | 1);
        if ( v11 >= v8 )
          result = v11;
        else
          result = 0LL;
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000085B64) ----------------------------------------------------
unsigned __int64 __fastcall ECDSA_SIG_max_len(unsigned __int64 a1)
{
  unsigned __int64 v1; // x9
  signed __int64 v2; // x8
  unsigned __int64 v3; // x9
  unsigned __int64 result; // x0
  unsigned __int64 v5; // x8
  signed __int64 v6; // x9
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x9

  v1 = a1 + 1;
  v2 = 1LL;
  if ( a1 + 1 >= 0x80 )
  {
    do
    {
      ++v2;
      v1 >>= 8;
    }
    while ( v1 );
  }
  v3 = a1 + v2 + 2;
  if ( v3 < a1 )
    return 0LL;
  v5 = 2 * v3;
  if ( 2 * v3 < v3 )
    return 0LL;
  v6 = 1LL;
  if ( v5 >= 0x80 )
  {
    v7 = v5;
    do
    {
      ++v6;
      v7 >>= 8;
    }
    while ( v7 );
  }
  v8 = (v5 | 1) + v6;
  if ( v8 >= v5 )
    result = v8;
  else
    result = 0LL;
  return result;
}

//----- (0000000000085BDC) ----------------------------------------------------
_QWORD *ECDSA_SIG_new()
{
  _QWORD *v0; // x19
  _QWORD *v1; // x0
  _DWORD *v2; // x20
  _QWORD *v3; // x0
  _DWORD *v4; // x21

  v0 = malloc(0x10uLL);
  if ( v0 )
  {
    v1 = BN_new();
    v2 = v1;
    *v0 = v1;
    v3 = BN_new();
    v4 = v3;
    v0[1] = v3;
    if ( !v2 || !v3 )
    {
      BN_free(v2);
      BN_free(v4);
      free(v0);
      v0 = 0LL;
    }
  }
  return v0;
}

//----- (0000000000085C4C) ----------------------------------------------------
void __fastcall ECDSA_SIG_parse(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // x20
  __int64 *v2; // x19
  int v3; // w0
  _DWORD *v4; // x20
  unsigned __int8 *v5[2]; // [xsp+8h] [xbp-28h]
  __int64 v6; // [xsp+18h] [xbp-18h]

  v1 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = ECDSA_SIG_new();
  if ( v2 )
  {
    v3 = CBS_get_asn1(v1, (char *)v5, 48);
    v4 = (_DWORD *)*v2;
    if ( !v3
      || !BN_parse_asn1_unsigned(v5, *v2)
      || !BN_parse_asn1_unsigned(v5, v2[1])
      || EVP_CIPHER_CTX_get_app_data((__int64)v5) )
    {
      ERR_put_error(26, 0LL, 100, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa_asn1.c", 122);
      BN_free(v4);
      BN_free((_DWORD *)v2[1]);
      free(v2);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000085D20) ----------------------------------------------------
void __fastcall ECDSA_SIG_from_bytes(__int64 a1, __int64 a2)
{
  _DWORD **v2; // x0
  _DWORD **v3; // x19
  unsigned __int8 *v4[2]; // [xsp+8h] [xbp-28h]
  __int64 v5; // [xsp+18h] [xbp-18h]

  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CBS_init(v4, a1, a2);
  ECDSA_SIG_parse(v4);
  v3 = v2;
  if ( v2 )
  {
    if ( EVP_CIPHER_CTX_get_app_data((__int64)v4) )
    {
      ERR_put_error(26, 0LL, 100, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa_asn1.c", 134);
      BN_free(*v3);
      BN_free(v3[1]);
      free(v3);
    }
  }
  else
  {
    ERR_put_error(26, 0LL, 100, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa_asn1.c", 134);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000085DF4) ----------------------------------------------------
signed __int64 __fastcall ECDSA_SIG_marshal(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // x20
  __int64 *v3; // x19
  signed __int64 result; // x0
  char v5; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_add_asn1(a1, (__int64 *)&v5, 0x30u)
    && (unsigned int)BN_marshal_asn1((__int64 *)&v5, *v2)
    && (unsigned int)BN_marshal_asn1((__int64 *)&v5, v2[1])
    && (unsigned int)CBB_flush(v3) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(26, 0LL, 105, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa_asn1.c", 147);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000085EA4) ----------------------------------------------------
signed __int64 __fastcall ECDSA_SIG_to_bytes(_QWORD *a1, _QWORD *a2, __int64 *a3)
{
  _QWORD *v3; // x20
  __int64 *v4; // x21
  _QWORD *v5; // x19
  signed __int64 result; // x0
  __int64 v7[4]; // [xsp+8h] [xbp-48h]
  __int64 v8; // [xsp+28h] [xbp-28h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(v7);
  if ( (unsigned int)CBB_init(v7, 0LL)
    && (unsigned int)ECDSA_SIG_marshal(v7, v4)
    && (unsigned int)CBB_finish((__int64)v7, v3, v5) )
  {
    result = 1LL;
  }
  else
  {
    ERR_put_error(26, 0LL, 105, (__int64)"external/boringssl/src/crypto/ecdsa/ecdsa_asn1.c", 160);
    CBB_cleanup(v7);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000085F68) ----------------------------------------------------
void __fastcall d2i_ECDSA_SIG(_DWORD ***a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x19
  _DWORD ***v4; // x21
  _DWORD **v5; // x0
  _DWORD **v6; // x20
  _DWORD **v7; // x22
  unsigned __int8 *v8[2]; // [xsp+8h] [xbp-38h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(a3 & 0x8000000000000000LL) )
  {
    CBS_init(v8, *a2, a3);
    ECDSA_SIG_parse(v8);
    v6 = v5;
    if ( v5 )
    {
      if ( v4 )
      {
        v7 = *v4;
        if ( *v4 )
        {
          BN_free(*v7);
          BN_free(v7[1]);
          free(v7);
        }
        *v4 = v6;
      }
      *v3 = lh_num_items((__int64)v8);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000008601C) ----------------------------------------------------
signed __int64 __fastcall i2d_ECDSA_SIG(__int64 *a1, void **a2)
{
  void **v2; // x19
  __int64 *v3; // x20
  signed __int64 result; // x0
  __int64 v5[4]; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBB_init(v5, 0LL) && (unsigned int)ECDSA_SIG_marshal(v5, v3) )
  {
    result = sub_6F744((__int64)v5, v2);
  }
  else
  {
    CBB_cleanup(v5);
    result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000860A8) ----------------------------------------------------
signed __int64 __fastcall ENGINE_set_RSA_method(_QWORD *a1, __int64 a2, __int64 a3)
{
  if ( a3 != 144 )
    return 0LL;
  if ( !*(_BYTE *)(a2 + 4) )
    return 0LL;
  *a1 = a2;
  return 1LL;
}

//----- (00000000000860D4) ----------------------------------------------------
signed __int64 __fastcall ENGINE_set_ECDSA_method(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a3 != 64 )
    return 0LL;
  if ( !*(_BYTE *)(a2 + 4) )
    return 0LL;
  *(_QWORD *)(a1 + 8) = a2;
  return 1LL;
}

//----- (0000000000086100) ----------------------------------------------------
__int64 __fastcall CRYPTO_get_ex_new_index(pthread_rwlock_t *a1, _DWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  pthread_rwlock_t *v6; // x19
  __int64 v7; // x22
  __int64 v8; // x23
  __int64 v9; // x24
  __int64 v10; // x25
  _DWORD *v11; // x20
  _QWORD *v12; // x21
  unsigned __int64 *v13; // x0
  unsigned int v14; // w20

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  v12 = malloc(0x20uLL);
  if ( v12 )
  {
    *v12 = v10;
    v12[1] = v9;
    v12[2] = v7;
    v12[3] = v8;
    CRYPTO_STATIC_MUTEX_lock_write(v6);
    v13 = (unsigned __int64 *)v6[1].__align;
    if ( (v13 || (v13 = sk_new_null(), (v6[1].__align = (__int64)v13) != 0)) && sk_push(v13, (__int64)v12) )
    {
      *v11 = (_QWORD *)((char *)sk_num((_QWORD *)v6[1].__align) + (unsigned __int8)v6[1].__size[8] - 1);
      v14 = 1;
    }
    else
    {
      ERR_put_error(14, 0LL, 65, (__int64)"external/boringssl/src/crypto/ex_data.c", 156);
      free(v12);
      v14 = 0;
    }
    CRYPTO_STATIC_MUTEX_unlock_write(v6);
  }
  else
  {
    ERR_put_error(14, 0LL, 65, (__int64)"external/boringssl/src/crypto/ex_data.c", 139);
    v14 = 0;
  }
  return v14;
}

//----- (0000000000086200) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_set_ex_data(unsigned __int64 **a1, int a2, __int64 a3)
{
  unsigned __int64 **v3; // x21
  unsigned __int64 *v4; // x0
  __int64 v5; // x19
  int v6; // w20
  int v7; // w0
  unsigned __int64 *v8; // x8
  int v9; // w22
  __int16 v11; // w4

  v3 = a1;
  v4 = *a1;
  v5 = a3;
  v6 = a2;
  if ( v4 || (v4 = sk_new_null(), (*v3 = v4) != 0LL) )
  {
    v7 = (unsigned __int64)sk_num(v4);
    v8 = *v3;
    if ( v7 > v6 )
    {
LABEL_7:
      sk_set(v8, v6, v5);
      return 1LL;
    }
    v9 = v7 - 1;
    while ( sk_push(v8, 0LL) )
    {
      v8 = *v3;
      if ( ++v9 >= v6 )
        goto LABEL_7;
    }
    v11 = 186;
  }
  else
  {
    v11 = 176;
  }
  ERR_put_error(14, 0LL, 65, (__int64)"external/boringssl/src/crypto/ex_data.c", v11);
  return 0LL;
}

//----- (00000000000862C4) ----------------------------------------------------
unsigned __int64 *__fastcall CRYPTO_get_ex_data(unsigned __int64 **a1, int a2)
{
  unsigned __int64 **v2; // x19
  unsigned __int64 *v3; // x0
  unsigned __int64 v4; // x20
  unsigned __int64 *result; // x0

  v2 = a1;
  if ( a2 & 0x80000000 || (v3 = *a1, !*v2) || (v4 = a2, a2 >= (unsigned __int64)sk_num(v3)) )
    result = 0LL;
  else
    result = sk_value(*v2, v4);
  return result;
}

//----- (0000000000086314) ----------------------------------------------------
_QWORD *__fastcall CRYPTO_new_ex_data(_QWORD *result)
{
  *result = 0LL;
  return result;
}

//----- (000000000008631C) ----------------------------------------------------
signed __int64 __fastcall CRYPTO_dup_ex_data(pthread_rwlock_t *a1, unsigned __int64 **a2, unsigned __int64 **a3)
{
  unsigned __int64 **v3; // x19
  unsigned __int64 **v4; // x20
  pthread_rwlock_t *v5; // x21
  signed __int64 result; // x0
  unsigned __int64 *v7; // x22
  unsigned __int64 v8; // x23
  unsigned __int64 *v9; // x24
  unsigned __int64 *v10; // x2
  int v11; // w8
  unsigned __int64 v12; // x25
  void (__fastcall *v13)(unsigned __int64 **, unsigned __int64 **, unsigned __int64 **, _QWORD, unsigned __int64, unsigned __int64); // x8
  unsigned __int64 *v14; // [xsp+8h] [xbp-58h]
  unsigned __int64 *v15; // [xsp+10h] [xbp-50h]
  __int64 v16; // [xsp+18h] [xbp-48h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !*a3 )
  {
LABEL_14:
    result = 1LL;
    goto LABEL_15;
  }
  result = sub_8645C(&v15, a1);
  if ( (_DWORD)result )
  {
    v7 = v15;
    if ( sk_num(v15) )
    {
      v8 = 0LL;
      do
      {
        v9 = sk_value(v7, v8);
        v10 = 0LL;
        if ( *v3 )
        {
          v11 = v8 + (unsigned __int8)v5[1].__size[8];
          if ( !(v11 & 0x80000000) )
          {
            v12 = v11;
            if ( v11 >= (unsigned __int64)sk_num(*v3) )
              v10 = 0LL;
            else
              v10 = sk_value(*v3, v12);
          }
        }
        v14 = v10;
        v13 = (void (__fastcall *)(unsigned __int64 **, unsigned __int64 **, unsigned __int64 **, _QWORD, unsigned __int64, unsigned __int64))v9[3];
        if ( v13 )
        {
          v13(v4, v3, &v14, (unsigned int)v8 + (unsigned __int8)v5[1].__size[8], *v9, v9[1]);
          v10 = v14;
        }
        CRYPTO_set_ex_data(v4, v8++ + (unsigned __int8)v5[1].__size[8], (__int64)v10);
      }
      while ( v8 < (unsigned __int64)sk_num(v7) );
    }
    sk_free((void **)v7);
    goto LABEL_14;
  }
LABEL_15:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000008645C) ----------------------------------------------------
signed __int64 __fastcall sub_8645C(_QWORD *a1, pthread_rwlock_t *a2)
{
  pthread_rwlock_t *v2; // x19
  _QWORD *v3; // x20

  v2 = a2;
  v3 = a1;
  *a1 = 0LL;
  CRYPTO_STATIC_MUTEX_lock_read(a2);
  if ( sk_num((_QWORD *)v2[1].__align) )
  {
    *v3 = sk_dup(v2[1].__align);
    CRYPTO_STATIC_MUTEX_unlock_write(v2);
    if ( !*v3 )
    {
      ERR_put_error(14, 0LL, 65, (__int64)"external/boringssl/src/crypto/ex_data.c", 223);
      return 0LL;
    }
  }
  else
  {
    CRYPTO_STATIC_MUTEX_unlock_write(v2);
  }
  return 1LL;
}

//----- (00000000000864E0) ----------------------------------------------------
void __fastcall CRYPTO_free_ex_data(pthread_rwlock_t *a1, __int64 a2, unsigned __int64 **a3)
{
  unsigned __int64 **v3; // x19
  __int64 v4; // x20
  pthread_rwlock_t *v5; // x21
  unsigned __int64 *v6; // x22
  unsigned __int64 v7; // x23
  unsigned __int64 *v8; // x24
  unsigned __int64 *v9; // x1
  int v10; // w8
  unsigned __int64 v11; // x25
  unsigned __int64 *v12; // [xsp+0h] [xbp-50h]
  __int64 v13; // [xsp+8h] [xbp-48h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *a3 && (unsigned int)sub_8645C(&v12, a1) )
  {
    v6 = v12;
    if ( sk_num(v12) )
    {
      v7 = 0LL;
      do
      {
        v8 = sk_value(v6, v7);
        if ( v8[2] )
        {
          v9 = 0LL;
          if ( *v3 )
          {
            v10 = v7 + (unsigned __int8)v5[1].__size[8];
            if ( !(v10 & 0x80000000) )
            {
              v11 = v10;
              if ( v10 >= (unsigned __int64)sk_num(*v3) )
                v9 = 0LL;
              else
                v9 = sk_value(*v3, v11);
            }
          }
          ((void (__fastcall *)(__int64, unsigned __int64 *, unsigned __int64 **, _QWORD, unsigned __int64, unsigned __int64))v8[2])(
            v4,
            v9,
            v3,
            (unsigned int)v7 + (unsigned __int8)v5[1].__size[8],
            *v8,
            v8[1]);
        }
        ++v7;
      }
      while ( v7 < (unsigned __int64)sk_num(v6) );
    }
    sk_free((void **)v6);
    sk_free((void **)*v3);
    *v3 = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000086610) ----------------------------------------------------
__int64 *__fastcall OBJ_dup(__int64 a1)
{
  __int64 v1; // x20
  __int64 *v2; // x19
  __int64 *v3; // x0
  size_t v4; // x22
  void *v5; // x0
  void *v6; // x21
  const void *v7; // x1
  void *v8; // x22
  __int64 v9; // x0

  v1 = a1;
  if ( !a1 )
    return 0LL;
  if ( *(_BYTE *)(a1 + 32) & 1 )
  {
    v3 = ASN1_OBJECT_new();
    v2 = v3;
    if ( !v3 )
    {
      ERR_put_error(8, 0LL, 12, (__int64)"external/boringssl/src/crypto/obj/obj.c", 116);
      return v2;
    }
    *v3 = 0LL;
    v3[1] = 0LL;
    v4 = *(signed int *)(v1 + 20);
    v5 = malloc(v4);
    v6 = v5;
    if ( v5 )
    {
      if ( (_DWORD)v4 )
      {
        v7 = *(const void **)(v1 + 24);
        if ( v7 )
          memcpy(v5, v7, v4);
      }
      v2[3] = (__int64)v6;
      *((_DWORD *)v2 + 5) = *(_DWORD *)(v1 + 20);
      *((_DWORD *)v2 + 4) = *(_DWORD *)(v1 + 16);
      if ( *(_QWORD *)(v1 + 8) )
      {
        v8 = (void *)OPENSSL_strdup();
        if ( !v8 )
          goto LABEL_18;
      }
      else
      {
        v8 = 0LL;
      }
      v9 = *(_QWORD *)v1;
      if ( !*(_QWORD *)v1 || (v9 = OPENSSL_strdup()) != 0 )
      {
        *v2 = v9;
        v2[1] = (__int64)v8;
        *((_DWORD *)v2 + 8) = *(_DWORD *)(v1 + 32) | 0xD;
        return v2;
      }
      goto LABEL_18;
    }
    v8 = 0LL;
LABEL_18:
    ERR_put_error(8, 0LL, 65, (__int64)"external/boringssl/src/crypto/obj/obj.c", 157);
    free(v8);
    free(v6);
    free(v2);
    return 0LL;
  }
  return (__int64 *)a1;
}
// 4BCA8: using guessed type __int64 OPENSSL_strdup(void);

//----- (0000000000086740) ----------------------------------------------------
__int64 __fastcall OBJ_cmp(__int64 a1, __int64 a2)
{
  size_t v2; // x2

  v2 = *(signed int *)(a1 + 20);
  if ( (_DWORD)v2 != *(_DWORD *)(a2 + 20) )
    return (unsigned int)(v2 - *(_DWORD *)(a2 + 20));
  if ( (_DWORD)v2 )
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2);
  return 0LL;
}

//----- (0000000000086774) ----------------------------------------------------
unsigned int *__fastcall OBJ_obj2nid(unsigned int *a1)
{
  unsigned int *v1; // x19
  unsigned int *result; // x0
  __int64 v3; // x20

  v1 = a1;
  if ( !a1 )
    return 0LL;
  result = (unsigned int *)a1[4];
  if ( !(_DWORD)result )
  {
    CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_107238);
    if ( qword_107270 && (v3 = lh_retrieve(qword_107270, (__int64)v1)) != 0 )
    {
      CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
      result = (unsigned int *)*(unsigned int *)(v3 + 16);
    }
    else
    {
      CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
      result = (unsigned int *)bsearch(v1, &unk_D8FB0, 0x36CuLL, 4uLL, (__compar_fn_t)sub_86828);
      if ( result )
        result = (unsigned int *)LODWORD(off_F81F8[5 * *result + 2]);
    }
  }
  return result;
}
// F81F8: using guessed type char *off_F81F8[2];
// 107270: using guessed type __int64 qword_107270;

//----- (0000000000086828) ----------------------------------------------------
__int64 __fastcall sub_86828(__int64 a1, unsigned int *a2)
{
  __int64 v2; // x8
  size_t v3; // x2
  signed int v4; // w10

  v2 = *a2;
  v3 = *(signed int *)(a1 + 20);
  v4 = HIDWORD(off_F81F8[5 * v2 + 2]);
  if ( (signed int)v3 < v4 )
    return 0xFFFFFFFFLL;
  if ( (signed int)v3 > v4 )
    return 1LL;
  if ( (_DWORD)v3 )
    return memcmp(*(const void **)(a1 + 24), off_F81F8[5 * v2 + 3], v3);
  return 0LL;
}
// F81F8: using guessed type char *off_F81F8[2];

//----- (0000000000086884) ----------------------------------------------------
unsigned int *__fastcall OBJ_cbs2nid(__int64 a1)
{
  __int64 v1; // x19
  unsigned int *result; // x0
  __int64 v3; // [xsp+0h] [xbp-40h]
  __int64 v4; // [xsp+8h] [xbp-38h]
  __int64 v5; // [xsp+10h] [xbp-30h]
  __int64 v6; // [xsp+18h] [xbp-28h]
  __int64 v7; // [xsp+20h] [xbp-20h]
  __int64 v8; // [xsp+28h] [xbp-18h]

  v1 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned __int64)EVP_CIPHER_CTX_get_app_data(a1) >> 31 )
  {
    result = 0LL;
  }
  else
  {
    v7 = 0LL;
    v4 = 0LL;
    v5 = 0LL;
    v3 = 0LL;
    v6 = lh_num_items(v1);
    HIDWORD(v5) = EVP_CIPHER_CTX_get_app_data(v1);
    result = OBJ_obj2nid((unsigned int *)&v3);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000008690C) ----------------------------------------------------
unsigned int *__fastcall OBJ_sn2nid(const void *a1)
{
  const void *v1; // x19
  __int64 v2; // x20
  unsigned int *result; // x0
  const void *v4; // [xsp+0h] [xbp-40h]
  __int64 v5; // [xsp+28h] [xbp-18h]

  v1 = a1;
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_107238);
  if ( qword_107278 && (v4 = v1, (v2 = lh_retrieve(qword_107278, (__int64)&v4)) != 0) )
  {
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
    result = (unsigned int *)*(unsigned int *)(v2 + 16);
  }
  else
  {
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
    result = (unsigned int *)bsearch(v1, &unk_D9D60, 0x3ABuLL, 4uLL, (__compar_fn_t)sub_869DC);
    if ( result )
      result = (unsigned int *)LODWORD(off_F81F8[5 * *result + 2]);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// F81F8: using guessed type char *off_F81F8[2];
// 107278: using guessed type __int64 qword_107278;

//----- (00000000000869DC) ----------------------------------------------------
__int64 __fastcall sub_869DC(const char *a1, unsigned int *a2)
{
  return strcmp(a1, off_F81F8[5 * *a2]);
}
// F81F8: using guessed type char *off_F81F8[2];

//----- (00000000000869F8) ----------------------------------------------------
unsigned int *__fastcall OBJ_ln2nid(const void *a1)
{
  const void *v1; // x19
  __int64 v2; // x20
  unsigned int *result; // x0
  __int64 v4; // [xsp+0h] [xbp-40h]
  const void *v5; // [xsp+8h] [xbp-38h]
  __int64 v6; // [xsp+28h] [xbp-18h]

  v1 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_107238);
  if ( qword_107280 && (v5 = v1, (v2 = lh_retrieve(qword_107280, (__int64)&v4)) != 0) )
  {
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
    result = (unsigned int *)*(unsigned int *)(v2 + 16);
  }
  else
  {
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
    result = (unsigned int *)bsearch(v1, &unk_DAC0C, 0x3ABuLL, 4uLL, (__compar_fn_t)sub_86AC8);
    if ( result )
      result = (unsigned int *)LODWORD(off_F81F8[5 * *result + 2]);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// F81F8: using guessed type char *off_F81F8[2];
// 107280: using guessed type __int64 qword_107280;

//----- (0000000000086AC8) ----------------------------------------------------
__int64 __fastcall sub_86AC8(const char *a1, unsigned int *a2)
{
  return strcmp(a1, off_F81F8[5 * *a2 + 1]);
}
// F81F8: using guessed type char *off_F81F8[2];

//----- (0000000000086AE4) ----------------------------------------------------
__int64 __fastcall OBJ_txt2nid(const char *a1)
{
  unsigned int *v1; // x0
  void **v2; // x19
  unsigned int v3; // w20

  OBJ_txt2obj(a1, 0);
  v2 = (void **)v1;
  v3 = (unsigned __int64)OBJ_obj2nid(v1);
  ASN1_OBJECT_free(v2);
  return v3;
}

//----- (0000000000086B1C) ----------------------------------------------------
void __fastcall OBJ_txt2obj(const char *a1, int a2)
{
  const char *v2; // x19
  signed int v3; // w0
  signed int v4; // w20
  size_t v5; // x22
  void *v6; // x21
  unsigned int v7; // w0
  void *v8; // [xsp+8h] [xbp-38h]
  __int64 v9; // [xsp+10h] [xbp-30h]
  __int64 v10; // [xsp+18h] [xbp-28h]

  v2 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 && ((v7 = (unsigned __int64)OBJ_sn2nid(a1)) != 0 || (v7 = (unsigned __int64)OBJ_ln2nid(v2)) != 0) )
  {
    OBJ_nid2obj(v7);
  }
  else
  {
    a2d_ASN1_OBJECT(0LL, 0, v2, -1);
    v4 = v3;
    if ( v3 >= 1 )
    {
      v5 = (signed int)ASN1_object_size(0, v3, 6);
      v6 = malloc(v5);
      if ( v6 )
      {
        v9 = (__int64)v6;
        ASN1_put_object((_BYTE **)&v9, 0, v4, 6, 0);
        a2d_ASN1_OBJECT(v9, v4, v2, -1);
        v8 = v6;
        d2i_ASN1_OBJECT(0LL, (__int64 *)&v8, v5);
        free(v6);
      }
      else
      {
        ERR_put_error(8, 0LL, 65, (__int64)"external/boringssl/src/crypto/obj/obj.c", 405);
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000086C50) ----------------------------------------------------
signed __int64 __fastcall OBJ_nid2cbb(__int64 *a1, unsigned int a2)
{
  __int64 *v2; // x19
  __int64 v3; // x0
  __int64 v4; // x20
  signed __int64 result; // x0
  char **v6[4]; // [xsp+8h] [xbp-38h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  OBJ_nid2obj(a2);
  v4 = v3;
  if ( v3 )
  {
    result = CBB_add_asn1(v2, (__int64 *)v6, 6u);
    if ( (_DWORD)result )
    {
      result = CBB_add_bytes(v6, *(const void **)(v4 + 24), *(signed int *)(v4 + 20));
      if ( (_DWORD)result )
        result = (unsigned int)CBB_flush(v2) != 0;
    }
  }
  else
  {
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000086CE8) ----------------------------------------------------
void __fastcall OBJ_nid2obj(unsigned int a1)
{
  int v1; // w19
  __int64 v2; // [xsp+0h] [xbp-40h]
  int v3; // [xsp+10h] [xbp-30h]
  __int64 v4; // [xsp+28h] [xbp-18h]

  v1 = a1;
  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 > 0x3B4 )
  {
    CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_107238);
    if ( qword_107288 )
    {
      v3 = v1;
      if ( lh_retrieve(qword_107288, (__int64)&v2) )
      {
        CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
        goto LABEL_10;
      }
    }
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
LABEL_9:
    ERR_put_error(8, 0LL, 100, (__int64)"external/boringssl/src/crypto/obj/obj.c", 354);
    goto LABEL_10;
  }
  if ( a1 && !LODWORD(off_F81F8[5 * (signed int)a1 + 2]) )
    goto LABEL_9;
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// F81F8: using guessed type char *off_F81F8[2];
// 107288: using guessed type __int64 qword_107288;

//----- (0000000000086DD8) ----------------------------------------------------
void __fastcall OBJ_nid2sn(unsigned int a1)
{
  __int64 *v1; // x0
  __int64 v2; // x0

  OBJ_nid2obj(a1);
  if ( v1 )
    v2 = *v1;
}

//----- (0000000000086DF4) ----------------------------------------------------
void __fastcall OBJ_nid2ln(unsigned int a1)
{
  __int64 v1; // x0
  __int64 v2; // x0

  OBJ_nid2obj(a1);
  if ( v1 )
    v2 = *(_QWORD *)(v1 + 8);
}

//----- (0000000000086E10) ----------------------------------------------------
void __fastcall OBJ_obj2txt(_BYTE *a1, signed int a2, unsigned int *a3, int a4)
{
  unsigned int *v4; // x21
  signed int v5; // w20
  _BYTE *v6; // x19
  unsigned __int64 v7; // x21
  int v8; // w0
  __int64 v9; // x4
  __int64 v10; // x5
  __int64 v11; // x6
  __int64 v12; // x7
  unsigned __int64 v13; // x23
  __int64 v14; // x4
  __int64 v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  __int64 v18; // x3
  unsigned __int64 v19; // x2
  const char *v20; // x1
  unsigned int v21; // w22
  __int64 v22; // x0
  const char **v23; // x0
  __int64 v24; // x0
  __int64 v25; // x0
  unsigned __int64 v26; // x23
  int v27; // w0
  __int64 v28; // x4
  __int64 v29; // x5
  __int64 v30; // x6
  __int64 v31; // x7
  __int64 v32; // x0
  unsigned __int64 v33; // x2
  __int64 v34; // [xsp+0h] [xbp-90h]
  char *v35; // [xsp+8h] [xbp-88h]
  char v36; // [xsp+10h] [xbp-80h]
  char **v37[4]; // [xsp+20h] [xbp-70h]
  unsigned __int8 v38; // [xsp+40h] [xbp-50h]
  __int64 v39; // [xsp+58h] [xbp-38h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v39 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a3 || !a3[5] )
  {
    if ( a2 <= 0 )
      v19 = 0LL;
    else
      v19 = (unsigned int)a2;
    v20 = (const char *)&unk_B8A4C;
    goto LABEL_18;
  }
  if ( !a4 )
  {
    v21 = (unsigned __int64)OBJ_obj2nid(a3);
    if ( v21 )
    {
      if ( (OBJ_nid2obj(v21), v22) && (v20 = *(const char **)(v22 + 8)) != 0LL
        || (OBJ_nid2obj(v21), v23) && (v20 = *v23) != 0LL )
      {
        if ( v5 <= 0 )
          v19 = 0LL;
        else
          v19 = (unsigned int)v5;
LABEL_18:
        if ( BUF_strlcpy(v6, v20, v19) >> 31 )
          ERR_put_error(8, 0LL, 69, (__int64)"external/boringssl/src/crypto/obj/obj.c", 425);
        goto LABEL_53;
      }
    }
  }
  if ( (unsigned int)CBB_init(v37, 0x20uLL) )
  {
    CBS_init(&v36, *((_QWORD *)v4 + 3), (signed int)v4[5]);
    v7 = 0LL;
    while ( 1 )
    {
      v8 = CBS_get_u8((__int64)&v36, &v38);
      if ( v7 >> 57 || !v8 || !v7 && v38 == 128 )
        break;
      v13 = v38 & 0x7F | (v7 << 7);
      v7 = v38 & 0x7F | (v7 << 7);
      if ( !(v38 & 0x80) )
      {
        if ( v13 < 0x50 )
        {
          BIO_snprintf(
            (__int64)&v38,
            24LL,
            (__int64)"%lu",
            (unsigned __int64)(v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL >> 64) >> 5,
            v9,
            v10,
            v11,
            v12,
            v34);
          v24 = __strlen_chk();
          if ( !(unsigned int)CBB_add_bytes(v37, &v38, v24) || !(unsigned int)CBB_add_u8((__int64 *)v37, 46) )
            break;
          v18 = v13 - 40 * ((unsigned __int64)(v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL >> 64) >> 5);
        }
        else
        {
          if ( !(unsigned int)CBB_add_bytes(v37, "2.", 2uLL) )
            break;
          v18 = v13 - 80;
        }
        BIO_snprintf((__int64)&v38, 24LL, (__int64)"%lu", v18, v14, v15, v16, v17, v34);
        v25 = __strlen_chk();
        if ( !(unsigned int)CBB_add_bytes(v37, &v38, v25) )
          break;
LABEL_33:
        if ( EVP_CIPHER_CTX_get_app_data((__int64)&v36) )
        {
          v26 = 0LL;
          while ( 1 )
          {
            v27 = CBS_get_u8((__int64)&v36, &v38);
            if ( v26 >> 57 || !v27 || !v26 && v38 == 128 )
              goto LABEL_51;
            v26 = v38 & 0x7F | (v26 << 7);
            if ( !(v38 & 0x80) )
            {
              if ( (unsigned int)CBB_add_u8((__int64 *)v37, 46) )
              {
                BIO_snprintf((__int64)&v38, 24LL, (__int64)"%lu", v26, v28, v29, v30, v31, v34);
                v32 = __strlen_chk();
                if ( (unsigned int)CBB_add_bytes(v37, &v38, v32) )
                  goto LABEL_33;
              }
              goto LABEL_51;
            }
          }
        }
        if ( !(unsigned int)CBB_add_u8((__int64 *)v37, 0) || !(unsigned int)CBB_finish((__int64)v37, &v35, &v34) )
          break;
        if ( v5 <= 0 )
          v33 = 0LL;
        else
          v33 = (unsigned int)v5;
        if ( BUF_strlcpy(v6, v35, v33) >> 31 )
          ERR_put_error(8, 0LL, 69, (__int64)"external/boringssl/src/crypto/obj/obj.c", 425);
        free(v35);
        goto LABEL_53;
      }
    }
  }
LABEL_51:
  CBB_cleanup((__int64 *)v37);
  if ( v5 >= 1 )
    *v6 = 0;
LABEL_53:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000087168) ----------------------------------------------------
void __fastcall OBJ_create(const char *a1, __int64 a2, __int64 a3)
{
  const char *v3; // x22
  __int64 v4; // x20
  __int64 v5; // x21
  signed int v6; // w0
  int v7; // w23
  void *v8; // x0
  void *v9; // x19
  int v10; // w0
  int v11; // w22
  int v12; // w24
  __int64 *v13; // x20
  __int64 v14; // x0
  _QWORD *v15; // x8
  int v16; // w21
  int v17; // w20
  __int64 v18; // [xsp+0h] [xbp-40h]
  __int64 v19; // [xsp+8h] [xbp-38h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  a2d_ASN1_OBJECT(0LL, 0, a1, -1);
  v7 = v6;
  if ( v6 < 1 )
  {
    v9 = 0LL;
  }
  else
  {
    v8 = malloc(v6);
    v9 = v8;
    if ( v8 )
    {
      a2d_ASN1_OBJECT((__int64)v8, v7, v3, -1);
      v11 = v10;
      if ( v10 )
      {
        CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_107290);
        v12 = dword_106600++;
        CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107290);
        v13 = ASN1_OBJECT_create(v12, (__int64)v9, v11, v5, v4);
        if ( v13 )
        {
          *((_DWORD *)v13 + 8) &= 0xFFFFFFF2;
          CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_107238);
          v14 = qword_107288;
          if ( !qword_107288 )
          {
            qword_107288 = (__int64)lh_new((__int64)sub_873C8, (__int64)sub_873D0);
            qword_107270 = (__int64)lh_new((__int64)sub_873E0, (__int64)sub_873F0);
            qword_107278 = (__int64)lh_new((__int64)sub_87424, (__int64)sub_8742C);
            v15 = lh_new((__int64)sub_87438, (__int64)sub_87440);
            v14 = qword_107288;
            qword_107280 = (__int64)v15;
          }
          v16 = (unsigned __int64)lh_insert(v14, &v18, (__int64)v13);
          if ( *((_DWORD *)v13 + 5) && v13[3] )
            v16 &= (unsigned __int64)lh_insert(qword_107270, &v18, (__int64)v13);
          if ( *v13 )
            v16 &= (unsigned __int64)lh_insert(qword_107278, &v18, (__int64)v13);
          if ( v13[1] )
            v16 &= (unsigned __int64)lh_insert(qword_107280, &v18, (__int64)v13);
          CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107238);
          if ( v16 )
            v17 = *((_DWORD *)v13 + 4);
        }
      }
    }
    else
    {
      ERR_put_error(8, 0LL, 65, (__int64)"external/boringssl/src/crypto/obj/obj.c", 620);
    }
  }
  ASN1_OBJECT_free(0LL);
  free(v9);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 106600: using guessed type int dword_106600;
// 107270: using guessed type __int64 qword_107270;
// 107278: using guessed type __int64 qword_107278;
// 107280: using guessed type __int64 qword_107280;
// 107288: using guessed type __int64 qword_107288;

//----- (00000000000873C8) ----------------------------------------------------
__int64 __fastcall sub_873C8(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (00000000000873D0) ----------------------------------------------------
__int64 __fastcall sub_873D0(__int64 a1, __int64 a2)
{
  return (unsigned int)(*(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16));
}

//----- (00000000000873E0) ----------------------------------------------------
signed __int64 __fastcall sub_873E0(__int64 a1)
{
  return OPENSSL_hash32(*(unsigned __int8 **)(a1 + 24), *(signed int *)(a1 + 20));
}

//----- (00000000000873F0) ----------------------------------------------------
__int64 __fastcall sub_873F0(__int64 a1, __int64 a2)
{
  size_t v2; // x2

  v2 = *(signed int *)(a1 + 20);
  if ( (_DWORD)v2 != *(_DWORD *)(a2 + 20) )
    return (unsigned int)(v2 - *(_DWORD *)(a2 + 20));
  if ( (_DWORD)v2 )
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2);
  return 0LL;
}

//----- (0000000000087424) ----------------------------------------------------
_BYTE *__fastcall sub_87424(_BYTE **a1)
{
  return lh_strhash(*a1);
}

//----- (000000000008742C) ----------------------------------------------------
__int64 __fastcall sub_8742C(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (0000000000087438) ----------------------------------------------------
_BYTE *__fastcall sub_87438(__int64 a1)
{
  return lh_strhash(*(_BYTE **)(a1 + 8));
}

//----- (0000000000087440) ----------------------------------------------------
__int64 __fastcall sub_87440(__int64 a1, __int64 a2)
{
  return strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8));
}

//----- (000000000008744C) ----------------------------------------------------
_QWORD *sub_8744C()
{
  _QWORD *v0; // x0
  _QWORD *v1; // x19
  _QWORD *v2; // x20
  _QWORD *v3; // x0

  v0 = malloc(0x18uLL);
  v1 = v0;
  if ( v0 )
  {
    v0[1] = 0LL;
    v0[2] = 0LL;
    v2 = BN_new();
    *v1 = v2;
    if ( v2 && (v3 = BN_new(), (v1[1] = v3) != 0LL) )
    {
      *((_DWORD *)v1 + 4) = 31;
    }
    else
    {
      BN_free(v2);
      BN_free(0LL);
      free(v1);
      v1 = 0LL;
    }
  }
  else
  {
    ERR_put_error(4, 0LL, 65, (__int64)"external/boringssl/src/crypto/rsa/blinding.c", 135);
  }
  return v1;
}

//----- (00000000000874E0) ----------------------------------------------------
void __fastcall sub_874E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x19
  __int64 v6; // x22
  __int64 v7; // x20
  __int64 v8; // x0
  __int64 v9; // x21
  __int64 v10; // x23
  int v11; // w8
  signed int v12; // w25
  int v13; // w0
  int v14; // w2
  __int16 v15; // w4
  _BOOL8 v16; // x0
  int v17; // w0
  int v18; // [xsp+4h] [xbp-4Ch]
  __int64 v19; // [xsp+8h] [xbp-48h]

  v5 = a2;
  v6 = a1;
  v7 = a5;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *(_QWORD *)a2;
  v9 = a4;
  v10 = a3;
  v11 = *(_DWORD *)(a2 + 16) + 1;
  *(_DWORD *)(a2 + 16) = v11;
  if ( v11 == 32 )
  {
    if ( (unsigned int)BN_rand_range_ex(v8, 1uLL, a4 + 24) )
    {
      v12 = -33;
      while ( 1 )
      {
        if ( !(unsigned int)BN_from_montgomery(*(_QWORD *)(v5 + 8), *(_QWORD *)v5, v9, v7) )
        {
          v14 = 68;
          v15 = 231;
          goto LABEL_22;
        }
        sub_69E64(*(_QWORD *)(v5 + 8), &v18, *(_QWORD *)(v5 + 8), v9, v7);
        if ( v13 )
          break;
        if ( !v18 )
        {
          v14 = 68;
          v15 = 241;
          goto LABEL_22;
        }
        if ( !++v12 )
        {
          v14 = 141;
          v15 = 248;
          goto LABEL_22;
        }
        ERR_clear_error();
        if ( !(unsigned int)BN_rand_range_ex(*(_QWORD *)v5, 1uLL, v9 + 24) )
          goto LABEL_9;
      }
      BN_mod_exp_mont(*(_QWORD *)v5, *(_QWORD *)v5, v10, v9 + 24, v7, v9);
      if ( v17 )
      {
        if ( (unsigned int)BN_to_montgomery(*(_QWORD *)v5, *(_QWORD *)v5, v9, v7) )
        {
          *(_DWORD *)(v5 + 16) = 0;
          goto LABEL_12;
        }
        v14 = 68;
        v15 = 260;
      }
      else
      {
        v14 = 68;
        v15 = 255;
      }
    }
    else
    {
LABEL_9:
      v14 = 68;
      v15 = 224;
    }
LABEL_22:
    ERR_put_error(4, 0LL, v14, (__int64)"external/boringssl/src/crypto/rsa/blinding.c", v15);
  }
  else if ( (unsigned int)BN_mod_mul_montgomery(v8, v8, v8, a4, a5)
         && (unsigned int)BN_mod_mul_montgomery(*(_QWORD *)(v5 + 8), *(_QWORD *)(v5 + 8), *(_QWORD *)(v5 + 8), v9, v7) )
  {
LABEL_12:
    v16 = (unsigned int)BN_mod_mul_montgomery(v6, v6, *(_QWORD *)v5, v9, v7) != 0;
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v19;
    return;
  }
  *(_DWORD *)(v5 + 16) = 31;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000087724) ----------------------------------------------------
__int64 __fastcall sub_87724(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return BN_mod_mul_montgomery(a1, a1, *(_QWORD *)(a2 + 8), a3, a4);
}

//----- (0000000000087740) ----------------------------------------------------
_QWORD *__fastcall X509at_get_attr_count(_QWORD *a1)
{
  return sk_num(a1);
}

//----- (0000000000087754) ----------------------------------------------------
__int64 __fastcall X509v3_get_ext_by_NID(unsigned __int64 *a1, unsigned int a2, int a3)
{
  unsigned __int64 *v3; // x19
  int v4; // w20
  __int64 v5; // x0
  __int64 v6; // x21
  unsigned __int64 v7; // x20
  signed int v8; // w0
  signed __int64 v9; // x22
  __int64 *v10; // x0

  v3 = a1;
  v4 = a3;
  OBJ_nid2obj(a2);
  v6 = v5;
  if ( v5 )
  {
    if ( v3
      && (v4 + 1 >= 0 ? (LODWORD(v7) = v4 + 1) : (LODWORD(v7) = 0),
          v8 = (unsigned __int64)sk_num(v3),
          (signed int)v7 < v8) )
    {
      v7 = (unsigned int)v7;
      v9 = v8;
      while ( 1 )
      {
        v10 = (__int64 *)sk_value(v3, v7);
        if ( !(unsigned int)OBJ_cmp(*v10, v6) )
          break;
        if ( (signed __int64)++v7 >= v9 )
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      LODWORD(v7) = -1;
    }
  }
  else
  {
    LODWORD(v7) = -2;
  }
  return (unsigned int)v7;
}

//----- (00000000000877EC) ----------------------------------------------------
__int64 __fastcall X509v3_get_ext_by_OBJ(unsigned __int64 *a1, __int64 a2, int a3)
{
  __int64 v3; // x19
  unsigned __int64 *v4; // x21
  unsigned __int64 v5; // x20
  signed int v6; // w0
  signed __int64 v7; // x22
  __int64 *v8; // x0

  v3 = a2;
  v4 = a1;
  if ( a1
    && (a3 + 1 >= 0 ? (LODWORD(v5) = a3 + 1) : (LODWORD(v5) = 0), v6 = (unsigned __int64)sk_num(a1), (signed int)v5 < v6) )
  {
    v5 = (unsigned int)v5;
    v7 = v6;
    while ( 1 )
    {
      v8 = (__int64 *)sk_value(v4, v5);
      if ( !(unsigned int)OBJ_cmp(*v8, v3) )
        break;
      if ( (signed __int64)++v5 >= v7 )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    LODWORD(v5) = -1;
  }
  return (unsigned int)v5;
}

//----- (000000000008786C) ----------------------------------------------------
unsigned __int64 *__fastcall X509v3_get_ext(unsigned __int64 *a1, int a2)
{
  int v2; // w20
  unsigned __int64 *v3; // x19
  unsigned __int64 *result; // x0

  v2 = a2;
  v3 = a1;
  result = 0LL;
  if ( v3 && !(a2 & 0x80000000) )
  {
    if ( (unsigned __int64)sk_num(v3) <= a2 )
      result = 0LL;
    else
      result = sk_value(v3, v2);
  }
  return result;
}

//----- (00000000000878BC) ----------------------------------------------------
__int64 __fastcall X509v3_delete_ext(unsigned __int64 *a1, int a2)
{
  int v2; // w20
  unsigned __int64 *v3; // x19
  __int64 result; // x0

  v2 = a2;
  v3 = a1;
  result = 0LL;
  if ( v3 && !(a2 & 0x80000000) )
  {
    if ( (unsigned __int64)sk_num(v3) <= a2 )
      result = 0LL;
    else
      result = sk_delete(v3, v2);
  }
  return result;
}

//----- (000000000008790C) ----------------------------------------------------
void **__fastcall X509at_add1_attr(void ***a1, __int64 a2)
{
  __int64 v2; // x21
  void ***v3; // x20
  void **v4; // x19
  __int64 v5; // x0
  __int64 v6; // x21

  v2 = a2;
  v3 = a1;
  if ( !a1 )
  {
    ERR_put_error(11, 0LL, 67, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 126);
    return 0LL;
  }
  v4 = *a1;
  if ( !*a1 )
  {
    v4 = (void **)sk_new_null();
    if ( !v4 )
    {
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 144);
LABEL_12:
      if ( !v4 )
        return v4;
      goto LABEL_13;
    }
  }
  X509_ATTRIBUTE_dup(v2);
  v6 = v5;
  if ( !v5 )
    goto LABEL_12;
  if ( !sk_push((unsigned __int64 *)v4, v5) )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 144);
    X509_ATTRIBUTE_free(v6);
    if ( !v4 )
      return v4;
LABEL_13:
    sk_free(v4);
    return 0LL;
  }
  if ( !*v3 )
    *v3 = v4;
  return v4;
}

//----- (00000000000879F8) ----------------------------------------------------
void **__fastcall X509at_add1_attr_by_OBJ(void ***a1, __int64 a2, int a3, const char *a4, signed int a5)
{
  void ***v5; // x19
  void ***v6; // x20
  void **v7; // x19

  v5 = a1;
  v6 = X509_ATTRIBUTE_create_by_OBJ(0LL, a2, a3, a4, a5);
  if ( !v6 )
    return 0LL;
  v7 = X509at_add1_attr(v5, (__int64)v6);
  X509_ATTRIBUTE_free((__int64)v6);
  return v7;
}

//----- (0000000000087A48) ----------------------------------------------------
void ***__fastcall X509_ATTRIBUTE_create_by_OBJ(void ****a1, __int64 a2, int a3, const char *a4, signed int a5)
{
  signed int v5; // w21
  const char *v6; // x22
  int v7; // w23
  __int64 v8; // x24
  void ****v9; // x20
  void ***v10; // x19
  __int64 *v11; // x0

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a1 && (v10 = *a1) != 0LL || (v10 = (void ***)X509_ATTRIBUTE_new()) != 0LL )
  {
    if ( v8
      && v10
      && (ASN1_OBJECT_free(*v10), v11 = OBJ_dup(v8), (*v10 = (void **)v11) != 0LL)
      && (unsigned int)X509_ATTRIBUTE_set1_data((unsigned int **)v10, v7, v6, v5) )
    {
      if ( v9 && !*v9 )
        *v9 = v10;
    }
    else
    {
      if ( !v9 || v10 != *v9 )
        X509_ATTRIBUTE_free((__int64)v10);
      v10 = 0LL;
    }
  }
  else
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 239);
  }
  return v10;
}

//----- (0000000000087B28) ----------------------------------------------------
void **__fastcall X509at_add1_attr_by_NID(void ***a1, unsigned int a2, int a3, const char *a4, signed int a5)
{
  void ***v5; // x19
  signed int v6; // w20
  const char *v7; // x21
  int v8; // w22
  __int64 v9; // x0
  void ***v10; // x20
  void **v11; // x19

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  OBJ_nid2obj(a2);
  if ( v9 )
  {
    v10 = X509_ATTRIBUTE_create_by_OBJ(0LL, v9, v8, v7, v6);
    if ( v10 )
    {
      v11 = X509at_add1_attr(v5, (__int64)v10);
      X509_ATTRIBUTE_free((__int64)v10);
      return v11;
    }
  }
  else
  {
    ERR_put_error(11, 0LL, 129, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 224);
  }
  return 0LL;
}

//----- (0000000000087BC8) ----------------------------------------------------
void ***__fastcall X509_ATTRIBUTE_create_by_NID(void ****a1, unsigned int a2, int a3, const char *a4, signed int a5)
{
  void ****v5; // x22
  signed int v6; // w19
  const char *v7; // x20
  int v8; // w21
  __int64 v9; // x0

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  OBJ_nid2obj(a2);
  if ( v9 )
    return X509_ATTRIBUTE_create_by_OBJ(v5, v9, v8, v7, v6);
  ERR_put_error(11, 0LL, 129, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 224);
  return 0LL;
}

//----- (0000000000087C4C) ----------------------------------------------------
void **__fastcall X509at_add1_attr_by_txt(void ***a1, const char *a2, int a3, const char *a4, signed int a5)
{
  __int64 v5; // x20
  void ***v6; // x19
  signed int v7; // w21
  const char *v8; // x22
  int v9; // w23
  __int64 v10; // x0
  void **v11; // x24
  void ***v12; // x20
  void **v13; // x19
  __int64 v15; // x3
  __int64 v16; // x4
  __int64 v17; // x5
  __int64 v18; // x6
  __int64 v19; // x7
  __int64 v20; // [xsp+0h] [xbp-30h]

  v5 = (__int64)a2;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  OBJ_txt2obj(a2, 0);
  v11 = (void **)v10;
  if ( v10 )
  {
    v12 = X509_ATTRIBUTE_create_by_OBJ(0LL, v10, v9, v8, v7);
    ASN1_OBJECT_free(v11);
    if ( v12 )
    {
      v13 = X509at_add1_attr(v6, (__int64)v12);
      X509_ATTRIBUTE_free((__int64)v12);
      return v13;
    }
  }
  else
  {
    ERR_put_error(11, 0LL, 111, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 269);
    ERR_add_error_data(2u, (__int64)"name=", v5, v15, v16, v17, v18, v19, v20);
  }
  return 0LL;
}

//----- (0000000000087D18) ----------------------------------------------------
void ***__fastcall X509_ATTRIBUTE_create_by_txt(void ****a1, const char *a2, int a3, const char *a4, signed int a5)
{
  __int64 v5; // x19
  void ****v6; // x24
  signed int v7; // w20
  const char *v8; // x21
  int v9; // w22
  __int64 v10; // x0
  void **v11; // x23
  void ***v12; // x19
  void ***result; // x0
  __int64 v14; // x3
  __int64 v15; // x4
  __int64 v16; // x5
  __int64 v17; // x6
  __int64 v18; // x7
  __int64 v19; // [xsp+0h] [xbp-30h]

  v5 = (__int64)a2;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  OBJ_txt2obj(a2, 0);
  v11 = (void **)v10;
  if ( v10 )
  {
    v12 = X509_ATTRIBUTE_create_by_OBJ(v6, v10, v9, v8, v7);
    ASN1_OBJECT_free(v11);
    result = v12;
  }
  else
  {
    ERR_put_error(11, 0LL, 111, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 269);
    ERR_add_error_data(2u, (__int64)"name=", v5, v14, v15, v16, v17, v18, v19);
    result = 0LL;
  }
  return result;
}

//----- (0000000000087DC8) ----------------------------------------------------
unsigned __int64 __fastcall X509at_get0_data_by_OBJ(unsigned __int64 *a1, __int64 a2, int a3, int a4)
{
  int v4; // w19
  int v5; // w20
  __int64 v6; // x22
  unsigned __int64 *v7; // x21
  signed __int64 v8; // x23
  signed int v9; // w0
  signed __int64 v10; // x24
  signed __int64 v11; // x25
  __int64 *v12; // x0
  signed __int64 v13; // x24
  signed int v14; // w0
  signed __int64 v15; // x26
  __int64 *v16; // x0
  unsigned __int64 *v17; // x21

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a1 )
    return 0LL;
  LODWORD(v8) = a3 + 1 >= 0 ? a3 + 1 : 0;
  v9 = (unsigned __int64)sk_num(a1);
  if ( (signed int)v8 >= v9 )
    return 0LL;
  v8 = (unsigned int)v8;
  v10 = v9;
  v11 = (unsigned __int64)(unsigned int)v8 << 32;
  while ( 1 )
  {
    v12 = (__int64 *)sk_value(v7, v8);
    if ( !(unsigned int)OBJ_cmp(*v12, v6) )
      break;
    ++v8;
    v11 += 0x100000000LL;
    if ( v8 >= v10 )
      return 0LL;
  }
  if ( (_DWORD)v8 == -1 )
    return 0LL;
  if ( (unsigned __int8)((v5 + 2 < 0) ^ __OFADD__(v5, 2)) | (v5 == -2) )
  {
    LODWORD(v13) = (signed int)v8 + 1 >= 0 ? v8 + 1 : 0;
    v14 = (unsigned __int64)sk_num(v7);
    if ( (signed int)v13 < v14 )
    {
      v13 = (unsigned int)v13;
      v15 = v14;
      do
      {
        v16 = (__int64 *)sk_value(v7, v13);
        if ( !(unsigned int)OBJ_cmp(*v16, v6) )
          break;
        ++v13;
      }
      while ( v13 < v15 );
      if ( (_DWORD)v13 != -1 )
        return 0LL;
    }
  }
  if ( v8 & 0x80000000 || (unsigned __int64)sk_num(v7) <= v11 >> 32 )
  {
    v17 = 0LL;
    if ( !((unsigned __int8)((v5 + 3 < 0) ^ __OFADD__(v5, 3)) | (v5 == -3)) )
      return X509_ATTRIBUTE_get0_data((__int64)v17, 0, v4);
  }
  else
  {
    v17 = sk_value(v7, v11 >> 32);
    if ( !((unsigned __int8)((v5 + 3 < 0) ^ __OFADD__(v5, 3)) | (v5 == -3)) )
      return X509_ATTRIBUTE_get0_data((__int64)v17, 0, v4);
  }
  if ( *((_DWORD *)v17 + 2) )
  {
    if ( (v17[2] != 0) != 1 )
      return 0LL;
    return X509_ATTRIBUTE_get0_data((__int64)v17, 0, v4);
  }
  if ( (unsigned int)sk_num((_QWORD *)v17[2]) == 1 )
    return X509_ATTRIBUTE_get0_data((__int64)v17, 0, v4);
  return 0LL;
}

//----- (0000000000087F64) ----------------------------------------------------
_QWORD *__fastcall X509_ATTRIBUTE_count(__int64 a1)
{
  _QWORD *result; // x0

  if ( *(_DWORD *)(a1 + 8) )
    result = (_QWORD *)(*(_QWORD *)(a1 + 16) != 0LL);
  else
    result = sk_num(*(_QWORD **)(a1 + 16));
  return result;
}

//----- (0000000000087F94) ----------------------------------------------------
unsigned __int64 __fastcall X509_ATTRIBUTE_get0_data(__int64 a1, signed int a2, int a3)
{
  int v3; // w19
  signed int v4; // w20
  __int64 v5; // x21
  unsigned __int64 *v6; // x20

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 8) )
  {
    if ( (*(_QWORD *)(a1 + 16) != 0LL) <= a2 )
      return 0LL;
  }
  else if ( (signed int)sk_num(*(_QWORD **)(a1 + 16)) <= a2 )
  {
    return 0LL;
  }
  if ( *(_DWORD *)(v5 + 8) )
  {
    v6 = *(unsigned __int64 **)(v5 + 16);
    if ( !v6 )
      return 0LL;
  }
  else
  {
    v6 = sk_value(*(unsigned __int64 **)(v5 + 16), v4);
    if ( !v6 )
      return 0LL;
  }
  if ( (unsigned int)ASN1_TYPE_get((unsigned int *)v6) == v3 )
    return v6[1];
  ERR_put_error(11, 0LL, 134, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 365);
  return 0LL;
}

//----- (0000000000088054) ----------------------------------------------------
bool __fastcall X509_EXTENSION_set_object(void ***a1, __int64 a2)
{
  __int64 v2; // x20
  void ***v3; // x19
  _BOOL8 result; // x0
  __int64 *v5; // x0

  v2 = a2;
  v3 = a1;
  result = 0LL;
  if ( v3 )
  {
    if ( a2 )
    {
      ASN1_OBJECT_free(*v3);
      v5 = OBJ_dup(v2);
      *v3 = (void **)v5;
      result = v5 != 0LL;
    }
  }
  return result;
}

//----- (000000000008809C) ----------------------------------------------------
signed __int64 __fastcall X509_ATTRIBUTE_set1_data(unsigned int **a1, int a2, const char *a3, signed int a4)
{
  signed int v4; // w23
  const char *v5; // x21
  int v6; // w22
  unsigned int **v7; // x20
  int v8; // w0
  __int64 v9; // x0
  __int64 v10; // x19
  int v11; // w25
  _DWORD *v12; // x0
  unsigned int *v13; // x0
  __int64 v14; // x0
  __int64 v15; // x24

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a1 )
    return 0LL;
  if ( a2 & 0x1000 )
  {
    v8 = (unsigned __int64)OBJ_obj2nid(*a1);
    v9 = ASN1_STRING_set_by_NID(0LL, v5, v4, v6, v8);
    v10 = v9;
    if ( !v9 )
    {
      ERR_put_error(11, 0LL, 12, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 299);
      return 0LL;
    }
    v11 = *(_DWORD *)(v9 + 4);
  }
  else if ( a4 == -1 )
  {
    v10 = 0LL;
    v11 = 0;
  }
  else
  {
    v12 = ASN1_STRING_type_new(a2);
    v10 = (__int64)v12;
    if ( !v12 || !(unsigned int)ASN1_STRING_set((__int64)v12, v5, v4) )
      goto LABEL_18;
    v11 = v6;
  }
  v13 = (unsigned int *)sk_new_null();
  v7[2] = v13;
  if ( !v13 )
  {
LABEL_18:
    v15 = 0LL;
    goto LABEL_19;
  }
  *((_DWORD *)v7 + 2) = 0;
  if ( !v6 )
  {
    ASN1_STRING_free(v10);
    return 1LL;
  }
  v14 = ASN1_TYPE_new();
  v15 = v14;
  if ( !v14 )
    goto LABEL_19;
  if ( v6 & 0x1000 || v4 != -1 )
  {
    ASN1_TYPE_set(v14, v11, v10);
    v10 = 0LL;
  }
  else if ( !(unsigned int)ASN1_TYPE_set1(v14, v6, (__int64)v5) )
  {
    goto LABEL_19;
  }
  if ( !sk_push((unsigned __int64 *)v7[2], v15) )
  {
LABEL_19:
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_att.c", 335);
    ASN1_TYPE_free(v15);
    ASN1_STRING_free(v10);
    return 0LL;
  }
  return 1LL;
}

//----- (0000000000088224) ----------------------------------------------------
unsigned __int64 *__fastcall X509_ATTRIBUTE_get0_type(__int64 a1, signed int a2)
{
  signed int v2; // w19
  __int64 v3; // x20
  unsigned __int64 *result; // x0

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 8) )
  {
    if ( (*(_QWORD *)(a1 + 16) != 0LL) <= a2 )
      return 0LL;
  }
  else if ( (signed int)sk_num(*(_QWORD **)(a1 + 16)) <= a2 )
  {
    return 0LL;
  }
  if ( *(_DWORD *)(v3 + 8) )
    result = *(unsigned __int64 **)(v3 + 16);
  else
    result = sk_value(*(unsigned __int64 **)(v3 + 16), v2);
  return result;
}

//----- (00000000000882A4) ----------------------------------------------------
__int64 __fastcall X509_issuer_and_serial_cmp(__int64 *a1, __int64 *a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 result; // x0

  v2 = *a1;
  v3 = *a2;
  result = ASN1_STRING_cmp(*(const void ***)(*a1 + 8), *(_QWORD *)(*a2 + 8));
  if ( !(_DWORD)result )
    result = X509_NAME_cmp(*(_QWORD *)(v2 + 24), *(_QWORD *)(v3 + 24));
  return result;
}

//----- (00000000000882E8) ----------------------------------------------------
__int64 __fastcall X509_NAME_cmp(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  int v4; // w0
  int v5; // w0
  size_t v6; // x2
  int v7; // w8
  __int64 result; // x0

  v2 = a1;
  v3 = a2;
  if ( !*(_QWORD *)(a1 + 24) || *(_DWORD *)(a1 + 8) )
  {
    i2d_X509_NAME();
    if ( v4 & 0x80000000 )
      return 4294967294LL;
  }
  if ( !*(_QWORD *)(v3 + 24) || *(_DWORD *)(v3 + 8) )
  {
    i2d_X509_NAME();
    if ( v5 & 0x80000000 )
      return 4294967294LL;
  }
  v6 = *(signed int *)(v2 + 32);
  v7 = *(_DWORD *)(v3 + 32);
  result = (unsigned int)(v6 - v7);
  if ( (_DWORD)v6 == v7 )
  {
    if ( (_DWORD)v6 )
      result = memcmp(*(const void **)(v2 + 24), *(const void **)(v3 + 24), v6);
    else
      result = 0LL;
  }
  return result;
}

//----- (000000000008837C) ----------------------------------------------------
signed __int64 __fastcall X509_issuer_and_serial_hash(__int64 a1)
{
  __int64 v1; // x19
  char *v2; // x0
  char *v3; // x20
  void *v4; // x0
  signed int *v5; // x8
  __int64 v6; // x1
  __int64 v7; // x2
  unsigned __int64 v8; // x19
  signed __int64 result; // x0
  void *v10[4]; // [xsp+8h] [xbp-48h]
  unsigned __int8 v11; // [xsp+28h] [xbp-28h]
  unsigned __int8 v12; // [xsp+29h] [xbp-27h]
  unsigned __int8 v13; // [xsp+2Ah] [xbp-26h]
  unsigned __int8 v14; // [xsp+2Bh] [xbp-25h]
  __int64 v15; // [xsp+38h] [xbp-18h]

  v1 = a1;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(v10);
  X509_NAME_oneline(*(unsigned __int64 ***)(*(_QWORD *)v1 + 24LL), 0LL, 0);
  v3 = v2;
  v4 = EVP_md5();
  if ( (unsigned int)EVP_DigestInit_ex((__int64 *)v10, (__int64)v4)
    && (strlen(v3), (unsigned int)EVP_DigestUpdate((__int64)v10))
    && (free(v3),
        v5 = *(signed int **)(*(_QWORD *)v1 + 8LL),
        v6 = *((_QWORD *)v5 + 1),
        v7 = *v5,
        (unsigned int)EVP_DigestUpdate((__int64)v10))
    && (unsigned int)EVP_DigestFinal_ex(v10, (__int64)&v11, 0LL) )
  {
    v8 = ((unsigned __int16)(v11 | (unsigned __int16)(v12 << 8)) | ((unsigned __int64)v13 << 16)) & 0xFFFFFFFF00FFFFFFLL | ((unsigned __int64)v14 << 24);
  }
  else
  {
    v8 = 0LL;
  }
  result = EVP_MD_CTX_cleanup(v10);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v15 )
    result = v8;
  return result;
}

//----- (0000000000088480) ----------------------------------------------------
__int64 __fastcall X509_issuer_name_cmp(__int64 a1, __int64 a2)
{
  return X509_NAME_cmp(*(_QWORD *)(*(_QWORD *)a1 + 24LL), *(_QWORD *)(*(_QWORD *)a2 + 24LL));
}

//----- (0000000000088494) ----------------------------------------------------
__int64 __fastcall X509_subject_name_cmp(__int64 a1, __int64 a2)
{
  return X509_NAME_cmp(*(_QWORD *)(*(_QWORD *)a1 + 40LL), *(_QWORD *)(*(_QWORD *)a2 + 40LL));
}

//----- (00000000000884A8) ----------------------------------------------------
__int64 __fastcall X509_CRL_cmp(__int64 a1, __int64 a2)
{
  return X509_NAME_cmp(*(_QWORD *)(*(_QWORD *)a1 + 16LL), *(_QWORD *)(*(_QWORD *)a2 + 16LL));
}

//----- (00000000000884BC) ----------------------------------------------------
__int64 __fastcall X509_CRL_match(__int64 a1, __int64 a2)
{
  return memcmp((const void *)(a1 + 72), (const void *)(a2 + 72), 0x14uLL);
}

//----- (00000000000884CC) ----------------------------------------------------
__int64 __fastcall X509_get_issuer_name(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 24LL);
}

//----- (00000000000884D8) ----------------------------------------------------
unsigned __int64 __fastcall X509_issuer_name_hash(__int64 a1)
{
  return X509_NAME_hash(*(_QWORD *)(*(_QWORD *)a1 + 24LL));
}

//----- (00000000000884E4) ----------------------------------------------------
unsigned __int64 __fastcall X509_NAME_hash(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x20
  __int64 v3; // x19
  void *v4; // x0
  int v5; // w0
  unsigned __int64 result; // x0
  unsigned __int8 v7; // [xsp+4h] [xbp-2Ch]
  unsigned __int8 v8; // [xsp+5h] [xbp-2Bh]
  unsigned __int8 v9; // [xsp+6h] [xbp-2Ah]
  unsigned __int8 v10; // [xsp+7h] [xbp-29h]
  __int64 v11; // [xsp+18h] [xbp-18h]

  v1 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  i2d_X509_NAME();
  v2 = *(_QWORD *)(v1 + 24);
  v3 = *(signed int *)(v1 + 32);
  v4 = EVP_sha1();
  EVP_Digest(v2, v3, (__int64)&v7, 0LL, (__int64)v4);
  if ( v5 )
    result = ((unsigned __int16)(v7 | (unsigned __int16)(v8 << 8)) | ((unsigned __int64)v9 << 16)) & 0xFFFFFFFF00FFFFFFLL | ((unsigned __int64)v10 << 24);
  else
    result = 0LL;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000088584) ----------------------------------------------------
signed __int64 __fastcall X509_issuer_name_hash_old(__int64 a1)
{
  return X509_NAME_hash_old(*(_QWORD *)(*(_QWORD *)a1 + 24LL));
}

//----- (0000000000088590) ----------------------------------------------------
signed __int64 __fastcall X509_NAME_hash_old(__int64 a1)
{
  __int64 v1; // x19
  void *v2; // x0
  __int64 v3; // x2
  unsigned __int64 v4; // x19
  signed __int64 result; // x0
  void *v6[4]; // [xsp+8h] [xbp-48h]
  unsigned __int8 v7; // [xsp+28h] [xbp-28h]
  unsigned __int8 v8; // [xsp+29h] [xbp-27h]
  unsigned __int8 v9; // [xsp+2Ah] [xbp-26h]
  unsigned __int8 v10; // [xsp+2Bh] [xbp-25h]
  __int64 v11; // [xsp+38h] [xbp-18h]

  v1 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  i2d_X509_NAME();
  EVP_MD_CTX_init(v6);
  v2 = EVP_md5();
  if ( (unsigned int)EVP_DigestInit_ex((__int64 *)v6, (__int64)v2)
    && (v3 = **(_QWORD **)(v1 + 16), (unsigned int)EVP_DigestUpdate((__int64)v6))
    && (unsigned int)EVP_DigestFinal_ex(v6, (__int64)&v7, 0LL) )
  {
    v4 = ((unsigned __int16)(v7 | (unsigned __int16)(v8 << 8)) | ((unsigned __int64)v9 << 16)) & 0xFFFFFFFF00FFFFFFLL | ((unsigned __int64)v10 << 24);
  }
  else
  {
    v4 = 0LL;
  }
  result = EVP_MD_CTX_cleanup(v6);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v11 )
    result = v4;
  return result;
}

//----- (0000000000088658) ----------------------------------------------------
__int64 __fastcall X509_get_subject_name(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 40LL);
}

//----- (0000000000088664) ----------------------------------------------------
__int64 __fastcall X509_get_serialNumber(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 8LL);
}

//----- (0000000000088670) ----------------------------------------------------
unsigned __int64 __fastcall X509_subject_name_hash(__int64 a1)
{
  return X509_NAME_hash(*(_QWORD *)(*(_QWORD *)a1 + 40LL));
}

//----- (000000000008867C) ----------------------------------------------------
signed __int64 __fastcall X509_subject_name_hash_old(__int64 a1)
{
  return X509_NAME_hash_old(*(_QWORD *)(*(_QWORD *)a1 + 40LL));
}

//----- (0000000000088688) ----------------------------------------------------
__int64 __fastcall X509_cmp(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 result; // x0
  __int64 v5; // x8
  __int64 v6; // x9
  size_t v7; // x2
  int v8; // w10

  v2 = a2;
  v3 = a1;
  X509_check_purpose(a1, -1);
  X509_check_purpose(v2, -1);
  result = memcmp((const void *)(v3 + 144), (const void *)(v2 + 144), 0x14uLL);
  if ( !(_DWORD)result )
  {
    v5 = *(_QWORD *)v3;
    if ( *(_DWORD *)(*(_QWORD *)v3 + 96LL) )
      return 0LL;
    v6 = *(_QWORD *)v2;
    if ( *(_DWORD *)(*(_QWORD *)v2 + 96LL) )
      return 0LL;
    v7 = *(_QWORD *)(v5 + 88);
    v8 = *(_DWORD *)(v6 + 88);
    result = (unsigned int)(v7 - v8);
    if ( (_DWORD)v7 == v8 )
    {
      if ( v7 )
        return memcmp(*(const void **)(v5 + 80), *(const void **)(v6 + 80), v7);
      return 0LL;
    }
  }
  return result;
}

//----- (000000000008871C) ----------------------------------------------------
unsigned __int64 *__fastcall X509_find_by_issuer_and_serial(unsigned __int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  unsigned __int64 *v5; // x21
  unsigned __int64 v6; // x22
  unsigned __int64 *v7; // x23
  unsigned __int64 v8; // x24

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 || !sk_num(a1) )
    return 0LL;
  v6 = 0LL;
  while ( 1 )
  {
    v7 = sk_value(v5, v6);
    v8 = *v7;
    if ( !(unsigned int)ASN1_STRING_cmp(*(const void ***)(*v7 + 8), v3)
      && !(unsigned int)X509_NAME_cmp(*(_QWORD *)(v8 + 24), v4) )
    {
      break;
    }
    if ( ++v6 >= (unsigned __int64)sk_num(v5) )
      return 0LL;
  }
  return v7;
}

//----- (00000000000887B4) ----------------------------------------------------
unsigned __int64 *__fastcall X509_find_by_subject(unsigned __int64 *a1, __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 *v3; // x20
  unsigned __int64 v4; // x21
  unsigned __int64 *v5; // x22

  v2 = a2;
  v3 = a1;
  if ( !sk_num(a1) )
    return 0LL;
  v4 = 0LL;
  while ( 1 )
  {
    v5 = sk_value(v3, v4);
    if ( !(unsigned int)X509_NAME_cmp(*(_QWORD *)(*v5 + 40), v2) )
      break;
    if ( ++v4 >= (unsigned __int64)sk_num(v3) )
      return 0LL;
  }
  return v5;
}

//----- (0000000000088828) ----------------------------------------------------
void __fastcall X509_get_pubkey(__int64 a1)
{
  if ( a1 )
  {
    if ( *(_QWORD *)a1 )
      X509_PUBKEY_get(*(_QWORD *)(*(_QWORD *)a1 + 48LL));
  }
}

//----- (0000000000088844) ----------------------------------------------------
__int64 __fastcall X509_get0_pubkey_bitstr(__int64 result)
{
  if ( result )
    result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)result + 48LL) + 8LL);
  return result;
}

//----- (0000000000088858) ----------------------------------------------------
bool __fastcall X509_check_private_key(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x0
  int *v4; // x19
  int v5; // w20
  int v6; // w2
  __int16 v7; // w4

  v2 = a2;
  if ( !a1 || !*(_QWORD *)a1 || (X509_PUBKEY_get(*(_QWORD *)(*(_QWORD *)a1 + 48LL)), (v4 = (int *)v3) == 0LL) )
  {
    ERR_put_error(11, 0LL, 128, (__int64)"external/boringssl/src/crypto/x509/x509_cmp.c", 340);
    return 0LL;
  }
  v5 = EVP_PKEY_cmp(v3, v2);
  switch ( v5 )
  {
    case 0:
      v6 = 116;
      v7 = 334;
      goto LABEL_11;
    case -1:
      v6 = 115;
      v7 = 337;
      goto LABEL_11;
    case -2:
      v6 = 128;
      v7 = 340;
LABEL_11:
      ERR_put_error(11, 0LL, v6, (__int64)"external/boringssl/src/crypto/x509/x509_cmp.c", v7);
      break;
  }
  EVP_PKEY_free(v4);
  return v5 > 0;
}

//----- (0000000000088934) ----------------------------------------------------
signed __int64 __fastcall X509_chain_check_suiteb(_DWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // x20
  unsigned __int64 *v5; // x23
  unsigned __int64 *v6; // x24
  _DWORD *v7; // x19
  unsigned __int64 v8; // x21
  signed __int64 result; // x0
  __int64 v10; // x0
  __int64 v11; // x22
  __int64 v12; // x0
  int v13; // w0
  unsigned __int64 v14; // x27
  unsigned int v15; // w23
  bool v16; // zf
  _QWORD *v17; // x25
  int v18; // w24
  unsigned __int64 *v19; // x25
  __int64 v20; // x0
  __int64 v21; // x0
  int v22; // w0
  _QWORD *v23; // x26
  __int64 v24; // x0
  int v25; // w0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !(a4 & 0x30000) )
    return 0LL;
  if ( a2 )
  {
    v8 = 0LL;
  }
  else
  {
    v6 = sk_value(a3, 0LL);
    v8 = 1LL;
  }
  if ( ASN1_INTEGER_get(*(_QWORD *)*v6) != 2 )
  {
    v8 = 0LL;
    v15 = 56;
    v14 = v4;
    goto LABEL_21;
  }
  if ( !v6 || !*v6 || (X509_PUBKEY_get(*(_QWORD *)(*v6 + 48)), (v11 = v10) == 0) )
  {
    v8 = 0LL;
    v15 = 57;
    v14 = v4;
    goto LABEL_21;
  }
  if ( *(_DWORD *)(v10 + 4) != 408 || (v12 = lh_num_items(*(_QWORD *)(v10 + 8))) == 0 )
  {
    v8 = 0LL;
    v15 = 57;
LABEL_19:
    v14 = v4;
    goto LABEL_20;
  }
  v13 = X509_VERIFY_PARAM_get_depth(v12);
  if ( v13 != 415 )
  {
    if ( v13 != 715 )
    {
      v8 = 0LL;
      v15 = 58;
      goto LABEL_19;
    }
    if ( v4 & 0x20000 )
    {
      v14 = v4 & 0xFFFFFFFFFFFEFFFFLL;
      goto LABEL_33;
    }
    goto LABEL_31;
  }
  v14 = v4;
  if ( !(v4 & 0x10000) )
  {
LABEL_31:
    v8 = 0LL;
    v15 = 60;
    goto LABEL_19;
  }
LABEL_33:
  v17 = sk_num(v5);
  v18 = (unsigned __int64)X509_get_signature_nid((__int64)v6);
  if ( v8 >= (unsigned __int64)v17 )
  {
LABEL_50:
    if ( *(_DWORD *)(v11 + 4) != 408 || (v24 = lh_num_items(*(_QWORD *)(v11 + 8))) == 0 )
    {
      v15 = 57;
      goto LABEL_20;
    }
    v25 = X509_VERIFY_PARAM_get_depth(v24);
    if ( v25 == 415 )
    {
      if ( v18 == 794 || v18 == -1 )
      {
        if ( v14 & 0x10000 )
        {
LABEL_70:
          EVP_PKEY_free((int *)v11);
          return 0LL;
        }
LABEL_65:
        v15 = 60;
        goto LABEL_20;
      }
    }
    else
    {
      if ( v25 != 715 )
      {
        v15 = 58;
        goto LABEL_20;
      }
      if ( v18 == 795 || v18 == -1 )
      {
        if ( v14 & 0x20000 )
          goto LABEL_70;
        goto LABEL_65;
      }
    }
LABEL_66:
    v15 = 59;
    goto LABEL_20;
  }
  while ( 1 )
  {
    v19 = sk_value(v5, v8);
    if ( ASN1_INTEGER_get(*(_QWORD *)*v19) != 2 )
    {
      v15 = 56;
      goto LABEL_20;
    }
    EVP_PKEY_free((int *)v11);
    if ( !v19 )
    {
      v15 = 57;
      goto LABEL_21;
    }
    if ( !*v19 || (X509_PUBKEY_get(*(_QWORD *)(*v19 + 48)), (v11 = v20) == 0) )
    {
      v15 = 57;
      goto LABEL_21;
    }
    if ( *(_DWORD *)(v20 + 4) != 408 || (v21 = lh_num_items(*(_QWORD *)(v20 + 8))) == 0 )
    {
      v15 = 57;
      goto LABEL_20;
    }
    v22 = X509_VERIFY_PARAM_get_depth(v21);
    if ( v22 != 415 )
      break;
    if ( v18 != 794 && v18 != -1 )
      goto LABEL_66;
    if ( !(v14 & 0x10000) )
      goto LABEL_65;
LABEL_49:
    ++v8;
    v23 = sk_num(v5);
    v18 = (unsigned __int64)X509_get_signature_nid((__int64)v19);
    if ( v8 >= (unsigned __int64)v23 )
      goto LABEL_50;
  }
  if ( v22 == 715 )
  {
    if ( v18 != 795 && v18 != -1 )
      goto LABEL_66;
    if ( !(v14 & 0x20000) )
      goto LABEL_65;
    v14 &= 0xFFFFFFFFFFFEFFFFLL;
    goto LABEL_49;
  }
  v15 = 58;
LABEL_20:
  EVP_PKEY_free((int *)v11);
LABEL_21:
  if ( v15 == 60 )
    v16 = v14 == v4;
  else
    v16 = 1;
  if ( v16 )
    result = v15;
  else
    result = 61LL;
  if ( v7 )
    *v7 = v8 - (v15 - 59 < 2 && v8 != 0);
  return result;
}

//----- (0000000000088C34) ----------------------------------------------------
signed __int64 __fastcall X509_CRL_check_suiteb(__int64 a1, __int64 a2, int a3)
{
  int v3; // w19
  __int64 v4; // x21
  int v5; // w20
  __int64 v6; // x0
  int v7; // w0

  v3 = a3;
  v4 = a2;
  if ( !(*(_QWORD *)&a3 & 0x30000LL) )
    return 0LL;
  v5 = (unsigned __int64)OBJ_obj2nid(**(unsigned int ***)(*(_QWORD *)a1 + 8LL));
  if ( !v4 )
    return 57LL;
  if ( *(_DWORD *)(v4 + 4) != 408 )
    return 57LL;
  v6 = lh_num_items(*(_QWORD *)(v4 + 8));
  if ( !v6 )
    return 57LL;
  v7 = X509_VERIFY_PARAM_get_depth(v6);
  if ( v7 == 415 )
  {
    if ( v5 == 794 || v5 == -1 )
    {
      if ( !(v3 & 0x10000) )
        return 60LL;
      return 0LL;
    }
  }
  else
  {
    if ( v7 != 715 )
      return 58LL;
    if ( v5 == 795 || v5 == -1 )
    {
      if ( !(v3 & 0x20000) )
        return 60LL;
      return 0LL;
    }
  }
  return 59LL;
}

//----- (0000000000088CFC) ----------------------------------------------------
unsigned __int64 *__fastcall X509_chain_up_ref(__int64 a1)
{
  unsigned __int64 *v1; // x19
  unsigned __int64 v2; // x20
  unsigned __int64 *v3; // x0

  v1 = sk_dup(a1);
  if ( sk_num(v1) )
  {
    v2 = 0LL;
    do
    {
      v3 = sk_value(v1, v2);
      X509_up_ref((__int64)v3);
      ++v2;
    }
    while ( v2 < (unsigned __int64)sk_num(v1) );
  }
  return v1;
}

//----- (0000000000088D50) ----------------------------------------------------
_QWORD *__fastcall X509_CRL_get_ext_count(__int64 a1)
{
  return X509v3_get_ext_count(*(_QWORD **)(*(_QWORD *)a1 + 48LL));
}

//----- (0000000000088D5C) ----------------------------------------------------
__int64 __fastcall X509_REQ_get_attr_by_NID(__int64 a1, unsigned int a2, int a3)
{
  return X509v3_get_ext_by_NID(*(unsigned __int64 **)(*(_QWORD *)a1 + 48LL), a2, a3);
}

//----- (0000000000088D68) ----------------------------------------------------
__int64 __fastcall X509_REQ_get_attr_by_OBJ(__int64 a1, __int64 a2, int a3)
{
  return X509v3_get_ext_by_OBJ(*(unsigned __int64 **)(*(_QWORD *)a1 + 48LL), a2, a3);
}

//----- (0000000000088D74) ----------------------------------------------------
__int64 __fastcall X509_CRL_get_ext_by_critical(__int64 a1, int a2, int a3)
{
  return X509v3_get_ext_by_critical(*(unsigned __int64 **)(*(_QWORD *)a1 + 48LL), a2, a3);
}

//----- (0000000000088D80) ----------------------------------------------------
unsigned __int64 *__fastcall X509_REQ_get_attr(__int64 a1, int a2)
{
  return X509v3_get_ext(*(unsigned __int64 **)(*(_QWORD *)a1 + 48LL), a2);
}

//----- (0000000000088D8C) ----------------------------------------------------
__int64 __fastcall X509_REQ_delete_attr(__int64 a1, int a2)
{
  return X509v3_delete_ext(*(unsigned __int64 **)(*(_QWORD *)a1 + 48LL), a2);
}

//----- (0000000000088D98) ----------------------------------------------------
unsigned __int64 *__fastcall X509_CRL_get_ext_d2i(__int64 a1, int a2, signed int *a3, _DWORD *a4)
{
  return X509V3_get_d2i(*(unsigned __int64 **)(*(_QWORD *)a1 + 48LL), a2, a3, a4);
}

//----- (0000000000088DA4) ----------------------------------------------------
__int64 __fastcall X509_CRL_add1_ext_i2d(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5)
{
  return X509V3_add1_i2d((unsigned __int64 **)(*(_QWORD *)a1 + 48LL), a2, a3, a4, a5);
}

//----- (0000000000088DB0) ----------------------------------------------------
bool __fastcall X509_CRL_add_ext(__int64 a1, __int64 a2, int a3)
{
  return X509v3_add_ext((void ***)(*(_QWORD *)a1 + 48LL), a2, a3) != 0LL;
}

//----- (0000000000088DD4) ----------------------------------------------------
_QWORD *__fastcall X509_get_ext_count(__int64 a1)
{
  return X509v3_get_ext_count(*(_QWORD **)(*(_QWORD *)a1 + 72LL));
}

//----- (0000000000088DE0) ----------------------------------------------------
__int64 __fastcall X509_get_ext_by_NID(__int64 a1, unsigned int a2, int a3)
{
  return X509v3_get_ext_by_NID(*(unsigned __int64 **)(*(_QWORD *)a1 + 72LL), a2, a3);
}

//----- (0000000000088DEC) ----------------------------------------------------
__int64 __fastcall X509_get_ext_by_OBJ(__int64 a1, __int64 a2, int a3)
{
  return X509v3_get_ext_by_OBJ(*(unsigned __int64 **)(*(_QWORD *)a1 + 72LL), a2, a3);
}

//----- (0000000000088DF8) ----------------------------------------------------
__int64 __fastcall X509_get_ext_by_critical(__int64 a1, int a2, int a3)
{
  return X509v3_get_ext_by_critical(*(unsigned __int64 **)(*(_QWORD *)a1 + 72LL), a2, a3);
}

//----- (0000000000088E04) ----------------------------------------------------
unsigned __int64 *__fastcall X509_get_ext(__int64 a1, int a2)
{
  return X509v3_get_ext(*(unsigned __int64 **)(*(_QWORD *)a1 + 72LL), a2);
}

//----- (0000000000088E10) ----------------------------------------------------
__int64 __fastcall X509_delete_ext(__int64 a1, int a2)
{
  return X509v3_delete_ext(*(unsigned __int64 **)(*(_QWORD *)a1 + 72LL), a2);
}

//----- (0000000000088E1C) ----------------------------------------------------
bool __fastcall X509_add_ext(__int64 a1, __int64 a2, int a3)
{
  return X509v3_add_ext((void ***)(*(_QWORD *)a1 + 72LL), a2, a3) != 0LL;
}

//----- (0000000000088E40) ----------------------------------------------------
unsigned __int64 *__fastcall X509_get_ext_d2i(__int64 a1, int a2, signed int *a3, _DWORD *a4)
{
  return X509V3_get_d2i(*(unsigned __int64 **)(*(_QWORD *)a1 + 72LL), a2, a3, a4);
}

//----- (0000000000088E4C) ----------------------------------------------------
__int64 __fastcall X509_add1_ext_i2d(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5)
{
  return X509V3_add1_i2d((unsigned __int64 **)(*(_QWORD *)a1 + 72LL), a2, a3, a4, a5);
}

//----- (0000000000088E58) ----------------------------------------------------
_QWORD *__fastcall X509_REVOKED_get_ext_count(__int64 a1)
{
  return X509v3_get_ext_count(*(_QWORD **)(a1 + 16));
}

//----- (0000000000088E60) ----------------------------------------------------
__int64 __fastcall X509_REVOKED_get_ext_by_NID(__int64 a1, unsigned int a2, int a3)
{
  return X509v3_get_ext_by_NID(*(unsigned __int64 **)(a1 + 16), a2, a3);
}

//----- (0000000000088E68) ----------------------------------------------------
__int64 __fastcall X509_REVOKED_get_ext_by_OBJ(__int64 a1, __int64 a2, int a3)
{
  return X509v3_get_ext_by_OBJ(*(unsigned __int64 **)(a1 + 16), a2, a3);
}

//----- (0000000000088E70) ----------------------------------------------------
__int64 __fastcall X509_REVOKED_get_ext_by_critical(__int64 a1, int a2, int a3)
{
  return X509v3_get_ext_by_critical(*(unsigned __int64 **)(a1 + 16), a2, a3);
}

//----- (0000000000088E78) ----------------------------------------------------
unsigned __int64 *__fastcall X509_REVOKED_get_ext(__int64 a1, int a2)
{
  return X509v3_get_ext(*(unsigned __int64 **)(a1 + 16), a2);
}

//----- (0000000000088E80) ----------------------------------------------------
__int64 __fastcall X509_REVOKED_delete_ext(__int64 a1, int a2)
{
  return X509v3_delete_ext(*(unsigned __int64 **)(a1 + 16), a2);
}

//----- (0000000000088E88) ----------------------------------------------------
bool __fastcall X509_REVOKED_add_ext(__int64 a1, __int64 a2, int a3)
{
  return X509v3_add_ext((void ***)(a1 + 16), a2, a3) != 0LL;
}

//----- (0000000000088EA8) ----------------------------------------------------
unsigned __int64 *__fastcall X509_REVOKED_get_ext_d2i(__int64 a1, int a2, signed int *a3, _DWORD *a4)
{
  return X509V3_get_d2i(*(unsigned __int64 **)(a1 + 16), a2, a3, a4);
}

//----- (0000000000088EB0) ----------------------------------------------------
__int64 __fastcall X509_REVOKED_add1_ext_i2d(__int64 a1, unsigned int a2, __int64 a3, int a4, char a5)
{
  return X509V3_add1_i2d((unsigned __int64 **)(a1 + 16), a2, a3, a4, a5);
}

//----- (0000000000088EB8) ----------------------------------------------------
void *__fastcall X509_LOOKUP_new(__int64 a1)
{
  __int64 v1; // x20
  _DWORD *v2; // x0
  void *v3; // x19
  unsigned int (*v4)(void); // x8

  v1 = a1;
  v2 = malloc(0x20uLL);
  v3 = v2;
  if ( v2 )
  {
    *v2 = 0;
    v2[1] = 0;
    *((_QWORD *)v2 + 2) = 0LL;
    *((_QWORD *)v2 + 3) = 0LL;
    *((_QWORD *)v2 + 1) = v1;
    v4 = *(unsigned int (**)(void))(v1 + 8);
    if ( v4 )
    {
      if ( !v4() )
      {
        free(v3);
        v3 = 0LL;
      }
    }
  }
  return v3;
}

//----- (0000000000088F14) ----------------------------------------------------
void __fastcall X509_LOOKUP_free(_QWORD *a1)
{
  void *v1; // x19
  __int64 v2; // x8
  void (*v3)(void); // x8

  v1 = a1;
  if ( a1 )
  {
    v2 = a1[1];
    if ( v2 )
    {
      v3 = *(void (**)(void))(v2 + 16);
      if ( v3 )
        v3();
    }
    free(v1);
  }
}

//----- (0000000000088F5C) ----------------------------------------------------
__int64 __fastcall X509_LOOKUP_init(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x1
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0LL;
  v2 = *(__int64 (**)(void))(v1 + 24);
  if ( v2 )
    result = v2();
  else
    result = 1LL;
  return result;
}

//----- (0000000000088F80) ----------------------------------------------------
__int64 __fastcall X509_LOOKUP_shutdown(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x1
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0LL;
  v2 = *(__int64 (**)(void))(v1 + 32);
  if ( v2 )
    result = v2();
  else
    result = 1LL;
  return result;
}

//----- (0000000000088FA4) ----------------------------------------------------
__int64 __fastcall X509_LOOKUP_ctrl(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x5
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0xFFFFFFFFLL;
  v2 = *(__int64 (**)(void))(v1 + 40);
  if ( v2 )
    result = v2();
  else
    result = 1LL;
  return result;
}

//----- (0000000000088FC8) ----------------------------------------------------
bool __fastcall X509_LOOKUP_by_subject(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  signed int (__cdecl *v3)(__int64, __int64); // x8

  v2 = *(_QWORD *)(a1 + 8);
  if ( !v2 )
    return 0LL;
  v3 = *(signed int (__cdecl **)(__int64, __int64))(v2 + 48);
  if ( !v3 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 4) )
    return 0LL;
  return v3(a1, a2) > 0;
}

//----- (0000000000089014) ----------------------------------------------------
bool __fastcall X509_LOOKUP_by_issuer_serial(__int64 a1)
{
  __int64 v1; // x8
  signed int (*v2)(void); // x8
  _BOOL8 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0LL;
  v2 = *(signed int (**)(void))(v1 + 56);
  if ( v2 )
    result = v2() > 0;
  else
    result = 0LL;
  return result;
}

//----- (0000000000089050) ----------------------------------------------------
bool __fastcall X509_LOOKUP_by_fingerprint(__int64 a1)
{
  __int64 v1; // x8
  signed int (*v2)(void); // x8
  _BOOL8 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0LL;
  v2 = *(signed int (**)(void))(v1 + 64);
  if ( v2 )
    result = v2() > 0;
  else
    result = 0LL;
  return result;
}

//----- (000000000008908C) ----------------------------------------------------
bool __fastcall X509_LOOKUP_by_alias(__int64 a1)
{
  __int64 v1; // x8
  signed int (*v2)(void); // x8
  _BOOL8 result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0LL;
  v2 = *(signed int (**)(void))(v1 + 72);
  if ( v2 )
    result = v2() > 0;
  else
    result = 0LL;
  return result;
}

//----- (00000000000890C8) ----------------------------------------------------
_DWORD *X509_STORE_new()
{
  _DWORD *v0; // x0
  _DWORD *v1; // x19
  _QWORD *v2; // x0
  _QWORD *v3; // x0
  _QWORD *v4; // x0
  __int64 v5; // x0
  void **v6; // x0
  void **v7; // x0

  v0 = malloc(0xC0uLL);
  v1 = v0;
  if ( v0 )
  {
    memset(v0, 0, 0xC0uLL);
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v1 + 4));
    v2 = sk_new((__int64)sub_89188);
    *((_QWORD *)v1 + 1) = v2;
    if ( v2
      && (*v1 = 1, v3 = sk_new_null(), (*((_QWORD *)v1 + 10) = v3) != 0LL)
      && (v4 = X509_VERIFY_PARAM_new(), (*((_QWORD *)v1 + 11) = v4) != 0LL) )
    {
      v1[46] = 1;
    }
    else
    {
      CRYPTO_MUTEX_cleanup(v1 + 4);
      v5 = *((_QWORD *)v1 + 11);
      if ( v5 )
        X509_VERIFY_PARAM_free(v5);
      v6 = (void **)*((_QWORD *)v1 + 10);
      if ( v6 )
        sk_free(v6);
      v7 = (void **)*((_QWORD *)v1 + 1);
      if ( v7 )
        sk_free(v7);
      free(v1);
      v1 = 0LL;
    }
  }
  return v1;
}
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);

//----- (0000000000089188) ----------------------------------------------------
__int64 __fastcall sub_89188(int **a1, int **a2)
{
  int *v2; // x8
  int *v3; // x9
  int v4; // w10
  int v5; // w11
  __int64 result; // x0

  v2 = *a1;
  v3 = *a2;
  v4 = **a1;
  v5 = **a2;
  result = (unsigned int)(v4 - v5);
  if ( v4 == v5 )
  {
    if ( v4 == 2 )
    {
      result = X509_CRL_cmp(*((_QWORD *)v2 + 1), *((_QWORD *)v3 + 1));
    }
    else if ( v4 == 1 )
    {
      result = X509_subject_name_cmp(*((_QWORD *)v2 + 1), *((_QWORD *)v3 + 1));
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000891D4) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_up_ref(__int64 a1)
{
  CRYPTO_refcount_inc((_DWORD *)(a1 + 184));
  return 1LL;
}

//----- (00000000000891F0) ----------------------------------------------------
void __fastcall X509_STORE_free(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int64 *v2; // x20
  unsigned __int64 v3; // x21
  unsigned __int64 *v4; // x22
  unsigned __int64 v5; // x8
  void (*v6)(void); // x8
  unsigned __int64 v7; // x8
  void (__fastcall *v8)(unsigned __int64 *); // x8
  __int64 v9; // x0

  v1 = a1;
  if ( a1 && (unsigned int)CRYPTO_refcount_dec_and_test_zero((int *)(a1 + 184)) )
  {
    CRYPTO_MUTEX_cleanup(v1 + 16);
    v2 = *(unsigned __int64 **)(v1 + 80);
    if ( sk_num(*(_QWORD **)(v1 + 80)) )
    {
      v3 = 0LL;
      do
      {
        v4 = sk_value(v2, v3);
        v5 = v4[1];
        if ( v5 )
        {
          v6 = *(void (**)(void))(v5 + 32);
          if ( v6 )
            v6();
        }
        if ( v4 )
        {
          v7 = v4[1];
          if ( v7 )
          {
            v8 = *(void (__fastcall **)(unsigned __int64 *))(v7 + 16);
            if ( v8 )
              v8(v4);
          }
          free(v4);
        }
        ++v3;
      }
      while ( v3 < (unsigned __int64)sk_num(v2) );
    }
    sk_free((void **)v2);
    sk_pop_free(*(unsigned __int64 **)(v1 + 8), (void (*)(void))sub_892D8);
    v9 = *(_QWORD *)(v1 + 88);
    if ( v9 )
      X509_VERIFY_PARAM_free(v9);
    free((void *)v1);
  }
}
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);

//----- (00000000000892D8) ----------------------------------------------------
void __fastcall sub_892D8(__int64 *a1)
{
  __int64 *v1; // x19

  v1 = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 == 2 )
    {
      X509_CRL_free(a1[1]);
    }
    else if ( *(_DWORD *)a1 == 1 )
    {
      X509_free(a1[1]);
    }
    free(v1);
  }
}

//----- (0000000000089330) ----------------------------------------------------
unsigned __int64 *__fastcall X509_STORE_add_lookup(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x19
  unsigned __int64 *v3; // x22
  unsigned __int64 v4; // x21
  unsigned __int64 v5; // x23
  unsigned __int64 *v6; // x20
  unsigned __int64 *v7; // x0
  unsigned int (*v8)(void); // x8
  unsigned __int64 v9; // x8
  void (__fastcall *v10)(unsigned __int64 *); // x8

  v2 = a1;
  v3 = *(unsigned __int64 **)(a1 + 80);
  v4 = a2;
  if ( sk_num(*(_QWORD **)(a1 + 80)) )
  {
    v5 = 0LL;
    while ( 1 )
    {
      v6 = sk_value(v3, v5);
      if ( v6[1] == v4 )
        break;
      if ( ++v5 >= (unsigned __int64)sk_num(v3) )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v7 = (unsigned __int64 *)malloc(0x20uLL);
    v6 = v7;
    if ( v7 )
    {
      *(_DWORD *)v7 = 0;
      *((_DWORD *)v7 + 1) = 0;
      v7[2] = 0LL;
      v7[3] = 0LL;
      v7[1] = v4;
      v8 = *(unsigned int (**)(void))(v4 + 8);
      if ( !v8 || v8() )
      {
        v6[3] = v2;
        if ( sk_push(*(unsigned __int64 **)(v2 + 80), (__int64)v6) )
          return v6;
        v9 = v6[1];
        if ( v9 )
        {
          v10 = *(void (__fastcall **)(unsigned __int64 *))(v9 + 16);
          if ( v10 )
            v10(v6);
        }
      }
      free(v6);
      return 0LL;
    }
  }
  return v6;
}

//----- (0000000000089410) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_get_by_subject(_QWORD *a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  int v6; // w21
  __int64 v7; // x24
  pthread_rwlock_t *v8; // x23
  unsigned __int64 *v9; // x22
  __int64 *v10; // x8
  int v11; // w0
  signed int v12; // w8
  unsigned __int64 *v13; // x22
  unsigned __int64 v14; // x23
  unsigned __int64 *v15; // x0
  unsigned __int64 v16; // x8
  signed int (*v17)(void); // x8
  int v18; // w8
  __int64 v19; // x0
  signed __int64 result; // x0
  signed __int64 v21; // [xsp+0h] [xbp-280h]
  char v22; // [xsp+8h] [xbp-278h]
  __int64 v23; // [xsp+18h] [xbp-268h]
  char v24; // [xsp+58h] [xbp-228h]
  __int64 v25; // [xsp+80h] [xbp-200h]
  int v26; // [xsp+C0h] [xbp-1C0h]
  char **v27; // [xsp+C8h] [xbp-1B8h]
  char v28; // [xsp+D0h] [xbp-1B0h]
  char *v29; // [xsp+148h] [xbp-138h]
  __int64 v30; // [xsp+238h] [xbp-48h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v30 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = *a1;
  v8 = (pthread_rwlock_t *)(*a1 + 16LL);
  CRYPTO_STATIC_MUTEX_lock_write(v8);
  v9 = *(unsigned __int64 **)(v7 + 8);
  v26 = v6;
  if ( v6 == 2 )
  {
    v27 = (char **)&v28;
    *(_QWORD *)&v28 = &v22;
    v10 = &v23;
  }
  else
  {
    if ( v6 != 1 )
    {
LABEL_11:
      v13 = 0LL;
      goto LABEL_12;
    }
    v27 = &v29;
    v29 = &v24;
    v10 = &v25;
  }
  *v10 = v5;
  v11 = (unsigned __int64)sk_find((__int64)v9, &v21, (__int64)&v26);
  v12 = v21;
  if ( !v11 )
    v12 = 1;
  if ( v12 == -1 )
    goto LABEL_11;
  v13 = sk_value(v9, v12);
LABEL_12:
  CRYPTO_STATIC_MUTEX_unlock_write(v8);
  if ( v6 == 2 || !v13 )
  {
    if ( (signed int)sk_num(*(_QWORD **)(v7 + 80)) < 1 )
    {
LABEL_21:
      if ( !v13 )
      {
        result = 0LL;
        goto LABEL_27;
      }
    }
    else
    {
      v14 = 0LL;
      while ( 1 )
      {
        v15 = sk_value(*(unsigned __int64 **)(v7 + 80), v14);
        v16 = v15[1];
        if ( v16 )
        {
          v17 = *(signed int (**)(void))(v16 + 48);
          if ( v17 )
          {
            if ( !*((_DWORD *)v15 + 1) && v17() > 0 )
              break;
          }
        }
        if ( (signed int)++v14 >= (signed int)sk_num(*(_QWORD **)(v7 + 80)) )
          goto LABEL_21;
      }
      v13 = (unsigned __int64 *)&v29;
    }
  }
  v18 = *(_DWORD *)v13;
  *(_DWORD *)v4 = *(_DWORD *)v13;
  v19 = v13[1];
  *(_QWORD *)(v4 + 8) = v19;
  if ( v18 == 2 )
  {
    X509_up_ref(v19);
  }
  else if ( v18 == 1 )
  {
    X509_up_ref(v19);
  }
  result = 1LL;
LABEL_27:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v30;
  return result;
}

//----- (00000000000895D4) ----------------------------------------------------
unsigned __int64 *__fastcall X509_OBJECT_retrieve_by_subject(__int64 a1, int a2, __int64 a3)
{
  unsigned __int64 *v3; // x19
  __int64 *v4; // x8
  int v5; // w0
  signed int v6; // w8
  unsigned __int64 *result; // x0
  signed __int64 v8; // [xsp+0h] [xbp-250h]
  char v9; // [xsp+8h] [xbp-248h]
  __int64 v10; // [xsp+18h] [xbp-238h]
  char v11; // [xsp+58h] [xbp-1F8h]
  __int64 v12; // [xsp+80h] [xbp-1D0h]
  int v13; // [xsp+C0h] [xbp-190h]
  char **v14; // [xsp+C8h] [xbp-188h]
  char v15; // [xsp+D0h] [xbp-180h]
  char *v16; // [xsp+148h] [xbp-108h]
  __int64 v17; // [xsp+238h] [xbp-18h]

  v3 = (unsigned __int64 *)a1;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = a2;
  if ( a2 == 2 )
  {
    v14 = (char **)&v15;
    *(_QWORD *)&v15 = &v9;
    v4 = &v10;
  }
  else
  {
    if ( a2 != 1 )
    {
LABEL_11:
      result = 0LL;
      goto LABEL_12;
    }
    v14 = &v16;
    v16 = &v11;
    v4 = &v12;
  }
  *v4 = a3;
  v5 = (unsigned __int64)sk_find(a1, &v8, (__int64)&v13);
  v6 = v8;
  if ( !v5 )
    v6 = 1;
  if ( v6 == -1 )
    goto LABEL_11;
  result = sk_value(v3, v6);
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000896A4) ----------------------------------------------------
signed __int64 __fastcall X509_OBJECT_up_ref_count(__int64 a1)
{
  if ( *(_DWORD *)a1 == 2 )
  {
    X509_up_ref(*(_QWORD *)(a1 + 8));
  }
  else if ( *(_DWORD *)a1 == 1 )
  {
    X509_up_ref(*(_QWORD *)(a1 + 8));
  }
  return 1LL;
}

//----- (00000000000896E0) ----------------------------------------------------
__int64 __fastcall X509_STORE_add_cert(__int64 a1, __int64 a2)
{
  __int64 v2; // x22
  __int64 v3; // x21
  __int64 *v4; // x20
  int v5; // w2
  __int16 v6; // w4

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    v4 = (__int64 *)malloc(0x10uLL);
    if ( v4 )
    {
      v4[1] = v2;
      *(_DWORD *)v4 = 1;
      CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(v3 + 16));
      X509_up_ref(v2);
      if ( X509_OBJECT_retrieve_match(*(_QWORD *)(v3 + 8), (__int64)v4) )
      {
        if ( *(_DWORD *)v4 == 2 )
        {
          X509_CRL_free(v4[1]);
        }
        else if ( *(_DWORD *)v4 == 1 )
        {
          X509_free(v4[1]);
        }
        free(v4);
        v5 = 105;
        v6 = 357;
      }
      else
      {
        if ( sk_push(*(unsigned __int64 **)(v3 + 8), (__int64)v4) )
        {
          LODWORD(v4) = 1;
LABEL_14:
          CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v3 + 16));
          return (unsigned int)v4;
        }
        if ( *(_DWORD *)v4 == 2 )
        {
          X509_CRL_free(v4[1]);
        }
        else if ( *(_DWORD *)v4 == 1 )
        {
          X509_free(v4[1]);
        }
        free(v4);
        v5 = 65;
        v6 = 362;
      }
      ERR_put_error(11, 0LL, v5, (__int64)"external/boringssl/src/crypto/x509/x509_lu.c", v6);
      LODWORD(v4) = 0;
      goto LABEL_14;
    }
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_lu.c", 344);
  }
  else
  {
    LODWORD(v4) = 0;
  }
  return (unsigned int)v4;
}

//----- (0000000000089830) ----------------------------------------------------
unsigned __int64 __fastcall X509_OBJECT_retrieve_match(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  unsigned __int64 *v3; // x19
  unsigned __int64 result; // x0
  unsigned __int64 v5; // x21
  unsigned __int64 v6; // x22
  int v7; // w8
  unsigned __int64 v8; // [xsp+0h] [xbp-30h]
  __int64 v9; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v3 = (unsigned __int64 *)a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = (unsigned __int64)sk_find(a1, (signed __int64 *)&v8, a2);
  if ( (_DWORD)result )
  {
    v5 = v8;
    if ( (unsigned int)(*(_DWORD *)v2 - 1) > 1 )
    {
      result = (unsigned __int64)sk_value(v3, v8);
      v6 = result;
      goto LABEL_20;
    }
    while ( 1 )
    {
      result = (unsigned __int64)sk_num(v3);
      if ( v5 >= result )
        break;
      result = (unsigned __int64)sk_value(v3, v5);
      v6 = result;
      v7 = *(_DWORD *)result;
      if ( *(_DWORD *)result != *(_DWORD *)v2 )
        break;
      if ( v7 == 2 )
      {
        result = X509_CRL_cmp(*(_QWORD *)(result + 8), *(_QWORD *)(v2 + 8));
        if ( (_DWORD)result )
          break;
      }
      else
      {
        if ( v7 != 1 )
          goto LABEL_13;
        result = X509_subject_name_cmp(*(_QWORD *)(result + 8), *(_QWORD *)(v2 + 8));
        if ( (_DWORD)result )
          break;
      }
      v7 = *(_DWORD *)v2;
LABEL_13:
      if ( v7 == 2 )
      {
        result = X509_CRL_match(*(_QWORD *)(v6 + 8), *(_QWORD *)(v2 + 8));
        if ( !(_DWORD)result )
          goto LABEL_20;
      }
      else
      {
        if ( v7 != 1 )
          goto LABEL_20;
        result = X509_cmp(*(_QWORD *)(v6 + 8), *(_QWORD *)(v2 + 8));
        if ( !(_DWORD)result )
          goto LABEL_20;
      }
      ++v5;
    }
  }
  v6 = 0LL;
LABEL_20:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v9 )
    result = v6;
  return result;
}

//----- (0000000000089968) ----------------------------------------------------
void __fastcall X509_OBJECT_free_contents(__int64 a1)
{
  if ( *(_DWORD *)a1 == 2 )
  {
    X509_CRL_free(*(_QWORD *)(a1 + 8));
  }
  else if ( *(_DWORD *)a1 == 1 )
  {
    X509_free(*(_QWORD *)(a1 + 8));
  }
}

//----- (0000000000089990) ----------------------------------------------------
__int64 __fastcall X509_STORE_add_crl(__int64 a1, __int64 a2)
{
  __int64 v2; // x22
  __int64 v3; // x21
  __int64 *v4; // x20
  int v5; // w2
  __int16 v6; // w4

  v2 = a2;
  v3 = a1;
  if ( a2 )
  {
    v4 = (__int64 *)malloc(0x10uLL);
    if ( v4 )
    {
      v4[1] = v2;
      *(_DWORD *)v4 = 2;
      CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(v3 + 16));
      X509_up_ref(v2);
      if ( X509_OBJECT_retrieve_match(*(_QWORD *)(v3 + 8), (__int64)v4) )
      {
        if ( *(_DWORD *)v4 == 2 )
        {
          X509_CRL_free(v4[1]);
        }
        else if ( *(_DWORD *)v4 == 1 )
        {
          X509_free(v4[1]);
        }
        free(v4);
        v5 = 105;
        v6 = 393;
      }
      else
      {
        if ( sk_push(*(unsigned __int64 **)(v3 + 8), (__int64)v4) )
        {
          LODWORD(v4) = 1;
LABEL_14:
          CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v3 + 16));
          return (unsigned int)v4;
        }
        if ( *(_DWORD *)v4 == 2 )
        {
          X509_CRL_free(v4[1]);
        }
        else if ( *(_DWORD *)v4 == 1 )
        {
          X509_free(v4[1]);
        }
        free(v4);
        v5 = 65;
        v6 = 398;
      }
      ERR_put_error(11, 0LL, v5, (__int64)"external/boringssl/src/crypto/x509/x509_lu.c", v6);
      LODWORD(v4) = 0;
      goto LABEL_14;
    }
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_lu.c", 380);
  }
  else
  {
    LODWORD(v4) = 0;
  }
  return (unsigned int)v4;
}

//----- (0000000000089AE0) ----------------------------------------------------
__int64 __fastcall X509_STORE_set0_additional_untrusted(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 72) = a2;
  return result;
}

//----- (0000000000089AE8) ----------------------------------------------------
signed __int64 __fastcall X509_OBJECT_idx_by_subject(__int64 a1, int a2, __int64 a3)
{
  __int64 *v3; // x8
  signed __int64 result; // x0
  signed __int64 v5; // [xsp+0h] [xbp-250h]
  char v6; // [xsp+8h] [xbp-248h]
  __int64 v7; // [xsp+18h] [xbp-238h]
  char v8; // [xsp+58h] [xbp-1F8h]
  __int64 v9; // [xsp+80h] [xbp-1D0h]
  int v10; // [xsp+C0h] [xbp-190h]
  char **v11; // [xsp+C8h] [xbp-188h]
  char v12; // [xsp+D0h] [xbp-180h]
  char *v13; // [xsp+148h] [xbp-108h]
  __int64 v14; // [xsp+238h] [xbp-18h]

  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = a2;
  if ( a2 == 2 )
  {
    v11 = (char **)&v12;
    *(_QWORD *)&v12 = &v6;
    v3 = &v7;
  }
  else
  {
    if ( a2 != 1 )
    {
      result = 0xFFFFFFFFLL;
      goto LABEL_10;
    }
    v11 = &v13;
    v13 = &v8;
    v3 = &v9;
  }
  *v3 = a3;
  if ( (unsigned int)sk_find(a1, &v5, (__int64)&v10) )
    result = (unsigned int)v5;
  else
    result = 1LL;
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000089B8C) ----------------------------------------------------
signed __int64 __fastcall sub_89B8C(__int64 a1, int a2, __int64 a3, _DWORD *a4)
{
  _DWORD *v4; // x19
  unsigned __int64 *v5; // x20
  __int64 *v6; // x8
  signed __int64 v7; // x21
  signed __int64 result; // x0
  int *v9; // [xsp+0h] [xbp-270h]
  unsigned __int64 *v10; // [xsp+8h] [xbp-268h]
  __int64 v11; // [xsp+10h] [xbp-260h]
  char v12; // [xsp+18h] [xbp-258h]
  __int64 v13; // [xsp+28h] [xbp-248h]
  char v14; // [xsp+68h] [xbp-208h]
  __int64 v15; // [xsp+90h] [xbp-1E0h]
  int v16; // [xsp+D0h] [xbp-1A0h]
  char **v17; // [xsp+D8h] [xbp-198h]
  char v18; // [xsp+E0h] [xbp-190h]
  char *v19; // [xsp+158h] [xbp-118h]
  __int64 v20; // [xsp+248h] [xbp-28h]

  v4 = a4;
  v5 = (unsigned __int64 *)a1;
  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v16 = a2;
  if ( a2 == 2 )
  {
    v17 = (char **)&v18;
    *(_QWORD *)&v18 = &v12;
    v6 = &v13;
  }
  else
  {
    if ( a2 != 1 )
    {
LABEL_12:
      result = 0xFFFFFFFFLL;
      goto LABEL_13;
    }
    v17 = &v19;
    v19 = &v14;
    v6 = &v15;
  }
  *v6 = a3;
  if ( !(unsigned int)sk_find(a1, &v11, (__int64)&v16) )
    goto LABEL_12;
  if ( v4 )
  {
    *v4 = 1;
    v9 = &v16;
    LODWORD(v7) = v11 + 1;
    if ( (signed int)v7 < (signed int)sk_num(v5) )
    {
      v7 = (signed int)v7;
      do
      {
        v10 = sk_value(v5, v7);
        if ( (unsigned int)sub_89188((int **)&v10, &v9) )
          break;
        ++v7;
        ++*v4;
      }
      while ( v7 < (signed int)sk_num(v5) );
    }
  }
  result = (unsigned int)v11;
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000089CB0) ----------------------------------------------------
void __fastcall X509_STORE_get1_certs(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x21
  _QWORD *v3; // x20
  void **v4; // x19
  int v5; // w0
  __int64 v6; // x8
  __int64 v7; // x22
  __int64 v8; // x23
  __int64 v9; // x21
  int v10; // [xsp+0h] [xbp-50h]
  __int64 v11; // [xsp+8h] [xbp-48h]
  int v12; // [xsp+14h] [xbp-3Ch]
  __int64 v13; // [xsp+18h] [xbp-38h]

  v2 = a2;
  v3 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (void **)sk_new_null();
  if ( !v4 )
    goto LABEL_17;
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(*v3 + 16LL));
  v5 = sub_89B8C(*(_QWORD *)(*v3 + 8LL), 1, v2, &v12);
  if ( v5 & 0x80000000 )
  {
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*v3 + 16LL));
    if ( (unsigned int)X509_STORE_get_by_subject(v3, 1, v2, (__int64)&v10) )
    {
      if ( v10 == 2 )
      {
        X509_CRL_free(v11);
      }
      else if ( v10 == 1 )
      {
        X509_free(v11);
      }
      CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(*v3 + 16LL));
      v5 = sub_89B8C(*(_QWORD *)(*v3 + 8LL), 1, v2, &v12);
      if ( !(v5 & 0x80000000) )
        goto LABEL_3;
      CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*v3 + 16LL));
    }
    sk_free(v4);
    goto LABEL_17;
  }
LABEL_3:
  v6 = *v3;
  if ( v12 < 1 )
  {
LABEL_7:
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v6 + 16));
  }
  else
  {
    v7 = 0LL;
    v8 = v5;
    while ( 1 )
    {
      v9 = sk_value(*(unsigned __int64 **)(v6 + 8), v8 + v7)[1];
      if ( !sk_push((unsigned __int64 *)v4, v9) )
        break;
      X509_up_ref(v9);
      v6 = *v3;
      if ( (signed int)++v7 >= v12 )
        goto LABEL_7;
    }
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*v3 + 16LL));
    sk_pop_free((unsigned __int64 *)v4, (void (*)(void))X509_free);
  }
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000089E50) ----------------------------------------------------
void __fastcall X509_STORE_get1_crls(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x21
  _QWORD *v3; // x20
  void **v4; // x19
  int v5; // w0
  __int64 v6; // x8
  __int64 v7; // x22
  __int64 v8; // x23
  __int64 v9; // x21
  int v10; // [xsp+0h] [xbp-50h]
  __int64 v11; // [xsp+8h] [xbp-48h]
  int v12; // [xsp+14h] [xbp-3Ch]
  __int64 v13; // [xsp+18h] [xbp-38h]

  v2 = a2;
  v3 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (void **)sk_new_null();
  if ( !v4 )
    goto LABEL_15;
  if ( !(unsigned int)X509_STORE_get_by_subject(v3, 2, v2, (__int64)&v10) )
  {
LABEL_14:
    sk_free(v4);
    goto LABEL_15;
  }
  if ( v10 == 2 )
  {
    X509_CRL_free(v11);
  }
  else if ( v10 == 1 )
  {
    X509_free(v11);
  }
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(*v3 + 16LL));
  v5 = sub_89B8C(*(_QWORD *)(*v3 + 8LL), 2, v2, &v12);
  if ( v5 & 0x80000000 )
  {
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*v3 + 16LL));
    goto LABEL_14;
  }
  v6 = *v3;
  if ( v12 < 1 )
  {
LABEL_12:
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v6 + 16));
  }
  else
  {
    v7 = 0LL;
    v8 = v5;
    while ( 1 )
    {
      v9 = sk_value(*(unsigned __int64 **)(v6 + 8), v8 + v7)[1];
      X509_up_ref(v9);
      if ( !sk_push((unsigned __int64 *)v4, v9) )
        break;
      v6 = *v3;
      if ( (signed int)++v7 >= v12 )
        goto LABEL_12;
    }
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*v3 + 16LL));
    X509_CRL_free(v9);
    sk_pop_free((unsigned __int64 *)v4, (void (*)(void))X509_CRL_free);
  }
LABEL_15:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v13;
}

//----- (0000000000089FC4) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_get1_issuer(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x21
  __int64 *v4; // x20
  __int64 v5; // x19
  __int64 v6; // x0
  __int64 v7; // x22
  signed __int64 result; // x0
  __int64 v9; // x23
  unsigned int v10; // w23
  __int64 v11; // x0
  unsigned __int64 i; // x23
  unsigned __int64 *v13; // x0
  unsigned __int64 *v14; // x24
  __int64 v15; // x0
  int v16; // [xsp+8h] [xbp-1C8h]
  __int64 v17; // [xsp+10h] [xbp-1C0h]
  __int64 v18; // [xsp+18h] [xbp-1B8h]
  char v19; // [xsp+20h] [xbp-1B0h]
  __int64 v20; // [xsp+48h] [xbp-188h]
  int v21; // [xsp+88h] [xbp-148h]
  char *v22; // [xsp+90h] [xbp-140h]
  char v23; // [xsp+98h] [xbp-138h]
  __int64 v24; // [xsp+188h] [xbp-48h]

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = X509_get_issuer_name(a3);
  v7 = v6;
  result = X509_STORE_get_by_subject((_QWORD *)v5, 1, v6, (__int64)&v16);
  if ( (_DWORD)result )
  {
    v9 = v17;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v5 + 72))(v5, v3, v17);
    if ( (_DWORD)result )
    {
      *v4 = v9;
      v10 = 1;
    }
    else
    {
      if ( v16 == 2 )
      {
        X509_CRL_free(v9);
      }
      else if ( v16 == 1 )
      {
        X509_free(v9);
      }
      CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(*(_QWORD *)v5 + 16LL));
      v11 = *(_QWORD *)(*(_QWORD *)v5 + 8LL);
      v21 = 1;
      v22 = &v23;
      *(_QWORD *)&v23 = &v19;
      v20 = v7;
      v10 = 0;
      if ( (unsigned int)sk_find(v11, &v18, (__int64)&v21) && (_DWORD)v18 != -1 )
      {
        for ( i = (signed int)v18; i < (unsigned __int64)sk_num(*(_QWORD **)(*(_QWORD *)v5 + 8LL)); ++i )
        {
          v13 = sk_value(*(unsigned __int64 **)(*(_QWORD *)v5 + 8LL), i);
          v14 = v13;
          if ( *(_DWORD *)v13 != 1 )
            break;
          v15 = X509_get_subject_name(v13[1]);
          if ( (unsigned int)X509_NAME_cmp(v7, v15) )
            break;
          if ( (*(unsigned int (__fastcall **)(__int64, __int64, unsigned __int64))(v5 + 72))(v5, v3, v14[1]) )
          {
            *v4 = v14[1];
            if ( *(_DWORD *)v14 == 2 )
            {
              X509_up_ref(v14[1]);
            }
            else if ( *(_DWORD *)v14 == 1 )
            {
              X509_up_ref(v14[1]);
            }
            v10 = 1;
            goto LABEL_17;
          }
        }
        v10 = 0;
      }
LABEL_17:
      result = CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*(_QWORD *)v5 + 16LL));
    }
  }
  else
  {
    v10 = 0;
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v24 )
    result = v10;
  return result;
}

//----- (000000000008A1C0) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_set_flags(__int64 a1, __int64 a2)
{
  return X509_VERIFY_PARAM_set_flags(*(_QWORD *)(a1 + 88), a2);
}

//----- (000000000008A1C8) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_set_depth(__int64 a1, int a2)
{
  X509_VERIFY_PARAM_set_depth(*(_QWORD *)(a1 + 88), a2);
  return 1LL;
}

//----- (000000000008A1E4) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_set_purpose(__int64 a1, int a2)
{
  return X509_VERIFY_PARAM_set_purpose(*(_QWORD *)(a1 + 88), a2);
}

//----- (000000000008A1EC) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_set_trust(__int64 a1, int a2)
{
  return X509_VERIFY_PARAM_set_trust(*(_QWORD *)(a1 + 88), a2);
}

//----- (000000000008A1F4) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_set1_param(__int64 a1, __int64 a2)
{
  return X509_VERIFY_PARAM_set1(*(_QWORD *)(a1 + 88), a2);
}

//----- (000000000008A1FC) ----------------------------------------------------
__int64 __fastcall X509_STORE_set_verify_cb(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 104) = a2;
  return result;
}

//----- (000000000008A204) ----------------------------------------------------
__int64 __fastcall X509_STORE_set_lookup_crls_cb(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 168) = a2;
  return result;
}

//----- (000000000008A20C) ----------------------------------------------------
void __fastcall X509_NAME_oneline(unsigned __int64 **a1, _BYTE *a2, signed int a3)
{
  signed int v3; // w21
  _BYTE *v4; // x19
  unsigned __int64 **v5; // x22
  _QWORD *v6; // x0
  _QWORD *v7; // x0
  _QWORD *v8; // x20
  int v9; // w27
  unsigned __int64 v10; // x26
  const char *v11; // x20
  unsigned __int64 *v12; // x0
  unsigned __int64 *v13; // x24
  unsigned int v14; // w0
  const char *v15; // x0
  const char *v16; // x21
  unsigned int v17; // w0
  unsigned int *v18; // x11
  unsigned int v19; // w14
  __int64 v20; // x19
  __int64 v21; // x8
  signed __int64 v22; // x10
  char v23; // w12
  _BOOL4 v24; // w9
  unsigned int v25; // w13
  signed __int64 v26; // x11
  signed __int64 v27; // x13
  __int64 v28; // x9
  int v29; // w9
  int v30; // w11
  int v31; // w10
  int v32; // w9
  bool v33; // zf
  __int64 v34; // x10
  int v35; // w9
  unsigned int v36; // w11
  const char *v37; // x23
  unsigned __int64 *v38; // x20
  const char *v39; // x24
  int v40; // w9
  int v41; // w21
  unsigned int v42; // w27
  _BYTE *v43; // x8
  _BYTE *v44; // x27
  char *v45; // x27
  const char *v46; // x1
  unsigned int v47; // w24
  char *v48; // x8
  _BYTE *v49; // x8
  __int64 v50; // x10
  __int64 v51; // x9
  unsigned int v52; // w11
  char v53; // w12
  char v54; // w11
  signed __int64 v55; // x12
  _BYTE *v56; // x19
  int v57; // w2
  __int16 v58; // w4
  int v59; // [xsp+8h] [xbp-D8h]
  _BYTE *v60; // [xsp+10h] [xbp-D0h]
  _QWORD *v61; // [xsp+18h] [xbp-C8h]
  int v62; // [xsp+24h] [xbp-BCh]
  char v63; // [xsp+28h] [xbp-B8h]
  __int64 v64; // [xsp+78h] [xbp-68h]
  __int64 v65; // [xsp+80h] [xbp-60h]
  __int64 v66; // [xsp+88h] [xbp-58h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v66 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 )
  {
    v6 = 0LL;
    if ( a3 < 1 )
      goto LABEL_80;
    goto LABEL_7;
  }
  v7 = BUF_MEM_new();
  if ( !v7 )
  {
    v61 = 0LL;
    goto LABEL_72;
  }
  v8 = v7;
  if ( !BUF_MEM_grow((__int64)v7, 0xC8uLL) )
  {
    v61 = v8;
LABEL_72:
    v57 = 65;
    v58 = 196;
LABEL_73:
    ERR_put_error(11, 0LL, v57, (__int64)"external/boringssl/src/crypto/x509/x509_obj.c", v58);
    BUF_MEM_free((__int64)v61);
    goto LABEL_80;
  }
  v3 = 200;
  v6 = v8;
  *(_BYTE *)v8[1] = 0;
LABEL_7:
  if ( !v5 )
  {
    if ( v6 )
    {
      v4 = (_BYTE *)v6[1];
      free(v6);
    }
    __strncpy_chk2();
    v4[v3 - 1] = 0;
    goto LABEL_80;
  }
  v60 = v4;
  v61 = v6;
  if ( !sk_num(*v5) )
  {
    v10 = 0LL;
LABEL_68:
    if ( v61 )
    {
      v56 = (_BYTE *)v61[1];
      free(v61);
      if ( v10 )
        goto LABEL_80;
    }
    else
    {
      v56 = v60;
      if ( v10 )
        goto LABEL_80;
    }
LABEL_79:
    *v56 = 0;
    goto LABEL_80;
  }
  v9 = 0;
  v10 = 0LL;
  v11 = "0123456789ABCDEF";
  v59 = v3;
  while ( 1 )
  {
    v12 = sk_value(*v5, v10);
    v13 = v12;
    v14 = (unsigned __int64)OBJ_obj2nid((unsigned int *)*v12);
    if ( !v14 || (OBJ_nid2sn(v14), (v16 = v15) == 0LL) )
    {
      v16 = &v63;
      i2t_ASN1_OBJECT(&v63, 80, (unsigned int *)*v13);
    }
    v17 = strlen(v16);
    v18 = (unsigned int *)v13[1];
    v19 = v17;
    v20 = *v18;
    if ( (signed int)v20 > 0x100000 )
    {
      v57 = 135;
      v58 = 124;
      goto LABEL_73;
    }
    v21 = *((_QWORD *)v18 + 1);
    v22 = 0LL;
    v23 = 1;
    v24 = 1;
    if ( v20 & 3 )
    {
      v26 = 3LL;
      v27 = 2LL;
    }
    else
    {
      v25 = v18[1];
      v26 = 3LL;
      v33 = v25 == 27;
      v27 = 2LL;
      if ( v33 )
      {
        v64 = 0LL;
        v65 = 0LL;
        if ( (signed int)v20 < 1 )
        {
          v31 = 0;
          v30 = 0;
          v29 = 0;
        }
        else
        {
          v28 = 0LL;
          do
          {
            if ( *(_BYTE *)(v21 + v28) )
              *((_DWORD *)&v64 + (v28 & 3)) = 1;
            ++v28;
          }
          while ( v20 != v28 );
          v30 = HIDWORD(v64);
          v29 = v64;
          v31 = v65;
        }
        v32 = v30 | v29 | v31;
        v33 = v32 == 0;
        v24 = v32 != 0;
        if ( v24 )
          v26 = 3LL;
        else
          v26 = 2LL;
        v22 = 3LL;
        if ( v33 )
          v27 = 1LL;
        else
          v27 = 2LL;
        if ( !v33 )
          v22 = 0LL;
        v23 = v24;
      }
    }
    *((_DWORD *)&v64 + v26) = v24;
    *((_DWORD *)&v64 + v27) = v24;
    *(_DWORD *)((unsigned __int64)&v64 & 0xFFFFFFFFFFFFFFFBLL | 4LL * (v23 & 1)) = v24;
    *((_DWORD *)&v64 + v22) = 1;
    if ( (signed int)v20 < 1 )
    {
      v35 = 0;
    }
    else
    {
      v34 = 0LL;
      v35 = 0;
      do
      {
        if ( *((_DWORD *)&v64 + (v34 & 3)) )
        {
          v36 = *(unsigned __int8 *)(v21 + v34);
          if ( v36 >= 0x20 && v36 < 0x7F )
            ++v35;
          else
            v35 += 4;
        }
        ++v34;
      }
      while ( v20 != v34 );
    }
    v37 = v11;
    v38 = v13;
    v39 = v16;
    v40 = v9 + v17 + v35 + 2;
    if ( v40 > 0x100000 )
    {
      v57 = 135;
      v58 = 155;
      goto LABEL_73;
    }
    v62 = v40;
    if ( v61 )
    {
      v41 = v9;
      v42 = v17;
      if ( !BUF_MEM_grow((__int64)v61, v40 + 1) )
        goto LABEL_72;
      v43 = (_BYTE *)v61[1];
      v19 = v42;
      v9 = v41;
      goto LABEL_49;
    }
    v43 = v60;
    if ( v40 >= v59 )
      break;
LABEL_49:
    v44 = &v43[v9];
    *v44 = 47;
    v45 = v44 + 1;
    if ( v19 )
    {
      v46 = v39;
      v47 = v19;
      memcpy(v45, v46, v19);
      v19 = v47;
    }
    v48 = &v45[v19];
    *v48 = 61;
    v49 = v48 + 1;
    if ( (signed int)v20 < 1 )
    {
      v11 = v37;
    }
    else
    {
      v50 = 0LL;
      v51 = *(_QWORD *)(v38[1] + 8);
      v11 = v37;
      do
      {
        if ( *((_DWORD *)&v64 + (v50 & 3)) )
        {
          v52 = *(unsigned __int8 *)(v51 + v50);
          if ( v52 - 32 < 0x5F )
          {
            v55 = (signed __int64)(v49 + 1);
            *v49 = v52;
          }
          else
          {
            *v49 = 92;
            v53 = v37[v52 >> 4];
            v54 = v37[v52 & 0xF];
            v49[1] = 120;
            v49[2] = v53;
            v55 = (signed __int64)(v49 + 4);
            v49[3] = v54;
          }
          v49 = (_BYTE *)v55;
        }
        ++v50;
      }
      while ( v20 != v50 );
    }
    *v49 = 0;
    ++v10;
    v9 = v62;
    if ( v10 >= (unsigned __int64)sk_num(*v5) )
      goto LABEL_68;
  }
  v56 = v60;
  if ( !v10 )
    goto LABEL_79;
LABEL_80:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000008A678) ----------------------------------------------------
_QWORD *__fastcall X509v3_get_ext_count(_QWORD *result)
{
  if ( result )
    result = sk_num(result);
  return result;
}

//----- (000000000008A690) ----------------------------------------------------
__int64 __fastcall X509v3_get_ext_by_critical(unsigned __int64 *a1, int a2, int a3)
{
  int v3; // w19
  unsigned __int64 *v4; // x21
  unsigned __int64 v5; // x20
  signed int v6; // w0
  signed __int64 v7; // x22

  v3 = a2;
  v4 = a1;
  if ( a1
    && (a3 + 1 >= 0 ? (LODWORD(v5) = a3 + 1) : (LODWORD(v5) = 0), v6 = (unsigned __int64)sk_num(a1), (signed int)v5 < v6) )
  {
    v5 = (unsigned int)v5;
    v7 = v6;
    while ( (v3 != 0) != *((_DWORD *)sk_value(v4, v5) + 2) > 0 )
    {
      if ( (signed __int64)++v5 >= v7 )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    LODWORD(v5) = -1;
  }
  return (unsigned int)v5;
}

//----- (000000000008A724) ----------------------------------------------------
void **__fastcall X509v3_add_ext(void ***a1, __int64 a2, int a3)
{
  int v3; // w21
  __int64 v4; // x22
  void ***v5; // x20
  void **v6; // x19
  int v7; // w23
  __int64 v8; // x0
  __int64 v9; // x22
  bool v10; // nf
  int v11; // w8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 )
  {
    ERR_put_error(11, 0LL, 67, (__int64)"external/boringssl/src/crypto/x509/x509_v3.c", 149);
    return 0LL;
  }
  v6 = *a1;
  if ( !*a1 )
  {
    v6 = (void **)sk_new_null();
    if ( !v6 )
    {
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_v3.c", 173);
LABEL_18:
      if ( !v6 )
        return v6;
      goto LABEL_19;
    }
  }
  v7 = (unsigned __int64)sk_num(v6);
  X509_EXTENSION_dup(v4);
  v9 = v8;
  if ( !v8 )
    goto LABEL_18;
  if ( v7 >= v3 )
    v10 = v3 < 0;
  else
    v10 = 1;
  if ( v10 )
    v11 = v7;
  else
    v11 = v3;
  if ( !sk_insert(v6, v8, v11) )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_v3.c", 173);
    X509_EXTENSION_free(v9);
    if ( !v6 )
      return v6;
LABEL_19:
    sk_free(v6);
    return 0LL;
  }
  if ( !*v5 )
    *v5 = v6;
  return v6;
}

//----- (000000000008A838) ----------------------------------------------------
__int64 __fastcall X509_EXTENSION_create_by_NID(__int64 *a1, unsigned int a2, int a3, __int64 a4)
{
  __int64 *v4; // x21
  __int64 v5; // x19
  int v6; // w20
  __int64 v7; // x0

  v4 = a1;
  v5 = a4;
  v6 = a3;
  OBJ_nid2obj(a2);
  if ( v7 )
    return X509_EXTENSION_create_by_OBJ(v4, v7, v6, v5);
  ERR_put_error(11, 0LL, 129, (__int64)"external/boringssl/src/crypto/x509/x509_v3.c", 191);
  return 0LL;
}

//----- (000000000008A8B4) ----------------------------------------------------
__int64 __fastcall X509_EXTENSION_create_by_OBJ(__int64 *a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // x21
  int v5; // w22
  __int64 v6; // x23
  __int64 *v7; // x20
  __int64 v8; // x19
  __int64 *v9; // x0
  signed int v10; // w8

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a1 && (v8 = *a1) != 0 || (v8 = X509_EXTENSION_new()) != 0 )
  {
    if ( v6
      && v8
      && (ASN1_OBJECT_free(*(void ***)v8), v9 = OBJ_dup(v6), (*(_QWORD *)v8 = v9) != 0LL)
      && (!v5 ? (v10 = 1) : (v10 = 255),
          *(_DWORD *)(v8 + 8) = v10,
          (unsigned int)ASN1_STRING_set(*(_QWORD *)(v8 + 16), *(const char **)(v4 + 8), *(_DWORD *)v4)) )
    {
      if ( v7 && !*v7 )
        *v7 = v8;
    }
    else
    {
      if ( !v7 || v8 != *v7 )
        X509_EXTENSION_free(v8);
      v8 = 0LL;
    }
  }
  else
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_v3.c", 206);
  }
  return v8;
}

//----- (000000000008A99C) ----------------------------------------------------
signed __int64 __fastcall X509_EXTENSION_set_critical(signed __int64 result, int a2)
{
  signed int v2; // w8

  if ( result )
  {
    if ( a2 )
      v2 = 255;
    else
      v2 = 1;
    *(_DWORD *)(result + 8) = v2;
    result = 1LL;
  }
  return result;
}

//----- (000000000008A9B8) ----------------------------------------------------
__int64 __fastcall X509_EXTENSION_set_data(__int64 result, __int64 a2)
{
  if ( result )
    result = (unsigned int)ASN1_STRING_set(*(_QWORD *)(result + 16), *(const char **)(a2 + 8), *(_DWORD *)a2) != 0;
  return result;
}

//----- (000000000008A9E8) ----------------------------------------------------
__int64 __fastcall X509_EXTENSION_get_data(__int64 result)
{
  if ( result )
    result = *(_QWORD *)(result + 16);
  return result;
}

//----- (000000000008A9F4) ----------------------------------------------------
__int64 __fastcall X509_EXTENSION_get_critical(__int64 result)
{
  if ( result )
    result = *(_DWORD *)(result + 8) > 0;
  return result;
}

//----- (000000000008AA08) ----------------------------------------------------
void __fastcall X509_verify_cert(_QWORD *a1)
{
  __int64 v1; // x19
  int v2; // w2
  __int16 v3; // w4
  __int64 v4; // x22
  unsigned int (__fastcall *v5)(_QWORD, _QWORD); // x28
  unsigned __int64 *v6; // x0
  __int64 v7; // x0
  unsigned __int64 *v8; // x20
  __int16 v9; // w4
  signed int v10; // w8
  __int64 v11; // x8
  unsigned __int64 v12; // x21
  unsigned __int64 *v13; // x0
  _QWORD *v14; // x0
  int v15; // w25
  unsigned __int64 *v16; // x0
  int v17; // w22
  __int64 v18; // x21
  int v19; // w26
  unsigned __int64 v20; // x22
  unsigned __int64 *v21; // x23
  bool v22; // zf
  bool v23; // nf
  unsigned __int8 v24; // vf
  int v25; // w8
  __int64 v26; // x27
  signed __int64 v27; // x23
  int v28; // w21
  unsigned __int64 *v29; // x24
  int v30; // w22
  unsigned __int64 *v31; // x0
  int v32; // w21
  unsigned int (__fastcall *v33)(_QWORD, __int64); // x26
  unsigned __int64 v34; // x25
  _QWORD *v35; // x0
  unsigned __int64 *v36; // x0
  unsigned __int64 *v37; // x22
  int v38; // w0
  signed int v39; // w22
  unsigned __int64 *v40; // x0
  __int64 (__fastcall *v41)(__int64, __int64); // x22
  __int64 v42; // x25
  __int64 v43; // x0
  unsigned __int64 *v44; // x0
  unsigned __int64 *v45; // x26
  unsigned __int64 v46; // x28
  unsigned __int64 *v47; // x27
  __int64 v48; // x22
  unsigned __int64 *v49; // x0
  int v50; // w22
  signed __int64 *v51; // x0
  signed int v52; // w8
  int v53; // w8
  unsigned int (__fastcall *v54)(_QWORD, __int64); // x21
  __int64 v55; // x8
  signed __int64 v56; // x24
  int v57; // w26
  int v58; // w27
  signed int v59; // w28
  unsigned __int64 *v60; // x0
  __int64 v61; // x25
  unsigned int v62; // w0
  signed int v63; // w8
  int v64; // w0
  __int64 v65; // x8
  __int64 v66; // x23
  signed __int64 v67; // x8
  int v68; // w8
  signed __int64 v69; // x23
  unsigned __int64 *v70; // x0
  __int64 v71; // x24
  signed __int64 v72; // x25
  unsigned __int64 **v73; // x1
  int v74; // w0
  unsigned int (__fastcall *v75)(_QWORD, __int64); // x8
  __int64 v76; // x23
  __int64 v77; // x21
  _QWORD *v78; // x25
  unsigned __int64 v79; // x26
  unsigned __int64 *v80; // x0
  unsigned __int64 *v81; // x22
  size_t v82; // x0
  int v83; // w0
  __int64 v84; // x9
  unsigned int (__fastcall *v85)(_QWORD, __int64); // x10
  _BYTE *v86; // x1
  int v87; // w0
  __int64 v88; // x9
  unsigned int (__fastcall *v89)(_QWORD, __int64); // x10
  _BYTE *v90; // x1
  int v91; // w0
  __int64 v92; // x9
  unsigned int (__fastcall *v93)(_QWORD, __int64); // x10
  int v94; // w0
  unsigned __int64 *v95; // x8
  unsigned __int64 v96; // x1
  __int64 (__fastcall *v97)(__int64); // x8
  int v98; // w0
  unsigned int (__fastcall *v99)(_QWORD, _QWORD); // [xsp+0h] [xbp-90h]
  unsigned int (__fastcall *v100)(_QWORD, __int64); // [xsp+0h] [xbp-90h]
  signed int v101; // [xsp+14h] [xbp-7Ch]
  __int64 v102; // [xsp+18h] [xbp-78h]
  __int64 v103; // [xsp+18h] [xbp-78h]
  int v104; // [xsp+24h] [xbp-6Ch]
  int v105; // [xsp+24h] [xbp-6Ch]
  __int64 (__fastcall **v106)(__int64 *, __int64, unsigned __int64 *); // [xsp+28h] [xbp-68h]
  int v107; // [xsp+28h] [xbp-68h]
  unsigned __int64 *v108; // [xsp+30h] [xbp-60h]
  __int64 v109; // [xsp+38h] [xbp-58h]

  v1 = (__int64)a1;
  v109 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1[1] )
  {
    v2 = 122;
    v3 = 200;
    goto LABEL_5;
  }
  if ( a1[19] )
  {
    v2 = 66;
    v3 = 209;
LABEL_5:
    ERR_put_error(11, 0LL, v2, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", v3);
    *(_DWORD *)(v1 + 176) = 65;
    goto LABEL_6;
  }
  v4 = a1[4];
  v5 = (unsigned int (__fastcall *)(_QWORD, _QWORD))a1[7];
  v6 = sk_new_null();
  *(_QWORD *)(v1 + 152) = v6;
  if ( !v6 || !sk_push(v6, *(_QWORD *)(v1 + 8)) )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", 222);
    v10 = 17;
LABEL_14:
    *(_DWORD *)(v1 + 176) = v10;
    goto LABEL_6;
  }
  X509_up_ref(*(_QWORD *)(v1 + 8));
  v7 = *(_QWORD *)(v1 + 16);
  *(_DWORD *)(v1 + 148) = 1;
  if ( v7 )
  {
    v8 = sk_dup(v7);
    if ( !v8 )
    {
      v9 = 233;
      goto LABEL_105;
    }
  }
  else
  {
    v8 = 0LL;
  }
  v11 = *(_QWORD *)v1;
  if ( *(_QWORD *)(*(_QWORD *)v1 + 72LL) )
  {
    if ( !v8 )
    {
      v8 = sk_new_null();
      if ( !v8 )
      {
        v9 = 242;
        goto LABEL_105;
      }
      v11 = *(_QWORD *)v1;
    }
    if ( sk_num(*(_QWORD **)(v11 + 72)) )
    {
      v12 = 0LL;
      do
      {
        v13 = sk_value(*(unsigned __int64 **)(*(_QWORD *)v1 + 72LL), v12);
        if ( !sk_push(v8, (__int64)v13) )
        {
          v9 = 253;
          goto LABEL_105;
        }
        ++v12;
      }
      while ( v12 < (unsigned __int64)sk_num(*(_QWORD **)(*(_QWORD *)v1 + 72LL)) );
    }
  }
  v14 = sk_num(*(_QWORD **)(v1 + 152));
  v15 = (signed int)v14;
  v16 = sk_value(*(unsigned __int64 **)(v1 + 152), (((_QWORD)v14 << 32) - 0x100000000LL) >> 32);
  v17 = *(_DWORD *)(v4 + 40);
  v18 = (__int64)v16;
  v104 = v17;
  if ( v17 < v15 )
  {
    v106 = (__int64 (__fastcall **)(__int64 *, __int64, unsigned __int64 *))(v1 + 64);
    goto LABEL_44;
  }
  v106 = (__int64 (__fastcall **)(__int64 *, __int64, unsigned __int64 *))(v1 + 64);
  while ( 1 )
  {
    X509_check_purpose(v18, -1);
    if ( *(_BYTE *)(v18 + 65) & 0x20 )
      goto LABEL_44;
    if ( *(_BYTE *)(*(_QWORD *)(v1 + 32) + 25LL) & 0x80 )
    {
      v19 = (*(__int64 (__fastcall **)(unsigned __int64 **, __int64, __int64))(v1 + 64))(&v108, v1, v18);
      if ( v19 & 0x80000000 )
      {
        v26 = 0LL;
LABEL_204:
        *(_DWORD *)(v1 + 176) = 66;
        if ( v8 )
          goto LABEL_189;
        goto LABEL_190;
      }
      if ( v19 )
      {
        X509_free((__int64)v108);
        goto LABEL_44;
      }
    }
    if ( !v8 )
      goto LABEL_44;
    if ( !sk_num(v8) )
      break;
    v20 = 0LL;
    while ( 1 )
    {
      v21 = sk_value(v8, v20);
      if ( (*(unsigned int (__fastcall **)(__int64, __int64, unsigned __int64 *))(v1 + 72))(v1, v18, v21) )
        break;
      if ( ++v20 >= (unsigned __int64)sk_num(v8) )
        goto LABEL_42;
    }
    v108 = v21;
    if ( !v21 )
      goto LABEL_43;
    v17 = v104;
    if ( !sk_push(*(unsigned __int64 **)(v1 + 152), (__int64)v21) )
    {
      v9 = 299;
LABEL_105:
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", v9);
      v19 = 0;
      v26 = 0LL;
LABEL_187:
      *(_DWORD *)(v1 + 176) = 17;
LABEL_188:
      if ( !v8 )
        goto LABEL_190;
      goto LABEL_189;
    }
    X509_up_ref((__int64)v108);
    sk_delete_ptr(v8, (__int64)v108);
    v24 = __OFSUB__(v104, v15);
    v22 = v104 == v15;
    v23 = v104 - v15 < 0;
    ++*(_DWORD *)(v1 + 148);
    v18 = (__int64)v108;
    v25 = v15++ + 1;
    if ( (unsigned __int8)(v23 ^ v24) | v22 )
    {
      v15 = v25;
      goto LABEL_44;
    }
  }
LABEL_42:
  v108 = 0LL;
LABEL_43:
  v17 = v104;
LABEL_44:
  v26 = 0LL;
  LODWORD(v27) = v15;
  v101 = 0;
  while ( 2 )
  {
    v28 = (int)((char *)sk_num(*(_QWORD **)(v1 + 152)) - 1);
    v29 = sk_value(*(unsigned __int64 **)(v1 + 152), v28);
    X509_check_purpose((__int64)v29, -1);
    if ( !(*((_BYTE *)v29 + 65) & 0x20) )
    {
      if ( v17 >= v15 )
        goto LABEL_62;
      goto LABEL_69;
    }
    if ( sk_num(*(_QWORD **)(v1 + 152)) != (_QWORD *)((char *)&dword_0 + 1) )
    {
      v26 = sk_pop(*(signed __int64 **)(v1 + 152));
      v31 = *(unsigned __int64 **)(v1 + 152);
      LODWORD(v27) = v27 - 1;
      --*(_DWORD *)(v1 + 148);
      v29 = sk_value(v31, v15-- - 2);
      if ( v17 >= v15 )
      {
        while ( 1 )
        {
LABEL_62:
          X509_check_purpose((__int64)v29, -1);
          if ( *((_BYTE *)v29 + 65) & 0x20 )
            goto LABEL_69;
          v19 = (*v106)((__int64 *)&v108, v1, v29);
          if ( v19 & 0x80000000 )
            goto LABEL_204;
          if ( !v19 )
            goto LABEL_69;
          v29 = v108;
          if ( !sk_push(*(unsigned __int64 **)(v1 + 152), (__int64)v108) )
            break;
          v32 = v15 + 1;
          v24 = __OFSUB__(v17, v15);
          v22 = v17 == v15;
          v23 = v17 - v15++ < 0;
          if ( (unsigned __int8)(v23 ^ v24) | v22 )
            goto LABEL_70;
        }
        X509_free((__int64)v108);
        ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", 391);
LABEL_186:
        v19 = 0;
        goto LABEL_187;
      }
LABEL_69:
      v32 = v15;
LABEL_70:
      v33 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v1 + 56);
      v34 = *(signed int *)(v1 + 148);
      v35 = *(_QWORD **)(v1 + 152);
      while ( v34 < (unsigned __int64)sk_num(v35) )
      {
        v36 = sk_value(*(unsigned __int64 **)(v1 + 152), v34);
        v37 = v36;
        v38 = X509_check_trust((__int64)v36, *(_DWORD *)(*(_QWORD *)(v1 + 32) + 36LL), 0);
        if ( v38 == 2 )
        {
          *(_QWORD *)(v1 + 184) = v37;
          *(_DWORD *)(v1 + 172) = v34;
          *(_DWORD *)(v1 + 176) = 28;
          if ( !v33(0LL, v1) )
          {
            v19 = 0;
            if ( !v8 )
              goto LABEL_190;
LABEL_189:
            sk_free((void **)v8);
            goto LABEL_190;
          }
        }
        else if ( v38 == 1 )
        {
          goto LABEL_114;
        }
        v35 = *(_QWORD **)(v1 + 152);
        ++v34;
      }
      v102 = v26;
      if ( *(_BYTE *)(*(_QWORD *)(v1 + 32) + 26LL) & 8 )
      {
        v39 = *(_DWORD *)(v1 + 148);
        if ( v39 < (signed int)sk_num(*(_QWORD **)(v1 + 152)) )
          goto LABEL_114;
        v40 = sk_value(*(unsigned __int64 **)(v1 + 152), 0LL);
        v41 = *(__int64 (__fastcall **)(__int64, __int64))(v1 + 120);
        v42 = (__int64)v40;
        v43 = X509_get_subject_name((__int64)v40);
        v44 = (unsigned __int64 *)v41(v1, v43);
        v45 = v44;
        if ( v44 )
        {
          v99 = v5;
          v46 = 0LL;
          if ( sk_num(v44) )
          {
            do
            {
              v47 = sk_value(v45, v46);
              if ( !(unsigned int)X509_cmp((__int64)v47, v42) )
                break;
              ++v46;
            }
            while ( v46 < (unsigned __int64)sk_num(v45) );
            v48 = (__int64)v47;
          }
          else
          {
            v47 = 0LL;
            v48 = 0LL;
          }
          if ( v46 >= (unsigned __int64)sk_num(v45) )
          {
            sk_pop_free(v45, (void (*)(void))X509_free);
            v5 = v99;
          }
          else
          {
            X509_up_ref(v48);
            sk_pop_free(v45, (void (*)(void))X509_free);
            v5 = v99;
            if ( v48 )
            {
              sk_set(*(unsigned __int64 **)(v1 + 152), 0LL, (__int64)v47);
              X509_free(v42);
              *(_DWORD *)(v1 + 148) = 0;
              v26 = v102;
              goto LABEL_114;
            }
          }
        }
      }
      v26 = v102;
      if ( !(*(_DWORD *)(*(_QWORD *)(v1 + 32) + 24LL) & 0x108000) )
      {
        v27 = (signed int)v27;
        do
        {
          if ( v27 < 2 )
            goto LABEL_100;
          v49 = sk_value(*(unsigned __int64 **)(v1 + 152), v27 - 2);
          v19 = (*v106)((__int64 *)&v108, v1, v49);
          if ( v19 & 0x80000000 )
            goto LABEL_188;
          --v27;
        }
        while ( !v19 );
        v50 = v27 + 1;
        X509_free((__int64)v108);
        v51 = *(signed __int64 **)(v1 + 152);
        if ( v32 >= (signed int)v27 + 1 )
        {
          do
          {
            v108 = (unsigned __int64 *)sk_pop(v51);
            X509_free((__int64)v108);
            v51 = *(signed __int64 **)(v1 + 152);
            v15 = v32 - 1;
            v24 = __OFSUB__(v32, v50);
            v22 = v32 == v50;
            v23 = v32-- - v50 < 0;
          }
          while ( !((unsigned __int8)(v23 ^ v24) | v22) );
        }
        else
        {
          v15 = v32;
        }
        *(_DWORD *)(v1 + 148) = (unsigned __int64)sk_num(v51);
        v17 = v104;
        continue;
      }
LABEL_100:
      if ( v101 )
        goto LABEL_114;
      if ( v102 && (*(unsigned int (__fastcall **)(__int64, unsigned __int64 *, __int64))(v1 + 72))(v1, v29, v102) )
      {
        sk_push(*(unsigned __int64 **)(v1 + 152), v102);
        ++v32;
        *(_QWORD *)(v1 + 184) = v102;
        v52 = 19;
        v26 = 0LL;
        *(_DWORD *)(v1 + 148) = v32;
      }
      else
      {
        v53 = *(_DWORD *)(v1 + 148);
        *(_QWORD *)(v1 + 184) = v29;
        if ( v53 < v32 )
          v52 = 2;
        else
          v52 = 20;
      }
      *(_DWORD *)(v1 + 176) = v52;
      *(_DWORD *)(v1 + 172) = v32 - 1;
      if ( v5(0LL, v1) )
      {
        v101 = 1;
LABEL_114:
        v103 = v26;
        v54 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v1 + 56);
        v100 = v5;
        if ( *(_QWORD *)(v1 + 216) )
        {
          v105 = 6;
          v107 = 0;
        }
        else
        {
          v55 = *(_QWORD *)(v1 + 32);
          v105 = *(_DWORD *)(v55 + 32);
          v107 = (*(_DWORD *)(v55 + 24) >> 6) & 1;
        }
        if ( *(_DWORD *)(v1 + 148) >= 1 )
        {
          v56 = 0LL;
          v57 = 0;
          v58 = 0;
          v59 = -1;
          while ( 1 )
          {
            v60 = sk_value(*(unsigned __int64 **)(v1 + 152), v56);
            v61 = (__int64)v60;
            if ( !(*(_BYTE *)(*(_QWORD *)(v1 + 32) + 24LL) & 0x10) )
            {
              if ( *((_BYTE *)v60 + 65) & 2 )
              {
                *(_DWORD *)(v1 + 172) = v56;
                *(_DWORD *)(v1 + 176) = 34;
                *(_QWORD *)(v1 + 184) = v60;
                if ( !v54(0LL, v1) )
                  goto LABEL_184;
              }
            }
            if ( !v107 )
            {
              if ( *(_BYTE *)(v61 + 65) & 4 )
              {
                *(_DWORD *)(v1 + 172) = v56;
                *(_DWORD *)(v1 + 176) = 40;
                *(_QWORD *)(v1 + 184) = v61;
                if ( !v54(0LL, v1) )
                  goto LABEL_184;
              }
            }
            v62 = X509_check_ca(v61);
            if ( v59 )
              break;
            if ( !v62 )
              goto LABEL_136;
            v63 = 37;
LABEL_135:
            *(_DWORD *)(v1 + 172) = v56;
            *(_DWORD *)(v1 + 176) = v63;
            *(_QWORD *)(v1 + 184) = v61;
            if ( !v54(0LL, v1) )
              goto LABEL_184;
LABEL_136:
            if ( *(_DWORD *)(*(_QWORD *)(v1 + 32) + 32LL) >= 1 )
            {
              v64 = X509_check_purpose(v61, v105);
              if ( !v64 || v64 != 1 && *(_QWORD *)(*(_QWORD *)(v1 + 32) + 24LL) & 0x20 )
              {
                *(_DWORD *)(v1 + 172) = v56;
                *(_DWORD *)(v1 + 176) = 26;
                *(_QWORD *)(v1 + 184) = v61;
                if ( !v54(0LL, v1) )
                  goto LABEL_184;
              }
            }
            if ( v56 >= 2 && !(*(_BYTE *)(v61 + 64) & 0x20) )
            {
              v65 = *(_QWORD *)(v61 + 48);
              if ( v65 != -1 && v58 > v65 + v57 + 1 )
              {
                *(_DWORD *)(v1 + 172) = v56;
                *(_DWORD *)(v1 + 176) = 25;
                *(_QWORD *)(v1 + 184) = v61;
                if ( !v54(0LL, v1) )
                  goto LABEL_184;
              }
            }
            v66 = *(_QWORD *)(v61 + 64);
            if ( v66 & 0x400 )
            {
              v67 = *(_QWORD *)(v61 + 56);
              if ( v67 != -1 && v56 > v67 )
              {
                *(_DWORD *)(v1 + 172) = v56;
                *(_DWORD *)(v1 + 176) = 38;
                *(_QWORD *)(v1 + 184) = v61;
                if ( !v54(0LL, v1) )
                  goto LABEL_184;
              }
              v59 = 0;
              ++v57;
            }
            else
            {
              v59 = 1;
            }
            v58 += ~((unsigned int)v66 >> 5) & 1;
            if ( (signed int)++v56 >= *(_DWORD *)(v1 + 148) )
              goto LABEL_153;
          }
          if ( v59 == -1 )
          {
            if ( v62 < 2 )
              goto LABEL_136;
          }
          else
          {
            if ( !v62 )
            {
LABEL_134:
              v63 = 24;
              goto LABEL_135;
            }
            if ( v62 == 1 )
              goto LABEL_136;
          }
          if ( !(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 24LL) & 0x20) )
            goto LABEL_136;
          goto LABEL_134;
        }
LABEL_153:
        v26 = v103;
        v68 = (int)((char *)sk_num(*(_QWORD **)(v1 + 152)) - 1);
        if ( v68 & 0x80000000 )
        {
LABEL_165:
          v76 = *(_QWORD *)(v1 + 8);
          v77 = *(_QWORD *)(*(_QWORD *)(v1 + 32) + 56LL);
          if ( *(_QWORD *)v77 )
          {
            v78 = sk_num(*(_QWORD **)v77);
            if ( *(_QWORD *)(v77 + 16) )
            {
              free(*(void **)(v77 + 16));
              *(_QWORD *)(v77 + 16) = 0LL;
            }
            if ( v78 )
            {
              v79 = 0LL;
              while ( 1 )
              {
                v80 = sk_value(*(unsigned __int64 **)v77, v79);
                v81 = v80;
                v82 = strlen((const char *)v80);
                X509_check_host(v76, v81, v82, *(_DWORD *)(v77 + 8), (_QWORD *)(v77 + 16));
                if ( v83 > 0 )
                  break;
                if ( ++v79 >= (unsigned __int64)v78 )
                {
                  v84 = *(_QWORD *)(v1 + 8);
                  v85 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v1 + 56);
                  *(_DWORD *)(v1 + 172) = 0;
                  *(_DWORD *)(v1 + 176) = 62;
                  *(_QWORD *)(v1 + 184) = v84;
                  if ( !v85(0LL, v1) )
                    goto LABEL_184;
                  break;
                }
              }
            }
          }
          v86 = *(_BYTE **)(v77 + 24);
          if ( v86 )
          {
            X509_check_email(v76, v86, *(_QWORD *)(v77 + 32), 0);
            if ( v87 <= 0 )
            {
              v88 = *(_QWORD *)(v1 + 8);
              v89 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v1 + 56);
              *(_DWORD *)(v1 + 172) = 0;
              *(_DWORD *)(v1 + 176) = 63;
              *(_QWORD *)(v1 + 184) = v88;
              if ( !v89(0LL, v1) )
                goto LABEL_184;
            }
          }
          v90 = *(_BYTE **)(v77 + 40);
          if ( v90 )
          {
            X509_check_ip(v76, v90, *(_QWORD *)(v77 + 48), 0);
            if ( v91 <= 0 )
            {
              v92 = *(_QWORD *)(v1 + 8);
              v93 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v1 + 56);
              *(_DWORD *)(v1 + 172) = 0;
              *(_DWORD *)(v1 + 176) = 64;
              *(_QWORD *)(v1 + 184) = v92;
              if ( !v93(0LL, v1) )
                goto LABEL_184;
            }
          }
          if ( (*(unsigned int (__fastcall **)(__int64))(v1 + 80))(v1)
            && ((v94 = X509_chain_check_suiteb(
                         (_DWORD *)(v1 + 172),
                         0LL,
                         *(unsigned __int64 **)(v1 + 152),
                         *(_QWORD *)(*(_QWORD *)(v1 + 32) + 24LL))) == 0
             || (v95 = *(unsigned __int64 **)(v1 + 152),
                 v96 = *(signed int *)(v1 + 172),
                 *(_DWORD *)(v1 + 176) = v94,
                 *(_QWORD *)(v1 + 184) = sk_value(v95, v96),
                 v100(0LL, v1))) )
          {
            v97 = *(__int64 (__fastcall **)(__int64))(v1 + 48);
            if ( v97 )
              v98 = v97(v1);
            else
              v98 = sub_8B73C(v1);
            v26 = v103;
            v19 = v98;
            if ( v101 || !v98 || !(*(_BYTE *)(*(_QWORD *)(v1 + 32) + 24LL) & 0x80) )
              goto LABEL_188;
            v19 = (*(__int64 (__fastcall **)(__int64))(v1 + 112))(v1);
            if ( v8 )
              goto LABEL_189;
          }
          else
          {
LABEL_184:
            v26 = v103;
            v19 = 0;
            if ( v8 )
              goto LABEL_189;
          }
          goto LABEL_190;
        }
        v69 = v68;
        while ( 1 )
        {
          v70 = sk_value(*(unsigned __int64 **)(v1 + 152), v69);
          v71 = (__int64)v70;
          if ( !v69 || !(v70[8] & 0x20) )
          {
            v72 = (((_QWORD)sk_num(*(_QWORD **)(v1 + 152)) << 32) - 0x100000000LL) >> 32;
            if ( v72 > v69 )
              break;
          }
LABEL_163:
          v22 = v69 == 0;
          v23 = v69-- < 0;
          if ( v23 || v22 )
            goto LABEL_165;
        }
        while ( 1 )
        {
          v73 = (unsigned __int64 **)sk_value(*(unsigned __int64 **)(v1 + 152), v72)[17];
          if ( v73 )
          {
            v74 = NAME_CONSTRAINTS_check(v71, v73);
            if ( v74 )
            {
              if ( v74 == 17 )
                goto LABEL_186;
              v75 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v1 + 56);
              *(_DWORD *)(v1 + 172) = v69;
              *(_DWORD *)(v1 + 176) = v74;
              *(_QWORD *)(v1 + 184) = v71;
              if ( !v75(0LL, v1) )
                break;
            }
          }
          if ( --v72 <= v69 )
            goto LABEL_163;
        }
      }
      v19 = 0;
      if ( v8 )
        goto LABEL_189;
      goto LABEL_190;
    }
    break;
  }
  v30 = (*v106)((__int64 *)&v108, v1, v29);
  if ( v30 <= 0 )
  {
    *(_DWORD *)(v1 + 172) = v28;
    *(_DWORD *)(v1 + 176) = 18;
    *(_QWORD *)(v1 + 184) = v29;
    goto LABEL_58;
  }
  if ( !(unsigned int)X509_cmp((__int64)v29, (__int64)v108) )
  {
    X509_free((__int64)v29);
    v29 = v108;
    sk_set(*(unsigned __int64 **)(v1 + 152), v28, (__int64)v108);
    *(_DWORD *)(v1 + 148) = 0;
    v17 = v104;
    if ( v104 >= v15 )
      goto LABEL_62;
    goto LABEL_69;
  }
  *(_DWORD *)(v1 + 172) = v28;
  *(_DWORD *)(v1 + 176) = 18;
  *(_QWORD *)(v1 + 184) = v29;
  if ( v30 == 1 )
    X509_free((__int64)v108);
LABEL_58:
  v17 = v104;
  if ( v5(0LL, v1) )
  {
    v101 = 1;
    if ( v104 >= v15 )
      goto LABEL_62;
    goto LABEL_69;
  }
  v19 = 0;
  if ( v8 )
    goto LABEL_189;
LABEL_190:
  if ( v26 )
    X509_free(v26);
  if ( v19 <= 0 && !*(_DWORD *)(v1 + 176) )
  {
    v10 = 1;
    goto LABEL_14;
  }
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v109;
}
// 0: using guessed type int dword_0;

//----- (000000000008B73C) ----------------------------------------------------
__int64 __fastcall sub_8B73C(__int64 a1)
{
  __int64 v1; // x19
  int v2; // w22
  unsigned __int64 *v3; // x0
  int v4; // w23
  unsigned __int64 *v5; // x21
  __int64 v6; // x20
  __int64 v7; // x8
  __int64 v8; // x9
  __int64 result; // x0
  unsigned __int64 *v10; // x0
  unsigned __int64 *v11; // x22
  __int64 v12; // x0
  int *v13; // x22
  int v14; // w0
  __int64 *v15; // x21
  __int64 v16; // x0
  __int64 (__fastcall *v17)(__int64, __int64); // x8
  __int64 v18; // x0
  __int64 (__fastcall *v19)(__int64, __int64); // x8
  unsigned __int8 v20; // vf
  __int64 (__fastcall *v21)(signed __int64, __int64); // [xsp+8h] [xbp-28h]

  v1 = a1;
  v21 = *(__int64 (__fastcall **)(signed __int64, __int64))(a1 + 56);
  v2 = (unsigned __int64)sk_num(*(_QWORD **)(a1 + 152));
  v3 = *(unsigned __int64 **)(v1 + 152);
  v4 = v2 - 1;
  *(_DWORD *)(v1 + 172) = v2 - 1;
  v5 = sk_value(v3, v2 - 1);
  if ( !(*(unsigned int (__fastcall **)(__int64, unsigned __int64 *, unsigned __int64 *))(v1 + 72))(v1, v5, v5) )
  {
    v7 = *(_QWORD *)(v1 + 32);
    v8 = *(_QWORD *)(v7 + 24);
    if ( v8 & 0x80000 )
      goto LABEL_9;
    if ( v2 <= 1 )
    {
      *(_DWORD *)(v1 + 176) = 21;
      *(_QWORD *)(v1 + 184) = v5;
      return v21(0LL, v1);
    }
    v10 = *(unsigned __int64 **)(v1 + 152);
    v4 = v2 - 2;
    v6 = (__int64)v5;
    *(_DWORD *)(v1 + 172) = v2 - 2;
    v5 = sk_value(v10, v2 - 2);
    if ( !((v2 - 2) & 0x80000000) )
      goto LABEL_11;
    return 1LL;
  }
  v6 = (__int64)v5;
  if ( v4 & 0x80000000 )
    return 1LL;
  while ( 1 )
  {
LABEL_11:
    *(_DWORD *)(v1 + 172) = v4;
    if ( v5 == (unsigned __int64 *)v6 )
    {
      v7 = *(_QWORD *)(v1 + 32);
      v8 = *(_QWORD *)(v7 + 24);
      if ( !(v8 & 0x4000) )
      {
LABEL_9:
        v11 = v5;
        v6 = (__int64)v5;
        goto LABEL_19;
      }
    }
    X509_get_pubkey(v6);
    v13 = (int *)v12;
    if ( !v12 )
    {
      *(_DWORD *)(v1 + 176) = 6;
      *(_QWORD *)(v1 + 184) = v6;
      result = v21(0LL, v1);
      if ( !(_DWORD)result )
        return result;
      goto LABEL_18;
    }
    X509_verify((__int64 **)v5, v12);
    if ( v14 <= 0 )
    {
      *(_DWORD *)(v1 + 176) = 7;
      *(_QWORD *)(v1 + 184) = v5;
      if ( !(unsigned int)v21(0LL, v1) )
        break;
    }
LABEL_18:
    EVP_PKEY_free(v13);
    v7 = *(_QWORD *)(v1 + 32);
    v11 = v5;
    v8 = *(_QWORD *)(v7 + 24);
LABEL_19:
    v15 = (__int64 *)((v7 + 8) & (v8 << 62 >> 63));
    X509_cmp_time(**(int ***)(*v11 + 32), v15);
    if ( (_DWORD)v16 )
    {
      if ( (signed int)v16 < 1 )
        goto LABEL_24;
      v17 = *(__int64 (__fastcall **)(__int64, __int64))(v1 + 56);
      *(_DWORD *)(v1 + 176) = 9;
      *(_QWORD *)(v1 + 184) = v11;
      v16 = 0LL;
    }
    else
    {
      v17 = *(__int64 (__fastcall **)(__int64, __int64))(v1 + 56);
      *(_DWORD *)(v1 + 176) = 13;
      *(_QWORD *)(v1 + 184) = v11;
    }
    result = v17(v16, v1);
    if ( !(_DWORD)result )
      return result;
LABEL_24:
    X509_cmp_time(*(int **)(*(_QWORD *)(*v11 + 32) + 8LL), v15);
    if ( !(_DWORD)v18 )
    {
      v19 = *(__int64 (__fastcall **)(__int64, __int64))(v1 + 56);
      *(_DWORD *)(v1 + 176) = 14;
      *(_QWORD *)(v1 + 184) = v11;
LABEL_28:
      result = v19(v18, v1);
      if ( !(_DWORD)result )
        return result;
      goto LABEL_29;
    }
    if ( v18 & 0x80000000 )
    {
      v19 = *(__int64 (__fastcall **)(__int64, __int64))(v1 + 56);
      *(_DWORD *)(v1 + 176) = 10;
      *(_QWORD *)(v1 + 184) = v11;
      v18 = 0LL;
      goto LABEL_28;
    }
LABEL_29:
    *(_QWORD *)(v1 + 184) = v11;
    *(_QWORD *)(v1 + 192) = v6;
    result = v21(1LL, v1);
    if ( !(_DWORD)result )
      return result;
    v20 = __OFSUB__(v4--, 1);
    if ( (v4 < 0) ^ v20 )
    {
      v5 = v11;
      if ( v4 & 0x80000000 )
        return 1LL;
    }
    else
    {
      v5 = sk_value(*(unsigned __int64 **)(v1 + 152), v4);
      v6 = (__int64)v11;
      if ( v4 & 0x80000000 )
        return 1LL;
    }
  }
  EVP_PKEY_free(v13);
  return 0LL;
}

//----- (000000000008B9C8) ----------------------------------------------------
void __fastcall X509_cmp_current_time(int *a1)
{
  X509_cmp_time(a1, 0LL);
}

//----- (000000000008B9D0) ----------------------------------------------------
void __fastcall X509_cmp_time(int *a1, __int64 *a2)
{
  int *v2; // x19
  int v3; // w9
  int v4; // w12
  __int64 v5; // x10
  signed int v6; // w13
  signed __int64 v7; // x11
  unsigned __int8 *v8; // x10
  int v9; // w16
  char *v10; // x11
  int v11; // w15
  int v12; // w14
  int v13; // w11
  __int64 v14; // x2
  __int64 v15; // x0
  int v16; // w8
  int v17; // w9
  int v18; // w10
  int v19; // w8
  int v20; // w11
  int v21; // w9
  __int64 v22; // x12
  signed __int64 v23; // x16
  int v24; // w14
  __int64 v25; // x15
  signed __int64 v26; // x10
  int v27; // w12
  signed __int64 v28; // x13
  bool v29; // zf
  __int64 v30; // x13
  __int64 v31; // x14
  __int64 v32; // x10
  signed __int64 v33; // x10
  signed __int64 v34; // x12
  signed __int64 v35; // x10
  int v36; // [xsp+0h] [xbp-60h]
  int v37; // [xsp+4h] [xbp-5Ch]
  unsigned __int8 *v38; // [xsp+8h] [xbp-58h]
  __int64 v39; // [xsp+10h] [xbp-50h]
  unsigned __int8 v40; // [xsp+18h] [xbp-48h]
  unsigned __int8 v41; // [xsp+19h] [xbp-47h]
  __int64 v42; // [xsp+30h] [xbp-30h]
  int v43; // [xsp+38h] [xbp-28h]
  __int64 v44; // [xsp+48h] [xbp-18h]

  v2 = a1;
  v44 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *a1;
  v3 = a1[1];
  v5 = *((_QWORD *)a1 + 1);
  if ( v3 == 23 )
  {
    if ( (unsigned int)(v4 - 11) > 6 )
      goto LABEL_30;
    v6 = -10;
    LOWORD(v43) = *(_WORD *)(v5 + 8);
    v42 = *(_QWORD *)v5;
    v7 = 10LL;
  }
  else
  {
    if ( (unsigned int)(v4 - 13) > 0xA )
      goto LABEL_30;
    v6 = -12;
    v43 = *(_DWORD *)(v5 + 8);
    v42 = *(_QWORD *)v5;
    v7 = 12LL;
  }
  v8 = (unsigned __int8 *)(v5 + v7);
  v9 = *v8;
  v10 = (char *)&v42 + v7;
  v11 = v6 + v4;
  if ( (unsigned int)(v9 - 43) <= 0x2F && (1LL << ((unsigned __int8)v9 - 43)) & 0x800000000005LL )
  {
    v12 = v6 + v4;
    *(_WORD *)v10 = 12336;
LABEL_11:
    *((_WORD *)v10 + 1) = 90;
    if ( !v12 )
      goto LABEL_30;
    goto LABEL_12;
  }
  v12 = v11 - 2;
  if ( v11 < 2 )
    goto LABEL_30;
  *v10 = v9;
  v10[1] = v8[1];
  if ( v11 == 2 )
    goto LABEL_44;
  v23 = (signed __int64)(v8 + 2);
  if ( v8[2] == 46 )
  {
    v24 = v11 - 3;
    if ( v11 != 3 )
    {
      v25 = 0LL;
      v26 = (signed __int64)(v8 + 3);
      v27 = v6 + v4 - 4;
      while ( (unsigned int)*(unsigned __int8 *)(v26 + v25) - 48 <= 9 )
      {
        v28 = v25 + 1;
        if ( (signed int)v25 + 1 <= 2 )
        {
          v29 = v27 == (_DWORD)v25++;
          if ( !v29 )
            continue;
        }
        v8 = (unsigned __int8 *)(v26 + v28);
        v12 = v24 - v28;
        goto LABEL_11;
      }
      v23 = v26 + v25;
      v12 = v24 - v25;
      goto LABEL_49;
    }
LABEL_44:
    *((_WORD *)v10 + 1) = 90;
    goto LABEL_30;
  }
LABEL_49:
  *((_WORD *)v10 + 1) = 90;
  v8 = (unsigned __int8 *)v23;
LABEL_12:
  v13 = *v8;
  if ( v13 == 43 || v13 == 45 )
  {
    if ( v12 != 5 )
      goto LABEL_30;
    v22 = v8[1];
    if ( (((_DWORD)v22 - 48) & 0xFFu) > 9 )
      goto LABEL_30;
    v30 = v8[2];
    if ( (((_DWORD)v30 - 48) & 0xFFu) > 9 )
      goto LABEL_30;
    v31 = v8[3];
    if ( (((_DWORD)v31 - 48) & 0xFFu) > 9 )
      goto LABEL_30;
    v32 = v8[4];
    if ( (((_DWORD)v32 - 48) & 0xFFu) > 9 )
      goto LABEL_30;
    v33 = 60 * (v30 + 10 * v22) + 10 * v31 + v32;
    v34 = v33 - 32208;
    v35 = 32208 - v33;
    if ( v13 != 45 )
      v35 = v34;
    v14 = 60 * v35;
  }
  else
  {
    if ( v13 != 90 || v12 != 1 )
      goto LABEL_30;
    v14 = 0LL;
  }
  v37 = v3;
  v36 = 24;
  v38 = &v40;
  v39 = 0LL;
  X509_time_adj_ex((__int64)&v36, 0, v14, a2);
  if ( v15 )
  {
    if ( v2[1] != 23 )
      goto LABEL_57;
    v16 = BYTE1(v42) + 10 * (unsigned __int8)v42;
    v17 = v41 + 10 * v40;
    v18 = v16 - 528;
    v19 = v16 - 428;
    v20 = v17 - 528;
    v21 = v17 - 428;
    if ( v18 >= 50 )
      v19 = v18;
    if ( v20 >= 50 )
      v21 = v20;
    if ( v19 >= v21 && v19 <= v21 )
LABEL_57:
      strcmp((const char *)&v42, (const char *)&v40);
  }
LABEL_30:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v44;
}

//----- (000000000008BD04) ----------------------------------------------------
void __fastcall X509_time_adj(__int64 a1, __int64 a2, __int64 *a3)
{
  X509_time_adj_ex(a1, 0, a2, a3);
}

//----- (000000000008BD1C) ----------------------------------------------------
void __fastcall X509_gmtime_adj(__int64 a1, __int64 a2)
{
  X509_time_adj_ex(a1, 0, a2, 0LL);
}

//----- (000000000008BD30) ----------------------------------------------------
void __fastcall X509_time_adj_ex(__int64 a1, int a2, __int64 a3, __int64 *a4)
{
  __int64 v4; // x19
  int v5; // w20
  __int64 v6; // x21
  int v7; // w8
  __int64 v8; // [xsp+0h] [xbp-30h]
  __int64 v9; // [xsp+8h] [xbp-28h]

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = 0LL;
  if ( a4 )
  {
    v8 = *a4;
    if ( !a1 )
      goto LABEL_9;
  }
  else
  {
    time(&v8);
    if ( !v6 )
    {
LABEL_9:
      ASN1_TIME_adj((_DWORD *)v6, v8, v5, v4);
      goto LABEL_10;
    }
  }
  if ( *(_BYTE *)(v6 + 16) & 0x40 )
    goto LABEL_9;
  v7 = *(_DWORD *)(v6 + 4);
  if ( v7 == 24 )
  {
    ASN1_GENERALIZEDTIME_adj((_DWORD *)v6, v8, v5, v4);
    goto LABEL_10;
  }
  if ( v7 != 23 )
    goto LABEL_9;
  ASN1_UTCTIME_adj((_DWORD *)v6, v8, v5, v4);
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
}

//----- (000000000008BE0C) ----------------------------------------------------
void __fastcall X509_CRL_diff(_QWORD *a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x21
  __int64 v5; // x19
  __int64 v6; // x20
  __int64 *v7; // x23
  int v8; // w2
  __int16 v9; // w4
  __int64 **v10; // x0
  __int64 *v11; // x22
  int v12; // w24
  unsigned __int64 *v13; // x0
  unsigned __int64 *v14; // x23
  unsigned __int64 v15; // x24
  unsigned __int64 *v16; // x25
  unsigned __int64 v17; // x2
  __int64 v18; // x0
  __int64 v19; // [xsp+0h] [xbp-50h]
  __int64 v20; // [xsp+8h] [xbp-48h]

  v4 = (__int64)a1;
  v5 = a4;
  v6 = a3;
  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a2;
  if ( a1[8] || a2[8] )
  {
    v8 = 106;
    v9 = 2004;
LABEL_4:
    ERR_put_error(11, 0LL, v8, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", v9);
    goto LABEL_5;
  }
  if ( !a1[7] || !a2[7] )
  {
    v8 = 124;
    v9 = 2009;
    goto LABEL_4;
  }
  if ( (unsigned int)X509_NAME_cmp(*(_QWORD *)(*a1 + 16LL), *(_QWORD *)(*a2 + 16)) )
  {
    v8 = 114;
    v9 = 2014;
    goto LABEL_4;
  }
  if ( !sub_8C16C(v4, (__int64)v7, 0x5Au) )
  {
    v8 = 100;
    v9 = 2019;
    goto LABEL_4;
  }
  if ( !sub_8C16C(v4, (__int64)v7, 0x302u) )
  {
    v8 = 108;
    v9 = 2023;
    goto LABEL_4;
  }
  if ( (signed int)ASN1_INTEGER_cmp(v7[7], *(_QWORD *)(v4 + 56)) <= 0 )
  {
    v8 = 119;
    v9 = 2028;
    goto LABEL_4;
  }
  if ( v6 && ((signed int)X509_CRL_verify(v4) < 1 || (signed int)X509_CRL_verify((__int64)v7) <= 0) )
  {
    v8 = 107;
    v9 = 2034;
    goto LABEL_4;
  }
  v10 = (__int64 **)X509_CRL_new();
  v11 = (__int64 *)v10;
  if ( !v10 )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", 2096);
    goto LABEL_5;
  }
  if ( !(unsigned int)X509_CRL_set_version(v10, 1LL)
    || !X509_CRL_set_issuer_name((__int64)v11, *(_QWORD *)(*v7 + 16))
    || !X509_CRL_set_lastUpdate((__int64)v11, *(_QWORD *)(*v7 + 24))
    || !X509_CRL_set_nextUpdate((__int64)v11, *(_QWORD *)(*v7 + 32))
    || !(unsigned int)X509_CRL_add1_ext_i2d((__int64)v11, 0x8Cu, *(_QWORD *)(v4 + 56), 1, 0) )
  {
    goto LABEL_44;
  }
  if ( (signed int)X509_CRL_get_ext_count((__int64)v7) >= 1 )
  {
    v12 = 0;
    do
    {
      v13 = X509_REQ_get_attr((__int64)v7, v12);
      if ( !X509_CRL_add_ext((__int64)v11, (__int64)v13, -1) )
        goto LABEL_44;
    }
    while ( ++v12 < (signed int)X509_CRL_get_ext_count((__int64)v7) );
  }
  v14 = *(unsigned __int64 **)(*v7 + 40);
  if ( sk_num(v14) )
  {
    v15 = 0LL;
    while ( 1 )
    {
      v16 = sk_value(v14, v15);
      v17 = *v16;
      if ( !(unsigned int)X509_CRL_get0_by_serial(v4) )
      {
        X509_REVOKED_dup((__int64)v16);
        v19 = v18;
        if ( !v18 )
          goto LABEL_44;
        if ( !(unsigned int)X509_CRL_add0_revoked(v11, v18) )
          break;
      }
      if ( ++v15 >= (unsigned __int64)sk_num(v14) )
        goto LABEL_34;
    }
    X509_REVOKED_free(v19);
    goto LABEL_44;
  }
LABEL_34:
  if ( v6 )
  {
    if ( v5 && !(unsigned int)X509_CRL_sign(v11, v6, v5) )
    {
LABEL_44:
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", 2096);
      X509_CRL_free((__int64)v11);
    }
  }
LABEL_5:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v20;
}

//----- (000000000008C16C) ----------------------------------------------------
bool __fastcall sub_8C16C(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // w21
  __int64 v4; // x19
  __int64 v5; // x20
  int v6; // w22
  _BOOL8 result; // x0
  __int64 v8; // x20
  unsigned __int64 *v9; // x0
  int v10; // w22
  __int64 v11; // x8
  unsigned __int64 *v12; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = X509_REQ_get_attr_by_NID(a1, a3, -1);
  if ( v6 & 0x80000000 )
  {
    v8 = 0LL;
  }
  else
  {
    if ( (unsigned int)X509_REQ_get_attr_by_NID(v5, v3, v6) != -1 )
      return 0LL;
    v9 = X509_REQ_get_attr(v5, v6);
    v8 = X509_EXTENSION_get_data((__int64)v9);
  }
  v10 = X509_REQ_get_attr_by_NID(v4, v3, -1);
  if ( !(v10 & 0x80000000) )
  {
    if ( (unsigned int)X509_REQ_get_attr_by_NID(v4, v3, v10) != -1 )
      return 0LL;
    v12 = X509_REQ_get_attr(v4, v10);
    v11 = X509_EXTENSION_get_data((__int64)v12);
    if ( v8 | v11 )
      goto LABEL_12;
    return 1LL;
  }
  v11 = 0LL;
  if ( !v8 )
    return 1LL;
LABEL_12:
  result = 0LL;
  if ( v8 )
  {
    if ( v11 )
      result = (unsigned int)ASN1_OCTET_STRING_cmp(v8, v11) == 0;
  }
  return result;
}
// A00C8: using guessed type __int64 __fastcall ASN1_OCTET_STRING_cmp(_QWORD, _QWORD);

//----- (000000000008C274) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // x19
  int v6; // w0
  __int64 v7; // x9
  signed __int64 result; // x0
  unsigned int v9; // [xsp+4h] [xbp-1Ch]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = *(_QWORD *)(v5 + 40);
  v6 = CRYPTO_get_ex_new_index((pthread_rwlock_t *)&unk_106608, &v9, a1, a2, a4, a5);
  v7 = *(_QWORD *)(v5 + 40);
  if ( v6 )
    result = v9;
  else
    result = 1LL;
  return result;
}

//----- (000000000008C2F0) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_set_ex_data(__int64 a1, int a2, __int64 a3)
{
  return CRYPTO_set_ex_data((unsigned __int64 **)(a1 + 224), a2, a3);
}

//----- (000000000008C2F8) ----------------------------------------------------
unsigned __int64 *__fastcall X509_STORE_CTX_get_ex_data(__int64 a1, int a2)
{
  return CRYPTO_get_ex_data((unsigned __int64 **)(a1 + 224), a2);
}

//----- (000000000008C300) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get_error(__int64 a1)
{
  return *(unsigned int *)(a1 + 176);
}

//----- (000000000008C308) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_set_error(__int64 result, int a2)
{
  *(_DWORD *)(result + 176) = a2;
  return result;
}

//----- (000000000008C310) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get_error_depth(__int64 a1)
{
  return *(unsigned int *)(a1 + 172);
}

//----- (000000000008C318) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get_current_cert(__int64 a1)
{
  return *(_QWORD *)(a1 + 184);
}

//----- (000000000008C320) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get_chain(__int64 a1)
{
  return *(_QWORD *)(a1 + 152);
}

//----- (000000000008C328) ----------------------------------------------------
unsigned __int64 *__fastcall X509_STORE_CTX_get1_chain(__int64 a1)
{
  unsigned __int64 *result; // x0

  result = *(unsigned __int64 **)(a1 + 152);
  if ( result )
    result = X509_chain_up_ref((__int64)result);
  return result;
}

//----- (000000000008C338) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get0_current_issuer(__int64 a1)
{
  return *(_QWORD *)(a1 + 192);
}

//----- (000000000008C340) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get0_current_crl(__int64 a1)
{
  return *(_QWORD *)(a1 + 200);
}

//----- (000000000008C348) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get0_parent_ctx(__int64 a1)
{
  return *(_QWORD *)(a1 + 216);
}

//----- (000000000008C350) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_set0_crls(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 24) = a2;
  return result;
}

//----- (000000000008C358) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_set_purpose(__int64 a1, int a2)
{
  return X509_STORE_CTX_purpose_inherit(a1, 0, a2, 0);
}

//----- (000000000008C36C) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_purpose_inherit(__int64 a1, int a2, int a3, int a4)
{
  int v4; // w19
  int v5; // w22
  __int64 v6; // x20
  int v7; // w21
  signed int v8; // w0
  unsigned __int64 *v9; // x0
  signed int v10; // w0
  signed int v11; // w8
  int v12; // w2
  __int16 v13; // w4
  __int64 v14; // x9
  __int64 v15; // x8

  v4 = a4;
  v5 = a2;
  v6 = a1;
  if ( a3 )
    v7 = a3;
  else
    v7 = a2;
  if ( v7 )
  {
    v8 = X509_PURPOSE_get_by_id(v7);
    if ( v8 == -1 )
    {
      v12 = 130;
      v13 = 2224;
      goto LABEL_25;
    }
    v9 = X509_PURPOSE_get0(v8);
    if ( *((_DWORD *)v9 + 1) == -1 )
    {
      v10 = X509_PURPOSE_get_by_id(v5);
      if ( v10 == -1 )
      {
        v12 = 130;
        v13 = 2231;
        goto LABEL_25;
      }
      v9 = X509_PURPOSE_get0(v10);
    }
    if ( v4 )
    {
LABEL_12:
      if ( (unsigned int)X509_TRUST_get_by_id(v4) != -1 )
      {
        v11 = 1;
        if ( !v7 )
          goto LABEL_20;
LABEL_18:
        v14 = *(_QWORD *)(v6 + 32);
        if ( !*(_DWORD *)(v14 + 32) )
          *(_DWORD *)(v14 + 32) = v7;
        goto LABEL_20;
      }
      v12 = 131;
      v13 = 2243;
LABEL_25:
      ERR_put_error(11, 0LL, v12, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", v13);
      return 0LL;
    }
    v4 = *((_DWORD *)v9 + 1);
  }
  if ( v4 )
    goto LABEL_12;
  v11 = 0;
  if ( v7 )
    goto LABEL_18;
LABEL_20:
  if ( v11 )
  {
    v15 = *(_QWORD *)(v6 + 32);
    if ( !*(_DWORD *)(v15 + 36) )
      *(_DWORD *)(v15 + 36) = v4;
  }
  return 1LL;
}

//----- (000000000008C484) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_set_trust(__int64 a1, int a2)
{
  return X509_STORE_CTX_purpose_inherit(a1, 0, 0, a2);
}

//----- (000000000008C498) ----------------------------------------------------
void *X509_STORE_CTX_new()
{
  void *v0; // x0
  void *v1; // x19

  v0 = malloc(0xE8uLL);
  v1 = v0;
  if ( v0 )
    memset(v0, 0, 0xE8uLL);
  else
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", 2260);
  return v1;
}

//----- (000000000008C4F4) ----------------------------------------------------
void __fastcall X509_STORE_CTX_free(__int64 a1)
{
  void *v1; // x19

  v1 = (void *)a1;
  if ( a1 )
  {
    X509_STORE_CTX_cleanup(a1);
    free(v1);
  }
}

//----- (000000000008C52C) ----------------------------------------------------
void __fastcall X509_STORE_CTX_cleanup(__int64 a1)
{
  __int64 v1; // x19
  void (*v2)(void); // x8
  __int64 v3; // x0
  __int64 v4; // x0
  unsigned __int64 *v5; // x0

  v1 = a1;
  v2 = *(void (**)(void))(a1 + 136);
  if ( v2 )
  {
    v2();
    *(_QWORD *)(v1 + 136) = 0LL;
  }
  v3 = *(_QWORD *)(v1 + 32);
  if ( v3 )
  {
    if ( !*(_QWORD *)(v1 + 216) )
      X509_VERIFY_PARAM_free(v3);
    *(_QWORD *)(v1 + 32) = 0LL;
  }
  v4 = *(_QWORD *)(v1 + 160);
  if ( v4 )
  {
    X509_policy_tree_free(v4);
    *(_QWORD *)(v1 + 160) = 0LL;
  }
  v5 = *(unsigned __int64 **)(v1 + 152);
  if ( v5 )
  {
    sk_pop_free(v5, (void (*)(void))X509_free);
    *(_QWORD *)(v1 + 152) = 0LL;
  }
  CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_106608, v1, (unsigned __int64 **)(v1 + 224));
  *(_QWORD *)(v1 + 224) = 0LL;
}

//----- (000000000008C5B4) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_init(unsigned __int64 **a1, __int64 *a2, unsigned __int64 *a3, unsigned __int64 *a4)
{
  unsigned __int64 *v4; // x22
  __int64 *v5; // x20
  unsigned __int64 *v6; // x21
  unsigned __int64 **v7; // x19
  unsigned __int64 *v8; // x0
  int v9; // w0
  __int64 v10; // x22
  __int64 v11; // x0
  __int64 (__fastcall *v12)(__int64, __int64, __int64); // x8
  signed __int64 (__fastcall *v13)(__int64 *, __int64, __int64); // x8
  __int64 (__fastcall *v14)(); // x8
  __int64 (__fastcall *v15)(__int64); // x8
  signed __int64 (__fastcall *v16)(__int64); // x8
  void (__fastcall *v17)(__int64, __int64); // x8
  __int64 (__fastcall *v18)(__int64, __int64, __int64); // x8
  unsigned __int64 *v19; // x8
  unsigned __int64 *v20; // x8
  __int64 v21; // x0

  v4 = a3;
  v5 = a2;
  v6 = a4;
  v7 = a1;
  memset(a1, 0, 0xE8uLL);
  v7[2] = v6;
  *v7 = (unsigned __int64 *)v5;
  v7[1] = v4;
  CRYPTO_new_ex_data(v7 + 28);
  v8 = X509_VERIFY_PARAM_new();
  v7[4] = v8;
  if ( v8 )
  {
    if ( v5 )
    {
      v9 = X509_VERIFY_PARAM_inherit((__int64)v8, v5[11]);
      v7[7] = (unsigned __int64 *)v5[13];
      v7[17] = (unsigned __int64 *)v5[22];
      if ( !v9 )
        goto LABEL_26;
    }
    else
    {
      v8[2] |= 0x11uLL;
      v7[17] = 0LL;
    }
    v10 = (__int64)v7[4];
    v11 = X509_VERIFY_PARAM_lookup((__int64)"default");
    if ( (unsigned int)X509_VERIFY_PARAM_inherit(v10, v11) )
    {
      if ( v5 )
      {
        v12 = (__int64 (__fastcall *)(__int64, __int64, __int64))v5[15];
        if ( !v12 )
          v12 = sub_8C804;
        v7[9] = (unsigned __int64 *)v12;
        v13 = (signed __int64 (__fastcall *)(__int64 *, __int64, __int64))v5[14];
        if ( !v13 )
          v13 = X509_STORE_CTX_get1_issuer;
        v7[8] = (unsigned __int64 *)v13;
        v14 = (__int64 (__fastcall *)())v5[13];
        if ( !v14 )
          v14 = nullsub_1;
        v7[7] = (unsigned __int64 *)v14;
        v15 = (__int64 (__fastcall *)(__int64))v5[12];
        if ( !v15 )
          v15 = sub_8B73C;
        v7[6] = (unsigned __int64 *)v15;
        v16 = (signed __int64 (__fastcall *)(__int64))v5[16];
        if ( !v16 )
          v16 = sub_8C87C;
        v7[10] = (unsigned __int64 *)v16;
        v7[11] = (unsigned __int64 *)v5[17];
        v17 = (void (__fastcall *)(__int64, __int64))v5[18];
        if ( !v17 )
          v17 = sub_8CB58;
        v7[12] = (unsigned __int64 *)v17;
        v18 = (__int64 (__fastcall *)(__int64, __int64, __int64))v5[19];
        if ( !v18 )
          v18 = sub_8CEFC;
        v7[13] = (unsigned __int64 *)v18;
        v19 = (unsigned __int64 *)v5[20];
        if ( !v19 )
          v19 = (unsigned __int64 *)X509_STORE_get1_certs;
        v7[15] = v19;
        v20 = (unsigned __int64 *)v5[21];
        if ( v20 )
          goto LABEL_31;
      }
      else
      {
        v7[8] = (unsigned __int64 *)X509_STORE_CTX_get1_issuer;
        v7[9] = (unsigned __int64 *)sub_8C804;
        v7[6] = (unsigned __int64 *)sub_8B73C;
        v7[7] = (unsigned __int64 *)nullsub_1;
        v7[12] = (unsigned __int64 *)sub_8CB58;
        v7[13] = (unsigned __int64 *)sub_8CEFC;
        v7[10] = (unsigned __int64 *)sub_8C87C;
        v7[11] = 0LL;
        v7[15] = (unsigned __int64 *)X509_STORE_get1_certs;
      }
      v20 = (unsigned __int64 *)X509_STORE_get1_crls;
LABEL_31:
      v7[16] = v20;
      v7[14] = (unsigned __int64 *)sub_8CFD0;
      return 1LL;
    }
  }
LABEL_26:
  CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_106608, (__int64)v7, v7 + 28);
  v21 = (__int64)v7[4];
  if ( v21 )
    X509_VERIFY_PARAM_free(v21);
  memset(v7, 0, 0xE8uLL);
  ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", 2375);
  return 0LL;
}
// 8C878: using guessed type __int64 __fastcall nullsub_1();

//----- (000000000008C804) ----------------------------------------------------
__int64 __fastcall sub_8C804(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 v5; // x21
  int v6; // w0

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v6 = X509_check_issued(a3, a2);
  if ( !v6 )
    return 1LL;
  if ( !(*(_BYTE *)(*(_QWORD *)(v4 + 32) + 24LL) & 1) )
    return 0LL;
  *(_DWORD *)(v4 + 176) = v6;
  *(_QWORD *)(v4 + 184) = v5;
  *(_QWORD *)(v4 + 192) = v3;
  return (*(__int64 (__fastcall **)(_QWORD, __int64))(v4 + 56))(0LL, v4);
}

//----- (000000000008C87C) ----------------------------------------------------
signed __int64 __fastcall sub_8C87C(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x8
  __int64 v3; // x8
  unsigned __int64 v4; // x20
  __int64 v5; // x25
  unsigned __int64 *v6; // x22
  int v7; // w28
  signed int v8; // w24
  unsigned int (__fastcall *v9)(__int64, __int64 *, unsigned __int64 *); // x8
  __int64 v10; // x23
  __int64 v11; // x23
  unsigned __int64 *v12; // x23
  __int64 v13; // x8
  unsigned int (__fastcall *v14)(__int64); // x8
  int v15; // w0
  bool v16; // zf
  __int64 (__fastcall *v17)(_QWORD, __int64); // x8
  __int64 (*v18)(void); // x8
  bool v19; // nf
  unsigned __int8 v20; // vf
  signed __int64 result; // x0
  __int64 v22; // [xsp+0h] [xbp-80h]
  __int64 v23; // [xsp+8h] [xbp-78h]
  __int64 v24; // [xsp+10h] [xbp-70h]
  int v25; // [xsp+18h] [xbp-68h]
  int v26; // [xsp+1Ch] [xbp-64h]
  __int64 v27; // [xsp+20h] [xbp-60h]
  __int64 v28; // [xsp+28h] [xbp-58h]

  v1 = a1;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24LL);
  if ( !(v2 & 4) )
  {
LABEL_35:
    result = 1LL;
    goto LABEL_36;
  }
  if ( v2 & 8 )
  {
    LODWORD(v3) = (_QWORD *)((char *)sk_num(*(_QWORD **)(a1 + 152)) - 1);
    if ( v3 & 0x80000000 )
      goto LABEL_35;
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 216);
    if ( v3 )
      goto LABEL_35;
  }
  v4 = 0LL;
  v5 = (signed int)v3;
  while ( 2 )
  {
    *(_DWORD *)(v1 + 172) = v4;
    v22 = 0LL;
    v6 = sk_value(*(unsigned __int64 **)(v1 + 152), v4);
    v7 = 0;
    v8 = 0;
    *(_QWORD *)(v1 + 184) = v6;
    *(_QWORD *)(v1 + 192) = 0LL;
    *(_QWORD *)(v1 + 208) = 0LL;
    while ( 1 )
    {
      if ( v7 == 32895 )
        goto LABEL_30;
      v9 = *(unsigned int (__fastcall **)(__int64, __int64 *, unsigned __int64 *))(v1 + 88);
      if ( !v9 )
        break;
      v10 = 0LL;
      if ( !v9(v1, &v22, v6) )
        goto LABEL_32;
LABEL_19:
      v14 = *(unsigned int (__fastcall **)(__int64))(v1 + 96);
      *(_QWORD *)(v1 + 200) = v22;
      if ( !v14(v1) )
        goto LABEL_31;
      if ( !v10 )
        goto LABEL_24;
      if ( !(*(unsigned int (__fastcall **)(__int64, __int64))(v1 + 96))(v1, v10) )
        goto LABEL_31;
      v15 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64 *))(v1 + 104))(v1, v10, v6);
      if ( v15 != 2 )
      {
        if ( !v15 )
        {
LABEL_31:
          v8 = 0;
          goto LABEL_33;
        }
LABEL_24:
        v8 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64 *))(v1 + 104))(v1, v22, v6);
        if ( !v8 )
          goto LABEL_33;
        goto LABEL_27;
      }
      v8 = 2;
LABEL_27:
      X509_CRL_free(v22);
      X509_CRL_free(v10);
      v22 = 0LL;
      v16 = v7 == *(_DWORD *)(v1 + 212);
      v7 = *(_DWORD *)(v1 + 212);
      if ( v16 )
      {
        v17 = *(__int64 (__fastcall **)(_QWORD, __int64))(v1 + 56);
        *(_DWORD *)(v1 + 176) = 3;
        v8 = v17(0LL, v1);
LABEL_30:
        v10 = 0LL;
        goto LABEL_33;
      }
    }
    v27 = 0LL;
    v26 = 0;
    v23 = 0LL;
    v24 = 0LL;
    v11 = X509_get_issuer_name((__int64)v6);
    v25 = *(_DWORD *)(v1 + 212);
    if ( !sub_8D27C(v1, &v24, &v23, (unsigned __int64 **)&v27, &v26, &v25, *(unsigned __int64 **)(v1 + 24)) )
    {
      v12 = (unsigned __int64 *)(*(__int64 (__fastcall **)(__int64, __int64))(v1 + 128))(v1, v11);
      if ( !v12 )
      {
        v13 = v24;
        if ( v24 )
          goto LABEL_17;
      }
      sub_8D27C(v1, &v24, &v23, (unsigned __int64 **)&v27, &v26, &v25, v12);
      sk_pop_free(v12, (void (*)(void))X509_CRL_free);
    }
    v13 = v24;
    if ( v24 )
    {
LABEL_17:
      *(_QWORD *)(v1 + 192) = v27;
      *(_DWORD *)(v1 + 208) = v26;
      *(_DWORD *)(v1 + 212) = v25;
      v10 = v23;
      v22 = v13;
      goto LABEL_19;
    }
    v10 = 0LL;
LABEL_32:
    v18 = *(__int64 (**)(void))(v1 + 56);
    *(_DWORD *)(v1 + 176) = 3;
    v8 = v18();
LABEL_33:
    X509_CRL_free(v22);
    X509_CRL_free(v10);
    *(_QWORD *)(v1 + 200) = 0LL;
    if ( v8 )
    {
      v20 = __OFSUB__(v4, v5);
      v19 = (signed __int64)(v4++ - v5) < 0;
      if ( !(v19 ^ v20) )
        goto LABEL_35;
      continue;
    }
    break;
  }
  result = 0LL;
LABEL_36:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v28;
  return result;
}

//----- (000000000008CB58) ----------------------------------------------------
void __fastcall sub_8CB58(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x22
  int v5; // w0
  unsigned __int64 *v6; // x21
  unsigned int (*v7)(void); // x8
  int *v8; // x24
  __int64 v9; // x8
  __int64 *v10; // x22
  __int64 v11; // x0
  unsigned int (__fastcall *v12)(__int64, __int64); // x8
  unsigned int (__fastcall *v13)(_QWORD, __int64); // x8
  int v14; // w8
  unsigned int (__fastcall *v15)(_QWORD, __int64); // x8
  unsigned int (__fastcall *v16)(_QWORD, __int64); // x8
  int *v17; // x0
  __int64 v18; // x0
  unsigned int (__fastcall *v19)(__int64, __int64); // x8
  __int64 v20; // x0
  int v21; // w0
  unsigned int (__fastcall *v22)(_QWORD, __int64); // x8
  unsigned int (__fastcall *v23)(_QWORD, __int64); // x8
  signed int v24; // w9
  __int64 v25; // x22
  signed int v26; // w0
  _BOOL4 v27; // w22
  unsigned __int64 *v28; // x22
  unsigned __int64 *v29; // x23
  _QWORD *v30; // x0
  unsigned __int64 *v31; // x22
  _QWORD *v32; // x0
  unsigned __int64 *v33; // x0
  unsigned int (__fastcall *v34)(_QWORD, __int64); // x8
  __int64 v35; // [xsp+0h] [xbp-130h]
  __int64 v36; // [xsp+18h] [xbp-118h]
  __int64 v37; // [xsp+20h] [xbp-110h]
  __int64 v38; // [xsp+38h] [xbp-F8h]
  unsigned __int64 *v39; // [xsp+98h] [xbp-98h]
  __int64 v40; // [xsp+D8h] [xbp-58h]
  __int64 v41; // [xsp+E8h] [xbp-48h]

  v2 = a1;
  v3 = a2;
  v41 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *(signed int *)(a1 + 172);
  v5 = (unsigned __int64)sk_num(*(_QWORD **)(a1 + 152));
  v6 = *(unsigned __int64 **)(v2 + 192);
  if ( !v6 )
  {
    if ( (signed int)v4 >= v5 - 1 )
    {
      v6 = sk_value(*(unsigned __int64 **)(v2 + 152), v5 - 1);
      if ( !(*(unsigned int (__fastcall **)(__int64, unsigned __int64 *, unsigned __int64 *))(v2 + 72))(v2, v6, v6) )
      {
        v7 = *(unsigned int (**)(void))(v2 + 56);
        *(_DWORD *)(v2 + 176) = 33;
        if ( !v7() )
          goto LABEL_51;
      }
      if ( !v6 )
        goto LABEL_52;
    }
    else
    {
      v6 = sk_value(*(unsigned __int64 **)(v2 + 152), v4 + 1);
      if ( !v6 )
        goto LABEL_52;
    }
  }
  if ( *(_QWORD *)(v3 + 64) )
  {
    v8 = (int *)(v2 + 208);
  }
  else
  {
    if ( v6[8] & 2 )
    {
      if ( !(v6[9] & 2) )
      {
        v13 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v2 + 56);
        *(_DWORD *)(v2 + 176) = 35;
        if ( !v13(0LL, v2) )
          goto LABEL_51;
      }
    }
    v8 = (int *)(v2 + 208);
    v14 = *(_DWORD *)(v2 + 208);
    if ( !(v14 & 0x80) )
    {
      v15 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v2 + 56);
      *(_DWORD *)(v2 + 176) = 44;
      if ( !v15(0LL, v2) )
        goto LABEL_51;
      v14 = *v8;
    }
    if ( !(v14 & 8) )
    {
      if ( *(_QWORD *)(v2 + 216)
        || !(unsigned int)X509_STORE_CTX_init(
                            (unsigned __int64 **)&v35,
                            *(__int64 **)v2,
                            *(unsigned __int64 **)(v2 + 192),
                            *(unsigned __int64 **)(v2 + 16)) )
      {
        goto LABEL_55;
      }
      v36 = *(_QWORD *)(v2 + 24);
      v25 = *(_QWORD *)(v2 + 32);
      if ( v37 )
        X509_VERIFY_PARAM_free(v37);
      v37 = v25;
      v40 = v2;
      v38 = *(_QWORD *)(v2 + 56);
      X509_verify_cert(&v35);
      v27 = v26;
      if ( v26 >= 1 )
      {
        v28 = *(unsigned __int64 **)(v2 + 152);
        v29 = v39;
        v30 = sk_num(*(_QWORD **)(v2 + 152));
        v31 = sk_value(v28, (unsigned __int64)v30 - 1);
        v32 = sk_num(v29);
        v33 = sk_value(v29, (unsigned __int64)v32 - 1);
        v27 = (unsigned __int64)X509_cmp((__int64)v31, (__int64)v33) == 0;
      }
      X509_STORE_CTX_cleanup((__int64)&v35);
      if ( v27 <= 0 )
      {
LABEL_55:
        v16 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v2 + 56);
        *(_DWORD *)(v2 + 176) = 54;
        if ( !v16(0LL, v2) )
          goto LABEL_51;
      }
    }
    if ( *(_BYTE *)(v3 + 48) & 2 )
    {
      v34 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v2 + 56);
      *(_DWORD *)(v2 + 176) = 41;
      if ( !v34(0LL, v2) )
        goto LABEL_51;
    }
  }
  if ( !(*(_BYTE *)v8 & 0x40) )
  {
    v9 = *(_QWORD *)(v2 + 32);
    *(_QWORD *)(v2 + 200) = v3;
    v10 = (__int64 *)((v9 + 8) & (*(_QWORD *)(v9 + 24) << 62 >> 63));
    X509_cmp_time(*(int **)(*(_QWORD *)v3 + 24LL), v10);
    if ( (_DWORD)v11 )
    {
      if ( (signed int)v11 < 1 )
      {
LABEL_26:
        v17 = *(int **)(*(_QWORD *)v3 + 32LL);
        if ( !v17 )
          goto LABEL_33;
        X509_cmp_time(v17, v10);
        if ( (_DWORD)v18 )
        {
          if ( !(v18 & 0x80000000) || *(_BYTE *)v8 & 2 )
            goto LABEL_33;
          v19 = *(unsigned int (__fastcall **)(__int64, __int64))(v2 + 56);
          *(_DWORD *)(v2 + 176) = 12;
          v18 = 0LL;
        }
        else
        {
          v19 = *(unsigned int (__fastcall **)(__int64, __int64))(v2 + 56);
          *(_DWORD *)(v2 + 176) = 16;
        }
        if ( v19(v18, v2) )
        {
LABEL_33:
          *(_QWORD *)(v2 + 200) = 0LL;
          goto LABEL_34;
        }
LABEL_51:
        v6 = 0LL;
        goto LABEL_52;
      }
      v12 = *(unsigned int (__fastcall **)(__int64, __int64))(v2 + 56);
      *(_DWORD *)(v2 + 176) = 11;
      v11 = 0LL;
    }
    else
    {
      v12 = *(unsigned int (__fastcall **)(__int64, __int64))(v2 + 56);
      *(_DWORD *)(v2 + 176) = 15;
    }
    if ( !v12(v11, v2) )
      goto LABEL_51;
    goto LABEL_26;
  }
LABEL_34:
  X509_get_pubkey((__int64)v6);
  v6 = (unsigned __int64 *)v20;
  if ( !v20 )
  {
    v23 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v2 + 56);
    v24 = 6;
    goto LABEL_40;
  }
  v21 = X509_CRL_check_suiteb(v3, v20, *(_QWORD *)(*(_QWORD *)(v2 + 32) + 24LL));
  if ( !v21
    || (v22 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v2 + 56), *(_DWORD *)(v2 + 176) = v21, v22(0LL, v2)) )
  {
    if ( (signed int)X509_CRL_verify(v3) <= 0 )
    {
      v23 = *(unsigned int (__fastcall **)(_QWORD, __int64))(v2 + 56);
      v24 = 8;
LABEL_40:
      *(_DWORD *)(v2 + 176) = v24;
      !v23(0LL, v2);
      goto LABEL_52;
    }
  }
LABEL_52:
  EVP_PKEY_free((int *)v6);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000008CEFC) ----------------------------------------------------
__int64 __fastcall sub_8CEFC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 v5; // x21
  __int64 (__fastcall *v6)(_QWORD, __int64); // x8
  __int64 result; // x0
  __int64 (__fastcall *v8)(_QWORD, __int64); // x8
  __int64 v9; // [xsp+0h] [xbp-30h]
  __int64 v10; // [xsp+8h] [xbp-28h]

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 32) + 24LL) & 0x10
    || !(*(_BYTE *)(a2 + 29) & 2)
    || (v6 = *(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 56),
        *(_DWORD *)(a1 + 176) = 36,
        result = v6(0LL, a1),
        (_DWORD)result) )
  {
    if ( (unsigned int)X509_CRL_get0_by_cert(v5, (__int64)&v9, v4) )
    {
      if ( *(_DWORD *)(v9 + 32) == 8 )
      {
        result = 2LL;
        goto LABEL_9;
      }
      v8 = *(__int64 (__fastcall **)(_QWORD, __int64))(v3 + 56);
      *(_DWORD *)(v3 + 176) = 23;
      result = v8(0LL, v3);
      if ( !(_DWORD)result )
        goto LABEL_9;
    }
    result = 1LL;
  }
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000008CFD0) ----------------------------------------------------
__int64 __fastcall sub_8CFD0(__int64 a1)
{
  __int64 v1; // x19
  __int64 result; // x0
  int v3; // w0
  unsigned __int64 v4; // x20
  unsigned __int64 *v5; // x0
  __int64 (__fastcall *v6)(_QWORD, __int64); // x8
  __int64 (__fastcall *v7)(signed __int64, __int64); // x8

  v1 = a1;
  if ( *(_QWORD *)(a1 + 216) )
    return 1LL;
  v3 = X509_policy_check(
         (__int64 *)(a1 + 160),
         (_DWORD *)(a1 + 168),
         *(unsigned __int64 **)(a1 + 152),
         *(unsigned __int64 **)(*(_QWORD *)(a1 + 32) + 48LL),
         *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24LL));
  if ( v3 == -2 )
  {
    *(_QWORD *)(v1 + 184) = 0LL;
    *(_DWORD *)(v1 + 176) = 43;
    return (*(__int64 (__fastcall **)(_QWORD, __int64))(v1 + 56))(0LL, v1);
  }
  if ( !v3 )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_vfy.c", 1668);
    result = 0LL;
    *(_DWORD *)(v1 + 176) = 17;
    return result;
  }
  if ( v3 != -1 )
  {
    if ( *(_BYTE *)(*(_QWORD *)(v1 + 32) + 25LL) & 8 )
    {
      v7 = *(__int64 (__fastcall **)(signed __int64, __int64))(v1 + 56);
      *(_QWORD *)(v1 + 184) = 0LL;
      result = v7(2LL, v1);
      if ( !(_DWORD)result )
        return result;
    }
    return 1LL;
  }
  if ( (unsigned __int64)sk_num(*(_QWORD **)(v1 + 152)) < 2 )
    return 1LL;
  v4 = 1LL;
  while ( 1 )
  {
    v5 = sk_value(*(unsigned __int64 **)(v1 + 152), v4);
    if ( *((_BYTE *)v5 + 65) & 8 )
    {
      v6 = *(__int64 (__fastcall **)(_QWORD, __int64))(v1 + 56);
      *(_QWORD *)(v1 + 184) = v5;
      *(_DWORD *)(v1 + 176) = 42;
      result = v6(0LL, v1);
      if ( !(_DWORD)result )
        break;
    }
    if ( ++v4 >= (unsigned __int64)sk_num(*(_QWORD **)(v1 + 152)) )
      return 1LL;
  }
  return result;
}

//----- (000000000008D10C) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_trusted_stack(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 40) = a2;
  *(_QWORD *)(result + 64) = sub_8D120;
  return result;
}

//----- (000000000008D120) ----------------------------------------------------
signed __int64 __fastcall sub_8D120(unsigned __int64 **a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x21
  unsigned __int64 *v4; // x22
  unsigned __int64 **v5; // x19
  __int64 v6; // x20
  unsigned __int64 v7; // x23
  unsigned __int64 *v8; // x24
  signed __int64 result; // x0

  v3 = a2;
  v4 = *(unsigned __int64 **)(a2 + 40);
  v5 = a1;
  v6 = a3;
  if ( sk_num(*(_QWORD **)(a2 + 40)) )
  {
    v7 = 0LL;
    while ( 1 )
    {
      v8 = sk_value(v4, v7);
      if ( (*(unsigned int (__fastcall **)(__int64, __int64, unsigned __int64 *))(v3 + 72))(v3, v6, v8) )
        break;
      if ( ++v7 >= (unsigned __int64)sk_num(v4) )
        goto LABEL_5;
    }
    *v5 = v8;
    if ( v8 )
    {
      X509_up_ref((__int64)v8);
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
LABEL_5:
    result = 0LL;
    *v5 = 0LL;
  }
  return result;
}

//----- (000000000008D1CC) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_set_depth(__int64 a1, int a2)
{
  return X509_VERIFY_PARAM_set_depth(*(_QWORD *)(a1 + 32), a2);
}

//----- (000000000008D1D4) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_set_flags(__int64 a1, __int64 a2)
{
  return X509_VERIFY_PARAM_set_flags(*(_QWORD *)(a1 + 32), a2);
}

//----- (000000000008D1DC) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_set_time(__int64 a1, __int64 a2, __int64 a3)
{
  return X509_VERIFY_PARAM_set_time(*(_QWORD *)(a1 + 32), a3);
}

//----- (000000000008D1E8) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_set_verify_cb(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 56) = a2;
  return result;
}

//----- (000000000008D1F0) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get0_policy_tree(__int64 a1)
{
  return *(_QWORD *)(a1 + 160);
}

//----- (000000000008D1F8) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get_explicit_policy(__int64 a1)
{
  return *(unsigned int *)(a1 + 168);
}

//----- (000000000008D200) ----------------------------------------------------
signed __int64 __fastcall X509_STORE_CTX_set_default(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x8
  signed __int64 result; // x0

  v2 = a1;
  v3 = X509_VERIFY_PARAM_lookup(a2);
  if ( v3 )
    result = X509_VERIFY_PARAM_inherit(*(_QWORD *)(v2 + 32), v3);
  else
    result = 0LL;
  return result;
}

//----- (000000000008D244) ----------------------------------------------------
__int64 __fastcall X509_STORE_CTX_get0_param(__int64 a1)
{
  return *(_QWORD *)(a1 + 32);
}

//----- (000000000008D24C) ----------------------------------------------------
void __fastcall X509_STORE_CTX_set0_param(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x0
  __int64 v4; // x20

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = a2;
  if ( v3 )
    X509_VERIFY_PARAM_free(v3);
  *(_QWORD *)(v2 + 32) = v4;
}

//----- (000000000008D27C) ----------------------------------------------------
bool __fastcall sub_8D27C(__int64 a1, __int64 *a2, __int64 *a3, unsigned __int64 **a4, int *a5, _DWORD *a6, unsigned __int64 *a7)
{
  __int64 v7; // x21
  int *v8; // x27
  unsigned __int64 *v9; // x20
  int v10; // w22
  _DWORD *v11; // x19
  unsigned __int64 **v12; // x23
  __int64 *v13; // x26
  __int64 *v14; // x24
  __int64 v15; // x23
  int v16; // w24
  unsigned __int64 v17; // x28
  unsigned __int64 *v18; // x0
  unsigned __int64 *v19; // x25
  int v20; // w8
  __int64 v21; // x0
  signed int v22; // w8
  __int64 *v23; // x19
  int v24; // w0
  int *v25; // x0
  int v26; // w0
  unsigned __int64 v27; // x20
  __int64 v28; // x19
  unsigned __int64 *v29; // x23
  int v30; // w0
  unsigned __int64 *v31; // x0
  __int64 v32; // x0
  unsigned __int64 v33; // x20
  unsigned __int64 *v34; // x0
  __int64 v35; // x0
  unsigned __int64 v36; // x20
  unsigned __int64 *v37; // x0
  __int64 v38; // x0
  int v39; // w8
  unsigned __int64 v40; // x19
  unsigned __int64 *v41; // x0
  unsigned __int64 *v42; // x26
  _QWORD *v43; // x0
  __int64 v44; // x20
  unsigned __int64 v45; // x23
  unsigned __int64 *v46; // x0
  unsigned __int64 *v47; // x8
  unsigned __int64 v48; // x20
  __int64 v49; // x1
  unsigned __int64 *v50; // x23
  unsigned __int64 v51; // x27
  unsigned __int64 *v52; // x0
  unsigned __int64 *v53; // x23
  unsigned __int64 v54; // x27
  unsigned __int64 *v55; // x0
  _QWORD **v56; // x8
  int v57; // w8
  int v58; // w9
  _QWORD *v59; // x8
  unsigned __int64 v60; // x24
  __int64 *v61; // x19
  __int64 *v62; // x20
  int v63; // w0
  int *v64; // x0
  int v65; // w0
  __int64 v66; // x8
  int *v68; // [xsp+0h] [xbp-E0h]
  __int64 *v69; // [xsp+8h] [xbp-D8h]
  int v70; // [xsp+14h] [xbp-CCh]
  unsigned __int64 **v71; // [xsp+18h] [xbp-C8h]
  __int64 *v72; // [xsp+20h] [xbp-C0h]
  unsigned __int64 **v73; // [xsp+28h] [xbp-B8h]
  unsigned __int64 *v74; // [xsp+38h] [xbp-A8h]
  __int64 v75; // [xsp+40h] [xbp-A0h]
  unsigned __int64 v76; // [xsp+40h] [xbp-A0h]
  unsigned __int64 v77; // [xsp+48h] [xbp-98h]
  unsigned __int64 *v78; // [xsp+50h] [xbp-90h]
  unsigned __int64 *v79; // [xsp+58h] [xbp-88h]
  _DWORD *v80; // [xsp+60h] [xbp-80h]
  unsigned __int64 *v81; // [xsp+68h] [xbp-78h]
  __int64 v82; // [xsp+70h] [xbp-70h]
  int v83; // [xsp+78h] [xbp-68h]
  int v84; // [xsp+7Ch] [xbp-64h]
  int v85; // [xsp+80h] [xbp-60h]
  int v86; // [xsp+84h] [xbp-5Ch]
  __int64 v87; // [xsp+88h] [xbp-58h]

  v7 = a1;
  v8 = a5;
  v9 = a7;
  v87 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = *a5;
  v11 = a6;
  v12 = a4;
  v13 = a3;
  v82 = *(_QWORD *)(a1 + 184);
  v14 = a2;
  if ( !sk_num(a7) )
    goto LABEL_137;
  v72 = v14;
  v73 = v12;
  v15 = v82;
  v16 = 0;
  v17 = 0LL;
  v74 = 0LL;
  v78 = 0LL;
  v79 = 0LL;
  v80 = v11;
  v81 = v9;
  do
  {
    v18 = sk_value(v9, v17);
    v19 = v18;
    v20 = *((_DWORD *)v18 + 12);
    if ( v20 & 2 )
      goto LABEL_110;
    v84 = v16;
    v16 = *v11;
    if ( *(_BYTE *)(*(_QWORD *)(v7 + 32) + 25LL) & 0x10 )
    {
      if ( v20 & 0x40 )
      {
        if ( !(*((_DWORD *)v18 + 13) & ~v16) )
        {
          v16 = v84;
          goto LABEL_110;
        }
      }
      else if ( v18[8] )
      {
        v16 = v84;
        goto LABEL_110;
      }
    }
    else if ( v20 & 0x60 )
    {
      v16 = v84;
      goto LABEL_110;
    }
    v21 = X509_get_issuer_name(v15);
    if ( (unsigned int)X509_NAME_cmp(v21, *(_QWORD *)(*v19 + 16)) )
    {
      if ( !(v19[6] & 0x20) )
      {
        v16 = v84;
        goto LABEL_110;
      }
      v22 = 0;
      v83 = v10;
    }
    else
    {
      v83 = v10;
      v22 = 32;
    }
    v10 = ((*((_DWORD *)v19 + 7) >> 1) & 0x100 | v22) ^ 0x100;
    v23 = (__int64 *)((*(_QWORD *)(v7 + 32) + 8LL) & (*(_QWORD *)(*(_QWORD *)(v7 + 32) + 24LL) << 62 >> 63));
    X509_cmp_time(*(int **)(*v19 + 24), v23);
    if ( v24 & 0x80000000 )
    {
      v25 = *(int **)(*v19 + 32);
      if ( !v25 || (X509_cmp_time(v25, v23), v26) && (!(v26 & 0x80000000) || *(_BYTE *)(v7 + 208) & 2) )
        v10 |= 0x40u;
    }
    v27 = *(signed int *)(v7 + 172);
    v28 = *(_QWORD *)(*v19 + 16);
    if ( (_QWORD *)v27 != (_QWORD *)((char *)sk_num(*(_QWORD **)(v7 + 152)) - 1) )
      ++v27;
    v29 = sk_value(*(unsigned __int64 **)(v7 + 152), v27);
    v30 = X509_check_akid((__int64)v29, (_QWORD *)v19[4]);
    if ( !(v10 & 0x20) || v30 )
    {
      LODWORD(v27) = v27 + 1;
      if ( (signed int)v27 >= (signed int)sk_num(*(_QWORD **)(v7 + 152)) )
      {
LABEL_33:
        if ( !(*(_BYTE *)(*(_QWORD *)(v7 + 32) + 25LL) & 0x10) )
          goto LABEL_44;
        if ( sk_num(*(_QWORD **)(v7 + 16)) )
        {
          v33 = 0LL;
          while ( 1 )
          {
            v34 = sk_value(*(unsigned __int64 **)(v7 + 16), v33);
            v29 = v34;
            v35 = X509_get_subject_name((__int64)v34);
            if ( !(unsigned int)X509_NAME_cmp(v35, v28)
              && !(unsigned int)X509_check_akid((__int64)v29, (_QWORD *)v19[4]) )
            {
              break;
            }
            if ( ++v33 >= (unsigned __int64)sk_num(*(_QWORD **)(v7 + 16)) )
              goto LABEL_39;
          }
        }
        else
        {
LABEL_39:
          if ( !sk_num(*(_QWORD **)(*(_QWORD *)v7 + 72LL)) )
            goto LABEL_44;
          v36 = 0LL;
          while ( 1 )
          {
            v37 = sk_value(*(unsigned __int64 **)(*(_QWORD *)v7 + 72LL), v36);
            v29 = v37;
            v38 = X509_get_subject_name((__int64)v37);
            if ( !(unsigned int)X509_NAME_cmp(v38, v28)
              && !(unsigned int)X509_check_akid((__int64)v29, (_QWORD *)v19[4]) )
            {
              break;
            }
            if ( ++v36 >= (unsigned __int64)sk_num(*(_QWORD **)(*(_QWORD *)v7 + 72LL)) )
              goto LABEL_44;
          }
        }
        v10 |= 4u;
      }
      else
      {
        v27 = (signed int)v27;
        while ( 1 )
        {
          v31 = sk_value(*(unsigned __int64 **)(v7 + 152), v27);
          v29 = v31;
          v32 = X509_get_subject_name((__int64)v31);
          if ( !(unsigned int)X509_NAME_cmp(v32, v28) && !(unsigned int)X509_check_akid((__int64)v29, (_QWORD *)v19[4]) )
            break;
          if ( (signed __int64)++v27 >= (signed int)sk_num(*(_QWORD **)(v7 + 152)) )
            goto LABEL_33;
        }
        v10 |= 0xCu;
      }
    }
    else
    {
      v10 |= 0x1Cu;
    }
    v79 = v29;
LABEL_44:
    v11 = v80;
    v9 = v81;
    v15 = v82;
    if ( !(v10 & 4) )
      goto LABEL_45;
    v39 = *((_DWORD *)v19 + 12);
    if ( v39 & 0x10 )
      goto LABEL_102;
    if ( *(_BYTE *)(v82 + 64) & 0x10 )
    {
      if ( v39 & 4 )
        goto LABEL_102;
    }
    else if ( v39 & 8 )
    {
      goto LABEL_102;
    }
    v70 = *((_DWORD *)v19 + 13);
    if ( !sk_num(*(_QWORD **)(v82 + 120)) )
    {
      v56 = (_QWORD **)(v19 + 5);
LABEL_95:
      v59 = *v56;
      v58 = v70;
      if ( v59 )
      {
        if ( !(v10 & 0x20) || *v59 )
          goto LABEL_102;
      }
      else if ( !(v10 & 0x20) )
      {
        goto LABEL_102;
      }
      if ( !(v70 & ~v16) )
        goto LABEL_45;
      goto LABEL_101;
    }
    v40 = 0LL;
    v68 = v8;
    v69 = v13;
    v71 = (unsigned __int64 **)(v19 + 5);
    while ( 1 )
    {
      v41 = sk_value(*(unsigned __int64 **)(v15 + 120), v40);
      v42 = v41;
      v43 = (_QWORD *)v41[2];
      if ( v43 )
      {
        v44 = *(_QWORD *)(*v19 + 16);
        if ( !sk_num(v43) )
          goto LABEL_88;
        v45 = 0LL;
        while ( 1 )
        {
          v46 = sk_value((unsigned __int64 *)v42[2], v45);
          if ( *(_DWORD *)v46 == 4 && !(unsigned int)X509_NAME_cmp(v46[1], v44) )
            break;
          if ( ++v45 >= (unsigned __int64)sk_num((_QWORD *)v42[2]) )
            goto LABEL_88;
        }
      }
      else if ( !(v10 & 0x20) )
      {
        goto LABEL_88;
      }
      v47 = *v71;
      if ( !*v71 )
        goto LABEL_92;
      v77 = *v42;
      if ( !*v42 )
        goto LABEL_92;
      v48 = *v47;
      if ( !*v47 )
        goto LABEL_92;
      if ( *(_DWORD *)v77 != 1 )
        break;
      v75 = *(_QWORD *)(v77 + 16);
      if ( !v75 )
        goto LABEL_88;
      if ( *(_DWORD *)v48 == 1 )
      {
        v49 = *(_QWORD *)(v48 + 16);
        if ( v49 && !(unsigned int)X509_NAME_cmp(v75, v49) )
          goto LABEL_92;
        goto LABEL_88;
      }
      v77 = *v47;
LABEL_83:
      v53 = *(unsigned __int64 **)(v77 + 8);
      if ( sk_num(*(_QWORD **)(v77 + 8)) )
      {
        v54 = 0LL;
        do
        {
          v55 = sk_value(v53, v54);
          if ( *(_DWORD *)v55 == 4 && !(unsigned int)X509_NAME_cmp(v75, v55[1]) )
            goto LABEL_92;
        }
        while ( ++v54 < (unsigned __int64)sk_num(v53) );
      }
LABEL_88:
      v15 = v82;
      if ( ++v40 >= (unsigned __int64)sk_num(*(_QWORD **)(v82 + 120)) )
      {
        v8 = v68;
        v13 = v69;
        v11 = v80;
        v9 = v81;
        v56 = (_QWORD **)(v19 + 5);
        goto LABEL_95;
      }
    }
    if ( *(_DWORD *)v48 == 1 )
    {
      v75 = *(_QWORD *)(v48 + 16);
      if ( !v75 )
        goto LABEL_88;
      goto LABEL_83;
    }
    if ( !sk_num(*(_QWORD **)(v77 + 8)) )
      goto LABEL_88;
    v76 = 0LL;
    while ( 1 )
    {
      v50 = sk_value(*(unsigned __int64 **)(v77 + 8), v76);
      if ( sk_num(*(_QWORD **)(v48 + 8)) )
        break;
LABEL_80:
      if ( ++v76 >= (unsigned __int64)sk_num(*(_QWORD **)(v77 + 8)) )
        goto LABEL_88;
    }
    v51 = 0LL;
    while ( 1 )
    {
      v52 = sk_value(*(unsigned __int64 **)(v48 + 8), v51);
      if ( !(unsigned int)GENERAL_NAME_cmp((__int64)v50, (__int64)v52) )
        break;
      if ( ++v51 >= (unsigned __int64)sk_num(*(_QWORD **)(v48 + 8)) )
        goto LABEL_80;
    }
LABEL_92:
    v57 = *((_DWORD *)v42 + 6);
    v8 = v68;
    v13 = v69;
    v11 = v80;
    v9 = v81;
    v15 = v82;
    v58 = v57 & v70;
    if ( !(v57 & v70 & ~v16) )
    {
LABEL_45:
      v10 = v83;
      v16 = v84;
      goto LABEL_110;
    }
LABEL_101:
    v16 |= v58;
    v10 |= 0x80u;
LABEL_102:
    if ( v10 < v83
      || !v10
      || v78
      && v10 == v83
      && (!(unsigned int)ASN1_TIME_diff(&v86, &v85, *(signed int **)(*v78 + 24), *(signed int **)(*v19 + 24))
       || v86 <= 0 && v85 < 1) )
    {
      goto LABEL_45;
    }
    v78 = v19;
    v74 = v79;
LABEL_110:
    ++v17;
  }
  while ( v17 < (unsigned __int64)sk_num(v9) );
  if ( v78 )
  {
    if ( *v72 )
      X509_CRL_free(*v72);
    *v72 = (__int64)v78;
    *v73 = v74;
    *v8 = v10;
    *v11 = v16;
    X509_up_ref((__int64)v78);
    if ( *v13 )
    {
      X509_CRL_free(*v13);
      *v13 = 0LL;
    }
    if ( *(_BYTE *)(*(_QWORD *)(v7 + 32) + 25LL) & 0x20
      && (*((_DWORD *)v78 + 7) | *(_DWORD *)(*(_QWORD *)(v7 + 184) + 64LL)) & 0x1000 )
    {
      if ( sk_num(v9) )
      {
        v60 = 0LL;
        while ( 1 )
        {
          v61 = (__int64 *)sk_value(v9, v60);
          if ( v61[8] )
          {
            if ( v78[7]
              && !(unsigned int)X509_NAME_cmp(*(_QWORD *)(*v78 + 16), *(_QWORD *)(*v61 + 16))
              && sub_8C16C((__int64)v61, (__int64)v78, 0x5Au)
              && sub_8C16C((__int64)v61, (__int64)v78, 0x302u)
              && (signed int)ASN1_INTEGER_cmp(v61[8], v78[7]) <= 0
              && (signed int)ASN1_INTEGER_cmp(v61[7], v78[7]) >= 1 )
            {
              break;
            }
          }
          if ( ++v60 >= (unsigned __int64)sk_num(v9) )
            goto LABEL_136;
        }
        v62 = (__int64 *)((*(_QWORD *)(v7 + 32) + 8LL) & (*(_QWORD *)(*(_QWORD *)(v7 + 32) + 24LL) << 62 >> 63));
        X509_cmp_time(*(int **)(*v61 + 24), v62);
        if ( v63 & 0x80000000 )
        {
          v64 = *(int **)(*v61 + 32);
          if ( !v64 || (X509_cmp_time(v64, v62), v65) && (!(v65 & 0x80000000) || *(_BYTE *)(v7 + 208) & 2) )
            *v8 |= 2u;
        }
        X509_up_ref((__int64)v61);
        *v13 = (__int64)v61;
      }
      else
      {
LABEL_136:
        *v13 = 0LL;
      }
    }
  }
LABEL_137:
  v66 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return v10 > 447;
}

//----- (000000000008DA6C) ----------------------------------------------------
_QWORD *X509_VERIFY_PARAM_new()
{
  _QWORD *v0; // x19
  _QWORD *v1; // x0

  v0 = malloc(0x40uLL);
  if ( v0 )
  {
    v1 = malloc(0x38uLL);
    if ( v1 )
    {
      v1[5] = 0LL;
      v1[6] = 0LL;
      v1[3] = 0LL;
      v1[4] = 0LL;
      v1[1] = 0LL;
      v1[2] = 0LL;
      *v1 = 0LL;
      v0[6] = 0LL;
      v0[7] = v1;
      v0[4] = 0LL;
      v0[5] = 0LL;
      v0[2] = 0LL;
      v0[3] = 0LL;
      *v0 = 0LL;
      v0[1] = 0LL;
      sub_8DADC((__int64)v0);
    }
    else
    {
      free(v0);
      v0 = 0LL;
    }
  }
  return v0;
}

//----- (000000000008DADC) ----------------------------------------------------
void __fastcall sub_8DADC(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int64 *v2; // x0
  __int64 v3; // x19
  void *v4; // x0
  void *v5; // x0
  void *v6; // x0
  _QWORD *v7; // x19
  void *v8; // t1

  v1 = a1;
  if ( a1 )
  {
    v2 = *(unsigned __int64 **)(a1 + 48);
    *(_QWORD *)v1 = 0LL;
    *(_QWORD *)(v1 + 24) = 0LL;
    *(_QWORD *)(v1 + 32) = 0LL;
    *(_QWORD *)(v1 + 16) = 0LL;
    *(_DWORD *)(v1 + 40) = -1;
    if ( v2 )
    {
      sk_pop_free(v2, (void (*)(void))ASN1_OBJECT_free);
      *(_QWORD *)(v1 + 48) = 0LL;
    }
    v3 = *(_QWORD *)(v1 + 56);
    if ( *(_QWORD *)v3 )
    {
      sk_pop_free(*(unsigned __int64 **)v3, (void (*)(void))j__free_0);
      *(_QWORD *)v3 = 0LL;
    }
    v4 = *(void **)(v3 + 16);
    if ( v4 )
    {
      free(v4);
      *(_QWORD *)(v3 + 16) = 0LL;
    }
    v5 = *(void **)(v3 + 24);
    if ( v5 )
    {
      free(v5);
      *(_QWORD *)(v3 + 24) = 0LL;
      *(_QWORD *)(v3 + 32) = 0LL;
    }
    v8 = *(void **)(v3 + 40);
    v7 = (_QWORD *)(v3 + 40);
    v6 = v8;
    if ( v8 )
    {
      free(v6);
      *v7 = 0LL;
      v7[1] = 0LL;
    }
  }
}
// 8DED0: using guessed type __int64 __fastcall j__free_0();

//----- (000000000008DB78) ----------------------------------------------------
void __fastcall X509_VERIFY_PARAM_free(__int64 a1)
{
  void **v1; // x19

  v1 = (void **)a1;
  if ( a1 )
  {
    sub_8DADC(a1);
    free(v1[7]);
    free(v1);
  }
}

//----- (000000000008DBB8) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_inherit(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 v4; // x21
  __int64 v5; // x8
  int v6; // w9
  __int64 v7; // x22
  __int64 v8; // x23
  int v9; // w9
  int v10; // w9
  __int64 v11; // x9
  __int64 v12; // x10
  unsigned __int64 *v13; // x1
  signed __int64 result; // x0
  _QWORD *v15; // x8
  unsigned __int64 *v16; // x0
  __int64 v17; // x8
  size_t v18; // x3

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    return 1LL;
  v4 = *(_QWORD *)(a2 + 56);
  v5 = *(_QWORD *)(a2 + 16) | *(_QWORD *)(a1 + 16);
  if ( v5 & 0x10 )
    *(_QWORD *)(a1 + 16) = 0LL;
  if ( v5 & 8 )
    return 1LL;
  v6 = *(_DWORD *)(a2 + 32);
  v7 = v5 & 1;
  v8 = v5 & 2;
  if ( v5 & 2 )
    goto LABEL_61;
  if ( !v6 )
    goto LABEL_12;
  if ( v5 & 1 || !*(_DWORD *)(a1 + 32) )
LABEL_61:
    *(_DWORD *)(a1 + 32) = v6;
  if ( v5 & 2 )
  {
    v9 = *(_DWORD *)(a2 + 36);
LABEL_15:
    *(_DWORD *)(a1 + 36) = v9;
    goto LABEL_16;
  }
LABEL_12:
  v9 = *(_DWORD *)(a2 + 36);
  if ( !v9 )
    goto LABEL_18;
  if ( v5 & 1 || !*(_DWORD *)(a1 + 36) )
    goto LABEL_15;
LABEL_16:
  if ( v5 & 2 )
  {
    v10 = *(_DWORD *)(a2 + 40);
LABEL_21:
    *(_DWORD *)(a1 + 40) = v10;
    goto LABEL_22;
  }
LABEL_18:
  v10 = *(_DWORD *)(a2 + 40);
  if ( v10 == -1 )
    goto LABEL_24;
  if ( v5 & 1 || *(_DWORD *)(a1 + 40) == -1 )
    goto LABEL_21;
LABEL_22:
  if ( v5 & 2 )
  {
    v11 = *(_QWORD *)(a1 + 24);
LABEL_25:
    v12 = *(_QWORD *)(a2 + 8);
    v11 &= 0xFFFFFFFFFFFFFFFDLL;
    *(_QWORD *)(a1 + 24) = v11;
    *(_QWORD *)(a1 + 8) = v12;
    goto LABEL_26;
  }
LABEL_24:
  v11 = *(_QWORD *)(a1 + 24);
  if ( !(v11 & 2) )
    goto LABEL_25;
LABEL_26:
  if ( v5 & 4 )
  {
    v11 = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
  }
  *(_QWORD *)(a1 + 24) = v11 | *(_QWORD *)(a2 + 24);
  v13 = *(unsigned __int64 **)(a2 + 48);
  if ( v5 & 2 )
    goto LABEL_62;
  if ( !v13 )
    goto LABEL_34;
  if ( v5 & 1 || !*(_QWORD *)(a1 + 48) )
  {
LABEL_62:
    result = (signed __int64)X509_VERIFY_PARAM_set1_policies(a1, v13);
    if ( !(_DWORD)result )
      return result;
  }
  if ( v8 )
  {
LABEL_37:
    v16 = **(unsigned __int64 ***)(v3 + 56);
    if ( v16 )
    {
      sk_pop_free(v16, (void (*)(void))j__free_0);
      **(_QWORD **)(v3 + 56) = 0LL;
    }
    if ( *(_QWORD *)v4 )
    {
      **(_QWORD **)(v3 + 56) = sk_deep_copy(
                                 *(_QWORD *)v4,
                                 (__int64 (*)(void))j_OPENSSL_strdup,
                                 (void (*)(void))j__free_0);
      v17 = *(_QWORD *)(v3 + 56);
      if ( !*(_QWORD *)v17 )
        return 0LL;
      *(_DWORD *)(v17 + 8) = *(_DWORD *)(v4 + 8);
    }
    goto LABEL_42;
  }
LABEL_34:
  v15 = *(_QWORD **)(v2 + 56);
  if ( !*v15 )
    goto LABEL_44;
  if ( v7 || !**(_QWORD **)(v3 + 56) )
    goto LABEL_37;
LABEL_42:
  if ( v8 )
  {
LABEL_47:
    result = sub_8E1D0(
               (void **)(*(_QWORD *)(v3 + 56) + 24LL),
               (size_t *)(*(_QWORD *)(v3 + 56) + 32LL),
               *(const char **)(v4 + 24),
               *(_QWORD *)(v4 + 32));
    if ( !(_DWORD)result )
      return result;
    goto LABEL_48;
  }
  v15 = *(_QWORD **)(v2 + 56);
LABEL_44:
  if ( !v15[3] )
    goto LABEL_50;
  if ( v7 || !*(_QWORD *)(*(_QWORD *)(v3 + 56) + 24LL) )
    goto LABEL_47;
LABEL_48:
  if ( v8 )
    goto LABEL_53;
  v15 = *(_QWORD **)(v2 + 56);
LABEL_50:
  if ( !v15[5] || !v7 && *(_QWORD *)(*(_QWORD *)(v3 + 56) + 40LL) )
    return 1LL;
LABEL_53:
  v18 = *(_QWORD *)(v4 + 48);
  result = 0LL;
  if ( v18 <= 0x10 )
  {
    if ( (1LL << v18) & 0x10011 )
    {
      result = sub_8E1D0(
                 (void **)(*(_QWORD *)(v3 + 56) + 40LL),
                 (size_t *)(*(_QWORD *)(v3 + 56) + 48LL),
                 *(const char **)(v4 + 40),
                 v18);
      if ( (_DWORD)result )
        return 1LL;
    }
  }
  return result;
}
// 8DED0: using guessed type __int64 __fastcall j__free_0();
// 8DED4: using guessed type __int64 __fastcall j_OPENSSL_strdup();

//----- (000000000008DDFC) ----------------------------------------------------
_QWORD *__fastcall X509_VERIFY_PARAM_set1_policies(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // x20
  __int64 v3; // x19
  unsigned __int64 *v4; // x0
  _QWORD *result; // x0
  unsigned __int64 v6; // x21
  unsigned __int64 *v7; // x0
  __int64 *v8; // x22

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return 0LL;
  v4 = *(unsigned __int64 **)(a1 + 48);
  if ( v4 )
    sk_pop_free(v4, (void (*)(void))ASN1_OBJECT_free);
  if ( !v2 )
  {
    *(_QWORD *)(v3 + 48) = 0LL;
    return (_QWORD *)(&dword_0 + 1);
  }
  result = sk_new_null();
  *(_QWORD *)(v3 + 48) = result;
  if ( !result )
    return result;
  if ( !sk_num(v2) )
  {
LABEL_11:
    *(_QWORD *)(v3 + 24) |= 0x80uLL;
    return (_QWORD *)(&dword_0 + 1);
  }
  v6 = 0LL;
  while ( 1 )
  {
    v7 = sk_value(v2, v6);
    v8 = OBJ_dup((__int64)v7);
    if ( !v8 )
      return 0LL;
    if ( !sk_push(*(unsigned __int64 **)(v3 + 48), (__int64)v8) )
      break;
    if ( ++v6 >= (unsigned __int64)sk_num(v2) )
      goto LABEL_11;
  }
  ASN1_OBJECT_free((void **)v8);
  return 0LL;
}
// 0: using guessed type int dword_0;

//----- (000000000008DED8) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set1_email(__int64 a1, const char *a2, size_t a3)
{
  return sub_8E1D0((void **)(*(_QWORD *)(a1 + 56) + 24LL), (size_t *)(*(_QWORD *)(a1 + 56) + 32LL), a2, a3);
}

//----- (000000000008DEFC) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set1_ip(__int64 a1, const char *a2, size_t a3)
{
  signed __int64 result; // x0

  if ( a3 <= 0x10 && (1LL << a3) & 0x10011 )
    result = sub_8E1D0((void **)(*(_QWORD *)(a1 + 56) + 40LL), (size_t *)(*(_QWORD *)(a1 + 56) + 48LL), a2, a3);
  else
    result = 0LL;
  return result;
}

//----- (000000000008DF44) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set1(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  signed __int64 result; // x0

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v3 | 1;
  result = X509_VERIFY_PARAM_inherit(a1, a2);
  *(_QWORD *)(v2 + 16) = v3;
  return result;
}

//----- (000000000008DF74) ----------------------------------------------------
bool __fastcall X509_VERIFY_PARAM_set1_name(void **a1, const char *a2)
{
  void **v2; // x19
  void *v3; // x0
  const char *v4; // x20
  _BYTE *v5; // x0

  v2 = a1;
  v3 = *a1;
  v4 = a2;
  if ( v3 )
    free(v3);
  v5 = BUF_strdup(v4);
  *v2 = v5;
  return v5 != 0LL;
}

//----- (000000000008DFB8) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set_flags(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 v3; // x9
  signed __int64 result; // x0
  __int64 v5; // x9

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 24);
  result = 1LL;
  v5 = v3 | a2;
  if ( a2 & 0x780 )
    v5 |= 0x80uLL;
  *(_QWORD *)(v2 + 24) = v5;
  return result;
}

//----- (000000000008DFDC) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_clear_flags(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 v3; // x9
  signed __int64 result; // x0

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 24);
  result = 1LL;
  *(_QWORD *)(v2 + 24) = v3 & ~a2;
  return result;
}

//----- (000000000008DFF4) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_get_flags(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}

//----- (000000000008DFFC) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set_purpose(__int64 a1, int a2)
{
  return X509_PURPOSE_set((int *)(a1 + 32), a2);
}

//----- (000000000008E004) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set_trust(__int64 a1, int a2)
{
  return X509_TRUST_set((int *)(a1 + 36), a2);
}

//----- (000000000008E00C) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_set_depth(__int64 result, int a2)
{
  *(_DWORD *)(result + 40) = a2;
  return result;
}

//----- (000000000008E014) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_set_time(__int64 result, __int64 a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 24) = v2 | 2;
  return result;
}

//----- (000000000008E028) ----------------------------------------------------
unsigned __int64 *__fastcall X509_VERIFY_PARAM_add0_policy(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  unsigned __int64 *result; // x0
  __int64 v4; // x19

  v2 = a1;
  result = *(unsigned __int64 **)(a1 + 48);
  v4 = a2;
  if ( result || (result = sk_new_null(), (*(_QWORD *)(v2 + 48) = result) != 0LL) )
    result = (unsigned __int64 *)(sk_push(result, v4) != 0LL);
  return result;
}

//----- (000000000008E06C) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set1_host(__int64 a1, const void *a2, size_t a3)
{
  const void *v3; // x21
  size_t v4; // x20
  unsigned __int64 **v5; // x19
  bool v6; // w23
  void *v7; // x8
  signed __int64 result; // x0
  _BYTE *v9; // x20
  unsigned __int64 *v10; // x0

  v3 = a2;
  v4 = a3;
  v5 = *(unsigned __int64 ***)(a1 + 56);
  v6 = a2 == 0LL || a3 == 0;
  if ( a2 == 0LL || a3 == 0 || (v7 = memchr(a2, 0, a3), result = 0LL, !v7) )
  {
    if ( *v5 )
    {
      sk_pop_free(*v5, (void (*)(void))j__free_0);
      *v5 = 0LL;
    }
    if ( v6 )
    {
      result = 1LL;
    }
    else
    {
      v9 = BUF_strndup(v3, v4);
      if ( v9 )
      {
        v10 = *v5;
        if ( *v5 || (v10 = sk_new_null(), (*v5 = v10) != 0LL) )
        {
          if ( sk_push(v10, (__int64)v9) )
          {
            result = 1LL;
          }
          else
          {
            free(v9);
            if ( sk_num(*v5) )
            {
              result = 0LL;
            }
            else
            {
              sk_free((void **)*v5);
              result = 0LL;
              *v5 = 0LL;
            }
          }
        }
        else
        {
          free(v9);
          result = 0LL;
        }
      }
      else
      {
        result = 0LL;
      }
    }
  }
  return result;
}
// 8DED0: using guessed type __int64 __fastcall j__free_0();

//----- (000000000008E19C) ----------------------------------------------------
void __fastcall X509_VERIFY_PARAM_add1_host(__int64 a1)
{
  __int64 v1; // x0

  v1 = *(_QWORD *)(a1 + 56);
  JUMPOUT(&loc_8E088);
}

//----- (000000000008E1B8) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_set_hostflags(__int64 result, int a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 56) + 8LL) = a2;
  return result;
}

//----- (000000000008E1C4) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_get0_peername(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 56) + 16LL);
}

//----- (000000000008E1D0) ----------------------------------------------------
signed __int64 __fastcall sub_8E1D0(void **a1, size_t *a2, const char *a3, size_t a4)
{
  size_t v4; // x21
  const char *v5; // x23
  size_t *v6; // x19
  void **v7; // x20
  void *v8; // x22
  void *v9; // x0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a3 )
  {
    v4 = 0LL;
    v8 = 0LL;
    v9 = *a1;
    if ( !*v7 )
      goto LABEL_10;
    goto LABEL_9;
  }
  if ( a4 )
  {
    v8 = BUF_memdup(a3, a4);
    if ( !v8 )
      return 0LL;
  }
  else
  {
    v8 = BUF_strdup(a3);
    v4 = strlen(v5);
    if ( !v8 )
      return 0LL;
  }
  v9 = *v7;
  if ( *v7 )
LABEL_9:
    free(v9);
LABEL_10:
  *v7 = v8;
  if ( v6 )
    *v6 = v4;
  return 1LL;
}

//----- (000000000008E27C) ----------------------------------------------------
signed __int64 __fastcall X509_VERIFY_PARAM_set1_ip_asc(__int64 a1, const char *a2)
{
  __int64 v2; // x19
  int v3; // w8
  signed __int64 result; // x0
  char v5; // [xsp+8h] [xbp-28h]
  __int64 v6; // [xsp+18h] [xbp-18h]

  v2 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = a2i_ipadd(&v5, a2);
  if ( v3 )
  {
    result = 0LL;
    if ( (unsigned __int64)v3 <= 0x10 && (1LL << v3) & 0x10011 )
      result = sub_8E1D0((void **)(*(_QWORD *)(v2 + 56) + 40LL), (size_t *)(*(_QWORD *)(v2 + 56) + 48LL), &v5, v3);
  }
  else
  {
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000008E318) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_add0_table(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int64 *v2; // x0
  void **v3; // x20
  __int64 result; // x0
  unsigned __int64 v5; // [xsp+0h] [xbp-30h]
  __int64 v6; // [xsp+8h] [xbp-28h]

  v1 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( qword_1072C8 )
  {
    if ( (unsigned int)sk_find(qword_1072C8, (signed __int64 *)&v5, a1) )
    {
      v2 = sk_value((unsigned __int64 *)qword_1072C8, v5);
      v3 = (void **)v2;
      if ( v2 )
      {
        sub_8DADC((__int64)v2);
        free(v3[7]);
        free(v3);
      }
      sk_delete((unsigned __int64 *)qword_1072C8, v5);
    }
    result = qword_1072C8;
    goto LABEL_8;
  }
  result = (__int64)sk_new((__int64)sub_8E3EC);
  qword_1072C8 = result;
  if ( result )
LABEL_8:
    result = sk_push((unsigned __int64 *)result, v1) != 0LL;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 1072C8: using guessed type __int64 qword_1072C8;

//----- (000000000008E3EC) ----------------------------------------------------
__int64 __fastcall sub_8E3EC(const char ***a1, const char ***a2)
{
  return strcmp(**a1, **a2);
}

//----- (000000000008E400) ----------------------------------------------------
signed __int64 X509_VERIFY_PARAM_get_count()
{
  signed __int64 result; // x0

  if ( qword_1072C8 )
    result = (unsigned int)sk_num((_QWORD *)qword_1072C8) + 5;
  else
    result = 5LL;
  return result;
}
// 1072C8: using guessed type __int64 qword_1072C8;

//----- (000000000008E42C) ----------------------------------------------------
unsigned __int64 *__fastcall X509_VERIFY_PARAM_get0(signed int a1)
{
  unsigned __int64 *result; // x0

  if ( a1 > 4 )
    result = sk_value((unsigned __int64 *)qword_1072C8, a1 - 5);
  else
    result = (unsigned __int64 *)&(&off_101640)[8 * (signed __int64)a1];
  return result;
}
// 101640: using guessed type char *off_101640;
// 1072C8: using guessed type __int64 qword_1072C8;

//----- (000000000008E470) ----------------------------------------------------
__int64 __fastcall X509_VERIFY_PARAM_lookup(__int64 a1)
{
  const char *v1; // x20
  __int64 result; // x0
  char **v3; // x19
  unsigned __int64 v4; // [xsp+0h] [xbp-60h]
  __int64 v5; // [xsp+8h] [xbp-58h]
  __int64 v6; // [xsp+48h] [xbp-18h]

  v1 = (const char *)a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = a1;
  if ( qword_1072C8 && (unsigned int)sk_find(qword_1072C8, (signed __int64 *)&v4, (__int64)&v5) )
  {
    result = (__int64)sk_value((unsigned __int64 *)qword_1072C8, v4);
    v3 = (char **)result;
  }
  else
  {
    result = strcmp("default", v1);
    v3 = &off_101640;
    if ( (_DWORD)result )
    {
      result = strcmp("pkcs7", v1);
      if ( (_DWORD)result )
      {
        result = strcmp("smime_sign", v1);
        if ( (_DWORD)result )
        {
          result = strcmp("ssl_client", v1);
          if ( (_DWORD)result )
          {
            result = strcmp("ssl_server", v1);
            if ( (_DWORD)result )
              v3 = 0LL;
            else
              v3 = &off_101740;
          }
          else
          {
            v3 = &off_101700;
          }
        }
        else
        {
          v3 = &off_1016C0;
        }
      }
      else
      {
        v3 = &off_101680;
      }
    }
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v6 )
    result = (__int64)v3;
  return result;
}
// 101640: using guessed type char *off_101640;
// 101680: using guessed type char *;
// 1016C0: using guessed type char *;
// 101700: using guessed type char *;
// 101740: using guessed type char *;
// 1072C8: using guessed type __int64 qword_1072C8;

//----- (000000000008E580) ----------------------------------------------------
void X509_VERIFY_PARAM_table_cleanup()
{
  if ( qword_1072C8 )
    sk_pop_free((unsigned __int64 *)qword_1072C8, (void (*)(void))X509_VERIFY_PARAM_free);
  qword_1072C8 = 0LL;
}
// 1072C8: using guessed type __int64 qword_1072C8;

//----- (000000000008E5B4) ----------------------------------------------------
signed __int64 __fastcall X509_CRL_set_version(__int64 **a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 **v3; // x20
  __int64 v4; // x0
  _DWORD *v5; // x0

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    v4 = **a1;
    if ( v4 )
      return ASN1_INTEGER_set(v4, v2);
    v5 = ASN1_STRING_type_new(2);
    **v3 = (__int64)v5;
    if ( v5 )
    {
      v4 = **v3;
      return ASN1_INTEGER_set(v4, v2);
    }
  }
  return 0LL;
}

//----- (000000000008E614) ----------------------------------------------------
bool __fastcall X509_CRL_set_issuer_name(__int64 a1, __int64 a2)
{
  _BOOL8 result; // x0

  if ( a1 && *(_QWORD *)a1 )
    result = X509_NAME_set((__int64 *)(*(_QWORD *)a1 + 16LL), a2);
  else
    result = 0LL;
  return result;
}

//----- (000000000008E630) ----------------------------------------------------
bool __fastcall X509_CRL_set_lastUpdate(__int64 a1, __int64 a2)
{
  _BYTE *v2; // x19
  __int64 v3; // x20

  v2 = (_BYTE *)a2;
  v3 = a1;
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 24LL) != a2 )
  {
    v2 = ASN1_STRING_dup(a2);
    if ( v2 )
    {
      ASN1_STRING_free(*(_QWORD *)(*(_QWORD *)v3 + 24LL));
      *(_QWORD *)(*(_QWORD *)v3 + 24LL) = v2;
    }
  }
  return v2 != 0LL;
}

//----- (000000000008E698) ----------------------------------------------------
bool __fastcall X509_CRL_set_nextUpdate(__int64 a1, __int64 a2)
{
  _BYTE *v2; // x19
  __int64 v3; // x20

  v2 = (_BYTE *)a2;
  v3 = a1;
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(*(_QWORD *)a1 + 32LL) != a2 )
  {
    v2 = ASN1_STRING_dup(a2);
    if ( v2 )
    {
      ASN1_STRING_free(*(_QWORD *)(*(_QWORD *)v3 + 32LL));
      *(_QWORD *)(*(_QWORD *)v3 + 32LL) = v2;
    }
  }
  return v2 != 0LL;
}

//----- (000000000008E700) ----------------------------------------------------
signed __int64 __fastcall X509_CRL_sort(__int64 *a1)
{
  __int64 *v1; // x19
  _QWORD *v2; // x0
  __int64 v3; // x8
  unsigned __int64 v4; // x20
  _QWORD *v5; // x0

  v1 = a1;
  sk_sort(*(_QWORD *)(*a1 + 40));
  v2 = sk_num(*(_QWORD **)(*v1 + 40));
  v3 = *v1;
  if ( v2 )
  {
    v4 = 0LL;
    do
    {
      *((_DWORD *)sk_value(*(unsigned __int64 **)(v3 + 40), v4) + 9) = v4;
      ++v4;
      v5 = sk_num(*(_QWORD **)(*v1 + 40));
      v3 = *v1;
    }
    while ( v4 < (unsigned __int64)v5 );
  }
  *(_DWORD *)(v3 + 72) = 1;
  return 1LL;
}

//----- (000000000008E778) ----------------------------------------------------
signed __int64 __fastcall X509_up_ref(__int64 a1)
{
  CRYPTO_refcount_inc((_DWORD *)(a1 + 24));
  return 1LL;
}

//----- (000000000008E794) ----------------------------------------------------
bool __fastcall X509_REVOKED_set_revocationDate(__int64 a1, __int64 a2)
{
  _BYTE *v2; // x19
  __int64 v3; // x20

  v2 = (_BYTE *)a2;
  v3 = a1;
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 8) != a2 )
  {
    v2 = ASN1_STRING_dup(a2);
    if ( v2 )
    {
      ASN1_STRING_free(*(_QWORD *)(v3 + 8));
      *(_QWORD *)(v3 + 8) = v2;
    }
  }
  return v2 != 0LL;
}

//----- (000000000008E7F0) ----------------------------------------------------
bool __fastcall X509_REVOKED_set_serialNumber(__int64 *a1, __int64 a2)
{
  _BYTE *v2; // x19
  __int64 *v3; // x20

  v2 = (_BYTE *)a2;
  v3 = a1;
  if ( !a1 )
    return 0LL;
  if ( *a1 != a2 )
  {
    v2 = ASN1_STRING_dup(a2);
    if ( v2 )
    {
      ASN1_STRING_free(*v3);
      *v3 = (__int64)v2;
    }
  }
  return v2 != 0LL;
}

//----- (000000000008E84C) ----------------------------------------------------
signed __int64 __fastcall X509_NAME_get_text_by_NID(unsigned __int64 **a1, unsigned int a2, void *a3, int a4)
{
  unsigned __int64 **v4; // x21
  int v5; // w19
  void *v6; // x20
  __int64 v7; // x0
  void *v8; // x2
  int v10; // w20
  void *v11; // x19
  __int64 v12; // x23
  unsigned __int64 *v13; // x24
  signed __int64 v14; // x25
  unsigned __int64 v15; // x22
  __int64 *v16; // x0
  unsigned __int64 *v17; // x0
  unsigned __int64 v18; // x8
  int v19; // w20

  v4 = a1;
  v5 = a4;
  v6 = a3;
  OBJ_nid2obj(a2);
  if ( !v7 )
    return 0xFFFFFFFFLL;
  v8 = v6;
  v10 = v5;
  v11 = v8;
  v12 = v7;
  if ( v4 )
  {
    v13 = *v4;
    v14 = (signed int)sk_num(*v4);
    v15 = -1LL;
    while ( (signed __int64)++v15 < v14 )
    {
      v16 = (__int64 *)sk_value(v13, v15);
      if ( !(unsigned int)OBJ_cmp(*v16, v12) )
      {
        if ( v15 & 0x80000000 )
          break;
        if ( (unsigned __int64)sk_num(*v4) > v15 && (v17 = sk_value(*v4, v15)) != 0LL )
          v18 = v17[1];
        else
          v18 = 0LL;
        if ( *(_DWORD *)v18 >= v10 )
          v19 = v10 - 1;
        else
          v19 = *(_DWORD *)v18;
        if ( v11 )
        {
          if ( v19 )
            memcpy(v11, *(const void **)(v18 + 8), v19);
          *((_BYTE *)v11 + v19) = 0;
        }
        else
        {
          v19 = *(_DWORD *)v18;
        }
        return (unsigned int)v19;
      }
    }
  }
  return (unsigned int)-1;
}

//----- (000000000008E9A0) ----------------------------------------------------
signed __int64 __fastcall X509_NAME_get_index_by_OBJ(unsigned __int64 **a1, __int64 a2, signed int a3)
{
  __int64 v3; // x19
  unsigned __int64 *v4; // x20
  signed int v5; // w21
  signed __int64 v6; // x22
  signed __int64 v7; // x21
  __int64 *v8; // x0

  v3 = a2;
  if ( a1 )
  {
    v4 = *a1;
    if ( a3 < 0 )
      v5 = 1;
    else
      v5 = a3;
    v6 = (signed int)sk_num(*a1);
    v7 = v5 + 1LL;
    while ( v7 < v6 )
    {
      v8 = (__int64 *)sk_value(v4, v7++);
      if ( !(unsigned int)OBJ_cmp(*v8, v3) )
        return (unsigned int)(v7 - 1);
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000008EA1C) ----------------------------------------------------
__int64 __fastcall X509_policy_node_get0_parent(__int64 result)
{
  if ( result )
    result = *(_QWORD *)(result + 8);
  return result;
}

//----- (000000000008EA28) ----------------------------------------------------
unsigned __int64 *__fastcall X509_NAME_get_entry(unsigned __int64 **a1, int a2)
{
  int v2; // w20
  unsigned __int64 **v3; // x19
  unsigned __int64 *result; // x0

  v2 = a2;
  v3 = a1;
  result = 0LL;
  if ( v3 && !(a2 & 0x80000000) )
  {
    if ( (unsigned __int64)sk_num(*v3) <= a2 )
      result = 0LL;
    else
      result = sk_value(*v3, v2);
  }
  return result;
}

//----- (000000000008EA78) ----------------------------------------------------
_QWORD *__fastcall X509_NAME_entry_count(_QWORD *result)
{
  if ( result )
    result = sk_num((_QWORD *)*result);
  return result;
}

//----- (000000000008EA94) ----------------------------------------------------
signed __int64 __fastcall X509_NAME_get_index_by_NID(unsigned __int64 **a1, unsigned int a2, signed int a3)
{
  unsigned __int64 **v3; // x20
  signed int v4; // w21
  __int64 v5; // x0
  __int64 v6; // x19
  unsigned __int64 *v7; // x20
  signed __int64 v8; // x22
  signed __int64 v9; // x21
  __int64 *v10; // x0

  v3 = a1;
  v4 = a3;
  OBJ_nid2obj(a2);
  v6 = v5;
  if ( !v5 )
    return 4294967294LL;
  if ( v3 )
  {
    v7 = *v3;
    if ( v4 < 0 )
      v4 = 1;
    v8 = (signed int)sk_num(v7);
    v9 = v4 + 1LL;
    while ( v9 < v8 )
    {
      v10 = (__int64 *)sk_value(v7, v9++);
      if ( !(unsigned int)OBJ_cmp(*v10, v6) )
        return (unsigned int)(v9 - 1);
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000008EB2C) ----------------------------------------------------
__int64 __fastcall X509_NAME_delete_entry(unsigned __int64 **a1, int a2)
{
  int v2; // w22
  unsigned __int64 **v3; // x24
  __int64 v4; // x19
  unsigned __int64 v5; // x20
  unsigned __int64 *v6; // x21
  int v7; // w23
  int v8; // w24
  unsigned __int8 v10; // vf
  int v11; // w22
  unsigned __int64 *v12; // x0

  v2 = a2;
  v3 = a1;
  v4 = 0LL;
  if ( a1 && !(a2 & 0x80000000) )
  {
    v5 = a2;
    if ( (unsigned __int64)sk_num(*a1) <= a2 )
    {
      v4 = 0LL;
    }
    else
    {
      v6 = *v3;
      v4 = sk_delete(*v3, v2);
      v7 = (unsigned __int64)sk_num(v6);
      *((_DWORD *)v3 + 2) = 1;
      if ( v7 != v2 )
      {
        if ( v2 )
          v8 = *((_DWORD *)sk_value(v6, v2 - 1) + 4);
        else
          v8 = *(_DWORD *)(v4 + 16) - 1;
        if ( v8 + 1 < *((_DWORD *)sk_value(v6, v2) + 4) )
        {
          v10 = __OFSUB__(v7, v2);
          v11 = v7 - v2;
          if ( !((unsigned __int8)((v11 < 0) ^ v10) | (v11 == 0)) )
          {
            do
            {
              v12 = sk_value(v6, v5++);
              --v11;
              --*((_DWORD *)v12 + 4);
            }
            while ( v11 );
          }
        }
      }
    }
  }
  return v4;
}

//----- (000000000008EC24) ----------------------------------------------------
__int64 __fastcall X509_NAME_add_entry_by_OBJ(unsigned __int64 **a1, __int64 a2, signed int a3, const char *a4, signed int a5, int a6, int a7)
{
  unsigned __int64 **v7; // x21
  int v8; // w19
  int v9; // w20
  void ***v10; // x22
  unsigned int v11; // w19

  v7 = a1;
  v8 = a7;
  v9 = a6;
  v10 = X509_NAME_ENTRY_create_by_OBJ(0LL, a2, a3, a4, a5);
  if ( !v10 )
    return 0LL;
  v11 = X509_NAME_add_entry(v7, (__int64)v10, v9, v8);
  X509_NAME_ENTRY_free((__int64)v10);
  return v11;
}

//----- (000000000008EC8C) ----------------------------------------------------
void ***__fastcall X509_NAME_ENTRY_create_by_OBJ(void ****a1, __int64 a2, signed int a3, const char *a4, signed int a5)
{
  signed int v5; // w21
  const char *v6; // x22
  signed int v7; // w23
  __int64 v8; // x24
  void ****v9; // x20
  void ***v10; // x19
  __int64 *v11; // x0

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a1 && (v10 = *a1) != 0LL || (v10 = (void ***)X509_NAME_ENTRY_new()) != 0LL )
  {
    if ( v8 && v10 )
    {
      ASN1_OBJECT_free(*v10);
      v11 = OBJ_dup(v8);
      *v10 = (void **)v11;
      if ( v11 && (unsigned int)X509_NAME_ENTRY_set_data((unsigned int **)v10, v7, v6, v5) )
      {
        if ( v9 && !*v9 )
          *v9 = v10;
        return v10;
      }
    }
    else
    {
      ERR_put_error(11, 0LL, 67, (__int64)"external/boringssl/src/crypto/x509/x509name.c", 344);
    }
    if ( !v9 || v10 != *v9 )
      X509_NAME_ENTRY_free((__int64)v10);
    v10 = 0LL;
  }
  return v10;
}

//----- (000000000008ED68) ----------------------------------------------------
signed __int64 __fastcall X509_NAME_add_entry(unsigned __int64 **a1, __int64 a2, int a3, int a4)
{
  int v4; // w21
  int v5; // w22
  __int64 v6; // x20
  unsigned __int64 **v7; // x23
  unsigned __int64 *v8; // x19
  int v9; // w0
  bool v10; // nf
  int v11; // w21
  _BOOL4 v12; // w23
  __int64 v13; // x0
  __int64 v14; // x20
  int v15; // w0
  int v16; // w20
  unsigned __int64 *v17; // x0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a1 )
    return 0LL;
  v8 = *a1;
  v9 = (unsigned __int64)sk_num(*a1);
  if ( v9 >= v5 )
    v10 = v5 < 0;
  else
    v10 = 1;
  if ( v10 )
    v5 = v9;
  *((_DWORD *)v7 + 2) = 1;
  if ( v4 == -1 )
  {
    if ( v5 )
    {
      v11 = *((_DWORD *)sk_value(v8, v5 - 1) + 4);
      v12 = 0;
    }
    else
    {
      v11 = 0;
      v12 = 1;
    }
  }
  else
  {
    if ( v5 >= v9 )
      v11 = v5 ? *((_DWORD *)sk_value(v8, v5 - 1) + 4) + 1 : 0;
    else
      v11 = *((_DWORD *)sk_value(v8, v5) + 4);
    v12 = v11 == 0;
  }
  X509_NAME_ENTRY_dup(v6);
  v14 = v13;
  if ( !v13 )
    return 0LL;
  *(_DWORD *)(v13 + 16) = v11;
  if ( !sk_insert(v8, v13, v5) )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509name.c", 267);
    X509_NAME_ENTRY_free(v14);
    return 0LL;
  }
  if ( !v12 )
    return 1LL;
  v15 = (unsigned __int64)sk_num(v8);
  if ( v5 + 1 >= v15 )
    return 1LL;
  v16 = v15 - 1;
  do
  {
    v17 = sk_value(v8, v5++);
    ++*((_DWORD *)v17 + 4);
  }
  while ( v16 != v5 );
  return 1LL;
}

//----- (000000000008EEE0) ----------------------------------------------------
__int64 __fastcall X509_NAME_add_entry_by_NID(unsigned __int64 **a1, unsigned int a2, signed int a3, const char *a4, signed int a5, int a6, int a7)
{
  unsigned __int64 **v7; // x21
  int v8; // w19
  int v9; // w20
  signed int v10; // w22
  const char *v11; // x23
  signed int v12; // w24
  __int64 v13; // x0
  void ***v14; // x22
  unsigned int v15; // w19

  v7 = a1;
  v8 = a7;
  v9 = a6;
  v10 = a5;
  v11 = a4;
  v12 = a3;
  OBJ_nid2obj(a2);
  if ( v13 )
  {
    v14 = X509_NAME_ENTRY_create_by_OBJ(0LL, v13, v12, v11, v10);
    if ( v14 )
    {
      v15 = X509_NAME_add_entry(v7, (__int64)v14, v9, v8);
      X509_NAME_ENTRY_free((__int64)v14);
      return v15;
    }
  }
  else
  {
    ERR_put_error(11, 0LL, 129, (__int64)"external/boringssl/src/crypto/x509/x509name.c", 307);
  }
  return 0LL;
}

//----- (000000000008EF98) ----------------------------------------------------
void ***__fastcall X509_NAME_ENTRY_create_by_NID(void ****a1, unsigned int a2, signed int a3, const char *a4, signed int a5)
{
  void ****v5; // x22
  signed int v6; // w19
  const char *v7; // x20
  signed int v8; // w21
  __int64 v9; // x0

  v5 = a1;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  OBJ_nid2obj(a2);
  if ( v9 )
    return X509_NAME_ENTRY_create_by_OBJ(v5, v9, v8, v7, v6);
  ERR_put_error(11, 0LL, 129, (__int64)"external/boringssl/src/crypto/x509/x509name.c", 307);
  return 0LL;
}

//----- (000000000008F01C) ----------------------------------------------------
__int64 __fastcall X509_NAME_add_entry_by_txt(unsigned __int64 **a1, const char *a2, signed int a3, const char *a4, signed int a5, int a6, int a7)
{
  __int64 v7; // x22
  unsigned __int64 **v8; // x21
  int v9; // w19
  int v10; // w20
  signed int v11; // w23
  const char *v12; // x24
  signed int v13; // w25
  __int64 v14; // x0
  void **v15; // x26
  void ***v16; // x22
  unsigned int v17; // w19
  __int64 v19; // x3
  __int64 v20; // x4
  __int64 v21; // x5
  __int64 v22; // x6
  __int64 v23; // x7
  __int64 v24; // [xsp+0h] [xbp-40h]

  v7 = (__int64)a2;
  v8 = a1;
  v9 = a7;
  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  OBJ_txt2obj(a2, 0);
  v15 = (void **)v14;
  if ( v14 )
  {
    v16 = X509_NAME_ENTRY_create_by_OBJ(0LL, v14, v13, v12, v11);
    ASN1_OBJECT_free(v15);
    if ( v16 )
    {
      v17 = X509_NAME_add_entry(v8, (__int64)v16, v10, v9);
      X509_NAME_ENTRY_free((__int64)v16);
      return v17;
    }
  }
  else
  {
    ERR_put_error(11, 0LL, 111, (__int64)"external/boringssl/src/crypto/x509/x509name.c", 292);
    ERR_add_error_data(2u, (__int64)"name=", v7, v19, v20, v21, v22, v23, v24);
  }
  return 0LL;
}

//----- (000000000008F100) ----------------------------------------------------
void ***__fastcall X509_NAME_ENTRY_create_by_txt(void ****a1, const char *a2, signed int a3, const char *a4, signed int a5)
{
  __int64 v5; // x19
  void ****v6; // x24
  signed int v7; // w20
  const char *v8; // x21
  signed int v9; // w22
  __int64 v10; // x0
  void **v11; // x23
  void ***v12; // x19
  void ***result; // x0
  __int64 v14; // x3
  __int64 v15; // x4
  __int64 v16; // x5
  __int64 v17; // x6
  __int64 v18; // x7
  __int64 v19; // [xsp+0h] [xbp-30h]

  v5 = (__int64)a2;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  OBJ_txt2obj(a2, 0);
  v11 = (void **)v10;
  if ( v10 )
  {
    v12 = X509_NAME_ENTRY_create_by_OBJ(v6, v10, v9, v8, v7);
    ASN1_OBJECT_free(v11);
    result = v12;
  }
  else
  {
    ERR_put_error(11, 0LL, 111, (__int64)"external/boringssl/src/crypto/x509/x509name.c", 292);
    ERR_add_error_data(2u, (__int64)"name=", v5, v14, v15, v16, v17, v18, v19);
    result = 0LL;
  }
  return result;
}

//----- (000000000008F1B0) ----------------------------------------------------
bool __fastcall X509_NAME_ENTRY_set_object(void ***a1, __int64 a2)
{
  __int64 v2; // x20
  _QWORD *v3; // x19
  __int64 *v4; // x0
  _BOOL8 result; // x0

  v2 = a2;
  v3 = a1;
  if ( a1 && a2 )
  {
    ASN1_OBJECT_free(*a1);
    v4 = OBJ_dup(v2);
    *v3 = v4;
    result = v4 != 0LL;
  }
  else
  {
    ERR_put_error(11, 0LL, 67, (__int64)"external/boringssl/src/crypto/x509/x509name.c", 344);
    result = 0LL;
  }
  return result;
}

//----- (000000000008F218) ----------------------------------------------------
signed __int64 __fastcall X509_NAME_ENTRY_set_data(unsigned int **a1, signed int a2, const char *a3, signed int a4)
{
  signed int v4; // w22
  char *v5; // x21
  int v6; // w20
  unsigned int **v7; // x19
  signed __int64 result; // x0
  __int64 *v9; // x19
  int v10; // w0

  v4 = a4;
  v5 = (char *)a3;
  v6 = a2;
  v7 = a1;
  if ( !a1 || !a3 && a4 )
    return 0LL;
  if ( a2 >= 1 && a2 & 0x1000 )
  {
    v9 = (__int64 *)(a1 + 1);
    v10 = (unsigned __int64)OBJ_obj2nid(*a1);
    result = ASN1_STRING_set_by_NID(v9, v5, v4, v6, v10) != 0;
  }
  else
  {
    if ( a4 & 0x80000000 )
      v4 = strlen(a3);
    result = ASN1_STRING_set((__int64)v7[1], v5, v4);
    if ( (_DWORD)result )
    {
      if ( v6 != -1 )
      {
        if ( v6 == -2 )
          v6 = ASN1_PRINTABLE_type(v5, v4);
        v7[1][1] = v6;
      }
      result = 1LL;
    }
  }
  return result;
}

//----- (000000000008F2E4) ----------------------------------------------------
void __fastcall X509_verify(__int64 **a1, __int64 a2)
{
  __int64 **v2; // x20
  __int64 v3; // x19

  v2 = a1;
  v3 = a2;
  if ( !(unsigned int)X509_ALGOR_cmp(a1[1], (__int64 *)(*a1)[2]) )
    ASN1_item_verify((__int64)&X509_CINF_it, (unsigned int **)v2[1], (__int64)v2[2], (__int64)*v2, v3);
}

//----- (000000000008F33C) ----------------------------------------------------
void __fastcall X509_REQ_verify(__int64 a1, __int64 a2)
{
  ASN1_item_verify((__int64)&X509_REQ_INFO_it, *(unsigned int ***)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)a1, a2);
}

//----- (000000000008F35C) ----------------------------------------------------
__int64 __fastcall X509_sign(__int64 *a1, __int64 a2, __int64 a3)
{
  *(_DWORD *)(*a1 + 96) = 1;
  return ASN1_item_sign((__int64)&X509_CINF_it, *(_QWORD *)(*a1 + 16), a1[1], a1[2], *a1, a2, a3);
}

//----- (000000000008F394) ----------------------------------------------------
__int64 __fastcall X509_sign_ctx(__int64 *a1, _QWORD *a2)
{
  *(_DWORD *)(*a1 + 96) = 1;
  return ASN1_item_sign_ctx((__int64)&X509_CINF_it, *(_QWORD *)(*a1 + 16), a1[1], a1[2], *a1, a2);
}

//----- (000000000008F3C4) ----------------------------------------------------
__int64 __fastcall X509_REQ_sign(__int64 *a1, __int64 a2, __int64 a3)
{
  return ASN1_item_sign((__int64)&X509_REQ_INFO_it, a1[1], 0LL, a1[2], *a1, a2, a3);
}

//----- (000000000008F3F0) ----------------------------------------------------
__int64 __fastcall X509_REQ_sign_ctx(__int64 *a1, _QWORD *a2)
{
  return ASN1_item_sign_ctx((__int64)&X509_REQ_INFO_it, a1[1], 0LL, a1[2], *a1, a2);
}

//----- (000000000008F414) ----------------------------------------------------
__int64 __fastcall X509_CRL_sign(__int64 *a1, __int64 a2, __int64 a3)
{
  *(_DWORD *)(*a1 + 72) = 1;
  return ASN1_item_sign((__int64)&X509_CRL_INFO_it, *(_QWORD *)(*a1 + 8), a1[1], a1[2], *a1, a2, a3);
}

//----- (000000000008F44C) ----------------------------------------------------
__int64 __fastcall X509_CRL_sign_ctx(__int64 *a1, _QWORD *a2)
{
  *(_DWORD *)(*a1 + 72) = 1;
  return ASN1_item_sign_ctx((__int64)&X509_CRL_INFO_it, *(_QWORD *)(*a1 + 8), a1[1], a1[2], *a1, a2);
}

//----- (000000000008F47C) ----------------------------------------------------
__int64 __fastcall NETSCAPE_SPKI_sign(__int64 *a1, __int64 a2, __int64 a3)
{
  return ASN1_item_sign((__int64)&NETSCAPE_SPKAC_it, a1[1], 0LL, a1[2], *a1, a2, a3);
}

//----- (000000000008F4A8) ----------------------------------------------------
void __fastcall NETSCAPE_SPKI_verify(__int64 a1, __int64 a2)
{
  ASN1_item_verify((__int64)&NETSCAPE_SPKAC_it, *(unsigned int ***)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)a1, a2);
}

//----- (000000000008F4C8) ----------------------------------------------------
void __fastcall d2i_X509_fp(__int64 a1, unsigned __int64 **a2)
{
  ASN1_item_d2i_fp((unsigned __int8 *)&X509_it, a1, a2);
}

//----- (000000000008F4E8) ----------------------------------------------------
__int64 __fastcall i2d_X509_fp(__int64 a1)
{
  return ASN1_item_i2d_fp((__int64)&X509_it, a1);
}

//----- (000000000008F508) ----------------------------------------------------
void __fastcall d2i_X509_bio(_QWORD *a1, unsigned __int64 **a2)
{
  ASN1_item_d2i_bio((unsigned __int8 *)&X509_it, a1, a2);
}

//----- (000000000008F528) ----------------------------------------------------
void i2d_X509_bio()
{
  ASN1_item_i2d_bio();
}

//----- (000000000008F548) ----------------------------------------------------
void __fastcall d2i_X509_CRL_fp(__int64 a1, unsigned __int64 **a2)
{
  ASN1_item_d2i_fp((unsigned __int8 *)&X509_CRL_it, a1, a2);
}

//----- (000000000008F568) ----------------------------------------------------
__int64 __fastcall i2d_X509_CRL_fp(__int64 a1)
{
  return ASN1_item_i2d_fp((__int64)&X509_CRL_it, a1);
}

//----- (000000000008F588) ----------------------------------------------------
void __fastcall d2i_X509_CRL_bio(_QWORD *a1, unsigned __int64 **a2)
{
  ASN1_item_d2i_bio((unsigned __int8 *)&X509_CRL_it, a1, a2);
}

//----- (000000000008F5A8) ----------------------------------------------------
void i2d_X509_CRL_bio()
{
  ASN1_item_i2d_bio();
}

//----- (000000000008F5C8) ----------------------------------------------------
void __fastcall d2i_X509_REQ_fp(__int64 a1, unsigned __int64 **a2)
{
  ASN1_item_d2i_fp((unsigned __int8 *)&X509_REQ_it, a1, a2);
}

//----- (000000000008F5E8) ----------------------------------------------------
__int64 __fastcall i2d_X509_REQ_fp(__int64 a1)
{
  return ASN1_item_i2d_fp((__int64)&X509_REQ_it, a1);
}

//----- (000000000008F608) ----------------------------------------------------
void __fastcall d2i_X509_REQ_bio(_QWORD *a1, unsigned __int64 **a2)
{
  ASN1_item_d2i_bio((unsigned __int8 *)&X509_REQ_it, a1, a2);
}

//----- (000000000008F628) ----------------------------------------------------
void i2d_X509_REQ_bio()
{
  ASN1_item_i2d_bio();
}

//----- (000000000008F648) ----------------------------------------------------
void __fastcall d2i_RSAPrivateKey_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)RSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_RSAPrivateKey, a1, a2);
}

//----- (000000000008F670) ----------------------------------------------------
__int64 __fastcall i2d_RSAPrivateKey_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_RSAPrivateKey, a1, a2);
}

//----- (000000000008F690) ----------------------------------------------------
void __fastcall d2i_RSAPublicKey_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)RSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_RSAPublicKey, a1, a2);
}

//----- (000000000008F6B8) ----------------------------------------------------
void __fastcall d2i_RSA_PUBKEY_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)RSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_RSA_PUBKEY, a1, a2);
}

//----- (000000000008F6E0) ----------------------------------------------------
__int64 __fastcall i2d_RSAPublicKey_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_RSAPublicKey, a1, a2);
}

//----- (000000000008F700) ----------------------------------------------------
__int64 __fastcall i2d_RSA_PUBKEY_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_RSA_PUBKEY, a1, a2);
}

//----- (000000000008F720) ----------------------------------------------------
void __fastcall d2i_RSAPrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)RSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_RSAPrivateKey, a1, a2);
}

//----- (000000000008F748) ----------------------------------------------------
void __fastcall i2d_RSAPrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_RSAPrivateKey, a1, a2);
}

//----- (000000000008F768) ----------------------------------------------------
void __fastcall d2i_RSAPublicKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)RSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_RSAPublicKey, a1, a2);
}

//----- (000000000008F790) ----------------------------------------------------
void __fastcall d2i_RSA_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)RSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_RSA_PUBKEY, a1, a2);
}

//----- (000000000008F7B8) ----------------------------------------------------
void __fastcall i2d_RSAPublicKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_RSAPublicKey, a1, a2);
}

//----- (000000000008F7D8) ----------------------------------------------------
void __fastcall i2d_RSA_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_RSA_PUBKEY, a1, a2);
}

//----- (000000000008F7F8) ----------------------------------------------------
void __fastcall d2i_DSAPrivateKey_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)DSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_DSAPrivateKey, a1, a2);
}

//----- (000000000008F820) ----------------------------------------------------
__int64 __fastcall i2d_DSAPrivateKey_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_DSAPrivateKey, a1, a2);
}

//----- (000000000008F840) ----------------------------------------------------
void __fastcall d2i_DSA_PUBKEY_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)DSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_DSA_PUBKEY, a1, a2);
}

//----- (000000000008F868) ----------------------------------------------------
__int64 __fastcall i2d_DSA_PUBKEY_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_DSA_PUBKEY, a1, a2);
}

//----- (000000000008F888) ----------------------------------------------------
void __fastcall d2i_DSAPrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)DSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_DSAPrivateKey, a1, a2);
}

//----- (000000000008F8B0) ----------------------------------------------------
void __fastcall i2d_DSAPrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_DSAPrivateKey, a1, a2);
}

//----- (000000000008F8D0) ----------------------------------------------------
void __fastcall d2i_DSA_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)DSA_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_DSA_PUBKEY, a1, a2);
}

//----- (000000000008F8F8) ----------------------------------------------------
void __fastcall i2d_DSA_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_DSA_PUBKEY, a1, a2);
}

//----- (000000000008F918) ----------------------------------------------------
void __fastcall d2i_EC_PUBKEY_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)EC_KEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_EC_PUBKEY, a1, a2);
}

//----- (000000000008F940) ----------------------------------------------------
__int64 __fastcall i2d_EC_PUBKEY_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_EC_PUBKEY, a1, a2);
}

//----- (000000000008F960) ----------------------------------------------------
void __fastcall d2i_ECPrivateKey_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)EC_KEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_ECPrivateKey, a1, a2);
}

//----- (000000000008F988) ----------------------------------------------------
__int64 __fastcall i2d_ECPrivateKey_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_ECPrivateKey, a1, a2);
}

//----- (000000000008F9A8) ----------------------------------------------------
void __fastcall d2i_EC_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)EC_KEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_EC_PUBKEY, a1, a2);
}

//----- (000000000008F9D0) ----------------------------------------------------
void __fastcall i2d_EC_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_EC_PUBKEY, a1, a2);
}

//----- (000000000008F9F0) ----------------------------------------------------
void __fastcall d2i_ECPrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)EC_KEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_ECPrivateKey, a1, a2);
}

//----- (000000000008FA18) ----------------------------------------------------
void __fastcall i2d_ECPrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_ECPrivateKey, a1, a2);
}

//----- (000000000008FA38) ----------------------------------------------------
void __fastcall X509_pubkey_digest(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  _DWORD *v4; // x19
  __int64 v5; // x21
  __int64 v6; // x20
  signed int *v7; // x0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = (signed int *)X509_get0_pubkey_bitstr(a1);
  if ( v7 )
    EVP_Digest(*((_QWORD *)v7 + 1), *v7, v5, v4, v6);
}

//----- (000000000008FA98) ----------------------------------------------------
void X509_digest()
{
  ASN1_item_digest();
}

//----- (000000000008FAC0) ----------------------------------------------------
void X509_CRL_digest()
{
  ASN1_item_digest();
}

//----- (000000000008FAE8) ----------------------------------------------------
void X509_REQ_digest()
{
  ASN1_item_digest();
}

//----- (000000000008FB10) ----------------------------------------------------
void X509_NAME_digest()
{
  ASN1_item_digest();
}

//----- (000000000008FB38) ----------------------------------------------------
void __fastcall d2i_PKCS8_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)X509_SIG_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_X509_SIG, a1, a2);
}

//----- (000000000008FB60) ----------------------------------------------------
__int64 __fastcall i2d_PKCS8_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_X509_SIG, a1, a2);
}

//----- (000000000008FB80) ----------------------------------------------------
void __fastcall d2i_PKCS8_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)X509_SIG_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_X509_SIG, a1, a2);
}

//----- (000000000008FBA8) ----------------------------------------------------
void __fastcall i2d_PKCS8_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_X509_SIG, a1, a2);
}

//----- (000000000008FBC8) ----------------------------------------------------
void __fastcall d2i_PKCS8_PRIV_KEY_INFO_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp(
    (__int64)PKCS8_PRIV_KEY_INFO_new,
    (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_PKCS8_PRIV_KEY_INFO,
    a1,
    a2);
}

//----- (000000000008FBF0) ----------------------------------------------------
__int64 __fastcall i2d_PKCS8_PRIV_KEY_INFO_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_PKCS8_PRIV_KEY_INFO, a1, a2);
}

//----- (000000000008FC10) ----------------------------------------------------
__int64 __fastcall i2d_PKCS8PrivateKeyInfo_fp(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x0
  __int64 v4; // x19
  unsigned int v5; // w20

  v2 = a1;
  EVP_PKEY2PKCS8(a2);
  v4 = v3;
  if ( !v3 )
    return 0LL;
  v5 = ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_PKCS8_PRIV_KEY_INFO, v2, v3);
  PKCS8_PRIV_KEY_INFO_free(v4);
  return v5;
}

//----- (000000000008FC68) ----------------------------------------------------
__int64 __fastcall i2d_PrivateKey_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_PrivateKey, a1, a2);
}

//----- (000000000008FC88) ----------------------------------------------------
void __fastcall d2i_PrivateKey_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)EVP_PKEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_AutoPrivateKey, a1, a2);
}

//----- (000000000008FCB0) ----------------------------------------------------
__int64 __fastcall i2d_PUBKEY_fp(__int64 a1, __int64 a2)
{
  return ASN1_i2d_fp((void (__fastcall *)(__int64, void **))i2d_PUBKEY, a1, a2);
}

//----- (000000000008FCD0) ----------------------------------------------------
void __fastcall d2i_PUBKEY_fp(__int64 a1, __int64 a2)
{
  ASN1_d2i_fp((__int64)EVP_PKEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_PUBKEY, a1, a2);
}

//----- (000000000008FCF8) ----------------------------------------------------
void __fastcall d2i_PKCS8_PRIV_KEY_INFO_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio(
    (__int64)PKCS8_PRIV_KEY_INFO_new,
    (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_PKCS8_PRIV_KEY_INFO,
    a1,
    a2);
}

//----- (000000000008FD20) ----------------------------------------------------
void __fastcall i2d_PKCS8_PRIV_KEY_INFO_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_PKCS8_PRIV_KEY_INFO, a1, a2);
}

//----- (000000000008FD40) ----------------------------------------------------
__int64 __fastcall i2d_PKCS8PrivateKeyInfo_bio(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // x20
  __int64 v3; // x0
  __int64 v4; // x19
  unsigned int v5; // w0
  unsigned int v6; // w20

  v2 = a1;
  EVP_PKEY2PKCS8(a2);
  v4 = v3;
  if ( !v3 )
    return 0LL;
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_PKCS8_PRIV_KEY_INFO, v2, v3);
  v6 = v5;
  PKCS8_PRIV_KEY_INFO_free(v4);
  return v6;
}

//----- (000000000008FD98) ----------------------------------------------------
void __fastcall i2d_PrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_PrivateKey, a1, a2);
}

//----- (000000000008FDB8) ----------------------------------------------------
void __fastcall d2i_PrivateKey_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)EVP_PKEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_AutoPrivateKey, a1, a2);
}

//----- (000000000008FDE0) ----------------------------------------------------
void __fastcall i2d_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_i2d_bio((void (__fastcall *)(__int64, void **))i2d_PUBKEY, a1, a2);
}

//----- (000000000008FE00) ----------------------------------------------------
void __fastcall d2i_PUBKEY_bio(_QWORD *a1, __int64 a2)
{
  ASN1_d2i_bio((__int64)EVP_PKEY_new, (void (__fastcall *)(__int64, __int64 *, _QWORD))d2i_PUBKEY, a1, a2);
}

//----- (000000000008FE28) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_ATTRIBUTE(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_ATTRIBUTE_it);
}

//----- (000000000008FE34) ----------------------------------------------------
void i2d_X509_ATTRIBUTE()
{
  ASN1_item_i2d();
}

//----- (000000000008FE40) ----------------------------------------------------
__int64 X509_ATTRIBUTE_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_ATTRIBUTE_it);
}

//----- (000000000008FE4C) ----------------------------------------------------
void __fastcall X509_ATTRIBUTE_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_ATTRIBUTE_it);
}

//----- (000000000008FE58) ----------------------------------------------------
void __fastcall X509_ATTRIBUTE_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_ATTRIBUTE_it, a1);
}

//----- (000000000008FE70) ----------------------------------------------------
__int64 __fastcall X509_ATTRIBUTE_create(unsigned int a1, int a2, __int64 a3)
{
  unsigned int v3; // w22
  __int64 v4; // x20
  int v5; // w21
  __int64 v6; // x19
  __int64 v7; // x0
  _QWORD *v8; // x0
  __int64 v9; // x22

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = ASN1_item_new((unsigned __int8 *)&X509_ATTRIBUTE_it);
  if ( v6 )
  {
    OBJ_nid2obj(v3);
    *(_QWORD *)v6 = v7;
    *(_DWORD *)(v6 + 8) = 0;
    v8 = sk_new_null();
    *(_QWORD *)(v6 + 16) = v8;
    if ( v8 && (v9 = ASN1_TYPE_new()) != 0 )
    {
      if ( sk_push(*(unsigned __int64 **)(v6 + 16), v9) )
      {
        ASN1_TYPE_set(v9, v5, v4);
        return v6;
      }
      ASN1_item_free(v6, (unsigned __int8 *)&X509_ATTRIBUTE_it);
      ASN1_TYPE_free(v9);
    }
    else
    {
      ASN1_item_free(v6, (unsigned __int8 *)&X509_ATTRIBUTE_it);
    }
    v6 = 0LL;
  }
  return v6;
}

//----- (000000000008FF30) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_REVOKED(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_REVOKED_it);
}

//----- (000000000008FF3C) ----------------------------------------------------
void i2d_X509_REVOKED()
{
  ASN1_item_i2d();
}

//----- (000000000008FF48) ----------------------------------------------------
__int64 X509_REVOKED_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_REVOKED_it);
}

//----- (000000000008FF54) ----------------------------------------------------
void __fastcall X509_REVOKED_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_REVOKED_it);
}

//----- (000000000008FF60) ----------------------------------------------------
void __fastcall X509_REVOKED_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_REVOKED_it, a1);
}

//----- (000000000008FF78) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_CRL_INFO(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_CRL_INFO_it);
}

//----- (000000000008FF84) ----------------------------------------------------
void i2d_X509_CRL_INFO()
{
  ASN1_item_i2d();
}

//----- (000000000008FF90) ----------------------------------------------------
__int64 X509_CRL_INFO_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_CRL_INFO_it);
}

//----- (000000000008FF9C) ----------------------------------------------------
void __fastcall X509_CRL_INFO_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_CRL_INFO_it);
}

//----- (000000000008FFA8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_CRL(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_CRL_it);
}

//----- (000000000008FFB4) ----------------------------------------------------
void i2d_X509_CRL()
{
  ASN1_item_i2d();
}

//----- (000000000008FFC0) ----------------------------------------------------
__int64 X509_CRL_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_CRL_it);
}

//----- (000000000008FFCC) ----------------------------------------------------
void __fastcall X509_CRL_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_CRL_it);
}

//----- (000000000008FFD8) ----------------------------------------------------
void __fastcall X509_CRL_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_CRL_it, a1);
}

//----- (000000000008FFF0) ----------------------------------------------------
signed __int64 __fastcall X509_CRL_add0_revoked(__int64 *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  unsigned __int64 *v4; // x0
  signed __int64 result; // x0

  v2 = *a1;
  v3 = a2;
  v4 = *(unsigned __int64 **)(*a1 + 40);
  if ( (v4 || (v4 = sk_new((__int64)sub_90064), (*(_QWORD *)(v2 + 40) = v4) != 0LL)) && sk_push(v4, v3) )
  {
    result = 1LL;
    *(_DWORD *)(v2 + 72) = 1;
  }
  else
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x_crl.c", 385);
    result = 0LL;
  }
  return result;
}

//----- (0000000000090064) ----------------------------------------------------
__int64 __fastcall sub_90064(const void ****a1, __int64 **a2)
{
  return ASN1_STRING_cmp(**a1, **a2);
}

//----- (0000000000090078) ----------------------------------------------------
__int64 __fastcall X509_CRL_verify(__int64 a1)
{
  __int64 (*v1)(void); // x2
  __int64 result; // x0

  v1 = *(__int64 (**)(void))(*(_QWORD *)(a1 + 104) + 32LL);
  if ( v1 )
    result = v1();
  else
    result = 0LL;
  return result;
}

//----- (0000000000090090) ----------------------------------------------------
__int64 __fastcall X509_CRL_get0_by_serial(__int64 a1)
{
  __int64 (*v1)(void); // x4
  __int64 result; // x0

  v1 = *(__int64 (**)(void))(*(_QWORD *)(a1 + 104) + 24LL);
  if ( v1 )
    result = v1();
  else
    result = 0LL;
  return result;
}

//----- (00000000000900AC) ----------------------------------------------------
__int64 __fastcall X509_CRL_get0_by_cert(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x8
  __int64 v5; // x21
  __int64 v6; // x20
  __int64 result; // x0
  __int64 (__fastcall *v8)(__int64, __int64, __int64, __int64); // ST08_8
  __int64 v9; // x22
  __int64 v10; // x3

  v3 = a1;
  v4 = *(_QWORD *)(a1 + 104);
  v5 = a3;
  v6 = a2;
  result = *(_QWORD *)(v4 + 24);
  if ( result )
  {
    v8 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(v4 + 24);
    v9 = X509_get_serialNumber(a3);
    v10 = X509_get_issuer_name(v5);
    result = v8(v3, v6, v9, v10);
  }
  return result;
}

//----- (000000000009012C) ----------------------------------------------------
void *__fastcall X509_CRL_set_default_method(void *result)
{
  void *v1; // x8

  v1 = &unk_101B80;
  if ( result )
    v1 = result;
  off_106650 = v1;
  return result;
}
// 106650: using guessed type void *off_106650;

//----- (0000000000090148) ----------------------------------------------------
_QWORD *__fastcall X509_CRL_METHOD_new(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x22
  __int64 v5; // x19
  __int64 v6; // x20
  __int64 v7; // x21
  _QWORD *result; // x0

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  result = malloc(0x28uLL);
  if ( result )
  {
    result[1] = v4;
    result[2] = v7;
    result[3] = v6;
    result[4] = v5;
    *(_DWORD *)result = 1;
  }
  return result;
}

//----- (0000000000090194) ----------------------------------------------------
void __fastcall X509_CRL_METHOD_free(void *ptr)
{
  if ( *(_BYTE *)ptr & 1 )
    free(ptr);
}

//----- (00000000000901A4) ----------------------------------------------------
__int64 __fastcall X509_CRL_set_meth_data(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 112) = a2;
  return result;
}

//----- (00000000000901AC) ----------------------------------------------------
__int64 __fastcall X509_CRL_get_meth_data(__int64 a1)
{
  return *(_QWORD *)(a1 + 112);
}

//----- (00000000000901B4) ----------------------------------------------------
signed __int64 __fastcall sub_901B4(int a1, __int64 a2)
{
  __int64 v2; // x0

  if ( *(_QWORD *)a2 )
  {
    if ( a1 == 5 )
    {
      v2 = *(_QWORD *)(*(_QWORD *)a2 + 40LL);
      if ( v2 )
        sk_set_cmp_func(v2, (__int64)sub_90064);
    }
  }
  return 1LL;
}

//----- (00000000000901EC) ----------------------------------------------------
__int64 __fastcall sub_901EC(int a1, __int64 *a2)
{
  __int64 v2; // x19
  void *v3; // x8
  unsigned __int64 *v4; // x0
  int v5; // w9
  int v6; // w8
  signed int v7; // w9
  __int64 v8; // x8
  __int64 (__fastcall *v9)(__int64); // x8
  __int64 result; // x0
  __int64 v11; // x0
  __int64 v12; // x0
  unsigned __int64 v13; // x8
  unsigned int v14; // w9
  unsigned int *v15; // x8
  unsigned __int64 v16; // x10
  unsigned __int64 *v17; // x0
  unsigned __int64 *v18; // x20
  unsigned __int64 v19; // x21
  unsigned __int64 *v20; // x0
  unsigned __int64 *v21; // x22
  int v22; // w0
  unsigned __int64 *v23; // x20
  unsigned __int64 v24; // x21
  __int64 v25; // x25
  unsigned __int64 *v26; // x0
  __int64 v27; // x22
  unsigned __int64 *v28; // x0
  __int64 v29; // x23
  unsigned __int64 *v30; // x0
  unsigned __int64 *v31; // x0
  unsigned __int64 *v32; // x23
  unsigned __int64 *v33; // x22
  unsigned __int64 v34; // x23
  unsigned __int64 *v35; // x0
  __int64 (__fastcall *v36)(__int64); // x8
  int v37; // [xsp+4h] [xbp-4Ch]
  __int64 v38; // [xsp+8h] [xbp-48h]

  v38 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *a2;
  if ( a1 == 5 )
  {
    EVP_sha1();
    X509_CRL_digest();
    v4 = X509_CRL_get_ext_d2i(v2, 770, 0LL, 0LL);
    *(_QWORD *)(v2 + 40) = v4;
    if ( v4 )
    {
      v5 = *(_DWORD *)(v2 + 48);
      v6 = v5 | 1;
      *(_DWORD *)(v2 + 48) = v5 | 1;
      if ( *((_DWORD *)v4 + 2) < 1 )
      {
        v7 = 0;
      }
      else
      {
        v6 = v5 | 5;
        v7 = 1;
        *(_DWORD *)(v2 + 48) = v6;
      }
      if ( *((_DWORD *)v4 + 3) >= 1 )
      {
        ++v7;
        v6 |= 8u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      if ( *((_DWORD *)v4 + 7) >= 1 )
      {
        ++v7;
        v6 |= 0x10u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      if ( v7 > 1 )
      {
        v6 |= 2u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      if ( *((_DWORD *)v4 + 6) >= 1 )
      {
        v6 |= 0x20u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      if ( v4[2] )
      {
        *(_DWORD *)(v2 + 48) = v6 | 0x40;
        v13 = v4[2];
        if ( *(_DWORD *)v13 < 1 )
        {
          v15 = (unsigned int *)(v2 + 52);
          v14 = *(_DWORD *)(v2 + 52);
        }
        else
        {
          v14 = **(unsigned __int8 **)(v13 + 8);
          *(_DWORD *)(v2 + 52) = v14;
          v15 = (unsigned int *)(v2 + 52);
          v16 = v4[2];
          if ( *(_DWORD *)v16 > 1 )
          {
            v14 = v14 & 0xFFFF00FF | (*(unsigned __int8 *)(*(_QWORD *)(v16 + 8) + 1LL) << 8);
            *v15 = v14;
          }
        }
        *v15 = v14 & 0x807F;
      }
      DIST_POINT_set_dpname(*v4, *(_QWORD *)(*(_QWORD *)v2 + 16LL));
    }
    *(_QWORD *)(v2 + 32) = X509_CRL_get_ext_d2i(v2, 90, 0LL, 0LL);
    *(_QWORD *)(v2 + 56) = X509_CRL_get_ext_d2i(v2, 88, 0LL, 0LL);
    v17 = X509_CRL_get_ext_d2i(v2, 140, 0LL, 0LL);
    *(_QWORD *)(v2 + 64) = v17;
    if ( v17 && !*(_QWORD *)(v2 + 56) )
      *(_DWORD *)(v2 + 28) |= 0x80u;
    v18 = *(unsigned __int64 **)(*(_QWORD *)v2 + 48LL);
    if ( sk_num(*(_QWORD **)(*(_QWORD *)v2 + 48LL)) )
    {
      v19 = 0LL;
      while ( 1 )
      {
        v20 = sk_value(v18, v19);
        v21 = v20;
        v22 = (unsigned __int64)OBJ_obj2nid((unsigned int *)*v20);
        if ( v22 == 857 )
          *(_DWORD *)(v2 + 28) |= 0x1000u;
        if ( *((_DWORD *)v21 + 2) >= 1 && v22 != 90 && v22 != 140 && v22 != 770 )
          break;
        if ( ++v19 >= (unsigned __int64)sk_num(v18) )
          goto LABEL_46;
      }
      *(_DWORD *)(v2 + 28) |= 0x200u;
    }
LABEL_46:
    v23 = *(unsigned __int64 **)(*(_QWORD *)v2 + 40LL);
    if ( sk_num(*(_QWORD **)(*(_QWORD *)v2 + 40LL)) )
    {
      v24 = 0LL;
      v25 = 0LL;
      while ( 1 )
      {
        v26 = sk_value(v23, v24);
        v27 = (__int64)v26;
        v28 = X509_REVOKED_get_ext_d2i((__int64)v26, 771, &v37, 0LL);
        v29 = (__int64)v28;
        if ( !v28 && v37 != -1 )
        {
LABEL_68:
          *(_DWORD *)(v2 + 28) |= 0x80u;
          goto LABEL_69;
        }
        if ( v28 )
        {
          v30 = *(unsigned __int64 **)(v2 + 96);
          if ( !v30 )
          {
            v30 = sk_new_null();
            *(_QWORD *)(v2 + 96) = v30;
            if ( !v30 )
              break;
          }
          v25 = v29;
          if ( !sk_push(v30, v29) )
            break;
        }
        *(_QWORD *)(v27 + 24) = v25;
        v31 = X509_REVOKED_get_ext_d2i(v27, 141, &v37, 0LL);
        v32 = v31;
        if ( !v31 && v37 != -1 )
          goto LABEL_68;
        if ( v31 )
        {
          *(_DWORD *)(v27 + 32) = ASN1_ENUMERATED_get((signed __int64)v31);
          ASN1_VISIBLESTRING_free(v32);
        }
        else
        {
          *(_DWORD *)(v27 + 32) = -1;
        }
        v33 = *(unsigned __int64 **)(v27 + 16);
        if ( sk_num(v33) )
        {
          v34 = 0LL;
          while ( 1 )
          {
            v35 = sk_value(v33, v34);
            if ( *((_DWORD *)v35 + 2) >= 1 && (unsigned int)OBJ_obj2nid((unsigned int *)*v35) != 771 )
              break;
            if ( ++v34 >= (unsigned __int64)sk_num(v33) )
              goto LABEL_66;
          }
          *(_DWORD *)(v2 + 28) |= 0x200u;
        }
LABEL_66:
        if ( ++v24 >= (unsigned __int64)sk_num(v23) )
          goto LABEL_69;
      }
      result = 0LL;
    }
    else
    {
LABEL_69:
      v36 = *(__int64 (__fastcall **)(__int64))(*(_QWORD *)(v2 + 104) + 8LL);
      if ( !v36 || (result = v36(v2), (_DWORD)result) )
      {
LABEL_71:
        result = 1LL;
        goto LABEL_72;
      }
    }
  }
  else
  {
    if ( a1 != 3 )
    {
      if ( a1 == 1 )
      {
        *(_QWORD *)(v2 + 44) = 0LL;
        *(_QWORD *)(v2 + 36) = 0LL;
        *(_QWORD *)(v2 + 28) = 0LL;
        *(_DWORD *)(v2 + 52) = 32895;
        v3 = off_106650;
        *(_QWORD *)(v2 + 96) = 0LL;
        *(_QWORD *)(v2 + 56) = 0LL;
        *(_QWORD *)(v2 + 64) = 0LL;
        *(_QWORD *)(v2 + 104) = v3;
        *(_QWORD *)(v2 + 112) = 0LL;
      }
      goto LABEL_71;
    }
    v8 = *(_QWORD *)(v2 + 104);
    if ( !v8 || (v9 = *(__int64 (__fastcall **)(__int64))(v8 + 16)) == 0LL || (result = v9(*a2), (_DWORD)result) )
    {
      v11 = *(_QWORD *)(v2 + 32);
      if ( v11 )
        AUTHORITY_KEYID_free(v11);
      v12 = *(_QWORD *)(v2 + 40);
      if ( v12 )
        ISSUING_DIST_POINT_free(v12);
      ASN1_VISIBLESTRING_free(*(_QWORD *)(v2 + 56));
      ASN1_VISIBLESTRING_free(*(_QWORD *)(v2 + 64));
      sk_pop_free(*(unsigned __int64 **)(v2 + 96), (void (*)(void))GENERAL_NAMES_free);
      goto LABEL_71;
    }
  }
LABEL_72:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v38;
  return result;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);
// 106650: using guessed type void *off_106650;

//----- (0000000000090674) ----------------------------------------------------
_BYTE *__fastcall sub_90674(__int64 *a1, unsigned __int64 **a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x21
  __int64 *v5; // x22
  __int64 v6; // x20
  unsigned __int64 **v7; // x19
  int v8; // w24
  _BYTE *result; // x0
  __int64 v10; // x8
  unsigned __int64 v11; // x23
  unsigned __int64 *v12; // x23
  _QWORD *v13; // x0
  __int64 v14; // x24
  unsigned __int64 v15; // x25
  unsigned __int64 *v16; // x0
  unsigned __int64 v17; // [xsp+8h] [xbp-78h]
  __int64 v18; // [xsp+10h] [xbp-70h]
  __int64 v19; // [xsp+38h] [xbp-48h]

  v4 = a3;
  v5 = a1;
  v6 = a4;
  v7 = a2;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v18 = a3;
  CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_1072D0);
  v8 = sk_is_sorted(*(_QWORD *)(*v5 + 40));
  CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_1072D0);
  if ( !v8 )
  {
    CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_1072D0);
    if ( !(unsigned int)sk_is_sorted(*(_QWORD *)(*v5 + 40)) )
      sk_sort(*(_QWORD *)(*v5 + 40));
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_1072D0);
  }
  result = sk_find(*(_QWORD *)(*v5 + 40), (signed __int64 *)&v17, (__int64)&v18);
  if ( !(_DWORD)result )
    goto LABEL_27;
  v10 = *v5;
  v11 = v17;
  while ( 1 )
  {
    if ( v11 >= (unsigned __int64)sk_num(*(_QWORD **)(v10 + 40))
      || (v12 = sk_value(*(unsigned __int64 **)(*v5 + 40), v17), (unsigned int)ASN1_INTEGER_cmp(*v12, v4)) )
    {
      result = 0LL;
      goto LABEL_27;
    }
    v13 = (_QWORD *)v12[3];
    if ( v13 )
      break;
    if ( !v6 || !(unsigned int)X509_NAME_cmp(v6, *(_QWORD *)(*v5 + 16)) )
      goto LABEL_22;
LABEL_9:
    v11 = v17++ + 1;
    v10 = *v5;
  }
  v14 = v6;
  if ( !v6 )
    v14 = *(_QWORD *)(*v5 + 16);
  if ( !sk_num(v13) )
    goto LABEL_9;
  v15 = 0LL;
  while ( 1 )
  {
    v16 = sk_value((unsigned __int64 *)v12[3], v15);
    if ( *(_DWORD *)v16 == 4 && !(unsigned int)X509_NAME_cmp(v14, v16[1]) )
      break;
    if ( ++v15 >= (unsigned __int64)sk_num((_QWORD *)v12[3]) )
      goto LABEL_9;
  }
LABEL_22:
  if ( v7 )
    *v7 = v12;
  if ( *((_DWORD *)v12 + 8) == 8 )
    result = (_BYTE *)(&dword_0 + 2);
  else
    result = (_BYTE *)(&dword_0 + 1);
LABEL_27:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000090848) ----------------------------------------------------
void __fastcall sub_90848(__int64 a1, __int64 a2)
{
  ASN1_item_verify((__int64)&X509_CRL_INFO_it, *(unsigned int ***)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)a1, a2);
}

//----- (0000000000090868) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_EXTENSION(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_EXTENSION_it);
}

//----- (0000000000090874) ----------------------------------------------------
void i2d_X509_EXTENSION()
{
  ASN1_item_i2d();
}

//----- (0000000000090880) ----------------------------------------------------
__int64 X509_EXTENSION_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_EXTENSION_it);
}

//----- (000000000009088C) ----------------------------------------------------
void __fastcall X509_EXTENSION_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_EXTENSION_it);
}

//----- (0000000000090898) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_EXTENSIONS(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_EXTENSIONS_it);
}

//----- (00000000000908A4) ----------------------------------------------------
void i2d_X509_EXTENSIONS()
{
  ASN1_item_i2d();
}

//----- (00000000000908B0) ----------------------------------------------------
void __fastcall X509_EXTENSION_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_EXTENSION_it, a1);
}

//----- (00000000000908C8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_NAME_ENTRY(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_NAME_ENTRY_it);
}

//----- (00000000000908D4) ----------------------------------------------------
void i2d_X509_NAME_ENTRY()
{
  ASN1_item_i2d();
}

//----- (00000000000908E0) ----------------------------------------------------
__int64 X509_NAME_ENTRY_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_NAME_ENTRY_it);
}

//----- (00000000000908EC) ----------------------------------------------------
void __fastcall X509_NAME_ENTRY_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_NAME_ENTRY_it);
}

//----- (00000000000908F8) ----------------------------------------------------
void __fastcall X509_NAME_ENTRY_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_NAME_ENTRY_it, a1);
}

//----- (0000000000090910) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_NAME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_NAME_it);
}

//----- (000000000009091C) ----------------------------------------------------
void i2d_X509_NAME()
{
  ASN1_item_i2d();
}

//----- (0000000000090928) ----------------------------------------------------
__int64 X509_NAME_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_NAME_it);
}

//----- (0000000000090934) ----------------------------------------------------
void __fastcall X509_NAME_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_NAME_it);
}

//----- (0000000000090940) ----------------------------------------------------
void __fastcall X509_NAME_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_NAME_it, a1);
}

//----- (0000000000090958) ----------------------------------------------------
bool __fastcall X509_NAME_set(__int64 *a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 *v3; // x20
  _BOOL8 result; // x0
  __int64 v5; // x0

  v2 = a2;
  v3 = a1;
  result = 0LL;
  if ( v3 && a2 )
  {
    if ( *v3 != a2 )
    {
      ASN1_item_dup((unsigned __int8 *)&X509_NAME_it, a2);
      v2 = v5;
      if ( v5 )
      {
        ASN1_item_free(*v3, (unsigned __int8 *)&X509_NAME_it);
        *v3 = v2;
      }
      else
      {
        v2 = *v3;
      }
    }
    result = v2 != 0;
  }
  return result;
}

//----- (00000000000909CC) ----------------------------------------------------
signed __int64 __fastcall sub_909CC(_QWORD *a1)
{
  _QWORD *v1; // x20
  _QWORD *v2; // x19
  _QWORD *v3; // x0
  _QWORD *v4; // x0
  signed __int64 result; // x0

  v1 = a1;
  v2 = malloc(0x28uLL);
  if ( v2 )
  {
    v3 = sk_new_null();
    *v2 = v3;
    if ( v3 )
    {
      v4 = BUF_MEM_new();
      v2[2] = v4;
      if ( v4 )
      {
        result = 1LL;
        v2[3] = 0LL;
        *((_DWORD *)v2 + 8) = 0;
        *((_DWORD *)v2 + 2) = 1;
        *v1 = v2;
        return result;
      }
    }
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x_name.c", 160);
    if ( *v2 )
      sk_free((void **)*v2);
    free(v2);
  }
  else
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x_name.c", 160);
  }
  return 0LL;
}

//----- (0000000000090A7C) ----------------------------------------------------
void __fastcall sub_90A7C(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 v2; // x20
  void *v3; // x0

  v1 = a1;
  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 )
    {
      BUF_MEM_free(*(_QWORD *)(v2 + 16));
      sk_pop_free(*(unsigned __int64 **)v2, (void (*)(void))X509_NAME_ENTRY_free);
      v3 = *(void **)(v2 + 24);
      if ( v3 )
        free(v3);
      free((void *)v2);
      *v1 = 0LL;
    }
  }
}

//----- (0000000000090AD4) ----------------------------------------------------
void __fastcall sub_90AD4(__int64 *a1, const void **a2, __int64 a3, __int64 a4, signed int a5, int a6, char a7, __int64 a8)
{
  const void **v8; // x19
  __int64 *v9; // x20
  _BYTE *v10; // x22
  signed int v11; // w0
  __int64 v12; // x21
  void *v13; // x0
  int v14; // w0
  __int64 v15; // x21
  unsigned __int64 v16; // x22
  unsigned __int64 *v17; // x23
  unsigned __int64 v18; // x24
  unsigned __int64 *v19; // x0
  int v20; // w0
  __int64 v21; // [xsp+0h] [xbp-50h]
  unsigned __int64 *v22; // [xsp+8h] [xbp-48h]
  _BYTE *v23; // [xsp+10h] [xbp-40h]
  __int64 v24; // [xsp+18h] [xbp-38h]

  v8 = a2;
  v9 = a1;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = *a2;
  if ( a3 > 0x100000 )
    a3 = 0x100000LL;
  v21 = 0LL;
  v22 = 0LL;
  v23 = v10;
  sub_A14A0(&v22, (const void **)&v23, a3, (unsigned __int8 *)&unk_101DC8, a5, a6, a7, a8);
  if ( v11 >= 1 )
  {
    v12 = *v9;
    if ( *v9 )
    {
      BUF_MEM_free(*(_QWORD *)(v12 + 16));
      sk_pop_free(*(unsigned __int64 **)v12, (void (*)(void))X509_NAME_ENTRY_free);
      v13 = *(void **)(v12 + 24);
      if ( v13 )
        free(v13);
      free((void *)v12);
      *v9 = 0LL;
    }
    v14 = sub_909CC(&v21);
    v15 = v21;
    if ( !v14 || !BUF_MEM_grow(*(_QWORD *)(v21 + 16), v23 - v10) )
      goto LABEL_27;
    if ( v23 != v10 )
      memcpy(*(void **)(*(_QWORD *)(v15 + 16) + 8LL), v10, v23 - v10);
    if ( sk_num(v22) )
    {
      v16 = 0LL;
      while ( 1 )
      {
        v17 = sk_value(v22, v16);
        if ( sk_num(v17) )
          break;
LABEL_18:
        if ( ++v16 >= (unsigned __int64)sk_num(v22) )
          goto LABEL_19;
      }
      v18 = 0LL;
      while ( 1 )
      {
        v19 = sk_value(v17, v18);
        *((_DWORD *)v19 + 4) = v16;
        if ( !sk_push(*(unsigned __int64 **)v15, (__int64)v19) )
          goto LABEL_22;
        sk_set(v17, v18++, 0LL);
        if ( v18 >= (unsigned __int64)sk_num(v17) )
          goto LABEL_18;
      }
    }
LABEL_19:
    sub_90EE8(v15);
    if ( !v20 )
    {
LABEL_27:
      if ( !v15 )
      {
LABEL_23:
        sk_pop_free(v22, (void (*)(void))sub_912B8);
        ERR_put_error(11, 0LL, 12, (__int64)"external/boringssl/src/crypto/x509/x_name.c", 264);
        goto LABEL_24;
      }
LABEL_22:
      ASN1_item_free(v15, (unsigned __int8 *)&X509_NAME_it);
      goto LABEL_23;
    }
    sk_pop_free(v22, (void (*)(void))j_sk_free);
    *(_DWORD *)(v15 + 8) = 0;
    *v9 = v15;
    *v8 = v23;
  }
LABEL_24:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 912B4: using guessed type __int64 __fastcall j_sk_free();

//----- (0000000000090CE8) ----------------------------------------------------
void __fastcall sub_90CE8(unsigned __int64 ***a1, void **a2)
{
  void **v2; // x19
  unsigned __int64 **v3; // x20
  unsigned __int64 *v4; // x21
  unsigned __int64 v5; // x22
  void **v6; // x23
  signed int v7; // w25
  unsigned __int64 *v8; // x24
  __int64 **v9; // x22
  int v10; // w0
  int v11; // w21
  int v12; // w0
  __int64 v13; // x21
  char *v14; // x0
  unsigned __int64 v15; // [xsp+8h] [xbp-58h]
  unsigned __int64 *v16; // [xsp+10h] [xbp-50h]
  __int64 v17; // [xsp+18h] [xbp-48h]

  v2 = a2;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v3 = *a1;
  if ( !*((_DWORD *)*a1 + 2) )
  {
    v9 = (__int64 **)(v3 + 2);
    goto LABEL_16;
  }
  v4 = sk_new_null();
  v16 = v4;
  if ( !v4 )
    goto LABEL_22;
  if ( sk_num(*v3) )
  {
    v5 = 0LL;
    v6 = 0LL;
    v7 = -1;
    do
    {
      v8 = sk_value(*v3, v5);
      if ( *((_DWORD *)v8 + 4) != v7 )
      {
        v6 = (void **)sk_new_null();
        if ( !v6 )
          goto LABEL_22;
        if ( !sk_push(v4, (__int64)v6) )
        {
          sk_free(v6);
LABEL_22:
          sk_pop_free(v4, (void (*)(void))j_sk_free);
          ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x_name.c", 335);
          goto LABEL_23;
        }
        v7 = *((_DWORD *)v8 + 4);
      }
      if ( !sk_push((unsigned __int64 *)v6, (__int64)v8) )
        goto LABEL_22;
      ++v5;
    }
    while ( v5 < (unsigned __int64)sk_num(*v3) );
  }
  sub_A3124(&v16, 0LL, (unsigned __int8 *)&unk_101DC8, -1, 0xFFFFFFFF);
  v9 = (__int64 **)(v3 + 2);
  v11 = v10;
  if ( !BUF_MEM_grow((__int64)v3[2], v10) )
  {
    v4 = v16;
    goto LABEL_22;
  }
  v15 = v3[2][1];
  sub_A3124(&v16, (_BYTE **)&v15, (unsigned __int8 *)&unk_101DC8, -1, 0xFFFFFFFF);
  sk_pop_free(v16, (void (*)(void))j_sk_free);
  *((_DWORD *)v3 + 2) = 0;
  if ( !(v11 & 0x80000000) )
  {
    sub_90EE8((__int64)v3);
    if ( !(v12 & 0x80000000) )
    {
LABEL_16:
      v13 = **v9;
      if ( v2 )
      {
        v14 = (char *)*v2;
        if ( (_DWORD)v13 )
        {
          memcpy(v14, (const void *)(*v9)[1], (signed int)v13);
          v14 = (char *)*v2;
        }
        *v2 = &v14[(signed int)v13];
      }
      goto LABEL_23;
    }
  }
LABEL_23:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 912B4: using guessed type __int64 __fastcall j_sk_free();

//----- (0000000000090EE8) ----------------------------------------------------
void __fastcall sub_90EE8(__int64 a1)
{
  unsigned __int64 **v1; // x20
  void *v2; // x0
  unsigned __int64 *v3; // x23
  unsigned __int64 v4; // x21
  void **v5; // x22
  unsigned __int64 *v6; // x25
  _QWORD *v7; // x24
  __int64 v8; // x27
  __int64 v9; // x25
  unsigned __int8 **v10; // x26
  signed int v11; // w0
  signed int v12; // w27
  unsigned __int8 *v13; // x23
  unsigned __int8 *v14; // x19
  int v15; // w0
  unsigned __int8 v16; // vf
  unsigned __int8 *v17; // x20
  int v18; // w0
  int v19; // w20
  int v20; // w28
  unsigned __int8 *v21; // x8
  int v22; // w9
  int v23; // w0
  int v24; // w0
  unsigned __int8 *v25; // x8
  unsigned __int64 v26; // x21
  int v27; // w19
  int v28; // w0
  _QWORD *v29; // x0
  unsigned __int64 v30; // x20
  int v31; // w0
  unsigned __int64 **v32; // [xsp+0h] [xbp-80h]
  unsigned __int64 *v33; // [xsp+8h] [xbp-78h]
  signed int v34; // [xsp+14h] [xbp-6Ch]
  _QWORD *v35; // [xsp+18h] [xbp-68h]
  unsigned __int64 *v36; // [xsp+20h] [xbp-60h]
  __int64 v37; // [xsp+28h] [xbp-58h]

  v1 = (unsigned __int64 **)a1;
  v37 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *(void **)(a1 + 24);
  if ( v2 )
  {
    free(v2);
    v1[3] = 0LL;
  }
  if ( sk_num(*v1) )
  {
    v3 = sk_new_null();
    if ( v3 )
    {
      if ( sk_num(*v1) )
      {
        v34 = -1;
        v4 = 0LL;
        v5 = 0LL;
        v32 = v1;
        v33 = v3;
        do
        {
          v6 = sk_value(*v1, v4);
          if ( *((_DWORD *)v6 + 4) != v34 )
          {
            v5 = (void **)sk_new_null();
            if ( !v5 )
              goto LABEL_65;
            if ( !sk_push(v3, (__int64)v5) )
            {
              sk_free(v5);
              goto LABEL_65;
            }
            v34 = *((_DWORD *)v6 + 4);
          }
          v7 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&X509_NAME_ENTRY_it);
          if ( !v7 )
            goto LABEL_65;
          *v7 = OBJ_dup(*v6);
          v8 = v6[1];
          v9 = v7[1];
          if ( ASN1_tag2bit(*(_DWORD *)(v8 + 4)) & 0x2956 )
          {
            v10 = (unsigned __int8 **)(v9 + 8);
            *(_DWORD *)(v9 + 4) = 12;
            ASN1_STRING_to_UTF8((_QWORD *)(v9 + 8), v8);
            v12 = v11;
            *(_DWORD *)v9 = v11;
            if ( v11 == -1 )
              goto LABEL_56;
            v13 = *v10;
            if ( v11 < 1 )
            {
              v25 = *v10;
            }
            else
            {
              v14 = *v10;
              do
              {
                v15 = *v14;
                if ( v15 & 0x80 )
                  break;
                if ( !(unsigned int)isspace(v15) )
                  break;
                ++v14;
                v16 = __OFSUB__(v12--, 1);
              }
              while ( !((unsigned __int8)((v12 < 0) ^ v16) | (v12 == 0)) );
              if ( v12 < 1 )
              {
                LODWORD(v25) = (_DWORD)v13;
              }
              else
              {
                v17 = &v14[v12 - 1];
                do
                {
                  v18 = *v17;
                  if ( v18 & 0x80 )
                    break;
                  if ( !(unsigned int)isspace(v18) )
                    break;
                  --v17;
                  v16 = __OFSUB__(v12--, 1);
                }
                while ( !((unsigned __int8)((v12 < 0) ^ v16) | (v12 == 0)) );
                if ( v12 >= 1 )
                {
                  v19 = 0;
                  while ( 1 )
                  {
                    v20 = *v14;
                    if ( v20 & 0x80 )
                    {
                      ++v14;
                      *v13 = v20;
                    }
                    else
                    {
                      if ( (unsigned int)isspace(v20) )
                      {
                        *v13 = 32;
                        v21 = v14 + 1;
                        v22 = v19 + 1;
                        do
                        {
                          v14 = v21;
                          v23 = *v21;
                          v19 = v22;
                          if ( v23 & 0x80 )
                            break;
                          v24 = isspace(v23);
                          v21 = v14 + 1;
                          v22 = v19 + 1;
                        }
                        while ( v24 );
                        goto LABEL_37;
                      }
                      *v13 = tolower(v20);
                      ++v14;
                    }
                    ++v19;
LABEL_37:
                    ++v13;
                    if ( v19 >= v12 )
                    {
                      v25 = *v10;
                      goto LABEL_44;
                    }
                  }
                }
                LODWORD(v25) = (_DWORD)v13;
LABEL_44:
                v1 = v32;
              }
            }
            *(_DWORD *)v9 = (_DWORD)v13 - (_DWORD)v25;
            v3 = v33;
          }
          else if ( !(unsigned int)ASN1_STRING_copy(v9, v8) )
          {
            goto LABEL_56;
          }
          if ( !sk_push((unsigned __int64 *)v5, (__int64)v7) )
          {
LABEL_56:
            ASN1_item_free((__int64)v7, (unsigned __int8 *)&X509_NAME_ENTRY_it);
            goto LABEL_65;
          }
          ++v4;
        }
        while ( v4 < (unsigned __int64)sk_num(*v1) );
      }
      if ( sk_num(v3) )
      {
        v26 = 0LL;
        v27 = 0;
        while ( 1 )
        {
          v36 = sk_value(v3, v26);
          sub_A3124(&v36, 0LL, (unsigned __int8 *)&unk_101D68, -1, 0xFFFFFFFF);
          if ( v28 & 0x80000000 )
            break;
          v27 += v28;
          if ( ++v26 >= (unsigned __int64)sk_num(v3) )
          {
            if ( !(v27 & 0x80000000) )
              goto LABEL_58;
            break;
          }
        }
      }
      else
      {
        v27 = 0;
LABEL_58:
        *((_DWORD *)v1 + 8) = v27;
        v29 = malloc(v27);
        v35 = v29;
        if ( v29 )
        {
          v1[3] = v29;
          if ( sk_num(v3) )
          {
            v30 = 0LL;
            do
            {
              v36 = sk_value(v3, v30);
              sub_A3124(&v36, (_BYTE **)&v35, (unsigned __int8 *)&unk_101D68, -1, 0xFFFFFFFF);
              if ( v31 & 0x80000000 )
                break;
              ++v30;
            }
            while ( v30 < (unsigned __int64)sk_num(v3) );
          }
        }
      }
LABEL_65:
      sk_pop_free(v3, (void (*)(void))sub_912B8);
    }
  }
  else
  {
    *((_DWORD *)v1 + 8) = 0;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000912B8) ----------------------------------------------------
void __fastcall sub_912B8(unsigned __int64 *a1)
{
  sk_pop_free(a1, (void (*)(void))X509_NAME_ENTRY_free);
}

//----- (00000000000912C4) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_PUBKEY(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_PUBKEY_it);
}

//----- (00000000000912D0) ----------------------------------------------------
void i2d_X509_PUBKEY()
{
  ASN1_item_i2d();
}

//----- (00000000000912DC) ----------------------------------------------------
__int64 X509_PUBKEY_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_PUBKEY_it);
}

//----- (00000000000912E8) ----------------------------------------------------
void __fastcall X509_PUBKEY_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_PUBKEY_it);
}

//----- (00000000000912F4) ----------------------------------------------------
signed __int64 __fastcall X509_PUBKEY_set(__int64 *a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x19
  unsigned __int64 *v4; // x20
  signed __int64 result; // x0
  char *v6; // [xsp+0h] [xbp-50h]
  __int64 v7[4]; // [xsp+8h] [xbp-48h]
  __int64 v8; // [xsp+28h] [xbp-28h]
  char *v9; // [xsp+30h] [xbp-20h]
  __int64 v10; // [xsp+38h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = 0LL;
  if ( a1 )
  {
    if ( (unsigned int)CBB_init(v7, 0LL)
      && (unsigned int)EVP_marshal_public_key((__int64)v7, v2)
      && (unsigned int)CBB_finish((__int64)v7, &v9, &v8)
      && !(v8 & 0x8000000000000000LL) )
    {
      v6 = v9;
      v4 = ASN1_item_d2i(0LL, (const void **)&v6, v8, (unsigned __int8 *)&X509_PUBKEY_it);
      if ( v4 && v6 == &v9[v8] )
      {
        free(v9);
        ASN1_item_free(*v3, (unsigned __int8 *)&X509_PUBKEY_it);
        *v3 = (__int64)v4;
        result = 1LL;
        goto LABEL_12;
      }
      ERR_put_error(11, 0LL, 125, (__int64)"external/boringssl/src/crypto/x509/x_pubkey.c", 112);
    }
    else
    {
      CBB_cleanup(v7);
      ERR_put_error(11, 0LL, 126, (__int64)"external/boringssl/src/crypto/x509/x_pubkey.c", 105);
      v4 = 0LL;
    }
    ASN1_item_free((__int64)v4, (unsigned __int8 *)&X509_PUBKEY_it);
    free(v9);
  }
  result = 0LL;
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v10;
  return result;
}

//----- (0000000000091444) ----------------------------------------------------
void __fastcall X509_PUBKEY_get(__int64 a1)
{
  __int64 v1; // x20
  __int64 v2; // x21
  __int64 v3; // x19
  int v4; // w0
  int *v5; // x0
  int *v6; // x19
  __int64 v7; // [xsp+0h] [xbp-40h]
  void *v8; // [xsp+10h] [xbp-30h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v1 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = 0LL;
  if ( !a1 )
    goto LABEL_18;
  CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_107308);
  v2 = *(_QWORD *)(v1 + 16);
  CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107308);
  if ( v2 )
  {
    EVP_PKEY_up_ref(*(_DWORD **)(v1 + 16));
    v3 = *(_QWORD *)(v1 + 16);
    goto LABEL_10;
  }
  ASN1_item_i2d();
  if ( v4 & 0x80000000 )
  {
LABEL_18:
    v6 = 0LL;
    goto LABEL_9;
  }
  CBS_init(&v7, (__int64)v8, v4);
  EVP_parse_public_key((unsigned __int8 **)&v7);
  v6 = v5;
  if ( !v5 || EVP_CIPHER_CTX_get_app_data((__int64)&v7) )
  {
    ERR_put_error(11, 0LL, 125, (__int64)"external/boringssl/src/crypto/x509/x_pubkey.c", 158);
LABEL_9:
    free(v8);
    EVP_PKEY_free(v6);
    goto LABEL_10;
  }
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_107308);
  if ( *(_QWORD *)(v1 + 16) )
  {
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107308);
    EVP_PKEY_free(v6);
    v6 = *(int **)(v1 + 16);
  }
  else
  {
    *(_QWORD *)(v1 + 16) = v6;
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107308);
  }
  free(v8);
  EVP_PKEY_up_ref(v6);
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
}

//----- (00000000000915A0) ----------------------------------------------------
int *__fastcall d2i_PUBKEY(int **a1, const void **a2, __int64 a3)
{
  int **v3; // x19
  unsigned __int64 *v4; // x0
  __int64 v5; // x21
  int *v6; // x0
  int *v7; // x20

  v3 = a1;
  v4 = ASN1_item_d2i(0LL, a2, a3, (unsigned __int8 *)&X509_PUBKEY_it);
  v5 = (__int64)v4;
  if ( !v4 )
    return 0LL;
  X509_PUBKEY_get((__int64)v4);
  v7 = v6;
  ASN1_item_free(v5, (unsigned __int8 *)&X509_PUBKEY_it);
  if ( v7 && v3 )
  {
    EVP_PKEY_free(*v3);
    *v3 = v7;
  }
  return v7;
}

//----- (0000000000091618) ----------------------------------------------------
void __fastcall i2d_PUBKEY(__int64 a1)
{
  __int64 v1; // [xsp+0h] [xbp-20h]
  __int64 v2; // [xsp+8h] [xbp-18h]

  v2 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v1 = 0LL;
  if ( a1 && (unsigned int)X509_PUBKEY_set(&v1, a1) )
  {
    ASN1_item_i2d();
    ASN1_item_free(v1, (unsigned __int8 *)&X509_PUBKEY_it);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000916B4) ----------------------------------------------------
void __fastcall d2i_RSA_PUBKEY(int **a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x20
  int **v4; // x19
  unsigned __int64 *v5; // x0
  __int64 v6; // x21
  int *v7; // x0
  int *v8; // x22
  __int64 v9; // x21
  __int64 v10; // [xsp+0h] [xbp-30h]
  __int64 v11; // [xsp+8h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = *a2;
  v5 = ASN1_item_d2i(0LL, (const void **)&v10, a3, (unsigned __int8 *)&X509_PUBKEY_it);
  v6 = (__int64)v5;
  if ( v5 )
  {
    X509_PUBKEY_get((__int64)v5);
    v8 = v7;
    ASN1_item_free(v6, (unsigned __int8 *)&X509_PUBKEY_it);
    if ( v8 )
    {
      v9 = EVP_PKEY_get1_RSA((__int64)v8);
      EVP_PKEY_free(v8);
      if ( v9 )
      {
        *v3 = v10;
        if ( v4 )
        {
          RSA_free(*v4);
          *v4 = (int *)v9;
        }
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000091788) ----------------------------------------------------
void __fastcall i2d_RSA_PUBKEY(__int64 a1)
{
  __int64 v1; // x21
  char *v2; // x0
  int *v3; // x19
  __int64 v4; // [xsp+0h] [xbp-30h]
  __int64 v5; // [xsp+8h] [xbp-28h]

  v1 = a1;
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v2 = EVP_PKEY_new();
    v3 = (int *)v2;
    if ( v2 )
    {
      EVP_PKEY_set1_RSA((__int64)v2, v1);
      v4 = 0LL;
      if ( (unsigned int)X509_PUBKEY_set(&v4, (__int64)v3) )
      {
        ASN1_item_i2d();
        ASN1_item_free(v4, (unsigned __int8 *)&X509_PUBKEY_it);
      }
      EVP_PKEY_free(v3);
    }
    else
    {
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x_pubkey.c", 251);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000091878) ----------------------------------------------------
void __fastcall d2i_DSA_PUBKEY(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x20
  __int64 *v4; // x19
  unsigned __int64 *v5; // x0
  __int64 v6; // x21
  int *v7; // x0
  int *v8; // x22
  __int64 v9; // x21
  __int64 v10; // [xsp+0h] [xbp-30h]
  __int64 v11; // [xsp+8h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = *a2;
  v5 = ASN1_item_d2i(0LL, (const void **)&v10, a3, (unsigned __int8 *)&X509_PUBKEY_it);
  v6 = (__int64)v5;
  if ( v5 )
  {
    X509_PUBKEY_get((__int64)v5);
    v8 = v7;
    ASN1_item_free(v6, (unsigned __int8 *)&X509_PUBKEY_it);
    if ( v8 )
    {
      v9 = EVP_PKEY_get1_DSA((__int64)v8);
      EVP_PKEY_free(v8);
      if ( v9 )
      {
        *v3 = v10;
        if ( v4 )
        {
          DSA_free(*v4);
          *v4 = v9;
        }
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009194C) ----------------------------------------------------
void __fastcall i2d_DSA_PUBKEY(__int64 a1)
{
  __int64 v1; // x21
  char *v2; // x0
  int *v3; // x19
  __int64 v4; // [xsp+0h] [xbp-30h]
  __int64 v5; // [xsp+8h] [xbp-28h]

  v1 = a1;
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v2 = EVP_PKEY_new();
    v3 = (int *)v2;
    if ( v2 )
    {
      EVP_PKEY_set1_DSA((__int64)v2, v1);
      v4 = 0LL;
      if ( (unsigned int)X509_PUBKEY_set(&v4, (__int64)v3) )
      {
        ASN1_item_i2d();
        ASN1_item_free(v4, (unsigned __int8 *)&X509_PUBKEY_it);
      }
      EVP_PKEY_free(v3);
    }
    else
    {
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x_pubkey.c", 290);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000091A3C) ----------------------------------------------------
void __fastcall d2i_EC_PUBKEY(__int64 *a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x20
  __int64 *v4; // x19
  unsigned __int64 *v5; // x0
  __int64 v6; // x21
  int *v7; // x0
  int *v8; // x22
  __int64 v9; // x21
  __int64 v10; // [xsp+0h] [xbp-30h]
  __int64 v11; // [xsp+8h] [xbp-28h]

  v3 = a2;
  v4 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = *a2;
  v5 = ASN1_item_d2i(0LL, (const void **)&v10, a3, (unsigned __int8 *)&X509_PUBKEY_it);
  v6 = (__int64)v5;
  if ( v5 )
  {
    X509_PUBKEY_get((__int64)v5);
    v8 = v7;
    ASN1_item_free(v6, (unsigned __int8 *)&X509_PUBKEY_it);
    if ( v8 )
    {
      v9 = EVP_PKEY_get1_EC_KEY((__int64)v8);
      EVP_PKEY_free(v8);
      if ( v9 )
      {
        *v3 = v10;
        if ( v4 )
        {
          EC_KEY_free(*v4);
          *v4 = v9;
        }
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000091B10) ----------------------------------------------------
void __fastcall i2d_EC_PUBKEY(__int64 a1)
{
  __int64 v1; // x21
  char *v2; // x0
  int *v3; // x19
  __int64 v4; // [xsp+0h] [xbp-30h]
  __int64 v5; // [xsp+8h] [xbp-28h]

  v1 = a1;
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v2 = EVP_PKEY_new();
    v3 = (int *)v2;
    if ( v2 )
    {
      EVP_PKEY_set1_EC_KEY((__int64)v2, v1);
      v4 = 0LL;
      if ( (unsigned int)X509_PUBKEY_set(&v4, (__int64)v3) )
      {
        ASN1_item_i2d();
        ASN1_item_free(v4, (unsigned __int8 *)&X509_PUBKEY_it);
      }
      EVP_PKEY_free(v3);
    }
    else
    {
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x_pubkey.c", 328);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000091C00) ----------------------------------------------------
__int64 __fastcall X509_PUBKEY_set0_param(__int64 *a1, __int64 a2, int a3, __int64 a4, __int64 a5, int a6)
{
  __int64 *v6; // x19
  int v7; // w20
  __int64 v8; // x21
  __int64 result; // x0
  __int64 v10; // x8
  void *v11; // x0

  v6 = a1;
  v7 = a6;
  v8 = a5;
  result = X509_ALGOR_set0(*a1, a2, a3, a4);
  if ( (_DWORD)result )
  {
    if ( v8 )
    {
      v10 = v6[1];
      v11 = *(void **)(v10 + 8);
      if ( v11 )
      {
        free(v11);
        v10 = v6[1];
      }
      *(_QWORD *)(v10 + 8) = v8;
      *(_DWORD *)v6[1] = v7;
      *(_QWORD *)(v6[1] + 16) &= 0xFFFFFFFFFFFFFFF0LL;
      *(_QWORD *)(v6[1] + 16) |= 8uLL;
    }
    result = 1LL;
  }
  return result;
}

//----- (0000000000091C80) ----------------------------------------------------
signed __int64 __fastcall X509_PUBKEY_get0_param(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5)
{
  if ( a1 )
    *a1 = **(_QWORD **)a5;
  if ( a2 )
  {
    *a2 = *(_QWORD *)(*(_QWORD *)(a5 + 8) + 8LL);
    *a3 = **(_DWORD **)(a5 + 8);
  }
  if ( a4 )
    *a4 = *(_QWORD *)a5;
  return 1LL;
}

//----- (0000000000091CC0) ----------------------------------------------------
signed __int64 __fastcall sub_91CC0(int a1, __int64 a2)
{
  if ( a1 == 3 )
    EVP_PKEY_free(*(int **)(*(_QWORD *)a2 + 16LL));
  return 1LL;
}

//----- (0000000000091CE8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_REQ_INFO(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_REQ_INFO_it);
}

//----- (0000000000091CF4) ----------------------------------------------------
void i2d_X509_REQ_INFO()
{
  ASN1_item_i2d();
}

//----- (0000000000091D00) ----------------------------------------------------
__int64 X509_REQ_INFO_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_REQ_INFO_it);
}

//----- (0000000000091D0C) ----------------------------------------------------
void __fastcall X509_REQ_INFO_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_REQ_INFO_it);
}

//----- (0000000000091D18) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_REQ(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_REQ_it);
}

//----- (0000000000091D24) ----------------------------------------------------
void i2d_X509_REQ()
{
  ASN1_item_i2d();
}

//----- (0000000000091D30) ----------------------------------------------------
__int64 X509_REQ_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_REQ_it);
}

//----- (0000000000091D3C) ----------------------------------------------------
void __fastcall X509_REQ_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_REQ_it);
}

//----- (0000000000091D48) ----------------------------------------------------
void __fastcall X509_REQ_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_REQ_it, a1);
}

//----- (0000000000091D60) ----------------------------------------------------
_QWORD *__fastcall sub_91D60(int a1, __int64 *a2)
{
  __int64 v2; // x19
  _QWORD *result; // x0

  if ( a1 != 1 || (v2 = *a2, result = sk_new_null(), (*(_QWORD *)(v2 + 48) = result) != 0LL) )
    result = (_QWORD *)(&dword_0 + 1);
  return result;
}
// 0: using guessed type int dword_0;

//----- (0000000000091D94) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_SIG(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_SIG_it);
}

//----- (0000000000091DA0) ----------------------------------------------------
void i2d_X509_SIG()
{
  ASN1_item_i2d();
}

//----- (0000000000091DAC) ----------------------------------------------------
__int64 X509_SIG_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_SIG_it);
}

//----- (0000000000091DB8) ----------------------------------------------------
void __fastcall X509_SIG_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_SIG_it);
}

//----- (0000000000091DC4) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_NETSCAPE_SPKAC(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&NETSCAPE_SPKAC_it);
}

//----- (0000000000091DD0) ----------------------------------------------------
void i2d_NETSCAPE_SPKAC()
{
  ASN1_item_i2d();
}

//----- (0000000000091DDC) ----------------------------------------------------
__int64 NETSCAPE_SPKAC_new()
{
  return ASN1_item_new((unsigned __int8 *)&NETSCAPE_SPKAC_it);
}

//----- (0000000000091DE8) ----------------------------------------------------
void __fastcall NETSCAPE_SPKAC_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&NETSCAPE_SPKAC_it);
}

//----- (0000000000091DF4) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_NETSCAPE_SPKI(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&NETSCAPE_SPKI_it);
}

//----- (0000000000091E00) ----------------------------------------------------
void i2d_NETSCAPE_SPKI()
{
  ASN1_item_i2d();
}

//----- (0000000000091E0C) ----------------------------------------------------
__int64 NETSCAPE_SPKI_new()
{
  return ASN1_item_new((unsigned __int8 *)&NETSCAPE_SPKI_it);
}

//----- (0000000000091E18) ----------------------------------------------------
void __fastcall NETSCAPE_SPKI_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&NETSCAPE_SPKI_it);
}

//----- (0000000000091E24) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_CINF(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_CINF_it);
}

//----- (0000000000091E30) ----------------------------------------------------
void i2d_X509_CINF()
{
  ASN1_item_i2d();
}

//----- (0000000000091E3C) ----------------------------------------------------
__int64 X509_CINF_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_CINF_it);
}

//----- (0000000000091E48) ----------------------------------------------------
void __fastcall X509_CINF_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_CINF_it);
}

//----- (0000000000091E54) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_it);
}

//----- (0000000000091E60) ----------------------------------------------------
void i2d_X509()
{
  ASN1_item_i2d();
}

//----- (0000000000091E6C) ----------------------------------------------------
__int64 X509_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_it);
}

//----- (0000000000091E78) ----------------------------------------------------
void __fastcall X509_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_it);
}

//----- (0000000000091E84) ----------------------------------------------------
void __fastcall X509_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_it, a1);
}

//----- (0000000000091E9C) ----------------------------------------------------
void __fastcall X509_parse_from_buffer(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x0
  __int64 v3; // x0
  unsigned __int64 *v4; // x20
  __int64 v5; // x21
  __int64 v6; // x21
  __int64 v7; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+10h] [xbp-30h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v1 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( X509_TRUST_get0_name(a1) & 0x8000000000000000LL )
  {
    ERR_put_error(16, 0LL, 69, (__int64)"external/boringssl/src/crypto/x509/x_x509.c", 156);
  }
  else
  {
    v2 = ASN1_item_new((unsigned __int8 *)&X509_it);
    if ( v2 )
    {
      *(_BYTE *)(*(_QWORD *)v2 + 100LL) |= 2u;
      v7 = v2;
      v8 = EVP_CIPHER_CTX_get_app_data(v1);
      v3 = X509_TRUST_get0_name(v1);
      v4 = ASN1_item_d2i((unsigned __int64 **)&v7, (const void **)&v8, v3, (unsigned __int8 *)&X509_it);
      if ( v4 && (v5 = v8, v6 = v5 - EVP_CIPHER_CTX_get_app_data(v1), v6 == X509_TRUST_get0_name(v1)) )
      {
        X509_up_ref(v1);
        v4[22] = v1;
      }
      else
      {
        ASN1_item_free(v7, (unsigned __int8 *)&X509_it);
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (0000000000091FB4) ----------------------------------------------------
signed __int64 __fastcall X509_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // x19
  int v6; // w0
  __int64 v7; // x9
  signed __int64 result; // x0
  unsigned int v9; // [xsp+4h] [xbp-1Ch]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = *(_QWORD *)(v5 + 40);
  v6 = CRYPTO_get_ex_new_index((pthread_rwlock_t *)&unk_107340, &v9, a1, a2, a4, a5);
  v7 = *(_QWORD *)(v5 + 40);
  if ( v6 )
    result = v9;
  else
    result = 1LL;
  return result;
}

//----- (0000000000092030) ----------------------------------------------------
signed __int64 __fastcall X509_set_ex_data(__int64 a1, int a2, __int64 a3)
{
  return CRYPTO_set_ex_data((unsigned __int64 **)(a1 + 40), a2, a3);
}

//----- (0000000000092038) ----------------------------------------------------
unsigned __int64 *__fastcall X509_get_ex_data(__int64 a1, int a2)
{
  return CRYPTO_get_ex_data((unsigned __int64 **)(a1 + 40), a2);
}

//----- (0000000000092040) ----------------------------------------------------
void __fastcall d2i_X509_AUX(unsigned __int64 **a1, __int64 *a2, __int64 a3)
{
  __int64 *v3; // x20
  __int64 v4; // x22
  unsigned __int64 **v5; // x19
  _BOOL4 v6; // w23
  unsigned __int64 *v7; // x0
  __int64 v8; // x21
  __int64 v9; // x8
  __int64 v10; // x2
  __int64 v11; // [xsp+0h] [xbp-40h]
  __int64 v12; // [xsp+8h] [xbp-38h]

  v3 = a2;
  v4 = a3;
  v5 = a1;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = *a2;
  v6 = !a1 || !*a1;
  v7 = ASN1_item_d2i(a1, (const void **)&v11, a3, (unsigned __int8 *)&X509_it);
  v8 = (__int64)v7;
  if ( v7 )
  {
    v9 = v11;
    v10 = *v3 - v11 + v4;
    if ( v10 < 1 )
    {
LABEL_9:
      *v3 = v9;
      goto LABEL_10;
    }
    if ( d2i_X509_CERT_AUX((unsigned __int64 **)v7 + 21, (const void **)&v11, v10) )
    {
      v9 = v11;
      goto LABEL_9;
    }
    if ( v6 )
    {
      ASN1_item_free(v8, (unsigned __int8 *)&X509_it);
      if ( v5 )
        *v5 = 0LL;
    }
  }
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v12;
}

//----- (0000000000092140) ----------------------------------------------------
void __fastcall i2d_X509_AUX(__int64 a1, void **a2)
{
  void **v2; // x19
  __int64 v3; // x21
  __int64 v4; // ST08_8
  void *v5; // x22
  signed int v6; // w0
  signed int v7; // w20
  __int64 v8; // x0
  int v9; // w0
  void *v10; // x22
  signed int v11; // w0
  signed int v12; // w20
  __int64 v13; // x0
  int v14; // w0
  signed int v15; // w0
  __int64 v16; // x0
  int v17; // w0

  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    v5 = 0LL;
    goto LABEL_16;
  }
  v5 = *a2;
  if ( *a2 )
  {
LABEL_16:
    ASN1_item_i2d();
    if ( v3 )
    {
      if ( v15 >= 1 )
      {
        v16 = *(_QWORD *)(v3 + 168);
        i2d_X509_CERT_AUX();
        if ( v17 & 0x80000000 )
        {
          if ( v5 )
            *v2 = v5;
        }
      }
    }
    goto LABEL_25;
  }
  ASN1_item_i2d();
  v7 = v6;
  if ( v3 && v6 >= 1 )
  {
    v8 = *(_QWORD *)(v3 + 168);
    i2d_X509_CERT_AUX();
    if ( v9 & 0x80000000 )
      goto LABEL_25;
    v7 += v9;
  }
  if ( v7 >= 1 )
  {
    v10 = malloc(v7);
    *v2 = v10;
    if ( v10 )
    {
      ASN1_item_i2d();
      v12 = v11;
      if ( v3 && v11 >= 1 )
      {
        v13 = *(_QWORD *)(v3 + 168);
        i2d_X509_CERT_AUX();
        if ( v14 & 0x80000000 )
        {
LABEL_24:
          free(*v2);
          *v2 = 0LL;
          goto LABEL_25;
        }
        v12 += v14;
      }
      if ( v12 <= 0 )
        goto LABEL_24;
    }
  }
LABEL_25:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000922B4) ----------------------------------------------------
_QWORD *__fastcall X509_get0_signature(_QWORD *result, _QWORD *a2, __int64 a3)
{
  if ( result )
    *result = *(_QWORD *)(a3 + 16);
  if ( a2 )
    *a2 = *(_QWORD *)(a3 + 8);
  return result;
}

//----- (00000000000922D0) ----------------------------------------------------
unsigned int *__fastcall X509_get_signature_nid(__int64 a1)
{
  return OBJ_obj2nid(**(unsigned int ***)(a1 + 8));
}

//----- (00000000000922DC) ----------------------------------------------------
signed __int64 __fastcall sub_922DC(int a1, __int64 *a2)
{
  __int64 v2; // x19
  void *v3; // x0
  __int64 v4; // x0

  v2 = *a2;
  switch ( a1 )
  {
    case 1:
      *(_QWORD *)(v2 + 32) = 0LL;
      *(_QWORD *)(v2 + 64) = 0LL;
      *(_QWORD *)(v2 + 120) = 0LL;
      *(_QWORD *)(v2 + 96) = 0LL;
      *(_QWORD *)(v2 + 104) = 0LL;
      *(_QWORD *)(v2 + 48) = -1LL;
      *(_QWORD *)(v2 + 168) = 0LL;
      *(_QWORD *)(v2 + 176) = 0LL;
      CRYPTO_new_ex_data((_QWORD *)(v2 + 40));
      CRYPTO_MUTEX_init((pthread_rwlock_t *)(v2 + 184));
      break;
    case 3:
      CRYPTO_MUTEX_cleanup(v2 + 184);
      CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_107340, v2, (unsigned __int64 **)(v2 + 40));
      X509_CERT_AUX_free(*(_QWORD *)(v2 + 168));
      ASN1_VISIBLESTRING_free(*(_QWORD *)(v2 + 96));
      AUTHORITY_KEYID_free(*(_QWORD *)(v2 + 104));
      CRL_DIST_POINTS_free(*(_QWORD *)(v2 + 120));
      sub_927B4(*(void *****)(v2 + 112));
      GENERAL_NAMES_free(*(_QWORD *)(v2 + 128));
      NAME_CONSTRAINTS_free(*(_QWORD *)(v2 + 136));
      CRYPTO_BUFFER_free(*(int **)(v2 + 176));
      free(*(void **)(v2 + 32));
      break;
    case 4:
      CRYPTO_BUFFER_free(*(int **)(v2 + 176));
      *(_QWORD *)(v2 + 176) = 0LL;
      break;
    case 5:
      v3 = *(void **)(v2 + 32);
      if ( v3 )
        free(v3);
      X509_NAME_oneline(*(unsigned __int64 ***)(*(_QWORD *)v2 + 40LL), 0LL, 0);
      *(_QWORD *)(v2 + 32) = v4;
      break;
    default:
      return 1LL;
  }
  return 1LL;
}
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (00000000000923E8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_CERT_AUX(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_CERT_AUX_it);
}

//----- (00000000000923F4) ----------------------------------------------------
void i2d_X509_CERT_AUX()
{
  ASN1_item_i2d();
}

//----- (0000000000092400) ----------------------------------------------------
__int64 X509_CERT_AUX_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_CERT_AUX_it);
}

//----- (000000000009240C) ----------------------------------------------------
void __fastcall X509_CERT_AUX_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_CERT_AUX_it);
}

//----- (0000000000092418) ----------------------------------------------------
__int64 __fastcall X509_alias_set1(__int64 a1, const char *a2, int a3)
{
  int v3; // w19
  const char *v4; // x20
  __int64 v5; // x21
  __int64 v6; // x22
  __int64 result; // x0
  __int64 v8; // x8
  __int64 v9; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a2 )
  {
    if ( a1
      && ((v6 = *(_QWORD *)(a1 + 168)) != 0
       || (v6 = ASN1_item_new((unsigned __int8 *)&X509_CERT_AUX_it), (*(_QWORD *)(v5 + 168) = v6) != 0LL)) )
    {
      result = *(_QWORD *)(v6 + 16);
      if ( result || (result = (__int64)ASN1_UTF8STRING_new(), (*(_QWORD *)(v6 + 16) = result) != 0LL) )
        result = ASN1_STRING_set(result, v4, v3);
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    if ( a1 )
    {
      v8 = *(_QWORD *)(a1 + 168);
      if ( v8 )
      {
        v9 = *(_QWORD *)(v8 + 16);
        if ( v9 )
        {
          ASN1_VISIBLESTRING_free(v9);
          *(_QWORD *)(*(_QWORD *)(v5 + 168) + 16LL) = 0LL;
        }
      }
    }
    result = 1LL;
  }
  return result;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (00000000000924C4) ----------------------------------------------------
__int64 __fastcall X509_keyid_set1(__int64 a1, const char *a2, int a3)
{
  int v3; // w19
  const char *v4; // x20
  __int64 v5; // x21
  __int64 v6; // x22
  __int64 result; // x0
  __int64 v8; // x8
  __int64 v9; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a2 )
  {
    if ( a1
      && ((v6 = *(_QWORD *)(a1 + 168)) != 0
       || (v6 = ASN1_item_new((unsigned __int8 *)&X509_CERT_AUX_it), (*(_QWORD *)(v5 + 168) = v6) != 0LL)) )
    {
      result = *(_QWORD *)(v6 + 24);
      if ( result || (result = (__int64)ASN1_OCTET_STRING_new(), (*(_QWORD *)(v6 + 24) = result) != 0LL) )
        result = ASN1_STRING_set(result, v4, v3);
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    if ( a1 )
    {
      v8 = *(_QWORD *)(a1 + 168);
      if ( v8 )
      {
        v9 = *(_QWORD *)(v8 + 24);
        if ( v9 )
        {
          ASN1_VISIBLESTRING_free(v9);
          *(_QWORD *)(*(_QWORD *)(v5 + 168) + 24LL) = 0LL;
        }
      }
    }
    result = 1LL;
  }
  return result;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (0000000000092570) ----------------------------------------------------
__int64 __fastcall X509_alias_get0(__int64 a1, _DWORD *a2)
{
  __int64 v2; // x8
  __int64 v3; // x8

  v2 = *(_QWORD *)(a1 + 168);
  if ( !v2 )
    return 0LL;
  v3 = *(_QWORD *)(v2 + 16);
  if ( !v3 )
    return 0LL;
  if ( a2 )
  {
    *a2 = *(_DWORD *)v3;
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 16LL);
  }
  return *(_QWORD *)(v3 + 8);
}

//----- (00000000000925AC) ----------------------------------------------------
__int64 __fastcall X509_keyid_get0(__int64 a1, _DWORD *a2)
{
  __int64 v2; // x8
  __int64 v3; // x8

  v2 = *(_QWORD *)(a1 + 168);
  if ( !v2 )
    return 0LL;
  v3 = *(_QWORD *)(v2 + 24);
  if ( !v3 )
    return 0LL;
  if ( a2 )
  {
    *a2 = *(_DWORD *)v3;
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 24LL);
  }
  return *(_QWORD *)(v3 + 8);
}

//----- (00000000000925E8) ----------------------------------------------------
signed __int64 __fastcall X509_add1_trust_object(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 *v3; // x19
  unsigned __int64 **v4; // x21
  unsigned __int64 *v5; // x0

  v2 = a1;
  v3 = OBJ_dup(a2);
  if ( v3 )
  {
    v4 = *(unsigned __int64 ***)(v2 + 168);
    if ( !v4 )
    {
      v4 = (unsigned __int64 **)ASN1_item_new((unsigned __int8 *)&X509_CERT_AUX_it);
      *(_QWORD *)(v2 + 168) = v4;
    }
    v5 = *v4;
    if ( *v4 || (v5 = sk_new_null(), (*v4 = v5) != 0LL) )
    {
      if ( sk_push(v5, (__int64)v3) )
        return 1LL;
    }
  }
  ASN1_OBJECT_free((void **)v3);
  return 0LL;
}

//----- (000000000009266C) ----------------------------------------------------
signed __int64 __fastcall X509_add1_reject_object(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 *v3; // x19
  __int64 v4; // x20
  __int64 v5; // x0
  unsigned __int64 *v6; // x0

  v2 = a1;
  v3 = OBJ_dup(a2);
  if ( !v3 )
    goto LABEL_11;
  if ( !v2 )
  {
    v4 = 0LL;
LABEL_7:
    v6 = *(unsigned __int64 **)(v4 + 8);
    if ( !v6 )
      goto LABEL_8;
    goto LABEL_9;
  }
  v4 = *(_QWORD *)(v2 + 168);
  if ( v4 )
    goto LABEL_7;
  v5 = ASN1_item_new((unsigned __int8 *)&X509_CERT_AUX_it);
  v4 = v5;
  *(_QWORD *)(v2 + 168) = v5;
  v6 = *(unsigned __int64 **)(v5 + 8);
  if ( !v6 )
  {
LABEL_8:
    v6 = sk_new_null();
    *(_QWORD *)(v4 + 8) = v6;
    if ( !v6 )
      goto LABEL_11;
  }
LABEL_9:
  if ( sk_push(v6, (__int64)v3) )
    return 1LL;
LABEL_11:
  ASN1_OBJECT_free((void **)v3);
  return 0LL;
}

//----- (0000000000092704) ----------------------------------------------------
void __fastcall X509_trust_clear(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int64 **v2; // x8

  v1 = a1;
  v2 = *(unsigned __int64 ***)(a1 + 168);
  if ( v2 )
  {
    if ( *v2 )
    {
      sk_pop_free(*v2, (void (*)(void))ASN1_OBJECT_free);
      **(_QWORD **)(v1 + 168) = 0LL;
    }
  }
}

//----- (0000000000092744) ----------------------------------------------------
void __fastcall X509_reject_clear(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x8
  unsigned __int64 *v3; // x0

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 168);
  if ( v2 )
  {
    v3 = *(unsigned __int64 **)(v2 + 8);
    if ( v3 )
    {
      sk_pop_free(v3, (void (*)(void))ASN1_OBJECT_free);
      *(_QWORD *)(*(_QWORD *)(v1 + 168) + 8LL) = 0LL;
    }
  }
}

//----- (0000000000092784) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_CERT_PAIR(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_CERT_PAIR_it);
}

//----- (0000000000092790) ----------------------------------------------------
void i2d_X509_CERT_PAIR()
{
  ASN1_item_i2d();
}

//----- (000000000009279C) ----------------------------------------------------
__int64 X509_CERT_PAIR_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_CERT_PAIR_it);
}

//----- (00000000000927A8) ----------------------------------------------------
void __fastcall X509_CERT_PAIR_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_CERT_PAIR_it);
}

//----- (00000000000927B4) ----------------------------------------------------
void __fastcall sub_927B4(void ****a1)
{
  void ****v1; // x19
  void ***v2; // x0
  unsigned __int64 *v3; // x0

  v1 = a1;
  if ( a1 )
  {
    v2 = *a1;
    if ( *v1 )
      sub_92BE8(v2);
    v3 = (unsigned __int64 *)v1[1];
    if ( v3 )
      sk_pop_free(v3, (void (*)(void))sub_92BE8);
    free(v1);
  }
}

//----- (0000000000092804) ----------------------------------------------------
__int64 __fastcall sub_92804(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x20
  __int64 result; // x0
  _QWORD *v4; // x21
  signed __int64 *v5; // x25
  unsigned __int64 *v6; // x0
  unsigned __int64 *v7; // x20
  signed __int64 v8; // x0
  signed __int64 v9; // x0
  unsigned __int64 *v10; // x0
  unsigned __int64 *v11; // x21
  int v12; // w22
  void ****v13; // x27
  void ***v14; // x0
  __int64 *v15; // x26
  unsigned __int64 v16; // x23
  unsigned __int64 *v17; // x0
  void ***v18; // x0
  void ***v19; // x24
  unsigned __int64 *v20; // x8
  unsigned __int64 *v21; // x21
  signed int v22; // w20
  unsigned __int64 *v23; // x0
  int v24; // [xsp+4h] [xbp-5Ch]
  __int64 v25; // [xsp+8h] [xbp-58h]

  v1 = a1;
  v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)&unk_107388);
  v2 = *(_QWORD *)(v1 + 112);
  result = CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107388);
  if ( v2 )
    goto LABEL_41;
  CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)&unk_107388);
  v2 = *(_QWORD *)(v1 + 112);
  if ( !v2 )
  {
    v4 = malloc(0x28uLL);
    if ( !v4 )
      goto LABEL_39;
    *v4 = 0LL;
    v4[1] = 0LL;
    v4[2] = -1LL;
    v5 = v4 + 2;
    v4[3] = -1LL;
    v4[4] = -1LL;
    *(_QWORD *)(v1 + 112) = v4;
    v6 = X509_get_ext_d2i(v1, 401, &v24, 0LL);
    v7 = v6;
    if ( v6 )
    {
      v8 = *v6;
      if ( *v7 )
      {
        if ( *(_DWORD *)(v8 + 4) == 258 )
          goto LABEL_30;
        v4[3] = ASN1_INTEGER_get(v8);
        v9 = v7[1];
        if ( !v9 )
          goto LABEL_14;
      }
      else
      {
        v9 = v7[1];
        if ( !v9 )
          goto LABEL_30;
      }
      if ( *(_DWORD *)(v9 + 4) == 258 )
        goto LABEL_30;
      v4[4] = ASN1_INTEGER_get(v9);
    }
    else if ( v24 != -1 )
    {
      goto LABEL_30;
    }
LABEL_14:
    v10 = X509_get_ext_d2i(v1, 89, &v24, 0LL);
    v11 = v10;
    if ( v10 )
    {
      v12 = v24;
      v13 = *(void *****)(v1 + 112);
      if ( sk_num(v10) )
      {
        v14 = (void ***)sk_new((__int64)sub_92BD4);
        v13[1] = v14;
        v15 = (__int64 *)(v13 + 1);
        if ( v14 )
        {
          if ( sk_num(v11) )
          {
            v16 = 0LL;
            do
            {
              v17 = sk_value(v11, v16);
              v18 = (void ***)sub_92C38(v17, 0LL, v12);
              v19 = v18;
              if ( !v18 )
                goto LABEL_37;
              if ( (unsigned int)OBJ_obj2nid((unsigned int *)v18[1]) == 746 )
              {
                if ( *v13 )
                  goto LABEL_48;
                *v13 = v19;
              }
              else
              {
                if ( (unsigned int)sk_find(*v15, 0LL, (__int64)v19) )
                {
LABEL_48:
                  v22 = -1;
                  *(_QWORD *)(v1 + 64) |= 0x800uLL;
LABEL_52:
                  sub_92BE8(v19);
                  sk_pop_free(v11, (void (*)(void))POLICYINFO_free);
                  goto LABEL_38;
                }
                if ( !sk_push((unsigned __int64 *)*v15, (__int64)v19) )
                {
                  v22 = 0;
                  goto LABEL_52;
                }
              }
              ++v16;
            }
            while ( v16 < (unsigned __int64)sk_num(v11) );
          }
          sk_pop_free(v11, (void (*)(void))POLICYINFO_free);
          v24 = 1;
          v20 = X509_get_ext_d2i(v1, 747, &v24, 0LL);
          if ( v20 )
          {
            v24 = sub_92D18(v1, v20);
            if ( v24 < 1 )
              goto LABEL_30;
LABEL_44:
            v23 = X509_get_ext_d2i(v1, 748, &v24, 0LL);
            v21 = v23;
            if ( v23 )
            {
              if ( *((_DWORD *)v23 + 1) != 258 )
              {
                *v5 = ASN1_INTEGER_get((signed __int64)v23);
                if ( !v7 )
                {
LABEL_34:
                  if ( v21 )
                    ASN1_VISIBLESTRING_free(v21);
                  goto LABEL_39;
                }
LABEL_33:
                POLICY_CONSTRAINTS_free((__int64)v7);
                goto LABEL_34;
              }
            }
            else if ( v24 == -1 )
            {
LABEL_32:
              if ( !v7 )
                goto LABEL_34;
              goto LABEL_33;
            }
LABEL_31:
            *(_QWORD *)(v1 + 64) |= 0x800uLL;
            goto LABEL_32;
          }
          if ( v24 == -1 )
            goto LABEL_44;
LABEL_30:
          v21 = 0LL;
          goto LABEL_31;
        }
      }
      else
      {
        v15 = (__int64 *)(v13 + 1);
      }
LABEL_37:
      sk_pop_free(v11, (void (*)(void))POLICYINFO_free);
      v22 = 0;
LABEL_38:
      sk_pop_free((unsigned __int64 *)*v15, (void (*)(void))sub_92BE8);
      *v15 = 0LL;
      v24 = v22;
      goto LABEL_39;
    }
    if ( v24 != -1 )
      goto LABEL_30;
LABEL_39:
    v2 = *(_QWORD *)(v1 + 112);
  }
  result = CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)&unk_107388);
LABEL_41:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v25 )
    result = v2;
  return result;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (0000000000092B60) ----------------------------------------------------
unsigned __int64 *__fastcall sub_92B60(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 *result; // x0
  __int64 v4; // [xsp+0h] [xbp-40h]
  __int64 v5; // [xsp+8h] [xbp-38h]
  unsigned __int64 v6; // [xsp+20h] [xbp-20h]
  __int64 v7; // [xsp+28h] [xbp-18h]

  v2 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = a2;
  if ( (unsigned int)sk_find(*(_QWORD *)(a1 + 8), (signed __int64 *)&v6, (__int64)&v4) )
    result = sk_value(*(unsigned __int64 **)(v2 + 8), v6);
  else
    result = 0LL;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000092BD4) ----------------------------------------------------
__int64 __fastcall sub_92BD4(__int64 a1, __int64 a2)
{
  return OBJ_cmp(*(_QWORD *)(*(_QWORD *)a1 + 8LL), *(_QWORD *)(*(_QWORD *)a2 + 8LL));
}

//----- (0000000000092BE8) ----------------------------------------------------
void __fastcall sub_92BE8(void ***a1)
{
  void ***v1; // x19

  v1 = a1;
  ASN1_OBJECT_free(a1[1]);
  if ( !(*(_BYTE *)v1 & 4) )
    sk_pop_free((unsigned __int64 *)v1[2], (void (*)(void))POLICYQUALINFO_free);
  sk_pop_free((unsigned __int64 *)v1[3], (void (*)(void))ASN1_OBJECT_free);
  free(v1);
}

//----- (0000000000092C38) ----------------------------------------------------
_QWORD *__fastcall sub_92C38(_QWORD *a1, __int64 a2, int a3)
{
  int v3; // w21
  _QWORD *v4; // x19
  _QWORD *v5; // x20
  __int64 *v6; // x22
  _QWORD *v7; // x0
  _QWORD *v8; // x19
  __int64 v9; // t1

  v3 = a3;
  v4 = a1;
  if ( !a1 && !a2 )
    return 0LL;
  if ( a2 )
  {
    v6 = OBJ_dup(a2);
    if ( !v6 )
      return 0LL;
  }
  else
  {
    v6 = 0LL;
  }
  v5 = malloc(0x20uLL);
  if ( !v5 )
    return v5;
  v7 = sk_new_null();
  v5[3] = v7;
  if ( v7 )
  {
    *(_DWORD *)v5 = 16 * (v3 != 0);
    if ( v6 )
    {
      v5[1] = v6;
      if ( !v4 )
        goto LABEL_18;
    }
    else
    {
      v5[1] = *v4;
      *v4 = 0LL;
      if ( !v4 )
      {
LABEL_18:
        v8 = v5 + 2;
        goto LABEL_19;
      }
    }
    v9 = v4[1];
    v8 = v4 + 1;
    v5[2] = v9;
LABEL_19:
    *v8 = 0LL;
    return v5;
  }
  free(v5);
  if ( v6 )
    ASN1_OBJECT_free((void **)v6);
  return 0LL;
}

//----- (0000000000092D18) ----------------------------------------------------
__int64 __fastcall sub_92D18(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // x20
  unsigned __int64 **v3; // x21
  unsigned __int64 *v4; // x19
  unsigned __int64 v5; // x22
  unsigned int **v6; // x23
  unsigned __int64 *v7; // x0
  unsigned __int64 *v8; // x24
  unsigned __int64 *v9; // x0
  unsigned __int64 v10; // x8
  unsigned int v11; // w20

  v2 = a1;
  v3 = *(unsigned __int64 ***)(a1 + 112);
  v4 = a2;
  if ( sk_num(a2) )
  {
    if ( sk_num(v4) )
    {
      v5 = 0LL;
      while ( 1 )
      {
        v6 = (unsigned int **)sk_value(v4, v5);
        if ( (unsigned int)OBJ_obj2nid(v6[1]) == 746 || (unsigned int)OBJ_obj2nid(*v6) == 746 )
          goto LABEL_15;
        v7 = sub_92B60((__int64)v3, (__int64)*v6);
        v8 = v7;
        if ( v7 )
        {
          *(_DWORD *)v7 |= 1u;
        }
        else
        {
          if ( !*v3 )
            goto LABEL_13;
          v9 = sub_92C38(0LL, (__int64)*v6, *(_DWORD *)*v3 & 0x10);
          v8 = v9;
          if ( !v9 )
            goto LABEL_18;
          v10 = (*v3)[2];
          *(_DWORD *)v9 |= 6u;
          v9[2] = v10;
          if ( !sk_push(v3[1], (__int64)v9) )
          {
            sub_92BE8((void ***)v8);
LABEL_18:
            v11 = 0;
            goto LABEL_19;
          }
        }
        if ( !sk_push((unsigned __int64 *)v8[3], (__int64)v6[1]) )
          goto LABEL_18;
        v6[1] = 0LL;
LABEL_13:
        if ( ++v5 >= (unsigned __int64)sk_num(v4) )
        {
          v11 = 1;
          goto LABEL_19;
        }
      }
    }
    v11 = 1;
  }
  else
  {
LABEL_15:
    *(_QWORD *)(v2 + 64) |= 0x800uLL;
    v11 = -1;
  }
LABEL_19:
  sk_pop_free(v4, (void (*)(void))POLICY_MAPPING_free);
  return v11;
}

//----- (0000000000092E74) ----------------------------------------------------
void __fastcall X509_policy_tree_free(__int64 a1)
{
  __int64 v1; // x19
  __int64 *v2; // x22
  int v3; // w21
  unsigned __int64 *v4; // x0
  unsigned __int64 *v5; // x0

  v1 = a1;
  if ( a1 )
  {
    sk_free(*(void ***)(a1 + 24));
    sk_pop_free(*(unsigned __int64 **)(v1 + 32), (void (*)(void))sub_92F3C);
    if ( *(_DWORD *)(v1 + 8) >= 1 )
    {
      v2 = *(__int64 **)v1;
      v3 = 0;
      do
      {
        if ( *v2 )
          X509_free(*v2);
        v4 = (unsigned __int64 *)v2[1];
        if ( v4 )
          sk_pop_free(v4, (void (*)(void))j__free);
        if ( v2[2] )
          j__free();
        ++v3;
        v2 += 4;
      }
      while ( v3 < *(_DWORD *)(v1 + 8) );
    }
    v5 = *(unsigned __int64 **)(v1 + 16);
    if ( v5 )
      sk_pop_free(v5, (void (*)(void))sub_92BE8);
    free(*(void **)v1);
    free((void *)v1);
  }
}
// AD1FC: using guessed type __int64 j__free(void);

//----- (0000000000092F3C) ----------------------------------------------------
void __fastcall sub_92F3C(void *ptr)
{
  if ( *(_QWORD *)ptr )
  {
    if ( **(_BYTE **)ptr & 8 )
      free(ptr);
  }
}

//----- (0000000000092F54) ----------------------------------------------------
signed __int64 __fastcall X509_policy_check(__int64 *a1, _DWORD *a2, unsigned __int64 *a3, unsigned __int64 *a4, __int16 a5)
{
  unsigned __int64 *v5; // x23
  _DWORD *v6; // x19
  __int64 *v7; // x21
  __int16 v8; // w22
  unsigned __int64 *v9; // x25
  _QWORD *v10; // x0
  _QWORD *v11; // x24
  int v12; // w20
  int v13; // w27
  signed __int64 result; // x0
  signed int v15; // w28
  signed __int64 v16; // x22
  signed int v17; // w26
  unsigned __int64 *v18; // x21
  __int64 v19; // x0
  unsigned __int64 v20; // x8
  signed __int64 v21; // x9
  signed int v22; // w8
  bool v23; // zf
  _DWORD *v24; // x19
  void *v25; // x0
  __int64 v26; // x25
  __int64 v27; // x0
  _QWORD *v28; // x8
  _DWORD *v29; // x21
  int v30; // w19
  signed __int64 v31; // x24
  unsigned __int64 *v32; // x25
  _QWORD *v33; // x26
  signed __int64 v34; // x8
  signed __int64 v35; // x9
  int v36; // w8
  bool v37; // zf
  bool v38; // nf
  unsigned __int8 v39; // vf
  signed __int64 v40; // x9
  bool v41; // zf
  bool v42; // nf
  unsigned __int8 v43; // vf
  __int64 v44; // x22
  signed int v45; // w8
  bool v46; // zf
  __int64 v47; // x0
  int v48; // w8
  __int64 v49; // x24
  unsigned __int64 *v50; // x28
  int v51; // w10
  signed __int64 v52; // x23
  unsigned __int64 **v53; // x20
  unsigned __int64 v54; // x26
  unsigned __int64 *v55; // x25
  unsigned __int64 v56; // x27
  signed int v57; // w19
  __int64 *v58; // x21
  __int64 v59; // x2
  unsigned __int64 v60; // x26
  signed int *v61; // x0
  signed int *v62; // x27
  _QWORD *v63; // x19
  __int64 v64; // x8
  void ***v65; // x21
  int v66; // w9
  unsigned __int64 *v67; // x28
  unsigned __int64 v68; // x25
  unsigned __int64 *v69; // x21
  signed int v70; // w8
  __int64 v71; // x8
  void ***v72; // x21
  int v73; // w9
  __int64 v74; // x2
  unsigned __int64 *v75; // x24
  int v76; // w8
  signed __int64 v77; // x25
  unsigned __int64 *v78; // x0
  signed __int64 v79; // x20
  signed __int64 v80; // x19
  unsigned __int64 *v81; // x24
  int v82; // w8
  signed __int64 v83; // x25
  unsigned __int64 *v84; // x0
  __int64 v85; // x0
  __int64 v86; // x8
  signed __int64 v87; // x8
  __int64 v88; // x23
  __int64 *v89; // x20
  __int64 *v90; // x21
  unsigned __int64 *v91; // x0
  __int64 v92; // x26
  __int64 v93; // x19
  signed int v94; // w22
  __int64 v95; // x25
  unsigned __int64 v96; // x23
  unsigned __int64 *v97; // x24
  unsigned __int64 *v98; // x0
  __int64 v99; // x23
  signed int v100; // w20
  __int64 *v101; // x26
  unsigned __int64 v102; // x24
  unsigned __int64 *v103; // x0
  unsigned __int64 v104; // x24
  unsigned __int64 *v105; // x21
  void *v106; // x25
  _QWORD *v107; // x8
  __int64 v108; // x9
  unsigned __int64 *v109; // x0
  _QWORD *v110; // x0
  __int64 v111; // [xsp+8h] [xbp-88h]
  __int64 *v112; // [xsp+10h] [xbp-80h]
  unsigned __int64 *v113; // [xsp+18h] [xbp-78h]
  int v114; // [xsp+20h] [xbp-70h]
  int v115; // [xsp+20h] [xbp-70h]
  _DWORD *v116; // [xsp+28h] [xbp-68h]
  void **v117; // [xsp+30h] [xbp-60h]
  __int64 v118; // [xsp+38h] [xbp-58h]

  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = a5;
  v9 = a4;
  v118 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v117 = 0LL;
  *a1 = 0LL;
  *a2 = 0;
  v10 = sk_num(a3);
  v11 = v10;
  if ( v8 & 0x200 )
    v12 = 0;
  else
    v12 = (_DWORD)v10 + 1;
  if ( v8 & 0x400 )
    v13 = 0;
  else
    v13 = (_DWORD)v10 + 1;
  if ( (_DWORD)v10 != 1 )
  {
    if ( v8 & 0x100 )
      v15 = 0;
    else
      v15 = (_DWORD)v10 + 1;
    v112 = v7;
    v113 = v9;
    v114 = (_DWORD)v10 - 2;
    v116 = v6;
    if ( !(((_DWORD)v10 - 2) & 0x80000000) )
    {
      v16 = (signed int)v10 - 2 + 1LL;
      v17 = 1;
      while ( 1 )
      {
        v18 = sk_value(v5, --v16);
        X509_check_purpose((__int64)v18, -1);
        v19 = sub_92804((__int64)v18);
        if ( !v19 )
          goto LABEL_175;
        v20 = v18[8];
        if ( v20 & 0x800 )
        {
          v17 = -1;
        }
        else if ( v17 == 1 )
        {
          if ( *(_QWORD *)(v19 + 8) )
            v17 = 1;
          else
            v17 = 2;
          if ( v15 < 1 )
            goto LABEL_30;
LABEL_24:
          v21 = *(_QWORD *)(v19 + 24);
          v22 = (((unsigned int)v20 >> 5) & 1) + v15 - 1;
          if ( v21 < v22 )
            v23 = v21 == -1;
          else
            v23 = 1;
          if ( v23 )
            v15 = v22;
          else
            v15 = *(_QWORD *)(v19 + 24);
          goto LABEL_30;
        }
        if ( v15 >= 1 )
          goto LABEL_24;
LABEL_30:
        if ( v16 <= 0 )
        {
          if ( v17 == 1 )
            break;
          v44 = 0LL;
          if ( v15 )
            v46 = 0;
          else
            v46 = v17 == 2;
          if ( v46 )
            v45 = 6;
          else
            v45 = v17;
LABEL_75:
          result = 1LL;
          switch ( v45 + 1 )
          {
            case 0:
              result = 0xFFFFFFFFLL;
              goto LABEL_176;
            case 1:
              goto LABEL_175;
            case 2:
              if ( !v44 )
                goto LABEL_8;
              goto LABEL_83;
            case 3:
              goto LABEL_176;
            case 6:
              *v116 = 1;
              goto def_93254;
            case 7:
              *v116 = 1;
              goto LABEL_148;
            default:
def_93254:
              if ( !v44 )
                goto LABEL_173;
LABEL_83:
              v48 = *(_DWORD *)(v44 + 8);
              v49 = *(_QWORD *)v44;
              if ( v48 >= 2 )
              {
                v50 = v113;
                v51 = 1;
                while ( 1 )
                {
                  v115 = v51;
                  v52 = v49 + 32;
                  v53 = (unsigned __int64 **)sub_92804(*(_QWORD *)(v49 + 32));
                  if ( sk_num(v53[1]) )
                  {
                    v54 = 0LL;
                    do
                    {
                      v55 = sk_value(v53[1], v54);
                      if ( !sk_num(*(_QWORD **)(v49 + 8)) )
                        goto LABEL_204;
                      v56 = 0LL;
                      v57 = 0;
                      do
                      {
                        v58 = (__int64 *)sk_value(*(unsigned __int64 **)(v49 + 8), v56);
                        if ( (unsigned int)sub_AD200(v49, v58, v55[1]) )
                        {
                          if ( !sub_AD114(v49 + 32, (__int64)v55, (__int64)v58, 0LL) )
                            goto LABEL_173;
                          v57 = 1;
                        }
                        ++v56;
                      }
                      while ( v56 < (unsigned __int64)sk_num(*(_QWORD **)(v49 + 8)) );
                      if ( !v57 )
                      {
LABEL_204:
                        v59 = *(_QWORD *)(v49 + 16);
                        if ( v59 && !sub_AD114(v49 + 32, (__int64)v55, v59, 0LL) )
                          goto LABEL_173;
                      }
                      ++v54;
                    }
                    while ( v54 < (unsigned __int64)sk_num(v53[1]) );
                  }
                  if ( !(*(_BYTE *)(v49 + 57) & 2) )
                  {
                    if ( sk_num(*(_QWORD **)(v49 + 8)) )
                    {
                      v60 = 0LL;
                      while ( 1 )
                      {
                        v61 = (signed int *)sk_value(*(unsigned __int64 **)(v49 + 8), v60);
                        v62 = v61;
                        v63 = (_QWORD *)v61[4];
                        if ( *(_BYTE *)(v49 + 25) & 4 || (v64 = *(_QWORD *)v61, !(**(_BYTE **)v61 & 1)) )
                        {
                          if ( (_DWORD)v63 )
                            goto LABEL_122;
                          v65 = (void ***)sub_92C38(0LL, *(_QWORD *)(*(_QWORD *)v61 + 8LL), **(_DWORD **)v61 & 0x10);
                          if ( v65 )
                          {
                            v66 = *(_DWORD *)v65 | 4;
                            v65[2] = (void **)(*v53)[2];
                            *(_DWORD *)v65 = v66;
                            if ( sub_AD114(v49 + 32, (__int64)v65, (__int64)v62, v44) )
                              goto LABEL_122;
                            sub_92BE8(v65);
                          }
                          goto LABEL_173;
                        }
                        v67 = *(unsigned __int64 **)(v64 + 24);
                        if ( v63 != sk_num(*(_QWORD **)(v64 + 24)) )
                        {
                          if ( sk_num(v67) )
                            break;
                        }
LABEL_122:
                        if ( ++v60 >= (unsigned __int64)sk_num(*(_QWORD **)(v49 + 8)) )
                          goto LABEL_123;
                      }
                      v68 = 0LL;
                      while ( 2 )
                      {
                        v69 = sk_value(v67, v68);
                        if ( sub_AD084(v49 + 32, (__int64)v62, (__int64)v69) )
                        {
                          v70 = 4;
LABEL_118:
                          if ( ((v70 | 4) & 7) != 4 )
                          {
                            if ( !v70 )
                              goto LABEL_122;
LABEL_173:
                            v47 = v44;
                            goto LABEL_174;
                          }
                          if ( ++v68 >= (unsigned __int64)sk_num(v67) )
                            goto LABEL_122;
                          continue;
                        }
                        break;
                      }
                      v71 = *(_QWORD *)v62;
                      if ( !v69 )
                        v69 = *(unsigned __int64 **)(v71 + 8);
                      v72 = (void ***)sub_92C38(0LL, (__int64)v69, *(_DWORD *)v71 & 0x10);
                      if ( v72 )
                      {
                        v73 = *(_DWORD *)v72 | 4;
                        v72[2] = (void **)(*v53)[2];
                        *(_DWORD *)v72 = v73;
                        if ( sub_AD114(v49 + 32, (__int64)v72, (__int64)v62, v44) )
                        {
                          v70 = 0;
                          goto LABEL_118;
                        }
                        sub_92BE8(v72);
                      }
                      v70 = 1;
                      goto LABEL_118;
                    }
LABEL_123:
                    v74 = *(_QWORD *)(v49 + 16);
                    v50 = v113;
                    if ( v74 && !sub_AD114(v49 + 32, (__int64)*v53, v74, 0LL) )
                      goto LABEL_173;
                  }
                  if ( *(_BYTE *)(v49 + 57) & 4 )
                  {
                    v75 = *(unsigned __int64 **)(v49 + 40);
                    v76 = (int)((char *)sk_num(v75) - 1);
                    if ( !(v76 & 0x80000000) )
                    {
                      v77 = v76 + 1LL;
                      do
                      {
                        v78 = sk_value(v75, --v77);
                        if ( *(_BYTE *)*v78 & 3 )
                        {
                          --*(_DWORD *)(v78[1] + 16);
                          free(v78);
                          sk_delete(v75, v77);
                        }
                      }
                      while ( v77 > 0 );
                    }
                  }
                  v79 = v52;
                  do
                  {
                    v80 = v79;
                    v81 = *(unsigned __int64 **)(v79 - 24);
                    v82 = (int)((char *)sk_num(*(_QWORD **)(v79 - 24)) - 1);
                    if ( !(v82 & 0x80000000) )
                    {
                      v83 = v82;
                      do
                      {
                        v84 = sk_value(v81, v83);
                        if ( !*((_DWORD *)v84 + 4) )
                        {
                          --*(_DWORD *)(v84[1] + 16);
                          free(v84);
                          sk_delete(v81, v83);
                        }
                        v23 = v83 == 0;
                        v38 = v83-- < 0;
                      }
                      while ( !v38 && !v23 );
                    }
                    v85 = *(_QWORD *)(v79 - 16);
                    v79 -= 32LL;
                    if ( v85 && !*(_DWORD *)(v85 + 16) )
                    {
                      v86 = *(_QWORD *)(v85 + 8);
                      if ( v86 )
                      {
                        --*(_DWORD *)(v86 + 16);
                        v85 = *(_QWORD *)(v80 - 16);
                      }
                      free((void *)v85);
                      v85 = 0LL;
                      *(_QWORD *)(v80 - 16) = 0LL;
                    }
                  }
                  while ( v79 != *(_QWORD *)v44 );
                  if ( !v85 )
                  {
                    X509_policy_tree_free(v44);
                    result = *v116 == 0;
                    goto LABEL_176;
                  }
                  v48 = *(_DWORD *)(v44 + 8);
                  v51 = v115 + 1;
                  v49 = v52;
                  if ( v115 + 1 >= v48 )
                    goto LABEL_150;
                }
              }
              v50 = v113;
              v79 = *(_QWORD *)v44;
LABEL_150:
              v87 = v79 + 32LL * v48;
              v88 = *(_QWORD *)(v87 - 16);
              v89 = (__int64 *)(v44 + 24);
              v90 = (__int64 *)(v44 + 24);
              if ( !v88 )
                goto LABEL_157;
              if ( *v89 )
              {
                if ( (unsigned int)sk_find(*v89, 0LL, *(_QWORD *)(v87 - 16)) )
                  goto LABEL_156;
                v91 = (unsigned __int64 *)*v89;
              }
              else
              {
                v91 = sub_ACFE4();
                *v89 = (__int64)v91;
                if ( !v91 )
                  goto LABEL_173;
              }
              if ( !sk_push(v91, v88) )
                goto LABEL_173;
LABEL_156:
              v90 = (__int64 *)&v117;
LABEL_157:
              v92 = v44;
              if ( *(_DWORD *)(v44 + 8) >= 2 )
              {
                v93 = *(_QWORD *)v44;
                v94 = 1;
                while ( 1 )
                {
                  v95 = *(_QWORD *)(v93 + 16);
                  if ( !v95 )
                    goto LABEL_170;
                  if ( sk_num(*(_QWORD **)(v93 + 40)) )
                    break;
LABEL_169:
                  v93 += 32LL;
                  if ( ++v94 >= *(_DWORD *)(v92 + 8) )
                    goto LABEL_170;
                }
                v96 = 0LL;
                while ( 1 )
                {
                  v97 = sk_value(*(unsigned __int64 **)(v93 + 40), v96);
                  if ( v97[1] == v95 )
                  {
                    if ( *v90 )
                    {
                      if ( (unsigned int)sk_find(*v90, 0LL, (__int64)v97) )
                        goto LABEL_168;
                      v98 = (unsigned __int64 *)*v90;
                    }
                    else
                    {
                      v98 = sub_ACFE4();
                      *v90 = (__int64)v98;
                      if ( !v98 )
                        goto LABEL_172;
                    }
                    if ( !sk_push(v98, (__int64)v97) )
                    {
LABEL_172:
                      v44 = v92;
                      goto LABEL_173;
                    }
                  }
LABEL_168:
                  if ( ++v96 >= (unsigned __int64)sk_num(*(_QWORD **)(v93 + 40)) )
                    goto LABEL_169;
                }
              }
LABEL_170:
              if ( v90 == (__int64 *)&v117 )
              {
                v99 = (__int64)v117;
                v100 = 2;
              }
              else
              {
                v99 = *v89;
                v100 = 1;
                v117 = (void **)v99;
              }
              v44 = v92;
              if ( !sk_num(v50) )
                goto LABEL_196;
              v101 = *(__int64 **)(*(_QWORD *)v92 + 32LL * *(signed int *)(v92 + 8) - 16);
              if ( sk_num(v50) )
              {
                v102 = 0LL;
                while ( 1 )
                {
                  v103 = sk_value(v50, v102);
                  if ( (unsigned int)OBJ_obj2nid((unsigned int *)v103) == 746 )
                    break;
                  if ( ++v102 >= (unsigned __int64)sk_num(v50) )
                    goto LABEL_184;
                }
                *(_DWORD *)(v44 + 40) |= 2u;
                goto LABEL_196;
              }
LABEL_184:
              if ( !sk_num(v50) )
              {
LABEL_196:
                if ( v100 == 2 )
                  sk_free(v117);
                *v112 = v44;
                if ( *v116 )
                {
                  v110 = (_QWORD *)X509_policy_tree_get0_user_policies(v44);
                  if ( !sk_num(v110) )
                  {
LABEL_148:
                    result = 4294967294LL;
                    goto LABEL_176;
                  }
                }
                goto LABEL_8;
              }
              v104 = 0LL;
              break;
          }
          while ( 2 )
          {
            v105 = sk_value(v50, v104);
            v106 = sub_AD00C(v99, (__int64)v105);
            if ( v106 )
            {
LABEL_190:
              v109 = *(unsigned __int64 **)(v44 + 32);
              if ( !v109 )
              {
                v109 = sk_new_null();
                *(_QWORD *)(v44 + 32) = v109;
                if ( !v109 )
                  goto LABEL_196;
              }
              if ( !sk_push(v109, (__int64)v106) )
                goto LABEL_173;
            }
            else if ( v101 )
            {
              v107 = sub_92C38(0LL, (__int64)v105, *(_DWORD *)*v101 & 0x10);
              if ( !v107 )
                goto LABEL_173;
              v108 = *(_QWORD *)(*v101 + 16);
              *(_DWORD *)v107 = 12;
              v107[2] = v108;
              v106 = sub_AD114(0LL, (__int64)v107, v101[1], v44);
              goto LABEL_190;
            }
            if ( ++v104 >= (unsigned __int64)sk_num(v50) )
              goto LABEL_196;
            continue;
          }
        }
      }
    }
    v24 = malloc(0x30uLL);
    if ( v24 )
    {
      v24[10] = 0;
      v25 = malloc((_QWORD)v11 << 32 >> 27);
      v26 = (__int64)v25;
      *(_QWORD *)v24 = v25;
      v24[2] = 0;
      *((_QWORD *)v24 + 3) = 0LL;
      *((_QWORD *)v24 + 4) = 0LL;
      *((_QWORD *)v24 + 2) = 0LL;
      if ( v25 )
      {
        if ( (_QWORD)v11 << 32 >> 27 )
        {
          memset(v25, 0, (_QWORD)v11 << 32 >> 27);
          v26 = *(_QWORD *)v24;
        }
        v24[2] = (_DWORD)v11;
        OBJ_nid2obj(0x2EAu);
        v28 = sub_92C38(0LL, v27, 0);
        if ( v28 && sub_AD114(v26, (__int64)v28, 0LL, (__int64)v24) )
        {
          v111 = (__int64)v24;
          if ( v114 & 0x80000000 )
          {
LABEL_65:
            v44 = v111;
            if ( v15 )
              v45 = 1;
            else
              v45 = 5;
            goto LABEL_75;
          }
          v29 = (_DWORD *)(v26 + 56);
          v30 = 2 - (_DWORD)v11;
          v31 = v114 + 1LL;
          while ( 1 )
          {
            v32 = sk_value(v5, --v31);
            v33 = (_QWORD *)sub_92804((__int64)v32);
            X509_up_ref((__int64)v32);
            *((_QWORD *)v29 - 3) = v32;
            if ( !*v33 )
              *v29 |= 0x200u;
            v34 = v32[8] & 0x20;
            if ( v12 )
            {
              v35 = v33[2];
              v36 = v12 - (v34 == 0);
              if ( v35 < v36 )
              {
                v39 = __OFSUB__(v35, -1LL);
                v37 = v35 == -1;
                v38 = v35 + 1 < 0;
              }
              else
              {
                v39 = 0;
                v37 = 1;
                v38 = 0;
              }
              if ( (unsigned __int8)(v38 ^ v39) | v37 )
                v12 = v36;
              else
                v12 = v33[2];
              if ( v13 )
              {
LABEL_56:
                v40 = v33[4];
                if ( v40 < ((*((_DWORD *)v32 + 16) >> 5) & 1) + v13 - 1 )
                {
                  v43 = __OFSUB__(v40, -1LL);
                  v41 = v40 == -1;
                  v42 = v40 + 1 < 0;
                }
                else
                {
                  v43 = 0;
                  v41 = 1;
                  v42 = 0;
                }
                if ( (unsigned __int8)(v42 ^ v43) | v41 )
                  v13 = ((*((_DWORD *)v32 + 16) >> 5) & 1) + v13 - 1;
                else
                  v13 = v33[4];
                goto LABEL_64;
              }
            }
            else if ( v30 && v34 )
            {
              v12 = 0;
              if ( v13 )
                goto LABEL_56;
            }
            else
            {
              v12 = 0;
              *v29 |= 0x200u;
              if ( v13 )
                goto LABEL_56;
            }
            *v29 |= 0x400u;
LABEL_64:
            ++v30;
            v29 += 8;
            if ( v31 <= 0 )
              goto LABEL_65;
          }
        }
        v47 = (__int64)v24;
LABEL_174:
        X509_policy_tree_free(v47);
      }
      else
      {
        free(v24);
      }
    }
LABEL_175:
    result = 0LL;
    goto LABEL_176;
  }
LABEL_8:
  result = 1LL;
LABEL_176:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v118;
  return result;
}

//----- (0000000000093974) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_AUTHORITY_KEYID(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&AUTHORITY_KEYID_it);
}

//----- (0000000000093980) ----------------------------------------------------
void i2d_AUTHORITY_KEYID()
{
  ASN1_item_i2d();
}

//----- (000000000009398C) ----------------------------------------------------
__int64 AUTHORITY_KEYID_new()
{
  return ASN1_item_new((unsigned __int8 *)&AUTHORITY_KEYID_it);
}

//----- (0000000000093998) ----------------------------------------------------
void __fastcall AUTHORITY_KEYID_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&AUTHORITY_KEYID_it);
}

//----- (00000000000939A4) ----------------------------------------------------
signed __int64 __fastcall sub_939A4(__int64 a1, unsigned __int64 *a2, _QWORD *a3, unsigned int a4)
{
  unsigned __int64 *v4; // x21
  unsigned int v5; // w19
  _QWORD *v6; // x20
  unsigned __int64 v7; // x22
  __int64 *v8; // x27
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  unsigned __int64 *v17; // x1

  v4 = a2;
  v5 = a4;
  v6 = a3;
  if ( sk_num(a2) )
  {
    v7 = 0LL;
    do
    {
      v8 = (__int64 *)sk_value(v4, v7);
      BIO_printf(v6, (__int64)"%*sPolicy: ", v9, v10, v11, v12, v13, v14, v15, v16, v5, &unk_B8A4C);
      i2a_ASN1_OBJECT(v6, *v8);
      BIO_puts(v6, "\n");
      v17 = (unsigned __int64 *)v8[1];
      if ( v17 )
        sub_944E8(v6, v17, v5 + 2);
      ++v7;
    }
    while ( v7 < (unsigned __int64)sk_num(v4) );
  }
  return 1LL;
}

//----- (0000000000093A7C) ----------------------------------------------------
unsigned __int64 *__fastcall sub_93A7C(__int64 a1, __int64 a2, const char *a3)
{
  const char *v3; // x20
  __int64 v4; // x28
  unsigned __int64 *v5; // x19
  unsigned __int64 *v6; // x0
  unsigned __int64 *v7; // x27
  signed int v8; // w20
  unsigned __int64 v9; // x24
  unsigned __int64 *v10; // x0
  __int64 *v11; // x21
  const char *v12; // x22
  unsigned __int64 *v13; // x25
  __int64 v14; // x22
  unsigned __int64 v15; // x26
  signed int v16; // w8
  unsigned __int64 *v17; // x21
  const char *v18; // x20
  unsigned __int64 *v19; // x23
  _QWORD *v20; // x20
  __int64 v21; // x0
  __int64 v22; // x25
  unsigned __int64 v23; // x21
  unsigned __int64 *v24; // x28
  const char *v25; // x23
  __int64 v26; // x27
  __int64 v27; // x0
  unsigned __int64 *v28; // x0
  unsigned __int64 *v29; // x23
  unsigned __int64 *v30; // x28
  unsigned __int64 v31; // x27
  unsigned __int64 *v32; // x0
  __int64 v33; // x0
  __int64 v34; // x20
  _DWORD *v35; // x20
  __int64 v36; // x0
  const char *v37; // x23
  int v38; // w0
  int v39; // w0
  _QWORD *v40; // x8
  unsigned __int64 *v41; // x0
  __int64 v42; // x0
  _QWORD *v43; // x23
  __int64 v44; // x0
  _DWORD *v45; // x20
  const char *v46; // x21
  int v47; // w0
  void **v48; // x0
  void **v49; // x23
  _QWORD *v50; // x0
  int v51; // w2
  __int16 v52; // w4
  int v53; // w2
  __int16 v54; // w4
  __int64 v55; // x7
  int v56; // w2
  __int16 v57; // w4
  int v58; // w2
  __int16 v59; // w4
  __int64 v60; // x7
  int v61; // w2
  __int16 v62; // w4
  __int64 v63; // x7
  int v64; // w2
  __int16 v65; // w4
  __int64 v66; // x7
  __int64 v68; // [xsp+0h] [xbp-90h]
  unsigned __int64 *v69; // [xsp+8h] [xbp-88h]
  signed int v70; // [xsp+14h] [xbp-7Ch]
  __int64 v71; // [xsp+18h] [xbp-78h]
  __int64 v72; // [xsp+20h] [xbp-70h]
  unsigned __int64 *v73; // [xsp+28h] [xbp-68h]
  unsigned __int64 *v74; // [xsp+30h] [xbp-60h]
  signed int v75; // [xsp+3Ch] [xbp-54h]

  v3 = a3;
  v4 = a2;
  v5 = sk_new_null();
  if ( !v5 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", 153);
    return v5;
  }
  v6 = X509V3_parse_list(v3);
  v7 = v6;
  if ( !v6 )
  {
    v51 = 20;
    v52 = 158;
    goto LABEL_76;
  }
  if ( !sk_num(v6) )
  {
LABEL_73:
    sk_pop_free(v7, (void (*)(void))X509V3_conf_free);
    return v5;
  }
  v8 = 0;
  v9 = 0LL;
  while ( 1 )
  {
    v10 = sk_value(v7, v9);
    v11 = (__int64 *)v10;
    if ( v10[2] || (v12 = (const char *)v10[1]) == 0LL )
    {
      v53 = 131;
      v54 = 165;
      goto LABEL_78;
    }
    if ( (unsigned int)strcmp((const char *)v10[1], "ia5org") )
      break;
    v8 = 1;
LABEL_72:
    if ( ++v9 >= (unsigned __int64)sk_num(v7) )
      goto LABEL_73;
  }
  if ( *v12 != 64 )
  {
    OBJ_txt2obj(v12, 0);
    v49 = v48;
    if ( v48 )
    {
      v50 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&POLICYINFO_it);
      v14 = (__int64)v50;
      if ( !v50 )
      {
        ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", 194);
        ASN1_OBJECT_free(v49);
        goto LABEL_108;
      }
      *v50 = v49;
LABEL_71:
      if ( sk_push(v5, v14) )
        goto LABEL_72;
      ASN1_item_free(v14, (unsigned __int8 *)&POLICYINFO_it);
      v51 = 65;
      v52 = 202;
LABEL_76:
      ERR_put_error(20, 0LL, v51, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", v52);
      goto LABEL_108;
    }
    v53 = 129;
    v54 = 188;
LABEL_78:
    ERR_put_error(20, 0LL, v53, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", v54);
    ERR_add_error_data(6u, (__int64)"section:", *v11, (__int64)",name:", v11[1], (__int64)",value:", v11[2], v55, v68);
    goto LABEL_108;
  }
  v13 = (unsigned __int64 *)X509V3_get_section(v4);
  if ( !v13 )
  {
    v53 = 134;
    v54 = 177;
    goto LABEL_78;
  }
  v14 = ASN1_item_new((unsigned __int8 *)&POLICYINFO_it);
  if ( !v14 )
  {
LABEL_82:
    v58 = 65;
    v59 = 291;
LABEL_83:
    ERR_put_error(20, 0LL, v58, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", v59);
    goto LABEL_107;
  }
  v75 = v8;
  if ( !sk_num(v13) )
  {
LABEL_65:
    if ( !*(_QWORD *)v14 )
    {
      v58 = 142;
      v59 = 284;
      goto LABEL_83;
    }
    X509V3_section_free(v4, (__int64)v13);
    v8 = v75;
    goto LABEL_71;
  }
  v15 = 0LL;
  v73 = v13;
  if ( v8 )
    v16 = 22;
  else
    v16 = 26;
  v70 = v16;
  while ( 1 )
  {
    v17 = sk_value(v13, v15);
    v18 = (const char *)v17[1];
    if ( !(unsigned int)strcmp((const char *)v17[1], "policyIdentifier") )
    {
      OBJ_txt2obj((const char *)v17[2], 0);
      if ( v42 )
      {
        *(_QWORD *)v14 = v42;
        goto LABEL_64;
      }
      v61 = 129;
      v62 = 228;
LABEL_94:
      ERR_put_error(20, 0LL, v61, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", v62);
      ERR_add_error_data(6u, (__int64)"section:", *v17, (__int64)",name:", v17[1], (__int64)",value:", v17[2], v63, v68);
      goto LABEL_107;
    }
    if ( (unsigned int)sub_9A0D4(v18, "CPS") )
      break;
    if ( !*(_QWORD *)(v14 + 8) )
      *(_QWORD *)(v14 + 8) = sk_new_null();
    v43 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&POLICYQUALINFO_it);
    if ( !v43 || !sk_push(*(unsigned __int64 **)(v14 + 8), (__int64)v43) )
      goto LABEL_82;
    OBJ_nid2obj(0xA4u);
    *v43 = v44;
    if ( !v44 )
    {
      v58 = 68;
      v59 = 244;
      goto LABEL_83;
    }
    v45 = ASN1_STRING_type_new(22);
    v43[1] = v45;
    if ( !v45 )
      goto LABEL_107;
    v46 = (const char *)v17[2];
    v47 = strlen(v46);
    if ( !(unsigned int)ASN1_STRING_set((__int64)v45, v46, v47) )
      goto LABEL_82;
LABEL_64:
    if ( ++v15 >= (unsigned __int64)sk_num(v13) )
      goto LABEL_65;
  }
  if ( (unsigned int)sub_9A0D4((const char *)v17[1], "userNotice") )
  {
    v61 = 130;
    v62 = 277;
    goto LABEL_94;
  }
  if ( *(_BYTE *)v17[2] != 64 )
  {
    v61 = 111;
    v62 = 257;
    goto LABEL_94;
  }
  v19 = (unsigned __int64 *)X509V3_get_section(v4);
  if ( !v19 )
  {
    v61 = 134;
    v62 = 263;
    goto LABEL_94;
  }
  v20 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&POLICYQUALINFO_it);
  if ( !v20 )
    goto LABEL_104;
  OBJ_nid2obj(0xA5u);
  *v20 = v21;
  if ( !v21 )
  {
    v64 = 68;
    v65 = 312;
    goto LABEL_105;
  }
  v22 = ASN1_item_new((unsigned __int8 *)&USERNOTICE_it);
  if ( !v22 )
  {
    v13 = v73;
    goto LABEL_104;
  }
  v71 = (__int64)v20;
  v72 = v4;
  v20[1] = v22;
  if ( !sk_num(v19) )
  {
LABEL_48:
    v40 = *(_QWORD **)v22;
    if ( *(_QWORD *)v22 && (!v40[1] || !*v40) )
    {
      ERR_put_error(20, 0LL, 138, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", 370);
      v4 = v72;
      v13 = v73;
      v20 = (_QWORD *)v71;
      goto LABEL_106;
    }
    v4 = v72;
    X509V3_section_free(v72, (__int64)v19);
    v41 = *(unsigned __int64 **)(v14 + 8);
    if ( !v41 )
    {
      v41 = sk_new_null();
      *(_QWORD *)(v14 + 8) = v41;
    }
    v13 = v73;
    if ( !sk_push(v41, v71) )
      goto LABEL_82;
    goto LABEL_64;
  }
  v23 = 0LL;
  v69 = v7;
  v74 = v19;
  while ( 1 )
  {
    v24 = sk_value(v19, v23);
    v25 = (const char *)v24[1];
    if ( !(unsigned int)strcmp((const char *)v24[1], "explicitText") )
    {
      v35 = ASN1_STRING_type_new(26);
      *(_QWORD *)(v22 + 8) = v35;
      if ( !v35 )
        goto LABEL_103;
LABEL_46:
      v37 = (const char *)v24[2];
      v38 = strlen((const char *)v24[2]);
      v39 = ASN1_STRING_set((__int64)v35, v37, v38);
      v19 = v74;
      if ( !v39 )
      {
        v4 = v72;
        v13 = v73;
        v20 = (_QWORD *)v71;
        goto LABEL_104;
      }
      goto LABEL_47;
    }
    if ( !(unsigned int)strcmp(v25, "organization") )
    {
      v36 = *(_QWORD *)v22;
      if ( !*(_QWORD *)v22 )
      {
        v36 = ASN1_item_new((unsigned __int8 *)&NOTICEREF_it);
        if ( !v36 )
          goto LABEL_103;
        *(_QWORD *)v22 = v36;
      }
      *(_DWORD *)(*(_QWORD *)v36 + 4LL) = v70;
      v35 = *(_DWORD **)v36;
      goto LABEL_46;
    }
    if ( (unsigned int)strcmp(v25, "noticeNumbers") )
    {
      ERR_put_error(20, 0LL, 130, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", 362);
      ERR_add_error_data(6u, (__int64)"section:", *v24, (__int64)",name:", v24[1], (__int64)",value:", v24[2], v66, v68);
      goto LABEL_98;
    }
    v26 = *(_QWORD *)v22;
    if ( *(_QWORD *)v22 )
      goto LABEL_32;
    v27 = ASN1_item_new((unsigned __int8 *)&NOTICEREF_it);
    v26 = v27;
    if ( !v27 )
      break;
    *(_QWORD *)v22 = v27;
LABEL_32:
    v28 = X509V3_parse_list((const char *)v24[2]);
    v29 = v28;
    if ( !v28 || !sk_num(v28) )
    {
      ERR_put_error(20, 0LL, 128, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", 353);
      ERR_add_error_data(6u, (__int64)"section:", *v24, (__int64)",name:", v24[1], (__int64)",value:", v24[2], v60, v68);
      v7 = v69;
LABEL_98:
      v4 = v72;
      v13 = v73;
      v20 = (_QWORD *)v71;
      v19 = v74;
      goto LABEL_106;
    }
    v30 = *(unsigned __int64 **)(v26 + 8);
    if ( sk_num(v29) )
    {
      v31 = 0LL;
      while ( 1 )
      {
        v32 = sk_value(v29, v31);
        s2i_ASN1_INTEGER(0LL, (unsigned __int8 *)v32[1]);
        v34 = v33;
        if ( !v33 )
        {
          v56 = 127;
          v57 = 394;
          goto LABEL_81;
        }
        if ( !sk_push(v30, v33) )
          break;
        if ( ++v31 >= (unsigned __int64)sk_num(v29) )
          goto LABEL_39;
      }
      ASN1_VISIBLESTRING_free(v34);
      v56 = 65;
      v57 = 404;
LABEL_81:
      ERR_put_error(20, 0LL, v56, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", v57);
      v7 = v69;
      v4 = v72;
      v13 = v73;
      v20 = (_QWORD *)v71;
      sk_pop_free(v29, (void (*)(void))X509V3_conf_free);
      v19 = v74;
      goto LABEL_106;
    }
LABEL_39:
    sk_pop_free(v29, (void (*)(void))X509V3_conf_free);
    v7 = v69;
    v19 = v74;
LABEL_47:
    if ( ++v23 >= (unsigned __int64)sk_num(v19) )
      goto LABEL_48;
  }
  v7 = v69;
LABEL_103:
  v4 = v72;
  v13 = v73;
  v20 = (_QWORD *)v71;
  v19 = v74;
LABEL_104:
  v64 = 65;
  v65 = 377;
LABEL_105:
  ERR_put_error(20, 0LL, v64, (__int64)"external/boringssl/src/crypto/x509v3/v3_cpols.c", v65);
LABEL_106:
  ASN1_item_free((__int64)v20, (unsigned __int8 *)&POLICYQUALINFO_it);
  X509V3_section_free(v4, (__int64)v19);
LABEL_107:
  ASN1_item_free(v14, (unsigned __int8 *)&POLICYINFO_it);
  X509V3_section_free(v4, (__int64)v13);
LABEL_108:
  sk_pop_free(v7, (void (*)(void))X509V3_conf_free);
  sk_pop_free(v5, (void (*)(void))POLICYINFO_free);
  return 0LL;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (0000000000094328) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_CERTIFICATEPOLICIES(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&CERTIFICATEPOLICIES_it);
}

//----- (0000000000094334) ----------------------------------------------------
void i2d_CERTIFICATEPOLICIES()
{
  ASN1_item_i2d();
}

//----- (0000000000094340) ----------------------------------------------------
__int64 CERTIFICATEPOLICIES_new()
{
  return ASN1_item_new((unsigned __int8 *)&CERTIFICATEPOLICIES_it);
}

//----- (000000000009434C) ----------------------------------------------------
void __fastcall CERTIFICATEPOLICIES_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&CERTIFICATEPOLICIES_it);
}

//----- (0000000000094358) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_POLICYINFO(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&POLICYINFO_it);
}

//----- (0000000000094364) ----------------------------------------------------
void i2d_POLICYINFO()
{
  ASN1_item_i2d();
}

//----- (0000000000094370) ----------------------------------------------------
__int64 POLICYINFO_new()
{
  return ASN1_item_new((unsigned __int8 *)&POLICYINFO_it);
}

//----- (000000000009437C) ----------------------------------------------------
void __fastcall POLICYINFO_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&POLICYINFO_it);
}

//----- (0000000000094388) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_POLICYQUALINFO(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&POLICYQUALINFO_it);
}

//----- (0000000000094394) ----------------------------------------------------
void i2d_POLICYQUALINFO()
{
  ASN1_item_i2d();
}

//----- (00000000000943A0) ----------------------------------------------------
__int64 POLICYQUALINFO_new()
{
  return ASN1_item_new((unsigned __int8 *)&POLICYQUALINFO_it);
}

//----- (00000000000943AC) ----------------------------------------------------
void __fastcall POLICYQUALINFO_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&POLICYQUALINFO_it);
}

//----- (00000000000943B8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_USERNOTICE(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&USERNOTICE_it);
}

//----- (00000000000943C4) ----------------------------------------------------
void i2d_USERNOTICE()
{
  ASN1_item_i2d();
}

//----- (00000000000943D0) ----------------------------------------------------
__int64 USERNOTICE_new()
{
  return ASN1_item_new((unsigned __int8 *)&USERNOTICE_it);
}

//----- (00000000000943DC) ----------------------------------------------------
void __fastcall USERNOTICE_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&USERNOTICE_it);
}

//----- (00000000000943E8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_NOTICEREF(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&NOTICEREF_it);
}

//----- (00000000000943F4) ----------------------------------------------------
void i2d_NOTICEREF()
{
  ASN1_item_i2d();
}

//----- (0000000000094400) ----------------------------------------------------
__int64 NOTICEREF_new()
{
  return ASN1_item_new((unsigned __int8 *)&NOTICEREF_it);
}

//----- (000000000009440C) ----------------------------------------------------
void __fastcall NOTICEREF_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&NOTICEREF_it);
}

//----- (0000000000094418) ----------------------------------------------------
void __fastcall X509_POLICY_NODE_print(_QWORD *a1, __int64 *a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // x22
  int v12; // w20
  _QWORD *v13; // x19
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  unsigned int v22; // w20
  const char *v23; // x4
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  unsigned __int64 *v32; // x1

  v11 = *a2;
  v12 = a3;
  v13 = a1;
  BIO_printf(a1, (__int64)"%*sPolicy: ", a4, a5, a6, a7, a8, a9, a10, a11);
  i2a_ASN1_OBJECT(v13, *(_QWORD *)(v11 + 8));
  BIO_puts(v13, "\n");
  v22 = v12 + 2;
  if ( *(_DWORD *)v11 & 0x10 )
    v23 = "Critical";
  else
    v23 = "Non Critical";
  BIO_printf(v13, (__int64)"%*s%s\n", v14, v15, v16, v17, v18, v19, v20, v21, v22, &unk_B8A4C, v23);
  v32 = *(unsigned __int64 **)(v11 + 16);
  if ( v32 )
    sub_944E8(v13, v32, v22);
  else
    BIO_printf(v13, (__int64)"%*sNo Qualifiers\n", v24, v25, v26, v27, v28, v29, v30, v31, v22, &unk_B8A4C);
}

//----- (00000000000944E8) ----------------------------------------------------
_QWORD *__fastcall sub_944E8(_QWORD *a1, unsigned __int64 *a2, unsigned int a3)
{
  unsigned __int64 *v3; // x20
  _QWORD *v4; // x21
  _QWORD *result; // x0
  unsigned __int64 v6; // x22
  unsigned int v7; // w23
  unsigned __int64 *v8; // x0
  __int64 *v9; // x24
  int v10; // w0
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  __int64 v19; // x2
  _QWORD *v20; // x0
  __int64 v21; // x4
  const char *v22; // x1
  __int64 v23; // x27
  unsigned __int64 **v24; // x19
  double v25; // d0
  double v26; // d1
  double v27; // d2
  double v28; // d3
  double v29; // d4
  double v30; // d5
  double v31; // d6
  double v32; // d7
  const char *v33; // x4
  unsigned __int64 v34; // x24
  unsigned __int64 *v35; // x26
  char *v36; // x26
  __int64 v37; // x8
  unsigned int v38; // [xsp+Ch] [xbp-54h]

  v3 = a2;
  v4 = a1;
  v38 = a3;
  result = sk_num(a2);
  if ( result )
  {
    v6 = 0LL;
    v7 = v38 + 2;
    do
    {
      v8 = sk_value(v3, v6);
      v9 = (__int64 *)v8;
      v10 = (unsigned __int64)OBJ_obj2nid((unsigned int *)*v8);
      if ( v10 == 165 )
      {
        BIO_printf(v4, (__int64)"%*sUser Notice:\n", v11, v12, v13, v14, v15, v16, v17, v18, v38, &unk_B8A4C);
        v23 = v9[1];
        v24 = *(unsigned __int64 ***)v23;
        if ( *(_QWORD *)v23 )
        {
          BIO_printf(
            v4,
            (__int64)"%*sOrganization: %s\n",
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v7,
            &unk_B8A4C,
            (*v24)[1]);
          if ( (unsigned __int64)sk_num(v24[1]) <= 1 )
            v33 = (const char *)&unk_B8A4C;
          else
            v33 = "s";
          BIO_printf(v4, (__int64)"%*sNumber%s: ", v25, v26, v27, v28, v29, v30, v31, v32, v7, &unk_B8A4C, v33);
          if ( sk_num(v24[1]) )
          {
            v34 = 0LL;
            do
            {
              v35 = sk_value(v24[1], v34);
              if ( v34 )
                BIO_puts(v4, ", ");
              if ( v35 )
              {
                v36 = (char *)i2s_ASN1_INTEGER(0LL, (unsigned __int8 **)v35);
                if ( !v36 )
                  goto LABEL_24;
                BIO_puts(v4, v36);
                free(v36);
              }
              else
              {
                BIO_puts(v4, "(null)");
              }
              ++v34;
            }
            while ( v34 < (unsigned __int64)sk_num(v24[1]) );
          }
          BIO_puts(v4, "\n");
        }
        v37 = *(_QWORD *)(v23 + 8);
        if ( !v37 )
          goto LABEL_24;
        v21 = *(_QWORD *)(v37 + 8);
        v20 = v4;
        v22 = "%*sExplicit Text: %s\n";
        v19 = v7;
      }
      else
      {
        if ( v10 != 164 )
        {
          BIO_printf(v4, (__int64)"%*sUnknown Qualifier: ", v11, v12, v13, v14, v15, v16, v17, v18, v7, &unk_B8A4C);
          i2a_ASN1_OBJECT(v4, *v9);
          BIO_puts(v4, "\n");
          goto LABEL_24;
        }
        v19 = v38;
        v20 = v4;
        v21 = *(_QWORD *)(v9[1] + 8);
        v22 = "%*sCPS: %s\n";
      }
      BIO_printf(v20, (__int64)v22, v11, v12, v13, v14, v15, v16, v17, v18, v19, &unk_B8A4C, v21);
LABEL_24:
      ++v6;
      result = sk_num(v3);
    }
    while ( v6 < (unsigned __int64)result );
  }
  return result;
}

//----- (0000000000094718) ----------------------------------------------------
unsigned __int64 *__fastcall sub_94718(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x21
  __int64 v4; // x20
  __int64 v5; // x22
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x23
  unsigned __int64 *v8; // x0
  _QWORD *v9; // x24
  unsigned __int64 *v10; // x0
  __int64 v11; // x27
  __int64 v12; // x0
  unsigned __int64 v13; // x1
  unsigned __int64 *v14; // x28
  __int64 v15; // x27
  unsigned __int64 v16; // x24
  unsigned __int64 *v17; // x0
  unsigned __int64 *v18; // x25
  int v19; // w0
  const char *v20; // x22
  unsigned __int64 *v21; // x0
  __int64 v23; // [xsp+8h] [xbp-58h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sk_new_null();
  if ( !v6 )
    goto LABEL_35;
  if ( !sk_num(v3) )
    return v6;
  v7 = 0LL;
  v23 = v5;
  while ( 1 )
  {
    v8 = sk_value(v3, v7);
    if ( !v8[2] )
      break;
    v9 = (_QWORD *)v2i_GENERAL_NAME(v5, v4, (__int64)v8);
    if ( !v9 )
    {
      v11 = 0LL;
      goto LABEL_38;
    }
    v10 = (unsigned __int64 *)GENERAL_NAMES_new();
    v11 = (__int64)v10;
    if ( !v10 )
      goto LABEL_37;
    if ( !sk_push(v10, (__int64)v9) )
      goto LABEL_37;
    v9 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&DIST_POINT_it);
    if ( !v9 )
      goto LABEL_37;
    if ( !sk_push(v6, (__int64)v9) )
    {
      ASN1_item_free((__int64)v9, (unsigned __int8 *)&DIST_POINT_it);
LABEL_36:
      v9 = 0LL;
LABEL_37:
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_crld.c", 336);
      goto LABEL_38;
    }
    v12 = ASN1_item_new((unsigned __int8 *)&DIST_POINT_NAME_it);
    *v9 = v12;
    if ( !v12 )
      goto LABEL_36;
    *(_QWORD *)(v12 + 8) = v11;
    *(_DWORD *)*v9 = 0;
LABEL_27:
    if ( ++v7 >= (unsigned __int64)sk_num(v3) )
      return v6;
  }
  v13 = v8[1];
  v14 = (unsigned __int64 *)X509V3_get_section(v4);
  if ( !v14 )
    goto LABEL_31;
  v15 = ASN1_item_new((unsigned __int8 *)&DIST_POINT_it);
  if ( !v15 )
    goto LABEL_30;
  if ( !sk_num(v14) )
  {
LABEL_26:
    X509V3_section_free(v4, (__int64)v14);
    v5 = v23;
    if ( sk_push(v6, v15) )
      goto LABEL_27;
    ASN1_item_free(v15, (unsigned __int8 *)&DIST_POINT_it);
LABEL_35:
    v11 = 0LL;
    goto LABEL_36;
  }
  v16 = 0LL;
  while ( 1 )
  {
    v17 = sk_value(v14, v16);
    v18 = v17;
    v19 = sub_94FBC(v15, v4, (__int64)v17);
    if ( v19 > 0 )
      goto LABEL_17;
    if ( v19 & 0x80000000 )
      goto LABEL_29;
    v20 = (const char *)v18[1];
    if ( (unsigned int)strcmp((const char *)v18[1], "reasons") )
      break;
    if ( !(unsigned int)sub_951A0((signed int **)(v15 + 8), (const char *)v18[2]) )
      goto LABEL_29;
LABEL_17:
    if ( ++v16 >= (unsigned __int64)sk_num(v14) )
      goto LABEL_26;
  }
  if ( (unsigned int)strcmp(v20, "CRLissuer") )
    goto LABEL_17;
  v21 = sub_953B8(v4, (const char *)v18[2]);
  *(_QWORD *)(v15 + 16) = v21;
  if ( v21 )
    goto LABEL_17;
LABEL_29:
  ASN1_item_free(v15, (unsigned __int8 *)&DIST_POINT_it);
LABEL_30:
  X509V3_section_free(v4, (__int64)v14);
LABEL_31:
  v11 = 0LL;
  v9 = 0LL;
LABEL_38:
  GENERAL_NAME_free((__int64)v9);
  GENERAL_NAMES_free(v11);
  sk_pop_free(v6, (void (*)(void))DIST_POINT_free);
  return 0LL;
}

//----- (00000000000949DC) ----------------------------------------------------
signed __int64 __fastcall sub_949DC(__int64 a1, unsigned __int64 *a2, _QWORD *a3, unsigned int a4)
{
  unsigned __int64 *v4; // x21
  unsigned int v5; // w19
  _QWORD *v6; // x20
  unsigned __int64 v7; // x22
  unsigned __int64 *v8; // x27
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  __int64 v17; // x2

  v4 = a2;
  v5 = a4;
  v6 = a3;
  if ( sk_num(a2) )
  {
    v7 = 0LL;
    do
    {
      BIO_puts(v6, "\n");
      v8 = sk_value(v4, v7);
      if ( *v8 )
        sub_954BC(v6, *v8, v5, v9, v10, v11, v12, v13, v14, v15, v16);
      v17 = v8[1];
      if ( v17 )
        sub_955A0(v6, (__int64)"Reasons", v17, v5, v9, v10, v11, v12, v13, v14, v15, v16);
      if ( v8[2] )
      {
        BIO_printf(v6, (__int64)"%*sCRL Issuer:\n", v9, v10, v11, v12, v13, v14, v15, v16, v5, &unk_B8A4C);
        sub_95668(v6, (unsigned __int64 *)v8[2], v5);
      }
      ++v7;
    }
    while ( v7 < (unsigned __int64)sk_num(v4) );
  }
  return 1LL;
}

//----- (0000000000094ADC) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_DIST_POINT_NAME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&DIST_POINT_NAME_it);
}

//----- (0000000000094AE8) ----------------------------------------------------
void i2d_DIST_POINT_NAME()
{
  ASN1_item_i2d();
}

//----- (0000000000094AF4) ----------------------------------------------------
__int64 DIST_POINT_NAME_new()
{
  return ASN1_item_new((unsigned __int8 *)&DIST_POINT_NAME_it);
}

//----- (0000000000094B00) ----------------------------------------------------
void __fastcall DIST_POINT_NAME_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&DIST_POINT_NAME_it);
}

//----- (0000000000094B0C) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_DIST_POINT(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&DIST_POINT_it);
}

//----- (0000000000094B18) ----------------------------------------------------
void i2d_DIST_POINT()
{
  ASN1_item_i2d();
}

//----- (0000000000094B24) ----------------------------------------------------
__int64 DIST_POINT_new()
{
  return ASN1_item_new((unsigned __int8 *)&DIST_POINT_it);
}

//----- (0000000000094B30) ----------------------------------------------------
void __fastcall DIST_POINT_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&DIST_POINT_it);
}

//----- (0000000000094B3C) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_CRL_DIST_POINTS(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&CRL_DIST_POINTS_it);
}

//----- (0000000000094B48) ----------------------------------------------------
void i2d_CRL_DIST_POINTS()
{
  ASN1_item_i2d();
}

//----- (0000000000094B54) ----------------------------------------------------
__int64 CRL_DIST_POINTS_new()
{
  return ASN1_item_new((unsigned __int8 *)&CRL_DIST_POINTS_it);
}

//----- (0000000000094B60) ----------------------------------------------------
void __fastcall CRL_DIST_POINTS_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&CRL_DIST_POINTS_it);
}

//----- (0000000000094B6C) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ISSUING_DIST_POINT(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ISSUING_DIST_POINT_it);
}

//----- (0000000000094B78) ----------------------------------------------------
void i2d_ISSUING_DIST_POINT()
{
  ASN1_item_i2d();
}

//----- (0000000000094B84) ----------------------------------------------------
__int64 ISSUING_DIST_POINT_new()
{
  return ASN1_item_new((unsigned __int8 *)&ISSUING_DIST_POINT_it);
}

//----- (0000000000094B90) ----------------------------------------------------
void __fastcall ISSUING_DIST_POINT_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&ISSUING_DIST_POINT_it);
}

//----- (0000000000094B9C) ----------------------------------------------------
__int64 __fastcall sub_94B9C(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x21
  __int64 v5; // x19
  unsigned __int64 v6; // x22
  unsigned __int64 *v7; // x0
  __int64 *v8; // x25
  const char *v9; // x24
  const char *v10; // x27
  int v11; // w0
  _DWORD *v12; // x1
  __int64 v14; // x7

  v3 = a3;
  v4 = a2;
  v5 = ASN1_item_new((unsigned __int8 *)&ISSUING_DIST_POINT_it);
  if ( !v5 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_crld.c", 458);
    goto LABEL_22;
  }
  if ( sk_num(v3) )
  {
    v6 = 0LL;
    do
    {
      v7 = sk_value(v3, v6);
      v8 = (__int64 *)v7;
      v9 = (const char *)v7[1];
      v10 = (const char *)v7[2];
      v11 = sub_94FBC(v5, v4, (__int64)v7);
      if ( v11 <= 0 )
      {
        if ( v11 & 0x80000000 )
          goto LABEL_22;
        if ( (unsigned int)strcmp(v9, "onlyuser") )
        {
          if ( !(unsigned int)strcmp(v9, "onlyCA") )
          {
            v12 = (_DWORD *)(v5 + 12);
            goto LABEL_18;
          }
          if ( !(unsigned int)strcmp(v9, "onlyAA") )
          {
            v12 = (_DWORD *)(v5 + 28);
            goto LABEL_18;
          }
          if ( !(unsigned int)strcmp(v9, "indirectCRL") )
          {
            v12 = (_DWORD *)(v5 + 24);
LABEL_18:
            if ( !(unsigned int)X509V3_get_value_bool((__int64)v8, v12) )
              goto LABEL_22;
            goto LABEL_19;
          }
          if ( (unsigned int)strcmp(v9, "onlysomereasons") )
          {
            ERR_put_error(20, 0LL, 123, (__int64)"external/boringssl/src/crypto/x509v3/v3_crld.c", 450);
            ERR_add_error_data(
              6u,
              (__int64)"section:",
              *v8,
              (__int64)",name:",
              v8[1],
              (__int64)",value:",
              v8[2],
              v14,
              v5 + 24);
LABEL_22:
            ASN1_item_free(v5, (unsigned __int8 *)&ISSUING_DIST_POINT_it);
            return 0LL;
          }
          if ( !(unsigned int)sub_951A0((signed int **)(v5 + 16), v10) )
            goto LABEL_22;
        }
        else if ( !(unsigned int)X509V3_get_value_bool((__int64)v8, (_DWORD *)(v5 + 8)) )
        {
          goto LABEL_22;
        }
      }
LABEL_19:
      ++v6;
    }
    while ( v6 < (unsigned __int64)sk_num(v3) );
  }
  return v5;
}

//----- (0000000000094DA4) ----------------------------------------------------
signed __int64 __fastcall sub_94DA4(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 *a10, _QWORD *a11, unsigned int a12)
{
  __int64 *v12; // x21
  __int64 v13; // x1
  unsigned int v14; // w19
  _QWORD *v15; // x20
  __int64 v16; // x2

  v12 = a10;
  v13 = *a10;
  v14 = a12;
  v15 = a11;
  if ( v13 )
    sub_954BC(a11, v13, a12, a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *((_DWORD *)v12 + 2) >= 1 )
    BIO_printf(v15, (__int64)"%*sOnly User Certificates\n", a1, a2, a3, a4, a5, a6, a7, a8, v14, &unk_B8A4C);
  if ( *((_DWORD *)v12 + 3) >= 1 )
    BIO_printf(v15, (__int64)"%*sOnly CA Certificates\n", a1, a2, a3, a4, a5, a6, a7, a8, v14, &unk_B8A4C);
  if ( *((_DWORD *)v12 + 6) >= 1 )
    BIO_printf(v15, (__int64)"%*sIndirect CRL\n", a1, a2, a3, a4, a5, a6, a7, a8, v14, &unk_B8A4C);
  v16 = v12[2];
  if ( v16 )
    sub_955A0(v15, (__int64)"Only Some Reasons", v16, v14, a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *((_DWORD *)v12 + 7) >= 1 )
    BIO_printf(v15, (__int64)"%*sOnly Attribute Certificates\n", a1, a2, a3, a4, a5, a6, a7, a8, v14, &unk_B8A4C);
  if ( !*v12
    && *((_DWORD *)v12 + 2) <= 0
    && *((_DWORD *)v12 + 3) <= 0
    && *((_DWORD *)v12 + 6) <= 0
    && !v12[2]
    && *((_DWORD *)v12 + 7) <= 0 )
  {
    BIO_printf(v15, (__int64)"%*s<EMPTY>\n", a1, a2, a3, a4, a5, a6, a7, a8, v14, &unk_B8A4C);
  }
  return 1LL;
}

//----- (0000000000094F00) ----------------------------------------------------
void __fastcall DIST_POINT_set_dpname(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 *v3; // x20
  __int64 v4; // x0
  unsigned __int64 v5; // x21
  unsigned __int64 *v6; // x1
  __int64 v7; // x0
  int v8; // w0

  v2 = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 == 1 )
    {
      v3 = *(unsigned __int64 **)(a1 + 8);
      X509_NAME_dup(a2);
      *(_QWORD *)(v2 + 16) = v4;
      if ( v4 )
      {
        if ( sk_num(v3) )
        {
          v5 = 0LL;
          while ( 1 )
          {
            v6 = sk_value(v3, v5);
            if ( !(unsigned int)X509_NAME_add_entry(*(unsigned __int64 ***)(v2 + 16), (__int64)v6, -1, v5 == 0) )
              break;
            if ( ++v5 >= (unsigned __int64)sk_num(v3) )
              goto LABEL_8;
          }
        }
        else
        {
LABEL_8:
          v7 = *(_QWORD *)(v2 + 16);
          i2d_X509_NAME();
          if ( !(v8 & 0x80000000) )
            return;
        }
        X509_NAME_free(*(_QWORD *)(v2 + 16));
        *(_QWORD *)(v2 + 16) = 0LL;
      }
    }
  }
}

//----- (0000000000094FBC) ----------------------------------------------------
signed __int64 __fastcall sub_94FBC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x21
  const char *v4; // x22
  __int64 v5; // x20
  __int64 v6; // x19
  signed __int64 result; // x0
  unsigned __int64 *v8; // x21
  unsigned __int64 *v9; // x20
  unsigned __int64 **v10; // x22
  __int64 v11; // x1
  unsigned __int64 *v12; // x21
  int v13; // w23
  _QWORD *v14; // x0
  _DWORD *v15; // x0
  _DWORD *v16; // x8

  v3 = a3;
  v4 = *(const char **)(a3 + 8);
  v5 = a2;
  v6 = a1;
  if ( !(unsigned int)strncmp(v4, "fullname", 9uLL) )
  {
    v8 = sub_953B8(v5, *(const char **)(v3 + 16));
    if ( !v8 )
      return 0xFFFFFFFFLL;
    v9 = 0LL;
    if ( !*(_QWORD *)v6 )
      goto LABEL_22;
LABEL_6:
    ERR_put_error(20, 0LL, 106, (__int64)"external/boringssl/src/crypto/x509v3/v3_crld.c", 155);
    goto LABEL_7;
  }
  if ( (unsigned int)strcmp(v4, "relativename") )
    return 0LL;
  v10 = (unsigned __int64 **)X509_NAME_new();
  if ( !v10 )
    return 0xFFFFFFFFLL;
  v11 = *(_QWORD *)(v3 + 16);
  v12 = (unsigned __int64 *)X509V3_get_section(v5);
  if ( !v12 )
  {
    ERR_put_error(20, 0LL, 153, (__int64)"external/boringssl/src/crypto/x509v3/v3_crld.c", 133);
    return 0xFFFFFFFFLL;
  }
  v13 = X509V3_NAME_from_section(v10, v12, 4097);
  X509V3_section_free(v5, (__int64)v12);
  v9 = *v10;
  *v10 = 0LL;
  X509_NAME_free((__int64)v10);
  if ( !v13 || !sk_num(v9) )
  {
LABEL_16:
    if ( v9 )
LABEL_17:
      sk_pop_free(v9, (void (*)(void))X509_NAME_ENTRY_free);
    return 0xFFFFFFFFLL;
  }
  v14 = sk_num(v9);
  if ( *((_DWORD *)sk_value(v9, (unsigned __int64)v14 - 1) + 4) )
  {
    ERR_put_error(20, 0LL, 122, (__int64)"external/boringssl/src/crypto/x509v3/v3_crld.c", 148);
    goto LABEL_16;
  }
  v8 = 0LL;
  if ( *(_QWORD *)v6 )
    goto LABEL_6;
LABEL_22:
  v15 = (_DWORD *)ASN1_item_new((unsigned __int8 *)&DIST_POINT_NAME_it);
  v16 = v15;
  *(_QWORD *)v6 = v15;
  if ( !v15 )
  {
LABEL_7:
    if ( v8 )
    {
      sk_pop_free(v8, (void (*)(void))GENERAL_NAME_free);
      if ( !v9 )
        return 0xFFFFFFFFLL;
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if ( v8 )
  {
    *v15 = 0;
    result = 1LL;
    *(_QWORD *)(*(_QWORD *)v6 + 8LL) = v8;
  }
  else
  {
    result = 1LL;
    *v16 = 1;
    *(_QWORD *)(*(_QWORD *)v6 + 8LL) = v9;
  }
  return result;
}

//----- (00000000000951A0) ----------------------------------------------------
__int64 __fastcall sub_951A0(signed int **a1, const char *a2)
{
  signed int **v2; // x20
  unsigned __int64 *v3; // x0
  unsigned __int64 *v4; // x19
  unsigned int v5; // w20
  unsigned __int64 v6; // x21
  const char *v7; // x27
  signed int *v8; // x28
  int *v9; // x8
  char **v10; // x27

  v2 = a1;
  v3 = X509V3_parse_list(a2);
  v4 = v3;
  if ( v3 && !*v2 )
  {
    if ( sk_num(v3) )
    {
      v6 = 0LL;
      while ( 1 )
      {
        v7 = (const char *)sk_value(v4, v6)[1];
        v8 = *v2;
        if ( !*v2 )
        {
          v8 = ASN1_BIT_STRING_new();
          *v2 = v8;
          if ( !v8 )
            break;
        }
        if ( (unsigned int)strcmp("unused", v7) )
        {
          if ( (unsigned int)strcmp("keyCompromise", v7) )
          {
            if ( (unsigned int)strcmp("CACompromise", v7) )
            {
              if ( (unsigned int)strcmp("affiliationChanged", v7) )
              {
                if ( (unsigned int)strcmp("superseded", v7) )
                {
                  if ( (unsigned int)strcmp("cessationOfOperation", v7) )
                  {
                    if ( (unsigned int)strcmp("certificateHold", v7) )
                    {
                      if ( (unsigned int)strcmp("privilegeWithdrawn", v7) )
                      {
                        if ( (unsigned int)strcmp("AACompromise", v7) )
                          break;
                        v9 = &dword_102FD0;
                        v10 = off_102FD8;
                      }
                      else
                      {
                        v9 = &dword_102FB8;
                        v10 = off_102FC0;
                      }
                    }
                    else
                    {
                      v9 = &dword_102FA0;
                      v10 = off_102FA8;
                    }
                  }
                  else
                  {
                    v9 = &dword_102F88;
                    v10 = off_102F90;
                  }
                }
                else
                {
                  v9 = &dword_102F70;
                  v10 = off_102F78;
                }
              }
              else
              {
                v9 = &dword_102F58;
                v10 = off_102F60;
              }
            }
            else
            {
              v9 = &dword_102F40;
              v10 = off_102F48;
            }
          }
          else
          {
            v9 = &dword_102F28;
            v10 = off_102F30;
          }
        }
        else
        {
          v10 = off_102F18;
          v9 = &dword_102F10;
        }
        if ( !(unsigned int)ASN1_BIT_STRING_set_bit(v8, *v9, 1) || !*v10 )
          break;
        if ( ++v6 >= (unsigned __int64)sk_num(v4) )
          goto LABEL_29;
      }
      v5 = 0;
    }
    else
    {
LABEL_29:
      v5 = 1;
    }
    sk_pop_free(v4, (void (*)(void))X509V3_conf_free);
  }
  else
  {
    v5 = 0;
  }
  return v5;
}
// 102F10: using guessed type int dword_102F10;
// 102F18: using guessed type char *off_102F18[2];
// 102F28: using guessed type int dword_102F28;
// 102F30: using guessed type char *off_102F30[2];
// 102F40: using guessed type int dword_102F40;
// 102F48: using guessed type char *off_102F48[2];
// 102F58: using guessed type int dword_102F58;
// 102F60: using guessed type char *off_102F60[2];
// 102F70: using guessed type int dword_102F70;
// 102F78: using guessed type char *off_102F78[2];
// 102F88: using guessed type int dword_102F88;
// 102F90: using guessed type char *off_102F90[2];
// 102FA0: using guessed type int dword_102FA0;
// 102FA8: using guessed type char *off_102FA8[2];
// 102FB8: using guessed type int dword_102FB8;
// 102FC0: using guessed type char *off_102FC0[2];
// 102FD0: using guessed type int dword_102FD0;
// 102FD8: using guessed type char *off_102FD8[2];

//----- (00000000000953B8) ----------------------------------------------------
unsigned __int64 *__fastcall sub_953B8(__int64 a1, const char *a2)
{
  const char *v2; // x20
  __int64 v3; // x19
  unsigned __int64 *v4; // x21
  unsigned __int64 *v5; // x22

  v2 = a2;
  v3 = a1;
  if ( *a2 == 64 )
  {
    v4 = (unsigned __int64 *)X509V3_get_section(a1);
    if ( !v4 )
      goto LABEL_7;
  }
  else
  {
    v4 = X509V3_parse_list(a2);
    if ( !v4 )
    {
LABEL_7:
      ERR_put_error(20, 0LL, 153, (__int64)"external/boringssl/src/crypto/x509v3/v3_crld.c", 104);
      return 0LL;
    }
  }
  v5 = v2i_GENERAL_NAMES(0LL, v3, v4);
  if ( *v2 == 64 )
    X509V3_section_free(v3, (__int64)v4);
  else
    sk_pop_free(v4, (void (*)(void))X509V3_conf_free);
  return v5;
}

//----- (000000000009547C) ----------------------------------------------------
signed __int64 __fastcall sub_9547C(int a1, __int64 *a2)
{
  __int64 v2; // x8
  signed __int64 result; // x0
  __int64 v4; // x0

  v2 = *a2;
  if ( a1 == 3 )
  {
    v4 = *(_QWORD *)(v2 + 16);
    if ( v4 )
      X509_NAME_free(v4);
  }
  else if ( a1 == 1 )
  {
    result = 1LL;
    *(_QWORD *)(v2 + 16) = 0LL;
    return result;
  }
  return 1LL;
}

//----- (00000000000954BC) ----------------------------------------------------
__int64 __fastcall sub_954BC(_QWORD *a1, __int64 a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // x21
  int v12; // w20
  _QWORD *v13; // x19
  __int64 result; // x0
  __int64 v15; // [xsp+0h] [xbp-50h]
  __int64 v16; // [xsp+28h] [xbp-28h]

  v11 = a2;
  v12 = a3;
  v13 = a1;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *(_DWORD *)a2 )
  {
    v15 = *(_QWORD *)(a2 + 8);
    BIO_printf(
      a1,
      (__int64)"%*sRelative Name:\n%*s",
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11,
      a3,
      &unk_B8A4C,
      a3 + 2,
      &unk_B8A4C);
    X509_NAME_print_ex(v13, (unsigned __int64 **)&v15, 0, 8520479LL);
    result = BIO_puts(v13, "\n");
  }
  else
  {
    BIO_printf(a1, (__int64)"%*sFull Name:\n", a4, a5, a6, a7, a8, a9, a10, a11, a3, &unk_B8A4C);
    result = (__int64)sub_95668(v13, *(unsigned __int64 **)(v11 + 8), v12);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000955A0) ----------------------------------------------------
__int64 __fastcall sub_955A0(_QWORD *a1, __int64 a2, __int64 a3, unsigned int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v12; // x20
  _QWORD *v13; // x19
  signed int v14; // w23
  int *v15; // x22
  __int64 v16; // x8
  const char *v17; // x1

  v12 = a3;
  v13 = a1;
  BIO_printf(a1, (__int64)"%*s%s:\n%*s", a5, a6, a7, a8, a9, a10, a11, a12, a4, &unk_B8A4C, a2, a4 + 2, &unk_B8A4C);
  v14 = 1;
  v15 = &dword_102F10;
  do
  {
    if ( (unsigned int)ASN1_BIT_STRING_get_bit(v12, *v15) )
    {
      if ( !v14 )
        BIO_puts(v13, ", ");
      BIO_puts(v13, *((const char **)v15 + 1));
      v14 = 0;
    }
    v16 = *((_QWORD *)v15 + 4);
    v15 += 6;
  }
  while ( v16 );
  if ( v14 )
    v17 = "<EMPTY>\n";
  else
    v17 = "\n";
  return BIO_puts(v13, v17);
}
// 102F10: using guessed type int dword_102F10;

//----- (0000000000095668) ----------------------------------------------------
_QWORD *__fastcall sub_95668(_QWORD *a1, unsigned __int64 *a2, int a3)
{
  unsigned __int64 *v3; // x19
  _QWORD *v4; // x20
  int v5; // w22
  _QWORD *result; // x0
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  unsigned __int64 v15; // x21
  unsigned int v16; // w22
  unsigned __int64 *v17; // x0
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7

  v3 = a2;
  v4 = a1;
  v5 = a3;
  result = sk_num(a2);
  if ( result )
  {
    v15 = 0LL;
    v16 = v5 + 2;
    do
    {
      BIO_printf(v4, (__int64)"%*s", v7, v8, v9, v10, v11, v12, v13, v14, v16, &unk_B8A4C);
      v17 = sk_value(v3, v15);
      GENERAL_NAME_print(v4, (__int64)v17, v18, v19, v20, v21, v22, v23, v24, v25);
      BIO_puts(v4, "\n");
      ++v15;
      result = sk_num(v3);
    }
    while ( v15 < (unsigned __int64)result );
  }
  return result;
}

//----- (000000000009571C) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_OTHERNAME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&OTHERNAME_it);
}

//----- (0000000000095728) ----------------------------------------------------
void i2d_OTHERNAME()
{
  ASN1_item_i2d();
}

//----- (0000000000095734) ----------------------------------------------------
__int64 OTHERNAME_new()
{
  return ASN1_item_new((unsigned __int8 *)&OTHERNAME_it);
}

//----- (0000000000095740) ----------------------------------------------------
void __fastcall OTHERNAME_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&OTHERNAME_it);
}

//----- (000000000009574C) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_EDIPARTYNAME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&EDIPARTYNAME_it);
}

//----- (0000000000095758) ----------------------------------------------------
void i2d_EDIPARTYNAME()
{
  ASN1_item_i2d();
}

//----- (0000000000095764) ----------------------------------------------------
__int64 EDIPARTYNAME_new()
{
  return ASN1_item_new((unsigned __int8 *)&EDIPARTYNAME_it);
}

//----- (0000000000095770) ----------------------------------------------------
void __fastcall EDIPARTYNAME_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&EDIPARTYNAME_it);
}

//----- (000000000009577C) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_GENERAL_NAME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&GENERAL_NAME_it);
}

//----- (0000000000095788) ----------------------------------------------------
void i2d_GENERAL_NAME()
{
  ASN1_item_i2d();
}

//----- (0000000000095794) ----------------------------------------------------
__int64 GENERAL_NAME_new()
{
  return ASN1_item_new((unsigned __int8 *)&GENERAL_NAME_it);
}

//----- (00000000000957A0) ----------------------------------------------------
void __fastcall GENERAL_NAME_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&GENERAL_NAME_it);
}

//----- (00000000000957AC) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_GENERAL_NAMES(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&GENERAL_NAMES_it);
}

//----- (00000000000957B8) ----------------------------------------------------
void i2d_GENERAL_NAMES()
{
  ASN1_item_i2d();
}

//----- (00000000000957C4) ----------------------------------------------------
__int64 GENERAL_NAMES_new()
{
  return ASN1_item_new((unsigned __int8 *)&GENERAL_NAMES_it);
}

//----- (00000000000957D0) ----------------------------------------------------
void __fastcall GENERAL_NAMES_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&GENERAL_NAMES_it);
}

//----- (00000000000957DC) ----------------------------------------------------
void __fastcall GENERAL_NAME_dup(__int64 a1)
{
  ASN1_dup(
    (__int64 (__fastcall *)(__int64, void **))i2d_GENERAL_NAME,
    (void (__fastcall *)(_QWORD, void **, _QWORD))d2i_GENERAL_NAME,
    a1);
}

//----- (00000000000957FC) ----------------------------------------------------
__int64 __fastcall GENERAL_NAME_cmp(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 result; // x0
  int *v4; // x0
  __int64 v5; // x1
  __int64 *v6; // x19
  __int64 *v7; // x20

  v2 = a1;
  result = 0xFFFFFFFFLL;
  if ( v2 && a2 )
  {
    if ( *(_DWORD *)v2 == *(_DWORD *)a2 )
    {
      switch ( *(_DWORD *)v2 )
      {
        case 0:
          v6 = *(__int64 **)(v2 + 8);
          result = 0xFFFFFFFFLL;
          if ( !v6 )
            return result;
          v7 = *(__int64 **)(a2 + 8);
          if ( !v7 )
            return result;
          result = OBJ_cmp(*v6, *v7);
          if ( (_DWORD)result )
            return result;
          v4 = (int *)v6[1];
          v5 = v7[1];
          goto LABEL_9;
        case 1:
        case 2:
        case 6:
          result = ASN1_STRING_cmp(*(const void ***)(v2 + 8), *(_QWORD *)(a2 + 8));
          break;
        case 3:
        case 5:
          v4 = *(int **)(v2 + 8);
          v5 = *(_QWORD *)(a2 + 8);
LABEL_9:
          result = ASN1_TYPE_cmp(v4, v5);
          break;
        case 4:
          result = X509_NAME_cmp(*(_QWORD *)(v2 + 8), *(_QWORD *)(a2 + 8));
          break;
        case 7:
          result = ASN1_OCTET_STRING_cmp(*(_QWORD *)(v2 + 8), *(_QWORD *)(a2 + 8));
          break;
        case 8:
          result = OBJ_cmp(*(_QWORD *)(v2 + 8), *(_QWORD *)(a2 + 8));
          break;
        default:
          goto def_95844;
      }
    }
    else
    {
def_95844:
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
// A00C8: using guessed type __int64 __fastcall ASN1_OCTET_STRING_cmp(_QWORD, _QWORD);

//----- (00000000000958EC) ----------------------------------------------------
__int64 __fastcall OTHERNAME_cmp(__int64 a1, __int64 *a2)
{
  __int64 *v2; // x19
  __int64 v3; // x20
  __int64 result; // x0

  v2 = a2;
  v3 = a1;
  result = 0xFFFFFFFFLL;
  if ( v3 && a2 )
  {
    result = OBJ_cmp(*(_QWORD *)v3, *a2);
    if ( !(_DWORD)result )
      result = ASN1_TYPE_cmp(*(int **)(v3 + 8), v2[1]);
  }
  return result;
}

//----- (000000000009593C) ----------------------------------------------------
__int64 __fastcall GENERAL_NAME_set0_value(__int64 result, unsigned int a2, __int64 a3)
{
  if ( a2 <= 8 )
    *(_QWORD *)(result + 8) = a3;
  *(_DWORD *)result = a2;
  return result;
}

//----- (0000000000095950) ----------------------------------------------------
__int64 __fastcall GENERAL_NAME_get0_value(__int64 a1, _DWORD *a2)
{
  __int64 result; // x0

  if ( a2 )
    *a2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 > 8u )
    result = 0LL;
  else
    result = *(_QWORD *)(a1 + 8);
  return result;
}

//----- (0000000000095978) ----------------------------------------------------
_QWORD *__fastcall GENERAL_NAME_set0_othername(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 v5; // x21
  _QWORD *result; // x0

  v3 = a1;
  v4 = a3;
  v5 = a2;
  result = (_QWORD *)ASN1_item_new((unsigned __int8 *)&OTHERNAME_it);
  if ( result )
  {
    *result = v5;
    result[1] = v4;
    *(_QWORD *)(v3 + 8) = result;
    result = (_QWORD *)(&dword_0 + 1);
    *(_DWORD *)v3 = 0;
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000959C4) ----------------------------------------------------
signed __int64 __fastcall GENERAL_NAME_get0_otherName(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  if ( *(_DWORD *)a1 )
    return 0LL;
  if ( a2 )
    *a2 = **(_QWORD **)(a1 + 8);
  if ( a3 )
    *a3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL);
  return 1LL;
}

//----- (00000000000959FC) ----------------------------------------------------
signed __int64 __fastcall X509V3_EXT_add(_BYTE *a1)
{
  unsigned __int64 *v1; // x8
  _BYTE *v2; // x19
  signed __int64 result; // x0
  __int16 v4; // w4

  v1 = (unsigned __int64 *)qword_1073C0;
  v2 = a1;
  if ( qword_1073C0 || (v1 = sk_new((__int64)sub_95AA0), (qword_1073C0 = (__int64)v1) != 0) )
  {
    if ( sk_push(v1, (__int64)v2) )
      return 1LL;
    v4 = 88;
  }
  else
  {
    v4 = 83;
  }
  ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_lib.c", v4);
  result = 0LL;
  if ( v2[4] & 1 )
  {
    free(v2);
    result = 0LL;
  }
  return result;
}
// 1073C0: using guessed type __int64 qword_1073C0;

//----- (0000000000095AA0) ----------------------------------------------------
__int64 __fastcall sub_95AA0(_DWORD **a1, _DWORD **a2)
{
  return (unsigned int)(**a1 - **a2);
}

//----- (0000000000095AB8) ----------------------------------------------------
void __fastcall sub_95AB8(void *ptr)
{
  if ( *((_BYTE *)ptr + 4) & 1 )
    free(ptr);
}

//----- (0000000000095AC8) ----------------------------------------------------
unsigned __int64 *__fastcall X509V3_EXT_get_nid(int a1)
{
  unsigned __int64 **v1; // x0
  unsigned __int64 *result; // x0
  unsigned __int64 v3; // [xsp+0h] [xbp-90h]
  int *v4; // [xsp+8h] [xbp-88h]
  int v5; // [xsp+10h] [xbp-80h]
  __int64 v6; // [xsp+78h] [xbp-18h]

  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = &v5;
  if ( a1 & 0x80000000 )
    goto LABEL_7;
  v5 = a1;
  v1 = (unsigned __int64 **)bsearch(&v4, &off_103310, 0x20uLL, 8uLL, (__compar_fn_t)sub_95B78);
  if ( !v1 )
  {
    result = (unsigned __int64 *)qword_1073C0;
    if ( !qword_1073C0 )
      goto LABEL_8;
    if ( (unsigned int)sk_find(qword_1073C0, (signed __int64 *)&v3, (__int64)&v5) )
    {
      result = sk_value((unsigned __int64 *)qword_1073C0, v3);
      goto LABEL_8;
    }
LABEL_7:
    result = 0LL;
    goto LABEL_8;
  }
  result = *v1;
LABEL_8:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 103310: using guessed type void *off_103310;
// 1073C0: using guessed type __int64 qword_1073C0;

//----- (0000000000095B78) ----------------------------------------------------
__int64 __fastcall sub_95B78(_DWORD **a1, _DWORD **a2)
{
  return (unsigned int)(**a1 - **a2);
}

//----- (0000000000095B90) ----------------------------------------------------
unsigned __int64 *__fastcall X509V3_EXT_get(unsigned int **a1)
{
  int v1; // w0
  unsigned __int64 **v2; // x0
  unsigned __int64 *result; // x0
  unsigned __int64 v4; // [xsp+0h] [xbp-90h]
  int *v5; // [xsp+8h] [xbp-88h]
  int v6; // [xsp+10h] [xbp-80h]
  __int64 v7; // [xsp+78h] [xbp-18h]

  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v1 = (unsigned __int64)OBJ_obj2nid(*a1);
  if ( !v1 )
    goto LABEL_8;
  v5 = &v6;
  if ( v1 & 0x80000000 )
    goto LABEL_8;
  v6 = v1;
  v2 = (unsigned __int64 **)bsearch(&v5, &off_103310, 0x20uLL, 8uLL, (__compar_fn_t)sub_95B78);
  if ( !v2 )
  {
    result = (unsigned __int64 *)qword_1073C0;
    if ( !qword_1073C0 )
      goto LABEL_9;
    if ( (unsigned int)sk_find(qword_1073C0, (signed __int64 *)&v4, (__int64)&v6) )
    {
      result = sk_value((unsigned __int64 *)qword_1073C0, v4);
      goto LABEL_9;
    }
LABEL_8:
    result = 0LL;
    goto LABEL_9;
  }
  result = *v2;
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 103310: using guessed type void *off_103310;
// 1073C0: using guessed type __int64 qword_1073C0;

//----- (0000000000095C4C) ----------------------------------------------------
signed __int64 __fastcall X509V3_EXT_free(int a1, __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 **v3; // x0
  unsigned __int64 *v4; // x0
  unsigned __int8 *v5; // x1
  signed __int64 result; // x0
  void (__fastcall *v7)(__int64); // x8
  __int16 v8; // w4
  unsigned __int64 v9; // [xsp+0h] [xbp-90h]
  int *v10; // [xsp+8h] [xbp-88h]
  int v11; // [xsp+10h] [xbp-80h]
  __int64 v12; // [xsp+78h] [xbp-18h]

  v2 = a2;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = &v11;
  if ( a1 & 0x80000000 )
  {
    v4 = 0LL;
  }
  else
  {
    v11 = a1;
    v3 = (unsigned __int64 **)bsearch(&v10, &off_103310, 0x20uLL, 8uLL, (__compar_fn_t)sub_95B78);
    if ( v3 )
    {
      v4 = *v3;
      if ( !v4 )
        goto LABEL_16;
      goto LABEL_7;
    }
    v4 = (unsigned __int64 *)qword_1073C0;
    if ( qword_1073C0 )
    {
      if ( !(unsigned int)sk_find(qword_1073C0, (signed __int64 *)&v9, (__int64)&v11) )
        goto LABEL_16;
      v4 = sk_value((unsigned __int64 *)qword_1073C0, v9);
      if ( !v4 )
        goto LABEL_16;
      goto LABEL_7;
    }
  }
  if ( !v4 )
  {
LABEL_16:
    v8 = 136;
    goto LABEL_17;
  }
LABEL_7:
  v5 = (unsigned __int8 *)v4[1];
  if ( v5 )
  {
    ASN1_item_free(v2, v5);
    result = 1LL;
  }
  else
  {
    v7 = (void (__fastcall *)(__int64))v4[3];
    if ( !v7 )
    {
      v8 = 145;
LABEL_17:
      ERR_put_error(20, 0LL, 104, (__int64)"external/boringssl/src/crypto/x509v3/v3_lib.c", v8);
      result = 0LL;
      goto LABEL_18;
    }
    v7(v2);
    result = 1LL;
  }
LABEL_18:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 103310: using guessed type void *off_103310;
// 1073C0: using guessed type __int64 qword_1073C0;

//----- (0000000000095D7C) ----------------------------------------------------
signed __int64 __fastcall X509V3_EXT_add_list(_DWORD *a1)
{
  _DWORD *v1; // x19
  signed __int64 result; // x0
  int v3; // t1

  v1 = a1;
  if ( *a1 == -1 )
    return 1LL;
  while ( 1 )
  {
    result = X509V3_EXT_add(v1);
    if ( !(_DWORD)result )
      break;
    v3 = v1[26];
    v1 += 26;
    if ( v3 == -1 )
      return 1LL;
  }
  return result;
}

//----- (0000000000095DC0) ----------------------------------------------------
signed __int64 __fastcall X509V3_EXT_add_alias(int a1, int a2)
{
  int v2; // w19
  unsigned __int64 **v3; // x0
  unsigned __int64 *v4; // x20
  _DWORD *v5; // x0
  _DWORD *v6; // x21
  int v7; // w8
  signed __int64 result; // x0
  int v9; // w2
  __int16 v10; // w4
  unsigned __int64 v11; // [xsp+0h] [xbp-A0h]
  int *v12; // [xsp+8h] [xbp-98h]
  int v13; // [xsp+10h] [xbp-90h]
  __int64 v14; // [xsp+78h] [xbp-28h]

  v2 = a1;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v12 = &v13;
  if ( a2 & 0x80000000 )
    goto LABEL_13;
  v13 = a2;
  v3 = (unsigned __int64 **)bsearch(&v12, &off_103310, 0x20uLL, 8uLL, (__compar_fn_t)sub_95B78);
  if ( v3 )
  {
    v4 = *v3;
    if ( !*v3 )
    {
LABEL_13:
      v9 = 114;
      v10 = 166;
LABEL_15:
      ERR_put_error(20, 0LL, v9, (__int64)"external/boringssl/src/crypto/x509v3/v3_lib.c", v10);
      result = 0LL;
      goto LABEL_16;
    }
  }
  else
  {
    if ( !qword_1073C0 )
      goto LABEL_13;
    if ( !(unsigned int)sk_find(qword_1073C0, (signed __int64 *)&v11, (__int64)&v13) )
      goto LABEL_13;
    v4 = sk_value((unsigned __int64 *)qword_1073C0, v11);
    if ( !v4 )
      goto LABEL_13;
  }
  v5 = malloc(0x68uLL);
  v6 = v5;
  if ( !v5 )
  {
    v9 = 65;
    v10 = 172;
    goto LABEL_15;
  }
  memcpy(v5, v4, 0x68uLL);
  v7 = v6[1] | 1;
  *v6 = v2;
  v6[1] = v7;
  result = X509V3_EXT_add(v6);
LABEL_16:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 103310: using guessed type void *off_103310;
// 1073C0: using guessed type __int64 qword_1073C0;

//----- (0000000000095F08) ----------------------------------------------------
void X509V3_EXT_cleanup()
{
  sk_pop_free((unsigned __int64 *)qword_1073C0, (void (*)(void))sub_95AB8);
  qword_1073C0 = 0LL;
}
// 1073C0: using guessed type __int64 qword_1073C0;

//----- (0000000000095F38) ----------------------------------------------------
unsigned __int64 *__fastcall X509V3_EXT_d2i(unsigned int **a1)
{
  unsigned int **v1; // x19
  unsigned __int64 *result; // x0
  unsigned int *v3; // x8
  unsigned __int8 *v4; // x3
  __int64 v5; // x2
  __int64 v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v1 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = X509V3_EXT_get(a1);
  if ( result )
  {
    v3 = v1[2];
    v6 = *((_QWORD *)v3 + 1);
    v4 = (unsigned __int8 *)result[1];
    v5 = (signed int)*v3;
    if ( v4 )
      result = ASN1_item_d2i(0LL, (const void **)&v6, v5, v4);
    else
      result = (unsigned __int64 *)((__int64 (__fastcall *)(_QWORD, __int64 *, __int64))result[4])(0LL, &v6, v5);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000095FC0) ----------------------------------------------------
unsigned __int64 *__fastcall X509V3_get_d2i(unsigned __int64 *a1, int a2, signed int *a3, _DWORD *a4)
{
  _DWORD *v4; // x20
  signed int *v5; // x19
  int v6; // w21
  unsigned __int64 *v7; // x22
  int v8; // w8
  unsigned __int64 v9; // x24
  unsigned __int64 *v10; // x25
  unsigned __int64 *v11; // x23
  _BOOL4 v12; // w8
  unsigned __int64 *result; // x0
  signed int *v14; // x8
  unsigned __int8 *v15; // x3
  __int64 v16; // x2
  signed int v17; // w8
  __int64 v18; // [xsp+0h] [xbp-50h]
  __int64 v19; // [xsp+8h] [xbp-48h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
  {
    if ( a4 )
      *a4 = -1;
    if ( a3 )
      goto LABEL_33;
    goto LABEL_37;
  }
  if ( a4 )
    v8 = *a4 + 1;
  else
    v8 = 0;
  if ( v8 >= 0 )
    v9 = (unsigned int)v8;
  else
    v9 = 0LL;
  if ( v9 >= (unsigned __int64)sk_num(a1) )
  {
    v12 = v5 != 0LL;
    if ( v4 )
      goto LABEL_31;
    goto LABEL_32;
  }
  v10 = 0LL;
  while ( 1 )
  {
    v11 = sk_value(v7, v9);
    if ( (unsigned int)OBJ_obj2nid((unsigned int *)*v11) == v6 )
      break;
    v11 = v10;
LABEL_19:
    ++v9;
    v10 = v11;
    if ( v9 >= (unsigned __int64)sk_num(v7) )
      goto LABEL_24;
  }
  if ( !v4 )
  {
    if ( v10 )
    {
      if ( !v5 )
        goto LABEL_37;
      result = 0LL;
      v17 = -2;
      goto LABEL_34;
    }
    goto LABEL_19;
  }
  *v4 = v9;
LABEL_24:
  v12 = v5 != 0LL;
  if ( v11 )
  {
    if ( v5 )
      *v5 = X509_EXTENSION_get_critical((__int64)v11);
    result = X509V3_EXT_get((unsigned int **)v11);
    if ( result )
    {
      v14 = (signed int *)v11[2];
      v18 = *((_QWORD *)v14 + 1);
      v15 = (unsigned __int8 *)result[1];
      v16 = *v14;
      if ( v15 )
        result = ASN1_item_d2i(0LL, (const void **)&v18, v16, v15);
      else
        result = (unsigned __int64 *)((__int64 (__fastcall *)(_QWORD, __int64 *, __int64))result[4])(0LL, &v18, v16);
    }
    goto LABEL_38;
  }
  if ( !v4 )
    goto LABEL_32;
LABEL_31:
  *v4 = -1;
LABEL_32:
  if ( !v12 )
  {
LABEL_37:
    result = 0LL;
    goto LABEL_38;
  }
LABEL_33:
  result = 0LL;
  v17 = -1;
LABEL_34:
  *v5 = v17;
LABEL_38:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v19;
  return result;
}

//----- (000000000009616C) ----------------------------------------------------
__int64 __fastcall X509V3_add1_i2d(unsigned __int64 **a1, unsigned int a2, __int64 a3, int a4, char a5)
{
  char v5; // w23
  int v6; // w21
  __int64 v7; // x20
  int v8; // w24
  unsigned __int64 **v9; // x19
  unsigned int v10; // w23
  signed int v11; // w22
  __int64 v12; // x0
  __int64 v13; // x20
  unsigned __int64 *v14; // x0
  unsigned __int64 *v15; // x0
  __int64 v16; // x0
  signed int v17; // w0
  int v18; // w8
  int v19; // w2
  __int16 v20; // w4

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( (a5 & 0xF) == 1LL )
  {
    v10 = 0;
    v11 = -1;
LABEL_3:
    X509V3_EXT_i2d(v8, v6, v7);
    v13 = v12;
    if ( v12 )
    {
      v14 = *v9;
      if ( v10 )
      {
        v15 = sk_value(v14, v11);
        X509_EXTENSION_free((__int64)v15);
        v16 = sk_set(*v9, v11, v13);
      }
      else
      {
        if ( !v14 )
        {
          v14 = sk_new_null();
          *v9 = v14;
          if ( !v14 )
            return (unsigned int)-1;
        }
        v16 = (__int64)sk_push(v14, v13);
      }
      goto LABEL_15;
    }
    v19 = 109;
    v20 = 338;
    goto LABEL_25;
  }
  v17 = X509v3_get_ext_by_NID(*a1, a2, -1);
  v18 = v5 & 0xF;
  v11 = v17;
  if ( v17 & 0x80000000 )
  {
    v19 = 114;
    if ( v18 != 3 && v18 != 5 )
    {
      v10 = 0;
      goto LABEL_3;
    }
LABEL_23:
    if ( v5 & 0x10 )
      return 0;
    v20 = 360;
LABEL_25:
    ERR_put_error(20, 0LL, v19, (__int64)"external/boringssl/src/crypto/x509v3/v3_lib.c", v20);
    return 0;
  }
  if ( !(v5 & 0xF) )
  {
    v19 = 112;
    goto LABEL_23;
  }
  v10 = 1;
  if ( v18 == 4 )
    return v10;
  if ( v18 != 5 )
    goto LABEL_3;
  v16 = sk_delete(*v9, v17);
LABEL_15:
  if ( v16 )
    v10 = 0;
  else
    v10 = -1;
  return v10;
}

//----- (00000000000962D0) ----------------------------------------------------
void __fastcall sub_962D0(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  __int64 v3; // x22
  unsigned __int64 *v4; // x20
  __int64 v5; // x21
  __int64 v6; // x19
  unsigned __int64 v7; // x23
  unsigned __int64 *v8; // x27
  unsigned __int64 v9; // x28
  unsigned __int64 **v10; // x25
  signed __int64 v11; // x8
  __int64 *v12; // x27
  unsigned __int64 *v13; // x0
  __int64 *v14; // x20
  __int64 v15; // [xsp+0h] [xbp-70h]
  unsigned __int64 v16; // [xsp+8h] [xbp-68h]
  unsigned __int64 v17; // [xsp+10h] [xbp-60h]
  __int64 v18; // [xsp+18h] [xbp-58h]

  v3 = a1;
  v4 = a3;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = a2;
  v6 = ASN1_item_new((unsigned __int8 *)&NAME_CONSTRAINTS_it);
  if ( !v6 )
  {
    v12 = 0LL;
LABEL_17:
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_ncons.c", 152);
LABEL_18:
    v14 = v12;
    if ( v6 )
      goto LABEL_19;
    goto LABEL_20;
  }
  if ( sk_num(v4) )
  {
    v7 = 0LL;
    do
    {
      v8 = sk_value(v4, v7);
      v9 = v8[1];
      if ( (unsigned int)strncmp((const char *)v8[1], "permitted", 9uLL) || !*(_BYTE *)(v9 + 9) )
      {
        if ( (unsigned int)strncmp((const char *)v9, "excluded", 8uLL) || !*(_BYTE *)(v9 + 8) )
        {
          ERR_put_error(20, 0LL, 135, (__int64)"external/boringssl/src/crypto/x509v3/v3_ncons.c", 135);
          v12 = 0LL;
          v14 = 0LL;
          if ( !v6 )
            goto LABEL_20;
LABEL_19:
          ASN1_item_free(v6, (unsigned __int8 *)&NAME_CONSTRAINTS_it);
LABEL_20:
          if ( v14 )
            ASN1_item_free((__int64)v12, (unsigned __int8 *)&GENERAL_SUBTREE_it);
          break;
        }
        v10 = (unsigned __int64 **)(v6 + 8);
        v11 = 9LL;
      }
      else
      {
        v10 = (unsigned __int64 **)v6;
        v11 = 10LL;
      }
      v16 = v9 + v11;
      v17 = v8[2];
      v12 = (__int64 *)ASN1_item_new((unsigned __int8 *)&GENERAL_SUBTREE_it);
      if ( !v2i_GENERAL_NAME_ex(*v12, v3, v5, (__int64)&v15, 1) )
        goto LABEL_18;
      v13 = *v10;
      if ( !*v10 )
      {
        v13 = sk_new_null();
        *v10 = v13;
        if ( !v13 )
          goto LABEL_17;
      }
      if ( !sk_push(v13, (__int64)v12) )
        goto LABEL_17;
      ++v7;
    }
    while ( v7 < (unsigned __int64)sk_num(v4) );
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v18;
}

//----- (00000000000964C8) ----------------------------------------------------
signed __int64 __fastcall sub_964C8(__int64 a1, unsigned __int64 **a2, _QWORD *a3, unsigned int a4)
{
  unsigned __int64 **v4; // x20
  unsigned int v5; // w19
  _QWORD *v6; // x21

  v4 = a2;
  v5 = a4;
  v6 = a3;
  sub_96804(*a2, a3, a4, (__int64)"Permitted");
  sub_96804(v4[1], v6, v5, (__int64)"Excluded");
  return 1LL;
}

//----- (0000000000096528) ----------------------------------------------------
__int64 GENERAL_SUBTREE_new()
{
  return ASN1_item_new((unsigned __int8 *)&GENERAL_SUBTREE_it);
}

//----- (0000000000096534) ----------------------------------------------------
void __fastcall GENERAL_SUBTREE_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&GENERAL_SUBTREE_it);
}

//----- (0000000000096540) ----------------------------------------------------
__int64 NAME_CONSTRAINTS_new()
{
  return ASN1_item_new((unsigned __int8 *)&NAME_CONSTRAINTS_it);
}

//----- (000000000009654C) ----------------------------------------------------
void __fastcall NAME_CONSTRAINTS_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&NAME_CONSTRAINTS_it);
}

//----- (0000000000096558) ----------------------------------------------------
unsigned __int64 __fastcall NAME_CONSTRAINTS_check(__int64 a1, unsigned __int64 **a2)
{
  unsigned __int64 **v2; // x19
  __int64 v3; // x20
  unsigned __int64 **v4; // x22
  unsigned __int64 result; // x0
  unsigned int v6; // w21
  signed int v7; // w23
  unsigned __int64 *v8; // x0
  signed int v9; // w8
  signed int v10; // w9
  unsigned __int64 v11; // x22
  unsigned __int64 *v12; // x0
  int v13; // [xsp+8h] [xbp-48h]
  unsigned __int64 **v14; // [xsp+10h] [xbp-40h]
  __int64 v15; // [xsp+18h] [xbp-38h]

  v2 = a2;
  v3 = a1;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (unsigned __int64 **)X509_get_subject_name(a1);
  if ( (signed int)X509_NAME_entry_count(v4) < 1 )
    goto LABEL_23;
  v13 = 4;
  v14 = v4;
  result = sub_966C8(&v13, v2);
  v6 = result;
  if ( !(_DWORD)result )
  {
    v7 = -1;
    v13 = 1;
    while ( 1 )
    {
      result = X509_NAME_get_index_by_NID(v4, 0x30u, v7);
      v7 = result;
      if ( (_DWORD)result == -1 )
      {
        v9 = 2;
        v10 = 2;
        goto LABEL_12;
      }
      v8 = X509_NAME_get_entry(v4, result);
      result = X509_policy_node_get0_parent((__int64)v8);
      v14 = (unsigned __int64 **)result;
      if ( *(_DWORD *)(result + 4) != 22 )
        break;
      result = sub_966C8(&v13, v2);
      v9 = result != 0;
      if ( (_DWORD)result )
        v6 = result;
      v10 = result != 0;
      if ( (_DWORD)result != 0 )
        goto LABEL_12;
    }
    v6 = 53;
    v9 = 1;
    v10 = 1;
LABEL_12:
    if ( v10 == 2 )
      goto LABEL_23;
    if ( !v9 )
    {
LABEL_23:
      result = (unsigned __int64)sk_num(*(_QWORD **)(v3 + 128));
      if ( result )
      {
        v11 = 0LL;
        while ( 1 )
        {
          v12 = sk_value(*(unsigned __int64 **)(v3 + 128), v11);
          result = sub_966C8(v12, v2);
          v6 = result;
          if ( (_DWORD)result )
            break;
          ++v11;
          result = (unsigned __int64)sk_num(*(_QWORD **)(v3 + 128));
          if ( v11 >= result )
            goto LABEL_18;
        }
      }
      else
      {
LABEL_18:
        v6 = 0;
      }
    }
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v15 )
    result = v6;
  return result;
}

//----- (00000000000966C8) ----------------------------------------------------
signed __int64 __fastcall sub_966C8(_DWORD *a1, unsigned __int64 **a2)
{
  unsigned __int64 **v2; // x19
  _DWORD *v3; // x20
  unsigned __int64 v4; // x21
  signed int v5; // w22
  __int64 *v6; // x0
  signed __int64 result; // x0
  unsigned __int64 v8; // x21
  __int64 *v9; // x0

  v2 = a2;
  v3 = a1;
  if ( sk_num(*a2) )
  {
    v4 = 0LL;
    v5 = 0;
    do
    {
      v6 = (__int64 *)sk_value(*v2, v4);
      if ( *v3 == *(_DWORD *)*v6 )
      {
        if ( v6[1] || v6[2] )
          return 49LL;
        if ( v5 == 2 )
          goto LABEL_30;
        if ( !v5 )
          v5 = 1;
        result = sub_969F4((__int64)v3, *v6);
        if ( (_DWORD)result )
        {
          if ( (_DWORD)result != 47 )
            return result;
        }
        else
        {
LABEL_30:
          v5 = 2;
        }
      }
      ++v4;
    }
    while ( v4 < (unsigned __int64)sk_num(*v2) );
    if ( v5 != 1 )
      goto LABEL_16;
    result = 47LL;
  }
  else
  {
LABEL_16:
    result = (signed __int64)sk_num(v2[1]);
    if ( result )
    {
      v8 = 0LL;
      while ( 1 )
      {
        v9 = (__int64 *)sk_value(v2[1], v8);
        if ( *v3 == *(_DWORD *)*v9 )
        {
          if ( v9[1] || v9[2] )
            return 49LL;
          result = sub_969F4((__int64)v3, *v9);
          if ( (_DWORD)result != 47 )
            break;
        }
        if ( ++v8 >= (unsigned __int64)sk_num(v2[1]) )
          return 0LL;
      }
      if ( !(_DWORD)result )
        result = 48LL;
    }
  }
  return result;
}

//----- (0000000000096804) ----------------------------------------------------
_QWORD *__fastcall sub_96804(unsigned __int64 *a1, _QWORD *a2, unsigned int a3, __int64 a4)
{
  __int64 v4; // x21
  unsigned int v5; // w22
  _QWORD *v6; // x19
  unsigned __int64 *v7; // x20
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  _QWORD *result; // x0
  unsigned __int64 v17; // x21
  unsigned int v18; // w22
  unsigned __int64 *v19; // x23
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7
  _DWORD *v36; // x1
  int *v37; // x8
  unsigned __int8 *v38; // x23
  int v39; // w24
  double v40; // d0
  double v41; // d1
  double v42; // d2
  double v43; // d3
  double v44; // d4
  double v45; // d5
  double v46; // d6
  double v47; // d7
  signed int v48; // w24
  __int64 v49; // [xsp+0h] [xbp-60h]
  __int64 v50; // [xsp+8h] [xbp-58h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( sk_num(a1) )
    BIO_printf(v6, (__int64)"%*s%s:\n", v8, v9, v10, v11, v12, v13, v14, v15, v5, &unk_B8A4C, v4);
  result = sk_num(v7);
  if ( result )
  {
    v17 = 0LL;
    v18 = v5 + 2;
    do
    {
      v19 = sk_value(v7, v17);
      BIO_printf(v6, (__int64)"%*s", v20, v21, v22, v23, v24, v25, v26, v27, v18, &unk_B8A4C);
      v36 = (_DWORD *)*v19;
      if ( *(_DWORD *)*v19 == 7 )
      {
        v37 = (int *)*((_QWORD *)v36 + 1);
        v38 = (unsigned __int8 *)*((_QWORD *)v37 + 1);
        v39 = *v37;
        BIO_puts(v6, "IP:");
        if ( v39 == 8 )
        {
          LODWORD(v50) = v38[7];
          LODWORD(v49) = v38[6];
          BIO_printf(
            v6,
            (__int64)"%d.%d.%d.%d/%d.%d.%d.%d",
            v40,
            v41,
            v42,
            v43,
            v44,
            v45,
            v46,
            v47,
            *v38,
            v38[1],
            v38[2],
            v38[3],
            v38[4],
            v38[5],
            v49,
            v50);
        }
        else
        {
          if ( v39 == 32 )
          {
            v48 = 0;
            while ( 1 )
            {
              BIO_printf(v6, (__int64)"%X", v40, v41, v42, v43, v44, v45, v46, v47, v38[1] | ((unsigned int)*v38 << 8));
              if ( v48 == 7 )
              {
                BIO_puts(v6, "/");
                v48 = 8;
              }
              else
              {
                if ( v48 == 15 )
                  goto LABEL_18;
                BIO_puts(v6, ":");
                if ( ++v48 == 16 )
                  goto LABEL_18;
              }
              v38 += 2;
            }
          }
          BIO_printf(v6, (__int64)"IP Address:<invalid>", v40, v41, v42, v43, v44, v45, v46, v47);
        }
      }
      else
      {
        GENERAL_NAME_print(v6, (__int64)v36, v28, v29, v30, v31, v32, v33, v34, v35);
      }
LABEL_18:
      BIO_puts(v6, "\n");
      ++v17;
      result = sk_num(v7);
    }
    while ( v17 < (unsigned __int64)result );
  }
  return result;
}

//----- (00000000000969F4) ----------------------------------------------------
__int64 __fastcall sub_969F4(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned int v3; // w19
  __int64 v4; // x23
  __int64 v5; // x24
  const char *v6; // x19
  const char *v7; // x20
  char *v8; // x22
  char *v9; // x0
  char *v10; // x21
  size_t v11; // x2
  int *v12; // x10
  const char *v13; // x0
  int *v14; // x8
  int v15; // w10
  int v16; // w11
  signed __int64 v17; // x1
  int v18; // w8
  __int64 v19; // x19
  __int64 v20; // x20
  int v21; // w0
  int v22; // w0
  size_t v23; // x2
  signed int *v24; // x19
  _BYTE *v25; // x20
  char *v26; // x0
  const char *v27; // x21
  char *v28; // x0
  signed int v29; // w0
  __int64 v30; // x2
  int v31; // w0

  v2 = a1;
  v3 = 51;
  switch ( *(_DWORD *)a2 )
  {
    case 1:
      v4 = *(_QWORD *)(a2 + 8);
      v5 = *(_QWORD *)(a1 + 8);
      v6 = *(const char **)(v4 + 8);
      v7 = *(const char **)(v5 + 8);
      v8 = strchr(*(const char **)(v4 + 8), 64);
      v9 = strchr(v7, 64);
      v10 = v9;
      if ( !v9 )
        return 53;
      if ( v8 )
      {
        v11 = v8 - v6;
        if ( v8 != v6 )
        {
          if ( v11 != v9 - v7 )
            return 47;
          if ( (unsigned int)strncmp(v6, v7, v11) )
            return 47;
        }
        v6 = v8 + 1;
LABEL_40:
        v17 = (signed __int64)(v10 + 1);
        v13 = v6;
        goto LABEL_41;
      }
      if ( *v6 != 46 )
        goto LABEL_40;
      if ( *(_DWORD *)v5 <= *(_DWORD *)v4 || (unsigned int)OPENSSL_strcasecmp(v6, &v7[*(_DWORD *)v5 - *(_DWORD *)v4]) )
        return 47;
      return 0;
    case 2:
      v12 = *(int **)(a2 + 8);
      v13 = (const char *)*((_QWORD *)v12 + 1);
      if ( !*v13 )
        return 0;
      v14 = *(int **)(v2 + 8);
      v15 = *v12;
      v16 = *v14;
      v17 = *((_QWORD *)v14 + 1);
      v18 = *v14 - v15;
      if ( v16 > v15 )
      {
        v17 += v18;
        if ( *v13 != 46 && *(_BYTE *)(v17 - 1) != 46 )
          return 47;
      }
LABEL_41:
      v31 = OPENSSL_strcasecmp(v13, v17);
      goto LABEL_42;
    case 4:
      v19 = *(_QWORD *)(a1 + 8);
      v20 = *(_QWORD *)(a2 + 8);
      if ( *(_DWORD *)(v19 + 8) && (i2d_X509_NAME(), v21 & 0x80000000) )
      {
        v3 = 17;
      }
      else if ( *(_DWORD *)(v20 + 8) && (i2d_X509_NAME(), v22 & 0x80000000) )
      {
        v3 = 17;
      }
      else
      {
        v23 = *(signed int *)(v20 + 32);
        if ( (signed int)v23 <= *(_DWORD *)(v19 + 32) )
        {
          if ( (_DWORD)v23 )
          {
            v31 = memcmp(*(const void **)(v20 + 24), *(const void **)(v19 + 24), v23);
LABEL_42:
            if ( v31 )
              v3 = 47;
            else
              v3 = 0;
          }
          else
          {
            v3 = 0;
          }
        }
        else
        {
          v3 = 47;
        }
      }
      return v3;
    case 6:
      v24 = *(signed int **)(a2 + 8);
      v25 = (_BYTE *)*((_QWORD *)v24 + 1);
      v26 = strchr(*(const char **)(*(_QWORD *)(a1 + 8) + 8LL), 58);
      if ( !v26 || v26[1] != 47 )
        return 53;
      if ( v26[2] != 47 )
        return 53;
      v27 = v26 + 3;
      v28 = strchr(v26 + 3, 58);
      if ( v28 || (v28 = strchr(v27, 47)) != 0LL )
      {
        v29 = (_DWORD)v28 - (_DWORD)v27;
        if ( v29 )
          goto LABEL_25;
        return 53;
      }
      v29 = strlen(v27);
      if ( !v29 )
        return 53;
LABEL_25:
      v30 = *v24;
      if ( *v25 == 46 )
      {
        if ( v29 <= (signed int)v30 || (unsigned int)OPENSSL_strncasecmp(&v27[v29 - v30], v25, v30) )
          return 47;
        return 0;
      }
      v3 = 47;
      if ( (_DWORD)v30 == v29 )
      {
        if ( (unsigned int)OPENSSL_strncasecmp(v27, v25, v29) )
          v3 = 47;
        else
          v3 = 0;
      }
      return v3;
    default:
      return v3;
  }
}
// 4BCAC: using guessed type __int64 __fastcall OPENSSL_strcasecmp(_QWORD, _QWORD);
// 4BCB0: using guessed type __int64 __fastcall OPENSSL_strncasecmp(_QWORD, _QWORD, _QWORD);

//----- (0000000000096CC4) ----------------------------------------------------
signed __int64 __fastcall sub_96CC4(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, _QWORD *a11, unsigned int a12)
{
  unsigned int v12; // w19
  _QWORD *v13; // x20
  __int64 v14; // x21
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  __int64 v39; // x8

  v12 = a12;
  v13 = a11;
  v14 = a10;
  BIO_printf(a11, (__int64)"%*sPath Length Constraint: ", a1, a2, a3, a4, a5, a6, a7, a8, a12, &unk_B8A4C);
  if ( *(_QWORD *)v14 )
    i2a_ASN1_INTEGER((__int64)v13, *(_QWORD *)v14);
  else
    BIO_printf(v13, (__int64)"infinite", v15, v16, v17, v18, v19, v20, v21, v22);
  BIO_puts(v13, "\n");
  BIO_printf(v13, (__int64)"%*sPolicy Language: ", v23, v24, v25, v26, v27, v28, v29, v30, v12, &unk_B8A4C);
  i2a_ASN1_OBJECT(v13, **(_QWORD **)(v14 + 8));
  BIO_puts(v13, "\n");
  v39 = *(_QWORD *)(*(_QWORD *)(v14 + 8) + 8LL);
  if ( v39 && *(_QWORD *)(v39 + 8) )
    BIO_printf(v13, (__int64)"%*sPolicy Text: %s\n", v31, v32, v33, v34, v35, v36, v37, v38, v12, &unk_B8A4C);
  return 1LL;
}

//----- (0000000000096DB0) ----------------------------------------------------
void __fastcall sub_96DB0(__int64 a1, __int64 a2, const char *a3)
{
  __int64 v3; // x20
  unsigned __int64 *v4; // x19
  unsigned __int64 v5; // x21
  unsigned __int64 *v6; // x0
  __int64 *v7; // x22
  _BYTE *v8; // x8
  unsigned __int64 *v9; // x23
  unsigned __int64 v10; // x22
  unsigned __int64 *v11; // x0
  __int64 v12; // x7
  unsigned int *v13; // x21
  int v14; // w0
  __int64 v15; // x22
  int v16; // w2
  __int16 v17; // w4
  void **v18; // x0
  int v19; // w2
  __int16 v20; // w4
  __int64 v21; // x0
  __int64 v22; // [xsp+0h] [xbp-50h]
  __int64 v23; // [xsp+8h] [xbp-48h]
  unsigned int *v24; // [xsp+10h] [xbp-40h]
  __int64 v25; // [xsp+18h] [xbp-38h]

  v3 = a2;
  v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v23 = 0LL;
  v24 = 0LL;
  v22 = 0LL;
  v4 = X509V3_parse_list(a3);
  if ( sk_num(v4) )
  {
    v5 = 0LL;
    while ( 1 )
    {
      v6 = sk_value(v4, v5);
      v7 = (__int64 *)v6;
      v8 = (_BYTE *)v6[1];
      if ( !v8 )
        break;
      if ( *v8 == 64 )
      {
        v9 = (unsigned __int64 *)X509V3_get_section(v3);
        if ( v9 )
        {
          v10 = 0LL;
          do
          {
            if ( v10 >= (unsigned __int64)sk_num(v9) )
            {
              X509V3_section_free(v3, (__int64)v9);
              goto LABEL_14;
            }
            v11 = sk_value(v9, v10++);
          }
          while ( (unsigned int)sub_97054((__int64)v11, &v24, &v23, (_DWORD **)&v22) );
          X509V3_section_free(v3, (__int64)v9);
          v18 = (void **)v24;
          if ( v24 )
            goto LABEL_28;
          goto LABEL_29;
        }
        v19 = 134;
        v20 = 221;
LABEL_26:
        ERR_put_error(20, 0LL, v19, (__int64)"external/boringssl/src/crypto/x509v3/v3_pci.c", v20);
LABEL_27:
        ERR_add_error_data(6u, (__int64)"section:", *v7, (__int64)",name:", v7[1], (__int64)",value:", v7[2], v12, v22);
        v18 = (void **)v24;
        if ( !v24 )
          goto LABEL_29;
        goto LABEL_28;
      }
      if ( !v6[2] )
        break;
      if ( !(unsigned int)sub_97054((__int64)v6, &v24, &v23, (_DWORD **)&v22) )
        goto LABEL_27;
LABEL_14:
      if ( ++v5 >= (unsigned __int64)sk_num(v4) )
      {
        v13 = v24;
        if ( !v24 )
          goto LABEL_21;
        v14 = (unsigned __int64)OBJ_obj2nid(v24);
        v15 = v22;
        if ( (v14 | 2) == 667 && v22 )
        {
          v16 = 152;
          v17 = 250;
          goto LABEL_22;
        }
        v21 = PROXY_CERT_INFO_EXTENSION_new();
        if ( v21 )
        {
          **(_QWORD **)(v21 + 8) = v13;
          v24 = 0LL;
          *(_QWORD *)(*(_QWORD *)(v21 + 8) + 8LL) = v15;
          v22 = 0LL;
          *(_QWORD *)v21 = v23;
          v23 = 0LL;
          goto LABEL_33;
        }
        v16 = 65;
        v17 = 256;
        goto LABEL_22;
      }
    }
    v19 = 132;
    v20 = 211;
    goto LABEL_26;
  }
LABEL_21:
  v16 = 143;
  v17 = 244;
LABEL_22:
  ERR_put_error(20, 0LL, v16, (__int64)"external/boringssl/src/crypto/x509v3/v3_pci.c", v17);
  v18 = (void **)v24;
  if ( v24 )
  {
LABEL_28:
    ASN1_OBJECT_free(v18);
    v24 = 0LL;
  }
LABEL_29:
  if ( v23 )
  {
    ASN1_VISIBLESTRING_free(v23);
    v23 = 0LL;
  }
  if ( v22 )
  {
    ASN1_VISIBLESTRING_free(v22);
    v22 = 0LL;
  }
LABEL_33:
  sk_pop_free(v4, (void (*)(void))X509V3_conf_free);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v25;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (0000000000097054) ----------------------------------------------------
signed __int64 __fastcall sub_97054(__int64 a1, _QWORD *a2, _QWORD *a3, _DWORD **a4)
{
  __int64 v4; // x20
  _QWORD *v5; // x23
  const char *v6; // x22
  _DWORD **v7; // x19
  _QWORD *v8; // x21
  signed __int64 result; // x0
  int v10; // w2
  __int16 v11; // w4
  _DWORD *v12; // x21
  signed int v13; // w23
  __int64 v14; // x0
  const char *v15; // x22
  int v16; // w2
  __int16 v17; // w4
  _BYTE *v18; // x21
  void *v19; // x0
  signed int *v20; // x8
  __int64 v21; // x9
  int v22; // w10
  size_t v23; // x0
  size_t v24; // x22
  void *v25; // x0
  _DWORD *v26; // x8
  _DWORD *v27; // x8
  __int64 v28; // x9
  __int64 v29; // x7
  __int64 v30; // x7
  size_t v31; // [xsp+0h] [xbp-40h]
  __int64 v32; // [xsp+8h] [xbp-38h]

  v4 = a1;
  v5 = a2;
  v32 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = *(const char **)(a1 + 8);
  v7 = a4;
  v8 = a3;
  if ( !(unsigned int)strcmp(*(const char **)(a1 + 8), "language") )
  {
    if ( *v5 )
    {
      v10 = 149;
      v11 = 91;
    }
    else
    {
      OBJ_txt2obj(*(const char **)(v4 + 16), 0);
      *v5 = v14;
      if ( v14 )
      {
        result = 1LL;
        goto LABEL_33;
      }
      v10 = 129;
      v11 = 96;
    }
    goto LABEL_31;
  }
  if ( !(unsigned int)strcmp(v6, "pathlen") )
  {
    if ( *v8 )
    {
      v10 = 151;
      v11 = 103;
    }
    else
    {
      if ( (unsigned int)X509V3_get_value_int(v4, v8) )
      {
        result = 1LL;
        goto LABEL_33;
      }
      v10 = 150;
      v11 = 108;
    }
    goto LABEL_31;
  }
  if ( (unsigned int)strcmp(v6, "policy") )
  {
    result = 1LL;
    goto LABEL_33;
  }
  v12 = *v7;
  if ( *v7 )
  {
    v13 = 0;
    goto LABEL_17;
  }
  v12 = ASN1_OCTET_STRING_new();
  *v7 = v12;
  if ( !v12 )
  {
    v10 = 65;
    v11 = 118;
LABEL_31:
    ERR_put_error(20, 0LL, v10, (__int64)"external/boringssl/src/crypto/x509v3/v3_pci.c", v11);
    ERR_add_error_data(
      6u,
      (__int64)"section:",
      *(_QWORD *)v4,
      (__int64)",name:",
      *(_QWORD *)(v4 + 8),
      (__int64)",value:",
      *(_QWORD *)(v4 + 16),
      v29,
      v31);
LABEL_32:
    result = 0LL;
    goto LABEL_33;
  }
  v13 = 1;
LABEL_17:
  v15 = *(const char **)(v4 + 16);
  if ( !(unsigned int)strncmp(*(const char **)(v4 + 16), "hex:", 4uLL) )
  {
    v18 = sub_99F20(v15 + 4, &v31);
    if ( v18 )
    {
      v19 = realloc(*((void **)*v7 + 1), v31 + (signed int)**v7 + 1);
      if ( v19 )
      {
        *((_QWORD *)*v7 + 1) = v19;
        v20 = *v7;
        v21 = (signed int)**v7;
        if ( v31 )
        {
          memcpy((void *)(*((_QWORD *)v20 + 1) + v21), v18, v31);
          v20 = *v7;
          v22 = v31;
          LODWORD(v21) = **v7;
        }
        else
        {
          v22 = 0;
        }
        *v20 = v21 + v22;
        *(_BYTE *)(*((_QWORD *)*v7 + 1) + (signed int)**v7) = 0;
        free(v18);
        result = 1LL;
        goto LABEL_33;
      }
      free(v18);
      *((_QWORD *)*v7 + 1) = 0LL;
      v16 = 65;
      v17 = 150;
      **v7 = 0;
    }
    else
    {
      v16 = 118;
      v17 = 129;
    }
LABEL_38:
    ERR_put_error(20, 0LL, v16, (__int64)"external/boringssl/src/crypto/x509v3/v3_pci.c", v17);
    ERR_add_error_data(
      6u,
      (__int64)"section:",
      *(_QWORD *)v4,
      (__int64)",name:",
      *(_QWORD *)(v4 + 8),
      (__int64)",value:",
      *(_QWORD *)(v4 + 16),
      v30,
      v31);
    if ( v13 )
    {
      ASN1_VISIBLESTRING_free(*v7);
      result = 0LL;
      *v7 = 0LL;
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  if ( (unsigned int)strncmp(v15, "text:", 5uLL) )
  {
    v16 = 119;
    v17 = 177;
    goto LABEL_38;
  }
  v23 = strlen(v15 + 5);
  v24 = v23;
  v31 = v23;
  v25 = realloc(*((void **)v12 + 1), v23 + (signed int)*v12 + 1);
  v26 = *v7;
  if ( !v25 )
  {
    *((_QWORD *)v26 + 1) = 0LL;
    **v7 = 0;
    v16 = 65;
    v17 = 172;
    goto LABEL_38;
  }
  *((_QWORD *)v26 + 1) = v25;
  v27 = *v7;
  v28 = (signed int)**v7;
  if ( v24 )
  {
    memcpy((void *)(*((_QWORD *)v27 + 1) + v28), (const void *)(*(_QWORD *)(v4 + 16) + 5LL), v24);
    v27 = *v7;
    LODWORD(v28) = **v7;
  }
  *v27 = v28 + v24;
  result = 1LL;
  *(_BYTE *)(*((_QWORD *)*v7 + 1) + (signed int)**v7) = 0;
LABEL_33:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v32;
  return result;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (0000000000097420) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_PROXY_POLICY(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&PROXY_POLICY_it);
}

//----- (000000000009742C) ----------------------------------------------------
void i2d_PROXY_POLICY()
{
  ASN1_item_i2d();
}

//----- (0000000000097438) ----------------------------------------------------
__int64 PROXY_POLICY_new()
{
  return ASN1_item_new((unsigned __int8 *)&PROXY_POLICY_it);
}

//----- (0000000000097444) ----------------------------------------------------
void __fastcall PROXY_POLICY_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&PROXY_POLICY_it);
}

//----- (0000000000097450) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_PROXY_CERT_INFO_EXTENSION(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&PROXY_CERT_INFO_EXTENSION_it);
}

//----- (000000000009745C) ----------------------------------------------------
void i2d_PROXY_CERT_INFO_EXTENSION()
{
  ASN1_item_i2d();
}

//----- (0000000000097468) ----------------------------------------------------
__int64 PROXY_CERT_INFO_EXTENSION_new()
{
  return ASN1_item_new((unsigned __int8 *)&PROXY_CERT_INFO_EXTENSION_it);
}

//----- (0000000000097474) ----------------------------------------------------
void __fastcall PROXY_CERT_INFO_EXTENSION_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&PROXY_CERT_INFO_EXTENSION_it);
}

//----- (0000000000097480) ----------------------------------------------------
__int64 __fastcall sub_97480(__int64 a1, unsigned __int8 ***a2, __int64 a3)
{
  unsigned __int64 v3; // x20
  unsigned __int8 ***v4; // x19
  __int64 result; // x0
  __int64 v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a2;
  v7 = *(_QWORD *)(v3 + 40);
  v6 = a3;
  X509V3_add_value_int("Require Explicit Policy", *a2, (unsigned __int64 **)&v6);
  X509V3_add_value_int("Inhibit Policy Mapping", v4[1], (unsigned __int64 **)&v6);
  result = v6;
  *(_QWORD *)(v3 + 40);
  return result;
}

//----- (00000000000974F4) ----------------------------------------------------
_QWORD *__fastcall sub_974F4(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  _QWORD *v4; // x19
  unsigned __int64 v5; // x22
  _QWORD *v6; // x21
  __int64 *v7; // x25
  const char *v8; // x26
  __int64 v9; // x7
  __int64 v11; // [xsp+0h] [xbp-40h]

  v3 = a3;
  v4 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&POLICY_CONSTRAINTS_it);
  if ( !v4 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_pcons.c", 113);
    return v4;
  }
  if ( sk_num(v3) )
  {
    v5 = 0LL;
    v6 = v4 + 1;
    while ( 1 )
    {
      v7 = (__int64 *)sk_value(v3, v5);
      v8 = (const char *)v7[1];
      if ( (unsigned int)strcmp((const char *)v7[1], "requireExplicitPolicy") )
      {
        if ( (unsigned int)strcmp(v8, "inhibitPolicyMapping") )
        {
          ERR_put_error(20, 0LL, 123, (__int64)"external/boringssl/src/crypto/x509v3/v3_pcons.c", 125);
          ERR_add_error_data(6u, (__int64)"section:", *v7, (__int64)",name:", v7[1], (__int64)",value:", v7[2], v9, v11);
LABEL_17:
          ASN1_item_free((__int64)v4, (unsigned __int8 *)&POLICY_CONSTRAINTS_it);
          return 0LL;
        }
        if ( !(unsigned int)X509V3_get_value_int((__int64)v7, v4 + 1) )
          goto LABEL_17;
      }
      else if ( !(unsigned int)X509V3_get_value_int((__int64)v7, v4) )
      {
        goto LABEL_17;
      }
      if ( ++v5 >= (unsigned __int64)sk_num(v3) )
        goto LABEL_13;
    }
  }
  v6 = v4 + 1;
LABEL_13:
  if ( !*v6 && !*v4 )
  {
    ERR_put_error(20, 0LL, 117, (__int64)"external/boringssl/src/crypto/x509v3/v3_pcons.c", 131);
    goto LABEL_17;
  }
  return v4;
}

//----- (0000000000097680) ----------------------------------------------------
__int64 POLICY_CONSTRAINTS_new()
{
  return ASN1_item_new((unsigned __int8 *)&POLICY_CONSTRAINTS_it);
}

//----- (000000000009768C) ----------------------------------------------------
void __fastcall POLICY_CONSTRAINTS_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&POLICY_CONSTRAINTS_it);
}

//----- (0000000000097698) ----------------------------------------------------
signed __int64 __fastcall sub_97698(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, signed int **a10, _QWORD *a11, unsigned int a12)
{
  _QWORD *v12; // x19
  signed int **v13; // x20
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  signed int **v22; // x20
  signed int *v23; // t1
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7

  v12 = a11;
  v13 = a10;
  BIO_printf(a11, (__int64)"%*s", a1, a2, a3, a4, a5, a6, a7, a8, a12, &unk_B8A4C);
  if ( *v13 )
  {
    BIO_write(v12, (__int64)"Not Before: ", 0xCu);
    ASN1_GENERALIZEDTIME_print(v12, *v13, v14, v15, v16, v17, v18, v19, v20, v21);
    v23 = v13[1];
    v22 = v13 + 1;
    if ( v23 )
    {
      BIO_write(v12, (__int64)", ", 2u);
      if ( !*v22 )
        return 1LL;
      goto LABEL_7;
    }
  }
  else
  {
    v22 = v13 + 1;
  }
  if ( *v22 )
  {
LABEL_7:
    BIO_write(v12, (__int64)"Not After: ", 0xBu);
    ASN1_GENERALIZEDTIME_print(v12, *v22, v24, v25, v26, v27, v28, v29, v30, v31);
  }
  return 1LL;
}

//----- (0000000000097758) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_PKEY_USAGE_PERIOD(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&PKEY_USAGE_PERIOD_it);
}

//----- (0000000000097764) ----------------------------------------------------
void i2d_PKEY_USAGE_PERIOD()
{
  ASN1_item_i2d();
}

//----- (0000000000097770) ----------------------------------------------------
__int64 PKEY_USAGE_PERIOD_new()
{
  return ASN1_item_new((unsigned __int8 *)&PKEY_USAGE_PERIOD_it);
}

//----- (000000000009777C) ----------------------------------------------------
void __fastcall PKEY_USAGE_PERIOD_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&PKEY_USAGE_PERIOD_it);
}

//----- (0000000000097788) ----------------------------------------------------
_QWORD *__fastcall sub_97788(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 *v3; // x19
  __int64 v4; // x20
  _QWORD *result; // x0
  unsigned __int64 v6; // x20
  unsigned int **v7; // x21
  __int64 v8; // [xsp+0h] [xbp-D0h]
  char v9; // [xsp+8h] [xbp-C8h]
  char v10; // [xsp+58h] [xbp-78h]
  __int64 v11; // [xsp+A8h] [xbp-28h]

  v3 = a2;
  v4 = a3;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a3;
  result = sk_num(a2);
  if ( result )
  {
    v6 = 0LL;
    do
    {
      v7 = (unsigned int **)sk_value(v3, v6);
      i2t_ASN1_OBJECT(&v10, 80, *v7);
      i2t_ASN1_OBJECT(&v9, 80, v7[1]);
      X509V3_add_value(&v10, &v9, (unsigned __int64 **)&v8);
      ++v6;
      result = sk_num(v3);
    }
    while ( v6 < (unsigned __int64)result );
    v4 = v8;
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v11 )
    result = (_QWORD *)v4;
  return result;
}

//----- (000000000009784C) ----------------------------------------------------
unsigned __int64 *__fastcall sub_9784C(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  unsigned __int64 *v4; // x19
  unsigned __int64 v5; // x22
  unsigned __int64 *v6; // x0
  __int64 *v7; // x21
  const char *v8; // x0
  __int64 v9; // x0
  __int64 v10; // x24
  __int64 v11; // x0
  __int64 v12; // x25
  _QWORD *v13; // x8
  __int16 v14; // w4
  __int64 v15; // x7
  __int64 v17; // [xsp+0h] [xbp-40h]

  v3 = a3;
  v4 = sk_new_null();
  if ( v4 )
  {
    if ( sk_num(v3) )
    {
      v5 = 0LL;
      while ( 1 )
      {
        v6 = sk_value(v3, v5);
        v7 = (__int64 *)v6;
        if ( !v6[2] || (v8 = (const char *)v6[1]) == 0LL )
        {
          sk_pop_free(v4, (void (*)(void))POLICY_MAPPING_free);
          v14 = 131;
LABEL_14:
          ERR_put_error(20, 0LL, 129, (__int64)"external/boringssl/src/crypto/x509v3/v3_pmaps.c", v14);
          ERR_add_error_data(
            6u,
            (__int64)"section:",
            *v7,
            (__int64)",name:",
            v7[1],
            (__int64)",value:",
            v7[2],
            v15,
            v17);
          goto LABEL_16;
        }
        OBJ_txt2obj(v8, 0);
        v10 = v9;
        OBJ_txt2obj((const char *)v7[2], 0);
        v12 = v11;
        if ( !v10 || !v11 )
        {
          sk_pop_free(v4, (void (*)(void))POLICY_MAPPING_free);
          v14 = 139;
          goto LABEL_14;
        }
        v13 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&POLICY_MAPPING_it);
        if ( !v13 )
          break;
        *v13 = v10;
        v13[1] = v12;
        sk_push(v4, (__int64)v13);
        if ( ++v5 >= (unsigned __int64)sk_num(v3) )
          return v4;
      }
      sk_pop_free(v4, (void (*)(void))POLICY_MAPPING_free);
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_pmaps.c", 146);
LABEL_16:
      v4 = 0LL;
    }
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_pmaps.c", 123);
  }
  return v4;
}

//----- (00000000000979F8) ----------------------------------------------------
__int64 POLICY_MAPPING_new()
{
  return ASN1_item_new((unsigned __int8 *)&POLICY_MAPPING_it);
}

//----- (0000000000097A04) ----------------------------------------------------
void __fastcall POLICY_MAPPING_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&POLICY_MAPPING_it);
}

//----- (0000000000097A10) ----------------------------------------------------
__int64 __fastcall X509_check_purpose(__int64 a1, int a2)
{
  int v2; // w21
  __int64 v3; // x8
  unsigned __int64 *v4; // x0
  __int64 result; // x0
  signed int v6; // w9
  __int64 v7; // [xsp+0h] [xbp-60h]
  int v8; // [xsp+8h] [xbp-58h]
  __int64 v9; // [xsp+38h] [xbp-28h]

  v2 = a2;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  sub_97B0C(a1);
  if ( v2 == -1 )
  {
    result = 1LL;
    goto LABEL_14;
  }
  LODWORD(v3) = v2 - 1;
  if ( (unsigned int)(v2 - 1) > 8 )
  {
    v8 = v2;
    if ( !qword_1073C8 || !(unsigned int)sk_find(qword_1073C8, &v7, (__int64)&v8) || (v6 = v7 + 9, (_DWORD)v7 == -10) )
    {
      result = 0xFFFFFFFFLL;
      goto LABEL_14;
    }
    if ( v6 & 0x80000000 )
    {
      v4 = 0LL;
      goto LABEL_5;
    }
    v3 = v6;
    if ( v6 > 8 )
    {
      v4 = sk_value((unsigned __int64 *)qword_1073C8, v6 - 9LL);
      goto LABEL_5;
    }
  }
  else
  {
    v3 = (signed int)v3;
  }
  v4 = (unsigned __int64 *)((char *)&unk_106658 + 48 * v3);
LABEL_5:
  result = ((__int64 (*)(void))v4[2])();
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
  return result;
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (0000000000097B0C) ----------------------------------------------------
__int64 __fastcall sub_97B0C(__int64 a1)
{
  __int64 v1; // x20
  pthread_rwlock_t *v2; // x19
  __int64 v3; // x21
  __int64 result; // x0
  unsigned __int64 *v5; // x0
  unsigned __int64 *v6; // x21
  signed __int64 v7; // x0
  signed __int64 v8; // x0
  signed __int64 *v9; // x21
  signed __int64 v10; // x0
  unsigned __int64 *v11; // x0
  __int64 v12; // x8
  unsigned __int64 *v13; // x0
  unsigned __int64 *v14; // x21
  unsigned __int64 v15; // x22
  unsigned __int64 *v16; // x0
  int v17; // w0
  signed __int64 v18; // x8
  unsigned __int64 *v19; // x0
  __int64 v20; // x8
  __int64 v21; // x9
  __int64 v22; // x21
  __int64 v23; // x0
  _QWORD *v24; // x1
  __int64 v25; // x8
  unsigned __int64 *v26; // x0
  unsigned __int64 *v27; // x0
  unsigned __int64 v28; // x21
  unsigned __int64 *v29; // x0
  unsigned __int64 *v30; // x22
  unsigned __int64 v31; // x10
  unsigned int v32; // w9
  unsigned int *v33; // x8
  _DWORD *v34; // x8
  unsigned __int64 v35; // x23
  unsigned __int64 *v36; // x0
  __int64 v37; // x1
  unsigned __int64 *v38; // x0
  unsigned __int64 *v39; // x23
  unsigned int *v40; // x0
  unsigned int *v41; // x0
  signed int v42; // w23
  int v43; // [xsp+0h] [xbp-40h]
  int v44; // [xsp+4h] [xbp-3Ch]
  __int64 v45; // [xsp+8h] [xbp-38h]

  v1 = a1;
  v2 = (pthread_rwlock_t *)(a1 + 184);
  v45 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)(a1 + 184));
  v3 = *(_QWORD *)(v1 + 64);
  result = CRYPTO_STATIC_MUTEX_unlock_write(v2);
  if ( !(v3 & 0x100) )
  {
    CRYPTO_STATIC_MUTEX_lock_write(v2);
    if ( !(*(_BYTE *)(v1 + 65) & 1) )
    {
      EVP_sha1();
      X509_digest();
      if ( !ASN1_INTEGER_get(**(_QWORD **)v1) )
        *(_QWORD *)(v1 + 64) |= 0x40uLL;
      v5 = X509_get_ext_d2i(v1, 87, 0LL, 0LL);
      v6 = v5;
      if ( v5 )
      {
        if ( *(_DWORD *)v5 )
          *(_QWORD *)(v1 + 64) |= 0x10uLL;
        v7 = v5[1];
        if ( v7 )
        {
          if ( *(_DWORD *)(v7 + 4) != 258 && *(_DWORD *)v6 )
          {
            v8 = ASN1_INTEGER_get(v7);
          }
          else
          {
            v8 = 0LL;
            *(_QWORD *)(v1 + 64) |= 0x80uLL;
          }
        }
        else
        {
          v8 = -1LL;
        }
        *(_QWORD *)(v1 + 48) = v8;
        BASIC_CONSTRAINTS_free((__int64)v6);
        *(_QWORD *)(v1 + 64) |= 1uLL;
      }
      v9 = (signed __int64 *)X509_get_ext_d2i(v1, 663, 0LL, 0LL);
      if ( v9 )
      {
        if ( *(_BYTE *)(v1 + 64) & 0x10
          || !(X509_get_ext_by_NID(v1, 0x55u, -1) & 0x80000000)
          || !(X509_get_ext_by_NID(v1, 0x56u, -1) & 0x80000000) )
        {
          *(_QWORD *)(v1 + 64) |= 0x80uLL;
        }
        if ( *v9 )
          v10 = ASN1_INTEGER_get(*v9);
        else
          v10 = -1LL;
        *(_QWORD *)(v1 + 56) = v10;
        PROXY_CERT_INFO_EXTENSION_free((__int64)v9);
        *(_QWORD *)(v1 + 64) |= 0x400uLL;
      }
      v11 = X509_get_ext_d2i(v1, 83, 0LL, 0LL);
      if ( v11 )
      {
        if ( *(_DWORD *)v11 < 1 )
        {
          *(_QWORD *)(v1 + 72) = 0LL;
        }
        else
        {
          v12 = *(unsigned __int8 *)v11[1];
          *(_QWORD *)(v1 + 72) = v12;
          if ( *(_DWORD *)v11 >= 2 )
            *(_QWORD *)(v1 + 72) = v12 & 0xFFFFFFFFFFFF00FFLL | ((unsigned __int64)*(unsigned __int8 *)(v11[1] + 1) << 8);
        }
        *(_QWORD *)(v1 + 64) |= 2uLL;
        ASN1_VISIBLESTRING_free(v11);
      }
      *(_QWORD *)(v1 + 80) = 0LL;
      v13 = X509_get_ext_d2i(v1, 126, 0LL, 0LL);
      v14 = v13;
      if ( v13 )
      {
        *(_QWORD *)(v1 + 64) |= 4uLL;
        if ( sk_num(v13) )
        {
          v15 = 0LL;
          while ( 1 )
          {
            v16 = sk_value(v14, v15);
            v17 = (unsigned __int64)OBJ_obj2nid((unsigned int *)v16);
            v18 = 1LL;
            switch ( 1 )
            {
              case 0:
                goto LABEL_44;
              case 1:
                v18 = 2LL;
                goto LABEL_44;
              case 2:
                v18 = 8LL;
                goto LABEL_44;
              case 3:
                v18 = 4LL;
                goto LABEL_44;
              case 4:
                v18 = 64LL;
                goto LABEL_44;
              case 5:
              case 6:
              case 7:
              case 9:
              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
              case 24:
              case 25:
              case 26:
              case 27:
              case 28:
              case 29:
              case 30:
              case 31:
              case 32:
              case 33:
              case 34:
              case 35:
              case 36:
              case 37:
              case 38:
              case 39:
              case 40:
              case 41:
              case 42:
              case 43:
              case 44:
              case 45:
              case 46:
              case 47:
              case 48:
              case 49:
              case 50:
                goto LABEL_45;
              case 8:
              case 10:
                v18 = 16LL;
                goto LABEL_44;
              case 51:
                v18 = 32LL;
                goto LABEL_44;
              default:
                if ( v17 == 297 )
                {
                  v18 = 128LL;
                }
                else
                {
                  if ( v17 != 910 )
                    goto LABEL_45;
                  v18 = 256LL;
                }
LABEL_44:
                *(_QWORD *)(v1 + 80) |= v18;
LABEL_45:
                if ( ++v15 >= (unsigned __int64)sk_num(v14) )
                  goto LABEL_46;
                break;
            }
          }
        }
LABEL_46:
        sk_pop_free(v14, (void (*)(void))ASN1_OBJECT_free);
      }
      v19 = X509_get_ext_d2i(v1, 71, 0LL, 0LL);
      if ( v19 )
      {
        if ( *(_DWORD *)v19 < 1 )
          v20 = 0LL;
        else
          v20 = *(unsigned __int8 *)v19[1];
        v21 = *(_QWORD *)(v1 + 64);
        *(_QWORD *)(v1 + 88) = v20;
        *(_QWORD *)(v1 + 64) = v21 | 8;
        ASN1_VISIBLESTRING_free(v19);
      }
      *(_QWORD *)(v1 + 96) = X509_get_ext_d2i(v1, 82, 0LL, 0LL);
      *(_QWORD *)(v1 + 104) = X509_get_ext_d2i(v1, 90, 0LL, 0LL);
      v22 = X509_get_subject_name(v1);
      v23 = X509_get_issuer_name(v1);
      if ( !(unsigned int)X509_NAME_cmp(v22, v23) )
      {
        v24 = *(_QWORD **)(v1 + 104);
        *(_QWORD *)(v1 + 64) |= 0x20uLL;
        if ( !(unsigned int)X509_check_akid(v1, v24) )
        {
          v25 = *(_QWORD *)(v1 + 64);
          if ( !(v25 & 2) || *(_BYTE *)(v1 + 72) & 4 )
            *(_QWORD *)(v1 + 64) = v25 | 0x2000;
        }
      }
      *(_QWORD *)(v1 + 128) = X509_get_ext_d2i(v1, 85, 0LL, 0LL);
      v26 = X509_get_ext_d2i(v1, 666, &v43, 0LL);
      *(_QWORD *)(v1 + 136) = v26;
      if ( !v26 && v43 != -1 )
        *(_QWORD *)(v1 + 64) |= 0x80uLL;
      v27 = X509_get_ext_d2i(v1, 103, 0LL, 0LL);
      *(_QWORD *)(v1 + 120) = v27;
      if ( sk_num(v27) )
      {
        v28 = 0LL;
        do
        {
          v29 = sk_value(*(unsigned __int64 **)(v1 + 120), v28);
          v30 = v29;
          v31 = v29[1];
          if ( v31 )
          {
            if ( *(_DWORD *)v31 < 1 )
            {
              v33 = (unsigned int *)(v29 + 3);
              v32 = *((_DWORD *)v29 + 6);
            }
            else
            {
              v32 = **(unsigned __int8 **)(v31 + 8);
              *((_DWORD *)v29 + 6) = v32;
              v33 = (unsigned int *)(v29 + 3);
              if ( *(_DWORD *)v31 > 1 )
              {
                v32 = v32 & 0xFFFF00FF | (*(unsigned __int8 *)(*(_QWORD *)(v31 + 8) + 1LL) << 8);
                *v33 = v32;
              }
            }
            *v33 = v32 & 0x807F;
            v34 = (_DWORD *)*v29;
            if ( *v29 )
            {
LABEL_70:
              if ( *v34 == 1 )
              {
                if ( !sk_num((_QWORD *)v29[2]) )
                  goto LABEL_77;
                v35 = 0LL;
                while ( 1 )
                {
                  v36 = sk_value((unsigned __int64 *)v30[2], v35);
                  if ( *(_DWORD *)v36 == 4 )
                    break;
                  if ( ++v35 >= (unsigned __int64)sk_num((_QWORD *)v30[2]) )
                    goto LABEL_77;
                }
                v37 = v36[1];
                if ( !v37 )
LABEL_77:
                  v37 = X509_get_issuer_name(v1);
                DIST_POINT_set_dpname(*v30, v37);
              }
              goto LABEL_79;
            }
          }
          else
          {
            *((_DWORD *)v29 + 6) = 32895;
            v34 = (_DWORD *)*v29;
            if ( *v29 )
              goto LABEL_70;
          }
LABEL_79:
          ++v28;
        }
        while ( v28 < (unsigned __int64)sk_num(*(_QWORD **)(v1 + 120)) );
      }
      v43 = 0;
      if ( (signed int)X509_get_ext_count(v1) >= 1 )
      {
        while ( 1 )
        {
          v38 = X509_get_ext(v1, v43);
          v39 = v38;
          v40 = (unsigned int *)sk_num(v38);
          if ( (unsigned int)OBJ_obj2nid(v40) == 857 )
            *(_QWORD *)(v1 + 64) |= 0x1000uLL;
          if ( (unsigned int)X509_EXTENSION_get_critical((__int64)v39) )
          {
            v41 = (unsigned int *)sk_num(v39);
            v44 = (unsigned __int64)OBJ_obj2nid(v41);
            if ( !v44 || !bsearch(&v44, &unk_DD494, 0xBuLL, 4uLL, (__compar_fn_t)sub_98748) )
              break;
          }
          v42 = ++v43;
          if ( v42 >= (signed int)X509_get_ext_count(v1) )
            goto LABEL_89;
        }
        *(_QWORD *)(v1 + 64) |= 0x200uLL;
      }
LABEL_89:
      *(_QWORD *)(v1 + 64) |= 0x100uLL;
    }
    result = CRYPTO_STATIC_MUTEX_unlock_write(v2);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (0000000000098124) ----------------------------------------------------
signed __int64 __fastcall X509_PURPOSE_get_by_id(int a1)
{
  int v1; // w8
  signed __int64 result; // x0
  signed __int64 v3; // [xsp+0h] [xbp-40h]
  int v4; // [xsp+8h] [xbp-38h]
  __int64 v5; // [xsp+38h] [xbp-8h]

  v1 = a1;
  result = (unsigned int)(a1 - 1);
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)result >= 9 )
  {
    v4 = v1;
    if ( qword_1073C8 && (unsigned int)sk_find(qword_1073C8, &v3, (__int64)&v4) )
      result = (unsigned int)(v3 + 9);
    else
      result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (00000000000981A0) ----------------------------------------------------
unsigned __int64 *__fastcall X509_PURPOSE_get0(signed int a1)
{
  if ( a1 & 0x80000000 )
    return 0LL;
  if ( a1 > 8 )
    return sk_value((unsigned __int64 *)qword_1073C8, a1 - 9LL);
  return (unsigned __int64 *)((char *)&unk_106658 + 48 * a1);
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (00000000000981EC) ----------------------------------------------------
signed __int64 __fastcall X509_PURPOSE_set(int *a1, int a2)
{
  int v2; // w19
  int *v3; // x20
  signed __int64 result; // x0
  signed __int64 v5; // [xsp+0h] [xbp-50h]
  int v6; // [xsp+8h] [xbp-48h]
  __int64 v7; // [xsp+38h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a2 - 1) <= 8
    || (v6 = a2, qword_1073C8) && (unsigned int)sk_find(qword_1073C8, &v5, (__int64)&v6) && (_DWORD)v5 != -10 )
  {
    result = 1LL;
    *v3 = v2;
  }
  else
  {
    ERR_put_error(20, 0LL, 133, (__int64)"external/boringssl/src/crypto/x509v3/v3_purp.c", 162);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (000000000009829C) ----------------------------------------------------
signed __int64 X509_PURPOSE_get_count()
{
  signed __int64 result; // x0

  if ( qword_1073C8 )
    result = (unsigned int)sk_num((_QWORD *)qword_1073C8) + 9;
  else
    result = 9LL;
  return result;
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (00000000000982C8) ----------------------------------------------------
signed __int64 __fastcall X509_PURPOSE_get_by_sname(const char *a1)
{
  const char *v1; // x19
  signed __int64 v2; // x20
  unsigned __int64 *v3; // x21
  unsigned __int64 *v4; // x0

  v1 = a1;
  v2 = 0LL;
  v3 = (unsigned __int64 *)&unk_106658;
  while ( qword_1073C8 )
  {
    if ( v2 >= (signed int)((char *)sk_num((_QWORD *)qword_1073C8) + 9) )
      return 0xFFFFFFFFLL;
LABEL_6:
    v4 = v3;
    if ( v2 >= 9 )
      v4 = sk_value((unsigned __int64 *)qword_1073C8, v2 - 9);
    ++v2;
    v3 += 6;
    if ( !(unsigned int)strcmp((const char *)v4[4], v1) )
      return (unsigned int)(v2 - 1);
  }
  if ( v2 < 9 )
    goto LABEL_6;
  return 0xFFFFFFFFLL;
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (000000000009835C) ----------------------------------------------------
signed __int64 __fastcall X509_PURPOSE_add(int a1, int a2, int a3, unsigned __int64 a4, const char *a5, const char *a6, unsigned __int64 a7)
{
  int v7; // w23
  unsigned __int64 v8; // x20
  const char *v9; // x25
  const char *v10; // x26
  unsigned __int64 v11; // x21
  int v12; // w24
  int v13; // w22
  __int64 v14; // x8
  signed int v15; // w27
  unsigned __int64 *v16; // x19
  signed int v17; // w9
  unsigned __int64 *v18; // x0
  _BYTE *v19; // x26
  _BYTE *v20; // x0
  void *v21; // x25
  int v22; // w8
  unsigned int v23; // w24
  unsigned __int64 *v24; // x0
  signed __int64 result; // x0
  int v26; // w8
  int v27; // w8
  __int64 v28; // [xsp+0h] [xbp-90h]
  int v29; // [xsp+8h] [xbp-88h]
  __int64 v30; // [xsp+38h] [xbp-58h]

  v7 = a1;
  v8 = a7;
  v9 = a6;
  v10 = a5;
  v11 = a4;
  v12 = a3;
  v13 = a2;
  LODWORD(v14) = a1 - 1;
  v30 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a1 - 1) <= 8 )
  {
    v14 = (signed int)v14;
LABEL_3:
    v15 = 0;
    v16 = (unsigned __int64 *)((char *)&unk_106658 + 48 * v14);
    goto LABEL_12;
  }
  v29 = a1;
  if ( qword_1073C8 )
  {
    if ( (unsigned int)sk_find(qword_1073C8, &v28, (__int64)&v29) )
    {
      v17 = v28 + 9;
      if ( (_DWORD)v28 != -10 )
      {
        if ( v17 & 0x80000000 )
        {
          v15 = 0;
          v16 = 0LL;
          goto LABEL_12;
        }
        v14 = v17;
        if ( v17 > 8 )
        {
          v16 = sk_value((unsigned __int64 *)qword_1073C8, v17 - 9LL);
          v15 = 0;
          goto LABEL_12;
        }
        goto LABEL_3;
      }
    }
  }
  v18 = (unsigned __int64 *)malloc(0x30uLL);
  v16 = v18;
  if ( !v18 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_purp.c", 232);
    goto LABEL_29;
  }
  v15 = 1;
  *((_DWORD *)v18 + 2) = 1;
LABEL_12:
  v19 = BUF_strdup(v10);
  v20 = BUF_strdup(v9);
  v21 = v20;
  if ( !v19 || !v20 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_purp.c", 243);
    if ( v19 )
      free(v19);
    if ( v21 )
      free(v21);
    if ( !v15 )
      goto LABEL_29;
    goto LABEL_26;
  }
  v22 = *((_DWORD *)v16 + 2);
  v23 = v12 & 0xFFFFFFFC;
  if ( v22 & 2 )
  {
    free((void *)v16[3]);
    free((void *)v16[4]);
    v22 = *((_DWORD *)v16 + 2);
  }
  v16[2] = v11;
  v16[3] = (unsigned __int64)v19;
  *(_DWORD *)v16 = v7;
  *((_DWORD *)v16 + 1) = v13;
  *((_DWORD *)v16 + 2) = v23 | v22 & 1 | 2;
  v16[4] = (unsigned __int64)v21;
  v16[5] = v8;
  if ( !v15 )
  {
    result = 1LL;
    goto LABEL_30;
  }
  v24 = (unsigned __int64 *)qword_1073C8;
  if ( !qword_1073C8 )
  {
    v24 = sk_new((__int64)sub_985F0);
    qword_1073C8 = (__int64)v24;
    if ( !v24 )
    {
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_purp.c", 274);
      v27 = *((_DWORD *)v16 + 2);
      result = 0LL;
      if ( !(v27 & 1) )
        goto LABEL_30;
      if ( !(v27 & 2) )
        goto LABEL_26;
      goto LABEL_38;
    }
  }
  if ( !sk_push(v24, (__int64)v16) )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_purp.c", 279);
    v26 = *((_DWORD *)v16 + 2);
    result = 0LL;
    if ( !(v26 & 1) )
      goto LABEL_30;
    if ( !(v26 & 2) )
      goto LABEL_26;
LABEL_38:
    free((void *)v16[3]);
    free((void *)v16[4]);
LABEL_26:
    free(v16);
LABEL_29:
    result = 0LL;
    goto LABEL_30;
  }
  result = 1LL;
LABEL_30:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v30;
  return result;
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (00000000000985F0) ----------------------------------------------------
__int64 __fastcall sub_985F0(_DWORD **a1, _DWORD **a2)
{
  return (unsigned int)(**a1 - **a2);
}

//----- (0000000000098608) ----------------------------------------------------
void __fastcall sub_98608(__int64 a1)
{
  void **v1; // x19
  int v2; // w8

  v1 = (void **)a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 8);
    if ( v2 & 1 )
    {
      if ( v2 & 2 )
      {
        free(*(void **)(a1 + 24));
        free(v1[4]);
      }
      free(v1);
    }
  }
}

//----- (0000000000098654) ----------------------------------------------------
void X509_PURPOSE_cleanup()
{
  __int64 v0; // x20
  int v1; // w8

  sk_pop_free((unsigned __int64 *)qword_1073C8, (void (*)(void))sub_98608);
  v0 = 0LL;
  do
  {
    if ( (_UNKNOWN *)((char *)&unk_106658 + v0) )
    {
      v1 = *(_DWORD *)((char *)&unk_106658 + v0 + 8);
      if ( v1 & 1 )
      {
        if ( v1 & 2 )
        {
          free(*(void **)((char *)&unk_106658 + v0 + 24));
          free(*(void **)((char *)&unk_106658 + v0 + 32));
        }
        free((char *)&unk_106658 + v0);
      }
    }
    v0 += 48LL;
  }
  while ( v0 != 432 );
  qword_1073C8 = 0LL;
}
// 1073C8: using guessed type __int64 qword_1073C8;

//----- (00000000000986D4) ----------------------------------------------------
unsigned int *__fastcall X509_supported_extension(_QWORD *a1)
{
  unsigned int *v1; // x0
  unsigned int *result; // x0
  int v3; // [xsp+4h] [xbp-Ch]
  __int64 v4; // [xsp+8h] [xbp-8h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v1 = (unsigned int *)sk_num(a1);
  result = OBJ_obj2nid(v1);
  v3 = (signed int)result;
  if ( (_DWORD)result )
    result = (unsigned int *)(bsearch(&v3, &unk_DD494, 0xBuLL, 4uLL, (__compar_fn_t)sub_98748) != 0LL);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000098748) ----------------------------------------------------
__int64 __fastcall sub_98748(_DWORD *a1, _DWORD *a2)
{
  return (unsigned int)(*a1 - *a2);
}

//----- (0000000000098758) ----------------------------------------------------
signed __int64 __fastcall X509_check_ca(__int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x8
  signed __int64 result; // x0

  v1 = a1;
  sub_97B0C(a1);
  v2 = *(_QWORD *)(v1 + 64);
  if ( v2 & 2 && !(*(_BYTE *)(v1 + 72) & 4) )
    return 0LL;
  if ( v2 & 1 )
    return ((unsigned int)v2 >> 4) & 1;
  if ( (*(_QWORD *)(v1 + 64) & 0x2040LL) == 8256 )
    result = 3LL;
  else
    result = 4LL;
  if ( (*(_QWORD *)(v1 + 64) & 0x2040LL) != 8256 && !(v2 & 2) )
  {
    if ( v2 & 8 && *(_BYTE *)(v1 + 88) & 7 )
      return 5LL;
    return 0LL;
  }
  return result;
}

//----- (00000000000987CC) ----------------------------------------------------
signed __int64 __fastcall X509_check_issued(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 v4; // x21
  __int64 v5; // x0
  signed __int64 result; // x0
  _QWORD *v7; // x1
  signed __int64 v8; // x8

  v2 = a2;
  v3 = a1;
  v4 = X509_get_subject_name(a1);
  v5 = X509_get_issuer_name(v2);
  if ( (unsigned int)X509_NAME_cmp(v4, v5) )
    return 29LL;
  sub_97B0C(v3);
  sub_97B0C(v2);
  v7 = *(_QWORD **)(v2 + 104);
  if ( !v7 || (result = X509_check_akid(v3, v7), !(_DWORD)result) )
  {
    v8 = *(_QWORD *)(v3 + 64) & 2LL;
    if ( *(_BYTE *)(v2 + 65) & 4 )
    {
      if ( v8 && !(*(_BYTE *)(v3 + 72) & 0x80) )
        return 39LL;
    }
    else if ( v8 && !(*(_BYTE *)(v3 + 72) & 4) )
    {
      return 32LL;
    }
    result = 0LL;
  }
  return result;
}

//----- (000000000009887C) ----------------------------------------------------
signed __int64 __fastcall X509_check_akid(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  __int64 v3; // x19
  __int64 v4; // x0
  __int64 v5; // x1
  signed __int64 result; // x0
  __int64 v7; // x0
  unsigned __int64 *v8; // x20
  unsigned __int64 v9; // x21
  unsigned __int64 *v10; // x0
  __int64 v11; // x20
  __int64 v12; // x0

  v2 = a2;
  v3 = a1;
  if ( !a2 )
    goto LABEL_18;
  v4 = *a2;
  if ( *a2 )
  {
    v5 = *(_QWORD *)(v3 + 96);
    if ( v5 )
    {
      if ( (unsigned int)ASN1_OCTET_STRING_cmp(v4, v5) )
        return 30LL;
    }
  }
  if ( v2[2] )
  {
    v7 = X509_get_serialNumber(v3);
    if ( (unsigned int)ASN1_INTEGER_cmp(v7, v2[2]) )
      return 31LL;
  }
  v8 = (unsigned __int64 *)v2[1];
  if ( !v8 || !sk_num(v8) )
    goto LABEL_18;
  v9 = 0LL;
  while ( 1 )
  {
    v10 = sk_value(v8, v9);
    if ( *(_DWORD *)v10 == 4 )
      break;
    if ( ++v9 >= (unsigned __int64)sk_num(v8) )
      goto LABEL_18;
  }
  v11 = v10[1];
  if ( v11 && (v12 = X509_get_issuer_name(v3), (unsigned int)X509_NAME_cmp(v11, v12)) )
    result = 31LL;
  else
LABEL_18:
    result = 0LL;
  return result;
}
// A00C8: using guessed type __int64 __fastcall ASN1_OCTET_STRING_cmp(_QWORD, _QWORD);

//----- (0000000000098960) ----------------------------------------------------
signed __int64 __fastcall sub_98960(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0
  __int64 v5; // x8

  v3 = *(_QWORD *)(a2 + 64);
  if ( v3 & 4 && !(*(_BYTE *)(a2 + 80) & 2) )
    return 0LL;
  if ( !a3 )
  {
    if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 0x88) )
      result = 0LL;
    else
      result = !(v3 & 8) || *(_BYTE *)(a2 + 88) & 0x80;
    return result;
  }
  if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 4) )
    return 0LL;
  if ( v3 & 1 )
  {
    result = ((unsigned int)v3 >> 4) & 1;
  }
  else
  {
    if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) == 8256 )
      result = 3LL;
    else
      result = 4LL;
    if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) != 8256 && !(v3 & 2) )
    {
      if ( !(v3 & 8) )
        return 0LL;
      v5 = *(_QWORD *)(a2 + 88);
      if ( v5 & 7 )
      {
        if ( !(v5 & 4) )
          return 0LL;
        return 5LL;
      }
      return 0LL;
    }
  }
  if ( !(result & 7) )
    return 0LL;
  if ( (result & 7) == 5 )
  {
    if ( !(*(_QWORD *)(a2 + 88) & 4) )
      return 0LL;
    return 5LL;
  }
  return result;
}

//----- (0000000000098A48) ----------------------------------------------------
signed __int64 __fastcall sub_98A48(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0
  __int64 v5; // x8

  v3 = *(_QWORD *)(a2 + 64);
  if ( v3 & 4 && !(*(_BYTE *)(a2 + 80) & 0x11) )
    return 0LL;
  if ( !a3 )
  {
    if ( !(v3 & 8) || *(_BYTE *)(a2 + 88) & 0x40 )
      result = !(v3 & 2) || *(_BYTE *)(a2 + 72) & 0xA8;
    else
      result = 0LL;
    return result;
  }
  if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 4) )
    return 0LL;
  if ( v3 & 1 )
  {
    result = ((unsigned int)v3 >> 4) & 1;
  }
  else
  {
    if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) == 8256 )
      result = 3LL;
    else
      result = 4LL;
    if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) != 8256 && !(v3 & 2) )
    {
      if ( !(v3 & 8) )
        return 0LL;
      v5 = *(_QWORD *)(a2 + 88);
      if ( v5 & 7 )
      {
        if ( !(v5 & 4) )
          return 0LL;
        return 5LL;
      }
      return 0LL;
    }
  }
  if ( !(result & 7) )
    return 0LL;
  if ( (result & 7) == 5 )
  {
    if ( !(*(_QWORD *)(a2 + 88) & 4) )
      return 0LL;
    return 5LL;
  }
  return result;
}

//----- (0000000000098B38) ----------------------------------------------------
signed __int64 __fastcall sub_98B38(__int64 a1, __int64 a2, int a3)
{
  int v3; // w20
  __int64 v4; // x19
  signed __int64 result; // x0

  v3 = a3;
  v4 = a2;
  result = sub_98A48(a1, a2, a3);
  if ( !v3 && (_DWORD)result && *(_BYTE *)(v4 + 64) & 2 && !(*(_BYTE *)(v4 + 72) & 0x20) )
    result = 0LL;
  return result;
}

//----- (0000000000098B78) ----------------------------------------------------
signed __int64 __fastcall sub_98B78(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0
  __int64 v5; // x8
  __int64 v6; // x9

  v3 = *(_QWORD *)(a2 + 64);
  if ( v3 & 4 && !(*(_BYTE *)(a2 + 80) & 4) )
    return 0LL;
  if ( a3 )
  {
    if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 4) )
      return 0LL;
    if ( v3 & 1 )
    {
      result = ((unsigned int)v3 >> 4) & 1;
    }
    else
    {
      if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) == 8256 )
        result = 3LL;
      else
        result = 4LL;
      if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) != 8256 && !(v3 & 2) )
      {
        if ( !(v3 & 8) )
          return 0LL;
        v5 = *(_QWORD *)(a2 + 88);
        if ( !(v5 & 7) )
          return 0LL;
        goto LABEL_21;
      }
    }
    if ( !(result & 7) )
      return 0LL;
    if ( (result & 7) != 5 )
      return result;
    v5 = *(_QWORD *)(a2 + 88);
LABEL_21:
    if ( v5 & 2 )
      return 5LL;
    return 0LL;
  }
  if ( v3 & 8 )
  {
    v6 = *(_QWORD *)(a2 + 88);
    if ( v6 & 0x20 )
    {
      result = 1LL;
    }
    else
    {
      result = ((unsigned int)v6 >> 6) & 2;
      if ( !(_DWORD)result )
        return result;
    }
  }
  else
  {
    result = 1LL;
  }
  if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 0xC0) )
    return 0LL;
  return result;
}

//----- (0000000000098C38) ----------------------------------------------------
signed __int64 __fastcall sub_98C38(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0
  __int64 v5; // x8
  __int64 v6; // x9

  v3 = *(_QWORD *)(a2 + 64);
  if ( v3 & 4 && !(*(_BYTE *)(a2 + 80) & 4) )
    return 0LL;
  if ( a3 )
  {
    if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 4) )
      return 0LL;
    if ( v3 & 1 )
    {
      result = ((unsigned int)v3 >> 4) & 1;
    }
    else
    {
      if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) == 8256 )
        result = 3LL;
      else
        result = 4LL;
      if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) != 8256 && !(v3 & 2) )
      {
        if ( !(v3 & 8) )
          return 0LL;
        v5 = *(_QWORD *)(a2 + 88);
        if ( !(v5 & 7) )
          return 0LL;
        goto LABEL_21;
      }
    }
    if ( !(result & 7) )
      return 0LL;
    if ( (result & 7) != 5 )
      return result;
    v5 = *(_QWORD *)(a2 + 88);
LABEL_21:
    if ( v5 & 2 )
      return 5LL;
    return 0LL;
  }
  if ( v3 & 8 )
  {
    v6 = *(_QWORD *)(a2 + 88);
    if ( v6 & 0x20 )
    {
      result = 1LL;
    }
    else
    {
      result = ((unsigned int)v6 >> 6) & 2;
      if ( !(_DWORD)result )
        return result;
    }
  }
  else
  {
    result = 1LL;
  }
  if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 0x20) )
    return 0LL;
  return result;
}

//----- (0000000000098CF4) ----------------------------------------------------
signed __int64 __fastcall sub_98CF4(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 v4; // x9
  signed __int64 result; // x0

  v3 = *(_QWORD *)(a2 + 64);
  v4 = *(_QWORD *)(a2 + 64) & 2LL;
  if ( !a3 )
    return !v4 || *(_BYTE *)(a2 + 72) & 2;
  if ( v4 && !(*(_BYTE *)(a2 + 72) & 4) )
    return 0LL;
  if ( v3 & 1 )
    return ((unsigned int)v3 >> 4) & 1;
  if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) == 8256 )
    result = 3LL;
  else
    result = 4LL;
  if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) != 8256 && !v4 )
  {
    if ( v3 & 8 && *(_BYTE *)(a2 + 88) & 7 )
      result = 5LL;
    else
      result = 0LL;
  }
  return result;
}

//----- (0000000000098D78) ----------------------------------------------------
signed __int64 __fastcall sub_98D78(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0

  if ( !a3 )
    return 1LL;
  v3 = *(_QWORD *)(a2 + 64);
  if ( v3 & 2 && !(*(_BYTE *)(a2 + 72) & 4) )
    goto LABEL_15;
  if ( v3 & 1 )
    return ((unsigned int)v3 >> 4) & 1;
  if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) == 8256 )
    result = 3LL;
  else
    result = 4LL;
  if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) != 8256 && !(v3 & 2) )
  {
    if ( v3 & 8 && *(_BYTE *)(a2 + 88) & 7 )
      return 5LL;
LABEL_15:
    result = 0LL;
  }
  return result;
}

//----- (0000000000098DDC) ----------------------------------------------------
__int64 __fastcall sub_98DDC(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // x19
  __int64 v4; // x8
  signed __int64 v5; // x9
  __int64 result; // x0
  __int64 v7; // x8
  int v8; // w8
  unsigned __int64 *v9; // x0

  v3 = a2;
  v4 = *(_QWORD *)(a2 + 64);
  v5 = *(_QWORD *)(a2 + 64) & 2LL;
  if ( !a3 )
  {
    if ( v5 )
    {
      result = 0LL;
      if ( !(v4 & 4) )
        return result;
      v7 = *(_QWORD *)(a2 + 72);
      if ( v7 & 0xFFFFFFFFFFFFFF3FLL || !(v7 & 0xC0) )
        return result;
    }
    else if ( !(v4 & 4) )
    {
      return 0LL;
    }
    if ( *(_QWORD *)(a2 + 80) == 64LL )
    {
      v8 = X509_get_ext_by_NID(a2, 0x7Eu, -1);
      if ( v8 & 0x80000000
        || (v9 = X509_get_ext(v3, v8), result = X509_EXTENSION_get_critical((__int64)v9), (_DWORD)result) )
      {
        result = 1LL;
      }
      return result;
    }
    return 0LL;
  }
  if ( v5 && !(*(_BYTE *)(a2 + 72) & 4) )
    return 0LL;
  if ( v4 & 1 )
    return ((unsigned int)v4 >> 4) & 1;
  if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) == 8256 )
    result = 3LL;
  else
    result = 4LL;
  if ( (*(_QWORD *)(a2 + 64) & 0x2040LL) != 8256 && !v5 )
  {
    if ( v4 & 8 && *(_BYTE *)(a2 + 88) & 7 )
      return 5LL;
    return 0LL;
  }
  return result;
}

//----- (0000000000098EBC) ----------------------------------------------------
char *__fastcall i2s_ASN1_OCTET_STRING(__int64 a1, unsigned __int8 **a2)
{
  return sub_99E68(a2[1], *(signed int *)a2);
}

//----- (0000000000098EC8) ----------------------------------------------------
void __fastcall sub_98EC8(__int64 a1, __int64 a2, const char *a3)
{
  const char *v3; // x21
  __int64 v4; // x20
  _DWORD *v5; // x19
  _BYTE *v6; // x0
  _QWORD *v7; // x8
  signed __int64 v8; // x8
  __int16 v9; // w4
  _QWORD *v10; // x8
  signed int *v11; // x8
  __int64 v12; // x20
  __int64 v13; // x21
  void *v14; // x0
  int v15; // w0
  int v16; // w2
  __int16 v17; // w4
  int v18; // [xsp+4h] [xbp-6Ch]
  __int64 v19; // [xsp+8h] [xbp-68h]
  __int64 v20; // [xsp+48h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)strcmp(a3, "hash") )
  {
    v5 = ASN1_STRING_type_new(4);
    if ( !v5 )
    {
      v9 = 116;
      goto LABEL_12;
    }
    if ( v4 )
    {
      if ( *(_DWORD *)v4 == 1 )
        goto LABEL_22;
      v7 = *(_QWORD **)(v4 + 24);
      if ( v7 )
      {
        v8 = *v7 + 40LL;
        goto LABEL_15;
      }
      v10 = *(_QWORD **)(v4 + 16);
      if ( v10 )
      {
        v8 = *v10 + 48LL;
LABEL_15:
        v11 = *(signed int **)(*(_QWORD *)v8 + 8LL);
        if ( v11 )
        {
          v12 = *((_QWORD *)v11 + 1);
          v13 = *v11;
          v14 = EVP_sha1();
          EVP_Digest(v12, v13, (__int64)&v19, &v18, (__int64)v14);
          if ( !v15 )
            goto LABEL_21;
          if ( (unsigned int)ASN1_STRING_set((__int64)v5, (const char *)&v19, v18) )
            goto LABEL_22;
          v16 = 65;
          v17 = 143;
        }
        else
        {
          v16 = 144;
          v17 = 134;
        }
LABEL_20:
        ERR_put_error(20, 0LL, v16, (__int64)"external/boringssl/src/crypto/x509v3/v3_skey.c", v17);
        goto LABEL_21;
      }
    }
    v16 = 144;
    v17 = 124;
    goto LABEL_20;
  }
  v5 = ASN1_STRING_type_new(4);
  if ( !v5 )
  {
    v9 = 89;
LABEL_12:
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_skey.c", v9);
    goto LABEL_22;
  }
  v6 = sub_99F20(v3, &v19);
  *((_QWORD *)v5 + 1) = v6;
  if ( !v6 )
  {
LABEL_21:
    ASN1_STRING_free((__int64)v5);
    goto LABEL_22;
  }
  *v5 = v19;
LABEL_22:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v20;
}

//----- (0000000000099084) ----------------------------------------------------
void __fastcall s2i_ASN1_OCTET_STRING(__int64 a1, __int64 a2, const char *a3)
{
  const char *v3; // x20
  _DWORD *v4; // x19
  _BYTE *v5; // x0
  __int64 v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v3 = a3;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = ASN1_STRING_type_new(4);
  if ( v4 )
  {
    v5 = sub_99F20(v3, &v6);
    *((_QWORD *)v4 + 1) = v5;
    if ( v5 )
      *v4 = v6;
    else
      ASN1_STRING_free((__int64)v4);
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_skey.c", 89);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009912C) ----------------------------------------------------
_QWORD *__fastcall sub_9912C(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x19
  _QWORD *result; // x0
  unsigned __int64 v5; // x20
  unsigned __int64 *v6; // x0
  const char *v7; // x21
  __int64 v8; // x0
  _QWORD *v9; // [xsp+0h] [xbp-30h]
  __int64 v10; // [xsp+8h] [xbp-28h]

  v3 = a3;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = 0LL;
  result = sk_num(a3);
  if ( result )
  {
    v5 = 0LL;
    while ( 1 )
    {
      v6 = sk_value(v3, v5);
      v7 = (const char *)v6[2];
      s2i_ASN1_INTEGER(0LL, (unsigned __int8 *)v6[1]);
      if ( !v8 )
        break;
      if ( !(unsigned int)sub_99354((__int64 *)&v9, v8, v7, -1) )
        goto LABEL_8;
      if ( ++v5 >= (unsigned __int64)sk_num(v3) )
      {
        result = v9;
        goto LABEL_9;
      }
    }
    ERR_put_error(20, 0LL, 108, (__int64)"external/boringssl/src/crypto/x509v3/v3_sxnet.c", 161);
LABEL_8:
    result = 0LL;
  }
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (0000000000099204) ----------------------------------------------------
signed __int64 __fastcall sub_99204(__int64 a1, signed __int64 *a2, _QWORD *a3, unsigned int a4)
{
  signed __int64 *v4; // x20
  unsigned int v5; // w19
  _QWORD *v6; // x21
  signed __int64 v7; // x0
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  unsigned __int64 v16; // x22
  unsigned __int64 *v17; // x25
  void *v18; // x26
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = ASN1_INTEGER_get(*a2);
  BIO_printf(v6, (__int64)"%*sVersion: %ld (0x%lX)", v8, v9, v10, v11, v12, v13, v14, v15, v5, &unk_B8A4C, v7 + 1, v7);
  if ( sk_num((_QWORD *)v4[1]) )
  {
    v16 = 0LL;
    do
    {
      v17 = sk_value((unsigned __int64 *)v4[1], v16);
      v18 = (void *)i2s_ASN1_INTEGER(0LL, (unsigned __int8 **)*v17);
      BIO_printf(v6, (__int64)"\n%*sZone: %s, User: ", v19, v20, v21, v22, v23, v24, v25, v26, v5, &unk_B8A4C, v18);
      free(v18);
      ASN1_STRING_print(v6, v17[1]);
      ++v16;
    }
    while ( v16 < (unsigned __int64)sk_num((_QWORD *)v4[1]) );
  }
  return 1LL;
}

//----- (00000000000992F4) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_SXNETID(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&SXNETID_it);
}

//----- (0000000000099300) ----------------------------------------------------
void i2d_SXNETID()
{
  ASN1_item_i2d();
}

//----- (000000000009930C) ----------------------------------------------------
__int64 SXNETID_new()
{
  return ASN1_item_new((unsigned __int8 *)&SXNETID_it);
}

//----- (0000000000099318) ----------------------------------------------------
void __fastcall SXNETID_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&SXNETID_it);
}

//----- (0000000000099324) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_SXNET(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&SXNET_it);
}

//----- (0000000000099330) ----------------------------------------------------
void i2d_SXNET()
{
  ASN1_item_i2d();
}

//----- (000000000009933C) ----------------------------------------------------
__int64 SXNET_new()
{
  return ASN1_item_new((unsigned __int8 *)&SXNET_it);
}

//----- (0000000000099348) ----------------------------------------------------
void __fastcall SXNET_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&SXNET_it);
}

//----- (0000000000099354) ----------------------------------------------------
signed __int64 __fastcall sub_99354(__int64 *a1, __int64 a2, const char *a3, int a4)
{
  int v4; // w23
  const char *v5; // x22
  __int64 v6; // x21
  __int64 *v7; // x19
  int v8; // w2
  __int16 v9; // w4
  signed __int64 result; // x0
  __int64 v11; // x20
  __int64 *v12; // x0
  unsigned __int64 v13; // x24
  unsigned __int64 *v14; // x25
  _QWORD *v15; // x24

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a1 || !a2 || !a3 )
  {
    v8 = 124;
    v9 = 193;
    goto LABEL_9;
  }
  if ( a4 == -1 )
    v4 = strlen(a3);
  if ( v4 >= 65 )
  {
    v8 = 162;
    v9 = 199;
LABEL_9:
    ERR_put_error(20, 0LL, v8, (__int64)"external/boringssl/src/crypto/x509v3/v3_sxnet.c", v9);
    return 0LL;
  }
  v11 = *v7;
  if ( !*v7 )
  {
    v12 = (__int64 *)ASN1_item_new((unsigned __int8 *)&SXNET_it);
    v11 = (__int64)v12;
    if ( !v12 || !(unsigned int)ASN1_INTEGER_set(*v12, 0LL) )
    {
      v15 = 0LL;
      goto LABEL_29;
    }
    *v7 = v11;
  }
  if ( sk_num(*(_QWORD **)(v11 + 8)) )
  {
    v13 = 0LL;
    while ( 1 )
    {
      v14 = sk_value(*(unsigned __int64 **)(v11 + 8), v13);
      if ( !(unsigned int)ASN1_STRING_cmp((const void **)*v14, v6) )
        break;
      if ( ++v13 >= (unsigned __int64)sk_num(*(_QWORD **)(v11 + 8)) )
        goto LABEL_22;
    }
    if ( v14[1] )
    {
      v8 = 107;
      v9 = 211;
      goto LABEL_9;
    }
  }
LABEL_22:
  v15 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&SXNETID_it);
  if ( v15 )
  {
    if ( v4 == -1 )
      v4 = strlen(v5);
    if ( (unsigned int)ASN1_STRING_set(v15[1], v5, v4) && sk_push(*(unsigned __int64 **)(v11 + 8), (__int64)v15) )
    {
      result = 1LL;
      *v15 = v6;
      return result;
    }
  }
LABEL_29:
  ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_sxnet.c", 228);
  ASN1_item_free((__int64)v15, (unsigned __int8 *)&SXNETID_it);
  ASN1_item_free(v11, (unsigned __int8 *)&SXNET_it);
  result = 0LL;
  *v7 = 0LL;
  return result;
}

//----- (0000000000099530) ----------------------------------------------------
signed __int64 __fastcall X509V3_add_value(const char *a1, char *a2, unsigned __int64 **a3)
{
  unsigned __int64 **v3; // x21
  char *v4; // x20
  _BYTE *v5; // x19
  _QWORD *v6; // x22
  unsigned __int64 *v7; // x0

  v3 = a3;
  v4 = a2;
  if ( a1 )
  {
    v5 = BUF_strdup(a1);
    if ( !v5 )
    {
      v4 = 0LL;
      goto LABEL_12;
    }
  }
  else
  {
    v5 = 0LL;
  }
  if ( v4 && (v4 = BUF_strdup(v4)) == 0LL || (v6 = sub_A5B28()) == 0LL )
  {
LABEL_12:
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 111);
    if ( !v5 )
      goto LABEL_16;
    goto LABEL_15;
  }
  if ( *v3 || (v7 = sk_new_null(), (*v3 = v7) != 0LL) )
  {
    *v6 = 0LL;
    v6[1] = v5;
    v6[2] = v4;
    if ( sk_push(*v3, (__int64)v6) )
      return 1LL;
  }
  ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 111);
  free(v6);
  if ( v5 )
LABEL_15:
    free(v5);
LABEL_16:
  if ( v4 )
    free(v4);
  return 0LL;
}

//----- (0000000000099630) ----------------------------------------------------
void __fastcall X509V3_conf_free(__int64 a1)
{
  __int64 v1; // x19
  void *v2; // x0
  void *v3; // x0

  v1 = a1;
  if ( a1 )
  {
    v2 = *(void **)(a1 + 8);
    if ( v2 )
      free(v2);
    v3 = *(void **)(v1 + 16);
    if ( v3 )
      free(v3);
    if ( *(_QWORD *)v1 )
      free(*(void **)v1);
    free((void *)v1);
  }
}

//----- (0000000000099684) ----------------------------------------------------
signed __int64 __fastcall X509V3_add_value_bool(const char *a1, int a2, unsigned __int64 **a3)
{
  char *v3; // x1

  if ( a2 )
    v3 = "TRUE";
  else
    v3 = "FALSE";
  return X509V3_add_value(a1, v3, a3);
}

//----- (00000000000996A0) ----------------------------------------------------
signed __int64 __fastcall X509V3_add_value_bool_nf(const char *a1, int a2, unsigned __int64 **a3)
{
  signed __int64 result; // x0

  if ( a2 )
    result = X509V3_add_value(a1, "TRUE", a3);
  else
    result = 1LL;
  return result;
}

//----- (00000000000996B8) ----------------------------------------------------
__int64 __fastcall i2s_ASN1_ENUMERATED(__int64 a1, unsigned __int8 **a2)
{
  signed int *v2; // x0
  signed int *v3; // x19
  __int64 v4; // x20

  if ( !a2 )
    return 0LL;
  v2 = (signed int *)ASN1_ENUMERATED_to_BN(a2, 0LL);
  v3 = v2;
  if ( !v2 || (v4 = BN_bn2dec(v2)) == 0 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 166);
    v4 = 0LL;
  }
  BN_free(v3);
  return v4;
}

//----- (000000000009972C) ----------------------------------------------------
__int64 __fastcall i2s_ASN1_INTEGER(__int64 a1, unsigned __int8 **a2)
{
  signed int *v2; // x0
  signed int *v3; // x19
  __int64 v4; // x20

  if ( !a2 )
    return 0LL;
  v2 = (signed int *)ASN1_INTEGER_to_BN(a2, 0LL);
  v3 = v2;
  if ( !v2 || (v4 = BN_bn2dec(v2)) == 0 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 179);
    v4 = 0LL;
  }
  BN_free(v3);
  return v4;
}

//----- (00000000000997A0) ----------------------------------------------------
void __fastcall s2i_ASN1_INTEGER(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // x19
  int v3; // w20
  int v4; // w0
  int v5; // w2
  __int16 v6; // w4
  _BOOL4 v7; // w20
  int *v8; // x19
  _QWORD *v9; // [xsp+0h] [xbp-20h]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v2 = a2;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = 0LL;
  if ( !a2 )
  {
    v5 = 126;
    v6 = 191;
LABEL_12:
    ERR_put_error(20, 0LL, v5, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", v6);
    goto LABEL_13;
  }
  v9 = BN_new();
  v3 = *v2;
  if ( v3 == 45 )
    ++v2;
  if ( *v2 != 48 || (v2[1] | 0x20) != 120 )
  {
    v4 = BN_dec2bn((__int64 *)&v9, v2);
    if ( !v4 )
    {
LABEL_10:
      BN_free(v9);
      ERR_put_error(20, 0LL, 102, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 214);
      goto LABEL_13;
    }
  }
  else
  {
    v2 += 2;
    v4 = BN_hex2bn((__int64 *)&v9, v2);
    if ( !v4 )
      goto LABEL_10;
  }
  if ( v2[v4] )
    goto LABEL_10;
  if ( v3 == 45 )
    v7 = BN_is_zero((__int64)v9) == 0;
  else
    v7 = 0;
  v8 = BN_to_ASN1_INTEGER((__int64)v9, 0LL);
  BN_free(v9);
  if ( !v8 )
  {
    v5 = 103;
    v6 = 224;
    goto LABEL_12;
  }
  if ( v7 )
    v8[1] |= 0x100u;
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v10;
}

//----- (000000000009990C) ----------------------------------------------------
signed __int64 __fastcall X509V3_add_value_int(const char *a1, unsigned __int8 **a2, unsigned __int64 **a3)
{
  unsigned __int64 **v3; // x19
  const char *v4; // x21
  signed int *v5; // x0
  signed int *v6; // x20
  char *v7; // x22
  unsigned int v8; // w19
  signed __int64 result; // x0

  v3 = a3;
  v4 = a1;
  if ( !a2 )
    return 1LL;
  v5 = (signed int *)ASN1_INTEGER_to_BN(a2, 0LL);
  v6 = v5;
  if ( v5 && (v7 = (char *)BN_bn2dec(v5)) != 0LL )
  {
    BN_free(v6);
    v8 = X509V3_add_value(v4, v7, v3);
    free(v7);
    result = v8;
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 179);
    BN_free(v6);
    result = 0LL;
  }
  return result;
}

//----- (00000000000999B8) ----------------------------------------------------
signed __int64 __fastcall X509V3_get_value_bool(__int64 a1, _DWORD *a2)
{
  __int64 *v2; // x19
  const char *v3; // x21
  _DWORD *v4; // x20
  __int64 v5; // x7
  __int64 v7; // [xsp+0h] [xbp-20h]

  v2 = (__int64 *)a1;
  v3 = *(const char **)(a1 + 16);
  v4 = a2;
  if ( !v3 )
    goto LABEL_14;
  if ( (unsigned int)strcmp(*(const char **)(a1 + 16), "TRUE")
    && (unsigned int)strcmp(v3, "true")
    && (unsigned int)strcmp(v3, "Y")
    && (unsigned int)strcmp(v3, "y")
    && (unsigned int)strcmp(v3, "YES")
    && (unsigned int)strcmp(v3, "yes") )
  {
    if ( (unsigned int)strcmp(v3, "FALSE")
      && (unsigned int)strcmp(v3, "false")
      && (unsigned int)strcmp(v3, "N")
      && (unsigned int)strcmp(v3, "n")
      && (unsigned int)strcmp(v3, "NO")
      && (unsigned int)strcmp(v3, "no") )
    {
LABEL_14:
      ERR_put_error(20, 0LL, 120, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 263);
      ERR_add_error_data(6u, (__int64)"section:", *v2, (__int64)",name:", v2[1], (__int64)",value:", v2[2], v5, v7);
      return 0LL;
    }
    *v4 = 0;
  }
  else
  {
    *v4 = 255;
  }
  return 1LL;
}

//----- (0000000000099B38) ----------------------------------------------------
signed __int64 __fastcall X509V3_get_value_int(__int64 a1, _QWORD *a2)
{
  __int64 *v2; // x19
  _QWORD *v3; // x20
  __int64 v4; // x0
  __int64 v5; // x7
  signed __int64 result; // x0
  __int64 v7; // [xsp+0h] [xbp-10h]

  v2 = (__int64 *)a1;
  v3 = a2;
  s2i_ASN1_INTEGER(a1, *(unsigned __int8 **)(a1 + 16));
  if ( v4 )
  {
    *v3 = v4;
    result = 1LL;
  }
  else
  {
    ERR_add_error_data(6u, (__int64)"section:", *v2, (__int64)",name:", v2[1], (__int64)",value:", v2[2], v5, v7);
    result = 0LL;
  }
  return result;
}

//----- (0000000000099BA0) ----------------------------------------------------
unsigned __int64 *__fastcall X509V3_parse_list(const char *a1)
{
  const char *v1; // x0
  char *v2; // x19
  const char *v3; // x20
  signed __int64 v4; // x21
  const char *v5; // x24
  signed int v6; // w25
  unsigned int v7; // w8
  char *v8; // x8
  const char *v9; // x0
  const char *v10; // x0
  char *v11; // x8
  char *v12; // x1
  int v13; // w2
  __int16 v14; // w4
  unsigned __int64 *result; // x0
  unsigned __int64 *v16; // [xsp+0h] [xbp-50h]
  __int64 v17; // [xsp+8h] [xbp-48h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v16 = 0LL;
  v1 = BUF_strdup(a1);
  v2 = (char *)v1;
  if ( !v1 )
  {
    v13 = 65;
    v14 = 296;
    goto LABEL_23;
  }
  v3 = 0LL;
  v4 = (signed __int64)(v1 + 1);
  v5 = v1;
  v6 = 1;
  while ( 1 )
  {
    v7 = *(unsigned __int8 *)(v4 - 1);
    if ( v7 <= 0xD )
    {
      if ( (1 << v7) & 0x2401 )
        break;
    }
    if ( v6 == 2 )
    {
      if ( v7 == 44 )
      {
        *(_BYTE *)(v4 - 1) = 0;
        v8 = (char *)sub_99DEC(v1);
        if ( !v8 )
        {
          v13 = 126;
          v14 = 340;
          goto LABEL_23;
        }
        X509V3_add_value(v3, v8, &v16);
        v3 = 0LL;
        v1 = v5 + 1;
LABEL_15:
        v6 = 1;
        goto LABEL_3;
      }
      v6 = 2;
    }
    else
    {
      if ( v6 != 1 )
        goto LABEL_3;
      if ( v7 == 44 )
      {
        *(_BYTE *)(v4 - 1) = 0;
        v9 = sub_99DEC(v1);
        v3 = v9;
        if ( !v9 )
        {
          v13 = 125;
          v14 = 324;
          goto LABEL_23;
        }
        X509V3_add_value(v9, 0LL, &v16);
        v6 = 1;
        v1 = (const char *)v4;
      }
      else
      {
        if ( v7 != 58 )
          goto LABEL_15;
        *(_BYTE *)(v4 - 1) = 0;
        v3 = sub_99DEC(v1);
        if ( !v3 )
        {
          v13 = 125;
          v14 = 312;
          goto LABEL_23;
        }
        v1 = v5 + 1;
        v6 = 2;
      }
    }
LABEL_3:
    ++v5;
    ++v4;
  }
  v10 = sub_99DEC(v1);
  v11 = (char *)v10;
  if ( v6 == 2 )
  {
    if ( v10 )
    {
      v10 = v3;
      v12 = v11;
LABEL_26:
      X509V3_add_value(v10, v12, &v16);
      free(v2);
      result = v16;
      goto LABEL_27;
    }
    v13 = 126;
    v14 = 357;
  }
  else
  {
    if ( v10 )
    {
      v12 = 0LL;
      goto LABEL_26;
    }
    v13 = 125;
    v14 = 367;
  }
LABEL_23:
  ERR_put_error(20, 0LL, v13, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", v14);
  free(v2);
  sk_pop_free(v16, (void (*)(void))X509V3_conf_free);
  result = 0LL;
LABEL_27:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v17;
  return result;
}

//----- (0000000000099DEC) ----------------------------------------------------
const char *__fastcall sub_99DEC(const char *a1)
{
  const char *v1; // x19
  unsigned __int8 v2; // w8
  int v3; // t1
  const char *result; // x0
  size_t v5; // x0
  signed __int64 v6; // x20
  int v7; // w8

  v1 = a1;
  v2 = *a1;
  if ( !*a1 )
    return 0LL;
  while ( (unsigned int)isspace(v2) )
  {
    v3 = *((unsigned __int8 *)v1++ + 1);
    v2 = v3;
    if ( !v3 )
      return 0LL;
  }
  v5 = strlen(v1);
  while ( 1 )
  {
    v6 = v5 - 1;
    if ( v5 == 1 )
      break;
    v7 = isspace((unsigned __int8)v1[v5 - 1]);
    v5 = v6;
    if ( !v7 )
    {
      v1[v6 + 1] = 0;
      break;
    }
  }
  if ( *v1 )
    result = v1;
  else
    result = 0LL;
  return result;
}

//----- (0000000000099E68) ----------------------------------------------------
char *__fastcall sub_99E68(unsigned __int8 *a1, signed __int64 a2)
{
  signed __int64 v2; // x19
  unsigned __int8 *v3; // x20
  char *result; // x0
  signed __int64 v5; // x21
  char *v6; // x8
  char *v7; // x10
  unsigned int v8; // t1
  char v9; // w11

  v2 = a2;
  v3 = a1;
  result = 0LL;
  if ( v3 && a2 )
  {
    v5 = 3 * a2;
    result = (char *)malloc(3 * a2 + 1);
    if ( result )
    {
      v6 = result;
      if ( v2 >= 1 )
      {
        v7 = result;
        do
        {
          v8 = *v3++;
          v7[2] = 58;
          --v2;
          v9 = a0123456789abcd_0[v8 & 0xF];
          *v7 = a0123456789abcd_0[(unsigned __int64)v8 >> 4];
          v7[1] = v9;
          v7 += 3;
        }
        while ( v2 );
        v6 = &result[v5];
      }
      *(v6 - 1) = 0;
    }
    else
    {
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 419);
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000099F20) ----------------------------------------------------
_BYTE *__fastcall sub_99F20(const char *a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  const char *v3; // x21
  size_t v4; // x0
  _BYTE *v5; // x0
  _BYTE *v6; // x19
  _BYTE *v7; // x24
  int v8; // w2
  __int16 v9; // w4
  int v10; // w23
  int v11; // w22
  char v12; // w8
  char v13; // w9

  v2 = a2;
  v3 = a1;
  if ( a1 )
  {
    v4 = strlen(a1);
    v5 = malloc(v4 >> 1);
    v6 = v5;
    if ( !v5 )
    {
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 487);
      return v6;
    }
    v7 = v5;
    while ( 2 )
    {
      ++v3;
      do
      {
        v11 = *((unsigned __int8 *)v3 - 1);
        if ( !*(v3 - 1) )
        {
          if ( v2 )
            *v2 = v7 - v6;
          return v6;
        }
        ++v3;
      }
      while ( v11 == 58 );
      v10 = *((unsigned __int8 *)v3 - 1);
      if ( !*(v3 - 1) )
      {
        ERR_put_error(20, 0LL, 146, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", 453);
        free(v6);
        return 0LL;
      }
      if ( (unsigned int)isupper(v11) )
        v11 = tolower(v11);
      if ( (unsigned int)isupper(v10) )
        v10 = tolower(v10);
      if ( ((v11 - 48) & 0xFFu) < 0xA )
      {
        v12 = -48;
        goto LABEL_16;
      }
      if ( ((v11 - 97) & 0xFFu) <= 5 )
      {
        v12 = -87;
LABEL_16:
        if ( ((v10 - 48) & 0xFFu) < 0xA )
        {
          v13 = -48;
LABEL_20:
          *v7++ = (v13 + v10) | 16 * (v12 + v11);
          continue;
        }
        if ( ((v10 - 97) & 0xFFu) <= 5 )
        {
          v13 = -87;
          goto LABEL_20;
        }
      }
      break;
    }
    free(v6);
    v8 = 118;
    v9 = 492;
  }
  else
  {
    v8 = 124;
    v9 = 442;
  }
  ERR_put_error(20, 0LL, v8, (__int64)"external/boringssl/src/crypto/x509v3/v3_utl.c", v9);
  return 0LL;
}

//----- (000000000009A0D4) ----------------------------------------------------
__int64 __fastcall sub_9A0D4(const char *a1, const char *a2)
{
  const char *v2; // x21
  const char *v3; // x19
  int v4; // w0
  __int64 v5; // x20
  __int64 result; // x0

  v2 = a2;
  v3 = a1;
  v4 = strlen(a2);
  v5 = v4;
  result = strncmp(v3, v2, v4);
  if ( !(_DWORD)result && v3[v5] && v3[v5] != 46 )
    result = 1LL;
  return result;
}

//----- (000000000009A134) ----------------------------------------------------
__int64 __fastcall X509_get1_email(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int64 *v2; // x20
  unsigned __int64 **v3; // x0
  __int64 v4; // x19

  v1 = a1;
  v2 = X509_get_ext_d2i(a1, 85, 0LL, 0LL);
  v3 = (unsigned __int64 **)X509_get_subject_name(v1);
  v4 = sub_9A18C(v3, v2);
  sk_pop_free(v2, (void (*)(void))GENERAL_NAME_free);
  return v4;
}

//----- (000000000009A18C) ----------------------------------------------------
__int64 __fastcall sub_9A18C(unsigned __int64 **a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 **v3; // x20
  signed int v4; // w21
  unsigned __int64 *v5; // x0
  __int64 v6; // x0
  __int64 result; // x0
  unsigned __int64 v8; // x20
  unsigned __int64 *v9; // x0
  __int64 v10; // [xsp+0h] [xbp-30h]
  __int64 v11; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v4 = -1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = 0LL;
  while ( 1 )
  {
    v4 = X509_NAME_get_index_by_NID(v3, 0x30u, v4);
    if ( v4 & 0x80000000 )
      break;
    v5 = X509_NAME_get_entry(v3, v4);
    v6 = X509_policy_node_get0_parent((__int64)v5);
    if ( !(unsigned int)sub_9A35C((unsigned __int64 **)&v10, v6) )
      goto LABEL_4;
  }
  if ( sk_num(v2) )
  {
    v8 = 0LL;
    while ( 1 )
    {
      v9 = sk_value(v2, v8);
      if ( *(_DWORD *)v9 == 1 && !(unsigned int)sub_9A35C((unsigned __int64 **)&v10, v9[1]) )
        break;
      if ( ++v8 >= (unsigned __int64)sk_num(v2) )
        goto LABEL_10;
    }
LABEL_4:
    result = 0LL;
    goto LABEL_11;
  }
LABEL_10:
  result = v10;
LABEL_11:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000009A278) ----------------------------------------------------
void __fastcall X509_get1_ocsp(__int64 a1)
{
  unsigned __int64 *v1; // x0
  unsigned __int64 *v2; // x19
  unsigned __int64 v3; // x20
  unsigned __int64 *v4; // x21
  unsigned __int64 v5; // x8
  __int64 v6; // [xsp+0h] [xbp-30h]
  __int64 v7; // [xsp+8h] [xbp-28h]

  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = 0LL;
  v1 = X509_get_ext_d2i(a1, 177, 0LL, 0LL);
  v2 = v1;
  if ( v1 )
  {
    v3 = 0LL;
    if ( sk_num(v1) )
    {
      do
      {
        v4 = sk_value(v2, v3);
        if ( (unsigned int)OBJ_obj2nid((unsigned int *)*v4) == 178 )
        {
          v5 = v4[1];
          if ( *(_DWORD *)v5 == 6 && !(unsigned int)sub_9A35C((unsigned __int64 **)&v6, *(_QWORD *)(v5 + 8)) )
            break;
        }
        ++v3;
      }
      while ( v3 < (unsigned __int64)sk_num(v2) );
    }
    AUTHORITY_INFO_ACCESS_free((__int64)v2);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009A35C) ----------------------------------------------------
unsigned __int64 *__fastcall sub_9A35C(unsigned __int64 **a1, __int64 a2)
{
  __int64 v2; // x20
  unsigned __int64 **v3; // x19
  __int64 v4; // x2
  unsigned __int64 *result; // x0
  _BYTE *v6; // x8

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a2 + 4) != 22 )
    return (_QWORD *)(&dword_0 + 1);
  v4 = *(_QWORD *)(a2 + 8);
  if ( !v4 || !*(_DWORD *)a2 )
    return (_QWORD *)(&dword_0 + 1);
  result = *a1;
  if ( !*v3 )
  {
    result = sk_new((__int64)sub_9AD8C);
    *v3 = result;
    if ( !result )
      return result;
    v4 = *(_QWORD *)(v2 + 8);
  }
  if ( (unsigned int)sk_find((__int64)result, 0LL, v4) )
    return (_QWORD *)(&dword_0 + 1);
  v6 = BUF_strdup(*(const char **)(v2 + 8));
  if ( v6 && sk_push(*v3, (__int64)v6) )
    return (_QWORD *)(&dword_0 + 1);
  sk_pop_free(*v3, (void (*)(void))j__free_1);
  result = 0LL;
  *v3 = 0LL;
  return result;
}
// 0: using guessed type int dword_0;
// 9A494: using guessed type __int64 __fastcall j__free_1();

//----- (000000000009A40C) ----------------------------------------------------
__int64 __fastcall X509_REQ_get1_email(__int64 *a1)
{
  __int64 *v1; // x19
  unsigned __int64 *v2; // x0
  unsigned __int64 *v3; // x20
  unsigned __int64 *v4; // x0
  __int64 v5; // x8
  unsigned __int64 *v6; // x19
  __int64 v7; // x21

  v1 = a1;
  v2 = X509_REQ_get_extensions(a1);
  v3 = v2;
  v4 = X509V3_get_d2i(v2, 85, 0LL, 0LL);
  v5 = *v1;
  v6 = v4;
  v7 = sub_9A18C(*(unsigned __int64 ***)(v5 + 32), v4);
  sk_pop_free(v6, (void (*)(void))GENERAL_NAME_free);
  sk_pop_free(v3, (void (*)(void))X509_EXTENSION_free);
  return v7;
}

//----- (000000000009A488) ----------------------------------------------------
void __fastcall X509_email_free(unsigned __int64 *a1)
{
  sk_pop_free(a1, (void (*)(void))j__free_1);
}
// 9A494: using guessed type __int64 __fastcall j__free_1();

//----- (000000000009A498) ----------------------------------------------------
void __fastcall X509_check_host(__int64 a1, _BYTE *a2, size_t a3, int a4, _QWORD *a5)
{
  _QWORD *v5; // x19
  int v6; // w20
  unsigned __int64 v7; // x21
  _BYTE *v8; // x22
  __int64 v9; // x23

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a2 && (!a3 || !memchr(a2, 0, a3)) )
    sub_9A520(v9, v8, v7, v6, 2, v5);
}

//----- (000000000009A520) ----------------------------------------------------
void __fastcall sub_9A520(__int64 a1, _BYTE *a2, unsigned __int64 a3, int a4, int a5, _QWORD *a6)
{
  int v6; // w25
  size_t v7; // x20
  __int64 v8; // x24
  unsigned int v9; // w22
  __int64 (__fastcall *v10)(); // x8
  signed int v11; // w21
  unsigned int v12; // w23
  unsigned __int64 *v13; // x0
  unsigned __int64 *v14; // x26
  signed int v15; // w19
  unsigned __int64 v16; // x27
  unsigned __int64 *v17; // x0
  signed int *v18; // x19
  const void *v19; // x0
  signed int v20; // w28
  unsigned __int64 **v21; // x24
  signed int v22; // w25
  unsigned __int64 *v23; // x0
  __int64 v24; // x0
  int v25; // w0
  size_t v26; // x26
  signed int v27; // w0
  signed int v28; // w28
  bool (__fastcall *v29)(unsigned __int8 *, size_t, unsigned __int8 *, __int64); // [xsp+8h] [xbp-78h]
  const void *v30; // [xsp+10h] [xbp-70h]
  _QWORD *v31; // [xsp+18h] [xbp-68h]
  void *v32; // [xsp+20h] [xbp-60h]
  __int64 v33; // [xsp+28h] [xbp-58h]

  v30 = a2;
  v31 = a6;
  v6 = a5;
  v7 = a3;
  v8 = a1;
  v9 = a4 & 0xFFFF7FFF;
  v33 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a5 == 1 )
  {
    v29 = sub_9AD98;
    v11 = 22;
    v12 = 48;
  }
  else if ( a5 == 2 )
  {
    if ( a3 >= 2 && *a2 == 46 )
      v9 = a4 | 0x8000;
    v10 = sub_9AEA0;
    if ( !(v9 & 2) )
      v10 = sub_9AF84;
    v11 = 22;
    v29 = (bool (__fastcall *)(unsigned __int8 *, size_t, unsigned __int8 *, __int64))v10;
    v12 = 13;
  }
  else
  {
    v12 = 0;
    v11 = 4;
    v29 = (bool (__fastcall *)(unsigned __int8 *, size_t, unsigned __int8 *, __int64))sub_9B3F4;
  }
  v13 = X509_get_ext_d2i(a1, 85, 0LL, 0LL);
  v14 = v13;
  if ( !v13 )
  {
    if ( !v12 )
      goto LABEL_46;
LABEL_35:
    v21 = (unsigned __int64 **)X509_get_subject_name(v8);
    v22 = -1;
    do
    {
      v22 = X509_NAME_get_index_by_NID(v21, v12, v22);
      if ( v22 & 0x80000000 )
        break;
      while ( 1 )
      {
        v23 = X509_NAME_get_entry(v21, v22);
        v24 = X509_policy_node_get0_parent((__int64)v23);
        if ( *(_QWORD *)(v24 + 8) )
        {
          if ( *(_DWORD *)v24 )
            break;
        }
        v22 = X509_NAME_get_index_by_NID(v21, v12, v22);
        if ( v22 & 0x80000000 )
          goto LABEL_46;
      }
      ASN1_STRING_to_UTF8(&v32, v24);
      if ( v25 & 0x80000000 )
        break;
      v26 = v25;
      v27 = ((__int64 (__fastcall *)(void *, _QWORD, const void *, size_t, _QWORD))v29)(v32, v25, v30, v7, v9);
      v28 = v27;
      if ( v31 && v27 >= 1 )
        *v31 = BUF_strndup(v32, v26);
      free(v32);
    }
    while ( !v28 );
    goto LABEL_46;
  }
  v15 = 0;
  if ( !sk_num(v13) )
  {
LABEL_30:
    GENERAL_NAMES_free((__int64)v14);
    if ( !v12 || !(v9 & 1) && v15 )
      goto LABEL_46;
    goto LABEL_35;
  }
  v16 = 0LL;
  while ( 1 )
  {
    v17 = sk_value(v14, v16);
    if ( *(_DWORD *)v17 == v6 )
      break;
LABEL_29:
    if ( ++v16 >= (unsigned __int64)sk_num(v14) )
      goto LABEL_30;
  }
  v18 = (signed int *)v17[1];
  v19 = (const void *)*((_QWORD *)v18 + 1);
  if ( !v19 || !*v18 || v18[1] != v11 )
    goto LABEL_28;
  if ( v11 == 22 )
  {
    v20 = ((__int64 (*)(void))v29)();
    if ( !v31 )
      goto LABEL_27;
    goto LABEL_26;
  }
  if ( *v18 != (_DWORD)v7 )
  {
LABEL_28:
    v15 = 1;
    goto LABEL_29;
  }
  if ( v7 )
  {
    v20 = (unsigned __int64)memcmp(v19, v30, v7) == 0;
    if ( !v31 )
    {
LABEL_27:
      if ( v20 )
        goto LABEL_49;
      goto LABEL_28;
    }
  }
  else
  {
    v20 = 1;
    if ( !v31 )
      goto LABEL_27;
  }
LABEL_26:
  if ( v20 < 1 )
    goto LABEL_27;
  *v31 = BUF_strndup(*((const void **)v18 + 1), *v18);
LABEL_49:
  GENERAL_NAMES_free((__int64)v14);
LABEL_46:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v33;
}
// 9AEA0: using guessed type __int64 __fastcall sub_9AEA0();
// 9AF84: using guessed type __int64 __fastcall sub_9AF84();
// 9B3F4: using guessed type __int64 __fastcall sub_9B3F4();

//----- (000000000009A82C) ----------------------------------------------------
void __fastcall X509_check_email(__int64 a1, _BYTE *a2, size_t a3, int a4)
{
  int v4; // w19
  unsigned __int64 v5; // x20
  _BYTE *v6; // x21
  __int64 v7; // x22

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a2 && (!a3 || !memchr(a2, 0, a3)) )
    sub_9A520(v7, v6, v5, v4, 1, 0LL);
}

//----- (000000000009A8A4) ----------------------------------------------------
void __fastcall X509_check_ip(__int64 a1, _BYTE *a2, unsigned __int64 a3, int a4)
{
  if ( a2 )
    sub_9A520(a1, a2, a3, a4, 7, 0LL);
}

//----- (000000000009A8BC) ----------------------------------------------------
void __fastcall X509_check_ip_asc(__int64 a1, const char *a2, int a3)
{
  int v3; // w19
  __int64 v4; // x20
  int v5; // w0
  char v6; // [xsp+8h] [xbp-28h]
  __int64 v7; // [xsp+18h] [xbp-18h]

  v3 = a3;
  v4 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 )
  {
    v5 = a2i_ipadd(&v6, a2);
    if ( v5 )
      sub_9A520(v4, &v6, v5, v3, 7, 0LL);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009A93C) ----------------------------------------------------
__int64 __fastcall a2i_ipadd(_BYTE *a1, const char *a2)
{
  const char *v2; // x20
  _BYTE *v3; // x19
  int v4; // w8
  char v5; // w8
  signed int v6; // w9
  unsigned int v7; // w8
  __int64 v8; // x10
  __int64 result; // x0
  int v10; // w9
  int v11; // [xsp+Ch] [xbp-44h]
  int v12; // [xsp+10h] [xbp-40h]
  int v13; // [xsp+14h] [xbp-3Ch]
  __int128 v14; // [xsp+18h] [xbp-38h]
  __int64 v15; // [xsp+28h] [xbp-28h]
  int v16; // [xsp+30h] [xbp-20h]
  __int64 v17; // [xsp+38h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( strchr(a2, 58) )
  {
    v15 = -4294967296LL;
    v16 = 0;
    if ( (unsigned int)sub_A5CC4(
                         v2,
                         0x3Au,
                         0,
                         (__int64 (__fastcall *)(const char *, __int64, __int64))sub_9B4A0,
                         (__int64)&v14) )
    {
      v4 = v15;
      if ( HIDWORD(v15) == -1 )
      {
        if ( (_DWORD)v15 == 16 )
          goto LABEL_14;
      }
      else if ( (_DWORD)v15 != 16 && v16 <= 3 )
      {
        if ( v16 != 2 )
        {
          if ( v16 == 3 )
          {
            if ( (signed int)v15 <= 0 )
              goto LABEL_28;
            goto LABEL_21;
          }
          v6 = 0;
          if ( !HIDWORD(v15) || HIDWORD(v15) == (_DWORD)v15 )
            goto LABEL_16;
LABEL_28:
          if ( !(v15 & 0x8000000000000000LL) )
          {
            if ( HIDWORD(v15) )
            {
              memcpy(v3, &v14, SHIDWORD(v15));
              v10 = HIDWORD(v15);
              v4 = v15;
            }
            else
            {
              v10 = 0;
            }
            if ( 16 != v4 )
            {
              memset(&v3[v10], 0, 16 - v4);
              v10 = HIDWORD(v15);
              v4 = v15;
            }
            if ( v4 != v10 )
              memcpy(&v3[v10 - v4 + 16], (char *)&v14 + v10, v4 - v10);
            goto LABEL_15;
          }
LABEL_14:
          *(_OWORD *)v3 = v14;
LABEL_15:
          v6 = 1;
LABEL_16:
          v7 = 16;
          goto LABEL_22;
        }
        if ( !HIDWORD(v15) || HIDWORD(v15) == (_DWORD)v15 )
          goto LABEL_28;
      }
    }
LABEL_21:
    v6 = 0;
    v7 = 16;
    goto LABEL_22;
  }
  if ( (unsigned int)sscanf(v2, "%d.%d.%d.%d") == 4 && (v5 = v14, (v13 | (unsigned int)v14 | v12 | v11) <= 0xFF) )
  {
    v3[1] = v13;
    v6 = 1;
    *v3 = v5;
    v3[2] = v12;
    v3[3] = v11;
  }
  else
  {
    v6 = 0;
  }
  v7 = 4;
LABEL_22:
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( v6 )
    result = v7;
  else
    result = 0LL;
  return result;
}
// 9B4A0: using guessed type __int64 __fastcall sub_9B4A0();

//----- (000000000009AB24) ----------------------------------------------------
__int64 __fastcall a2i_IPADDRESS(const char *a1)
{
  __int64 result; // x0
  __int64 v2; // x19
  char v3; // [xsp+8h] [xbp-28h]
  __int64 v4; // [xsp+18h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = a2i_ipadd(&v3, a1);
  if ( (_DWORD)result )
  {
    result = (__int64)ASN1_OCTET_STRING_new();
    v2 = result;
    if ( !result )
      goto LABEL_6;
    result = ASN1_OCTET_STRING_set();
    if ( (_DWORD)result )
      goto LABEL_6;
    result = ASN1_VISIBLESTRING_free(v2);
  }
  v2 = 0LL;
LABEL_6:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v4 )
    result = v2;
  return result;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);
// 9DDD8: using guessed type __int64 ASN1_OCTET_STRING_set(void);

//----- (000000000009ABB0) ----------------------------------------------------
void __fastcall a2i_IPADDRESS_NC(const char *a1)
{
  const char *v1; // x20
  char *v2; // x21
  const char *v3; // x0
  char *v4; // x19
  char *v5; // x21
  int v6; // w20
  int v7; // w21
  _DWORD *v8; // x19
  char v9[32]; // [xsp+8h] [xbp-48h]
  __int64 v10; // [xsp+28h] [xbp-28h]

  v1 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = strchr(a1, 47);
  if ( v2 )
  {
    v3 = BUF_strdup(v1);
    v4 = (char *)v3;
    if ( v3 )
    {
      v5 = (char *)&v3[v2 - v1];
      *v5 = 0;
      v6 = a2i_ipadd(v9, v3);
      if ( v6 )
      {
        v7 = a2i_ipadd(&v9[v6], v5 + 1);
        free(v4);
        if ( v7 )
        {
          if ( v6 == v7 )
          {
            v8 = ASN1_OCTET_STRING_new();
            if ( v8 )
            {
              if ( !(unsigned int)ASN1_OCTET_STRING_set() )
                ASN1_VISIBLESTRING_free(v8);
            }
          }
        }
      }
      else
      {
        free(v4);
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);
// 9DDD8: using guessed type __int64 ASN1_OCTET_STRING_set(void);
// 9ABB0: using guessed type char var_48[32];

//----- (000000000009ACA8) ----------------------------------------------------
__int64 __fastcall X509V3_NAME_from_section(unsigned __int64 **a1, unsigned __int64 *a2, signed int a3)
{
  signed int v3; // w19
  unsigned __int64 *v4; // x20
  unsigned __int64 **v5; // x21
  unsigned __int64 v6; // x22
  unsigned __int64 *v7; // x0
  unsigned __int8 *v8; // x8
  unsigned __int8 *i; // x9
  signed int v10; // w10
  int v11; // w10
  int v12; // w6
  const char *v13; // x1
  __int64 result; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 )
    return 0LL;
  if ( !sk_num(a2) )
    return 1LL;
  v6 = 0LL;
  while ( 2 )
  {
    v7 = sk_value(v4, v6);
    v8 = (unsigned __int8 *)v7[1];
    for ( i = v8 + 1; ; ++i )
    {
      v10 = *(i - 1);
      if ( v10 <= 45 )
        break;
      if ( v10 == 58 || v10 == 46 )
        goto LABEL_12;
LABEL_5:
      ;
    }
    if ( !*(i - 1) )
      goto LABEL_14;
    if ( v10 != 44 )
      goto LABEL_5;
LABEL_12:
    if ( *i )
      v8 = i;
LABEL_14:
    v11 = *v8;
    if ( v11 == 43 )
      v12 = -1;
    else
      v12 = 0;
    if ( v11 == 43 )
      v13 = (const char *)(v8 + 1);
    else
      v13 = (const char *)v8;
    result = X509_NAME_add_entry_by_txt(v5, v13, v3, (const char *)v7[2], -1, -1, v12);
    if ( (_DWORD)result )
    {
      if ( ++v6 >= (unsigned __int64)sk_num(v4) )
        return 1LL;
      continue;
    }
    return result;
  }
}

//----- (000000000009AD8C) ----------------------------------------------------
__int64 __fastcall sub_9AD8C(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (000000000009AD98) ----------------------------------------------------
bool __fastcall sub_9AD98(unsigned __int8 *a1, size_t a2, unsigned __int8 *a3, __int64 a4)
{
  signed __int64 v4; // x12
  signed __int64 v5; // x10
  int v6; // w9
  int v7; // w13
  size_t v8; // x8
  signed __int64 v9; // x10
  int v10; // w13
  _BOOL8 result; // x0

  if ( a2 != a4 )
    return 0LL;
  v4 = -1LL;
  do
  {
    v5 = v4;
    if ( a2 + v4 == -1LL )
    {
      v8 = 0LL;
      goto LABEL_20;
    }
    v6 = a1[a2 + v4];
    if ( v6 == 64 )
      break;
    v7 = a3[a2 + v4--];
  }
  while ( v7 != 64 );
  v8 = a2 + v5;
  if ( !v5 )
  {
LABEL_20:
    if ( !v8 )
      v8 = a2;
    if ( v8 )
      result = (unsigned int)memcmp(a1, a3, v8) == 0;
    else
      result = 1LL;
    return result;
  }
  if ( !v6 )
    return 0LL;
  v9 = v5 + 1;
  while ( 1 )
  {
    v10 = a3[a2 - 1 + v9];
    if ( (unsigned __int8)v6 != v10 )
    {
      if ( ((v6 - 65) & 0xFFu) < 0x1A )
        LOBYTE(v6) = v6 + 32;
      v6 = (unsigned __int8)v6;
      if ( (unsigned int)(v10 - 65) < 0x1A )
        LOBYTE(v10) = v10 + 32;
      if ( v6 != (unsigned __int8)v10 )
        return 0LL;
    }
    if ( !v9 )
      goto LABEL_20;
    v6 = a1[a2 + v9++];
    if ( !v6 )
      return 0LL;
  }
}

//----- (000000000009B640) ----------------------------------------------------
#error "9B640: too complex function (funcsize=1143)"

//----- (000000000009C8B0) ----------------------------------------------------
signed __int64 __fastcall sub_9C8B0(unsigned __int8 **a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned int v3; // w8
  unsigned __int64 v4; // x9
  unsigned __int8 *v6; // x9

  v3 = -22;
  if ( a1 && a2 && a3 >= 7 )
  {
    if ( (a2[1] | (*a2 << 8)) != 1 )
      return 4294966285LL;
    v4 = (unsigned __int64)&a2[a2[3] | ((unsigned __int64)a2[2] << 8)];
    if ( v4 + 7 > (unsigned __int64)&a2[a3] )
      return 4294966280LL;
    v6 = (unsigned __int8 *)(v4 + 4);
    if ( (unsigned int)*v6 - 1 > 1 )
      return 4294966280LL;
    if ( &v6[(v6[2] | ((unsigned __int64)v6[1] << 8)) + 3] > &a2[a3] )
      return 4294966280LL;
    v3 = 0;
    *a1 = a2;
  }
  return v3;
}

//----- (000000000009C968) ----------------------------------------------------
__int64 __fastcall sub_9C968(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // x21
  _QWORD *v4; // x20
  __int64 v5; // x23
  _BYTE *v6; // x19
  unsigned int v7; // w22
  __int64 v8; // x22
  _BYTE *v9; // x0
  unsigned __int64 v10; // x24
  unsigned __int8 *v11; // x25
  char *v12; // x23
  size_t v13; // x22
  const void *v14; // x1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0LL;
  v7 = -22;
  if ( !a1 || !a2 || !a3 )
    goto LABEL_15;
  v8 = *(unsigned __int8 *)(a1 + 3) | ((unsigned int)*(unsigned __int8 *)(a1 + 2) << 8);
  if ( (_DWORD)v8 )
  {
    v9 = malloc(*(unsigned __int8 *)(a1 + 3) | ((unsigned int)*(unsigned __int8 *)(a1 + 2) << 8));
    v6 = v9;
    if ( !v9 )
    {
      v7 = -12;
      goto LABEL_15;
    }
    v10 = v5 + v8 + 4;
    v11 = (unsigned __int8 *)(v5 + 4);
    v12 = v9;
    while ( 1 )
    {
      v13 = v11[1] | ((unsigned int)*v11 << 8);
      if ( !(_DWORD)v13 )
        break;
      v14 = v11 + 2;
      v11 += v13 + 2;
      if ( (unsigned __int64)v11 > v10 )
      {
        v7 = -105;
        goto LABEL_15;
      }
      memcpy(v12, v14, v13);
      v12 += v13;
      if ( (unsigned __int64)v11 >= v10 )
      {
        v7 = 0;
        *v3 = v12 - v6;
        *v4 = v6;
        return v7;
      }
    }
  }
  else
  {
    v6 = 0LL;
  }
  v7 = -1016;
LABEL_15:
  free(v6);
  return v7;
}

//----- (000000000009CA58) ----------------------------------------------------
signed __int64 __fastcall sub_9CA58(__int64 a1, _BYTE *a2)
{
  __int64 v2; // x8
  signed __int64 result; // x0

  v2 = a1;
  result = 4294967274LL;
  if ( v2 )
  {
    if ( a2 )
    {
      result = 0LL;
      *a2 = *(_BYTE *)(v2 + (*(unsigned __int8 *)(v2 + 3) | ((unsigned __int64)*(unsigned __int8 *)(v2 + 2) << 8)) + 4);
    }
  }
  return result;
}

//----- (000000000009CA88) ----------------------------------------------------
signed __int64 __fastcall sub_9CA88(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v3; // x8
  signed __int64 result; // x0
  unsigned __int64 v5; // x8
  signed __int64 v6; // x8
  unsigned __int8 v7; // t1
  __int64 v8; // x9

  v3 = a1;
  result = 4294967274LL;
  if ( v3 && a2 && a3 )
  {
    v5 = v3 + 2 + (*(unsigned __int8 *)(v3 + 3) | ((unsigned __int64)*(unsigned __int8 *)(v3 + 2) << 8));
    v7 = *(_BYTE *)(v5 + 3);
    v6 = v5 + 3;
    v8 = *(unsigned __int8 *)(v6 + 1) | ((unsigned int)v7 << 8);
    if ( (_DWORD)v8 )
    {
      result = 0LL;
      *a3 = v8;
      *a2 = v6 + 2;
    }
    else
    {
      result = 4294966280LL;
    }
  }
  return result;
}

//----- (000000000009CAD8) ----------------------------------------------------
signed __int64 __fastcall sub_9CAD8(int **a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x19
  _QWORD *v4; // x22
  int **v5; // x21
  int *v6; // x8
  signed __int64 result; // x0
  unsigned int v8; // w20
  int *v9; // x10
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x11
  const char *v13; // x21
  size_t v14; // x22
  void *v15; // x0
  int v16; // [xsp+4h] [xbp-3Ch]
  unsigned __int8 *v17; // [xsp+8h] [xbp-38h]
  int v18; // [xsp+10h] [xbp-30h]
  char v19; // [xsp+14h] [xbp-2Ch]
  __int64 v20; // [xsp+18h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v19 = 0;
  v18 = 0;
  v17 = 0LL;
  v16 = 0;
  if ( !a1 || (v6 = *a1) == 0LL || !*((_QWORD *)v6 + 3) )
  {
    result = 4294967274LL;
    goto LABEL_12;
  }
  result = 4294967274LL;
  if ( a2 && *((_QWORD *)v6 + 4) )
  {
    v8 = sub_9CCD0(v5, (unsigned __int64 *)&v17, &v19, &v18, &v16);
    if ( v8 & 0x80000000 )
      goto LABEL_30;
    if ( v19 )
    {
      result = 4294966280LL;
      if ( v16 != 1 || v19 == 1 && v18 != 10 )
        goto LABEL_12;
LABEL_16:
      v9 = *v5;
      v10 = *v17;
      if ( v10 >= *((_QWORD *)*v5 + 3) )
      {
        result = 4294966280LL;
        goto LABEL_12;
      }
      v11 = (unsigned __int64)(v17++ + 1);
      v12 = (unsigned __int64)v5[1];
      if ( v12 && v12 >= v11 )
      {
        if ( (int *)v12 != v5[3] )
        {
          result = 4294966289LL;
          goto LABEL_12;
        }
        *v4 = 0LL;
        if ( v3 )
          goto LABEL_25;
      }
      else
      {
        *v4 = *((_QWORD *)v9 + 4) + 40 * v10;
        v5[1] = (int *)v11;
        if ( v3 )
        {
LABEL_25:
          if ( *(_DWORD *)v3 )
          {
            if ( *(_DWORD *)v3 != 1 )
            {
              result = 0xFFFFFFFFLL;
              goto LABEL_12;
            }
            *(_DWORD *)(v3 + 8) = v10;
          }
          else
          {
            v13 = *(const char **)(*((_QWORD *)*v5 + 4) + 40 * v10 + 8);
            v14 = strlen(v13);
            free(*(void **)(v3 + 8));
            v15 = malloc(v14 + 1);
            *(_QWORD *)(v3 + 8) = v15;
            if ( !v15 )
            {
              result = 4294967284LL;
              goto LABEL_12;
            }
            memcpy(v15, v13, v14);
            *(_BYTE *)(*(_QWORD *)(v3 + 8) + v14) = 0;
          }
          goto LABEL_30;
        }
      }
LABEL_30:
      result = v8;
      goto LABEL_12;
    }
    result = 4294966280LL;
    if ( v16 == 1 && v18 == 10 )
      goto LABEL_16;
  }
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v20;
  return result;
}

//----- (000000000009CCD0) ----------------------------------------------------
signed __int64 __fastcall sub_9CCD0(int **a1, unsigned __int64 *a2, _BYTE *a3, signed int *a4, signed int *a5)
{
  int v5; // w8
  signed int v6; // w9
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x11
  signed int v9; // w9
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x9
  signed int v12; // w8
  unsigned __int64 v13; // x9
  __int64 v14; // x8
  signed __int64 result; // x0
  unsigned __int64 v16; // x11
  unsigned __int64 v17; // x10
  signed int v18; // w9
  char *v19; // x13
  unsigned __int8 *v20; // x11
  int v21; // w14
  __int64 v22; // x12
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x11
  char *v25; // x10
  unsigned __int8 *v26; // x8
  signed int v27; // w8
  char *v28; // x13
  unsigned __int8 *v29; // x10
  int v30; // w12
  __int64 v31; // x9
  unsigned __int64 v32; // x9
  int v33; // w14
  __int64 v34; // x12
  unsigned __int64 v35; // x8
  unsigned __int8 *v36; // x9
  unsigned __int64 v37; // x10
  unsigned int v38; // w8
  unsigned __int64 v39; // x13
  unsigned __int64 v40; // x13
  signed int v41; // w8
  unsigned __int64 v42; // x12
  char *v43; // x11
  unsigned __int8 *v44; // x8
  int v45; // w13
  __int64 v46; // x10
  unsigned __int8 *v47; // x10
  unsigned int v48; // w8
  unsigned __int64 v49; // x11

  *a2 = (unsigned __int64)a1[2];
  v5 = **a1;
  if ( (_BYTE)v5 )
    v6 = 3;
  else
    v6 = 2;
  if ( !(v5 & 0x200) )
    v6 = (unsigned __int8)v5 != 0;
  *a3 = v6;
  if ( !v6 )
  {
    v10 = (unsigned __int64)a1[3];
    if ( v10 )
    {
      v11 = *a2 + 1;
      if ( v11 <= v10 )
      {
        v12 = *(unsigned __int8 *)*a2;
        *a2 = v11;
      }
      else
      {
        v12 = -1013;
      }
    }
    else
    {
      v12 = -22;
    }
    *a4 = v12;
    v24 = (unsigned __int64)a1[3];
    if ( !v24 )
      goto LABEL_87;
    v25 = (char *)*a2;
    v26 = (unsigned __int8 *)(*a2 + 1);
    if ( (unsigned __int64)v26 <= v24 )
    {
      v30 = *v25;
      v31 = (unsigned __int8)v30;
      if ( v30 & 0x80000000 )
      {
        if ( (_DWORD)v31 == 130 )
        {
          v26 = (unsigned __int8 *)(v25 + 3);
          if ( (unsigned __int64)(v25 + 3) > v24 )
            goto LABEL_34;
          v31 = (unsigned __int8)v25[2] | ((unsigned int)(unsigned __int8)v25[1] << 8);
        }
        else
        {
          if ( (_DWORD)v31 != 129 )
          {
            v27 = -1016;
            goto LABEL_88;
          }
          v37 = (unsigned __int64)(v25 + 2);
          if ( v37 > v24 )
            goto LABEL_34;
          v31 = *v26;
          v26 = (unsigned __int8 *)v37;
        }
      }
      *a2 = (unsigned __int64)v26;
      *a5 = v31;
      v32 = *a2 + v31;
      if ( v32 > (unsigned __int64)a1[3] )
        return 4294966280LL;
      v38 = 0;
      a1[3] = (int *)v32;
      return v38;
    }
LABEL_34:
    v27 = -1013;
LABEL_88:
    *a5 = v27;
    return 4294966280LL;
  }
  if ( v6 != 2 )
  {
    v5 = (unsigned __int8)v5;
    if ( v6 == 3 )
    {
      v7 = (unsigned __int64)a1[3];
      if ( v7 )
      {
        v8 = *a2 + 1;
        if ( v8 > v7 )
        {
          v9 = -1013;
          goto LABEL_26;
        }
        v9 = *(unsigned __int8 *)*a2;
        *a2 = v8;
        v7 = (unsigned __int64)a1[3];
        if ( v7 )
        {
LABEL_26:
          v19 = (char *)*a2;
          v20 = (unsigned __int8 *)(*a2 + 1);
          if ( (unsigned __int64)v20 <= v7 )
          {
            v21 = *v19;
            v22 = (unsigned __int8)v21;
            if ( !(v21 & 0x80000000) )
              goto LABEL_28;
            if ( (_DWORD)v22 == 130 )
            {
              v20 = (unsigned __int8 *)(v19 + 3);
              if ( (unsigned __int64)(v19 + 3) <= v7 )
              {
                v22 = (unsigned __int8)v19[2] | ((unsigned int)(unsigned __int8)v19[1] << 8);
LABEL_28:
                *a2 = (unsigned __int64)v20;
                *a5 = v22;
                if ( v5 != v9 )
                  return 4294966280LL;
                v23 = *a2 + v22;
                if ( v23 > (unsigned __int64)a1[3] )
                  return 4294966280LL;
                a1[3] = (int *)v23;
                result = 0LL;
                *a4 = 0;
                return result;
              }
            }
            else
            {
              if ( (_DWORD)v22 != 129 )
              {
                v27 = -1016;
                goto LABEL_88;
              }
              v39 = (unsigned __int64)(v19 + 2);
              if ( v39 <= v7 )
              {
                v22 = *v20;
                v20 = (unsigned __int8 *)v39;
                goto LABEL_28;
              }
            }
          }
          goto LABEL_34;
        }
      }
LABEL_87:
      v27 = -22;
      goto LABEL_88;
    }
    v16 = (unsigned __int64)a1[3];
    if ( !v16 )
      return 4294966280LL;
    v17 = *a2 + 1;
    if ( v17 <= v16 )
    {
      v18 = *(unsigned __int8 *)*a2;
      *a2 = v17;
      v16 = (unsigned __int64)a1[3];
      if ( !v16 )
        return 4294966280LL;
    }
    else
    {
      v18 = -1013;
    }
    v28 = (char *)*a2;
    v29 = (unsigned __int8 *)(*a2 + 1);
    if ( (unsigned __int64)v29 > v16 )
      return 4294966280LL;
    v33 = *v28;
    v34 = (unsigned __int8)v33;
    if ( v33 & 0x80000000 )
    {
      if ( (_DWORD)v34 == 130 )
      {
        v29 = (unsigned __int8 *)(v28 + 3);
        if ( (unsigned __int64)(v28 + 3) > v16 )
          return 4294966280LL;
        v34 = (unsigned __int8)v28[2] | ((unsigned int)(unsigned __int8)v28[1] << 8);
      }
      else
      {
        if ( (_DWORD)v34 != 129 )
          return 4294966280LL;
        v40 = (unsigned __int64)(v28 + 2);
        if ( v40 > v16 )
          return 4294966280LL;
        v34 = *v29;
        v29 = (unsigned __int8 *)v40;
      }
    }
    *a2 = (unsigned __int64)v29;
    if ( v5 != v18 )
      return 4294966280LL;
    v35 = (unsigned __int64)a1[3];
    v36 = &v29[v34];
    if ( (unsigned __int64)&v29[v34] > v35 )
      return 4294966280LL;
    if ( v35 )
    {
      if ( (unsigned __int64)(v29 + 1) <= v35 )
      {
        v41 = *v29;
        *a2 = (unsigned __int64)(v29 + 1);
      }
      else
      {
        v41 = -1013;
      }
    }
    else
    {
      v41 = -22;
    }
    *a4 = v41;
    v42 = (unsigned __int64)a1[3];
    if ( !v42 )
      goto LABEL_87;
    v43 = (char *)*a2;
    v44 = (unsigned __int8 *)(*a2 + 1);
    if ( (unsigned __int64)v44 <= v42 )
    {
      v45 = *v43;
      v46 = (unsigned __int8)v45;
      if ( !(v45 & 0x80000000) )
        goto LABEL_82;
      if ( (_DWORD)v46 == 130 )
      {
        v44 = (unsigned __int8 *)(v43 + 3);
        if ( (unsigned __int64)(v43 + 3) <= v42 )
        {
          v46 = (unsigned __int8)v43[2] | ((unsigned int)(unsigned __int8)v43[1] << 8);
LABEL_82:
          *a2 = (unsigned __int64)v44;
          *a5 = v46;
          v47 = (unsigned __int8 *)(*a2 + v46);
          v38 = -1016;
          if ( v47 <= (unsigned __int8 *)a1[3] )
          {
            if ( v36 == v47 )
              v48 = 0;
            else
              v48 = -1016;
            a1[3] = (int *)v47;
            return v48;
          }
          return v38;
        }
      }
      else
      {
        if ( (_DWORD)v46 != 129 )
        {
          v27 = -1016;
          goto LABEL_88;
        }
        v49 = (unsigned __int64)(v43 + 2);
        if ( v49 <= v42 )
        {
          v46 = *v44;
          v44 = (unsigned __int8 *)v49;
          goto LABEL_82;
        }
      }
    }
    goto LABEL_34;
  }
  *a5 = 0;
  v13 = (unsigned __int64)a1[2];
  if ( v13 < (unsigned __int64)a1[3] )
  {
    v14 = 0LL;
    do
      *a5 = ++v14;
    while ( v13 + v14 < (unsigned __int64)a1[3] );
    v13 = (unsigned __int64)a1[2];
  }
  result = 0LL;
  *a2 = v13;
  *a4 = 0;
  return result;
}

//----- (000000000009D114) ----------------------------------------------------
signed __int64 __fastcall sub_9D114(int **a1, _QWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // x19
  _QWORD *v4; // x21
  int **v5; // x20
  int *v6; // x8
  signed __int64 result; // x0
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x9
  __int64 v10; // x10
  int v11; // w12
  unsigned __int8 v12; // w11
  signed __int64 v13; // x13
  int v14; // w11
  int v15; // [xsp+4h] [xbp-3Ch]
  unsigned __int64 v16; // [xsp+8h] [xbp-38h]
  int v17; // [xsp+10h] [xbp-30h]
  char v18; // [xsp+14h] [xbp-2Ch]
  __int64 v19; // [xsp+18h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v18 = 0;
  v17 = 0;
  v16 = 0LL;
  v15 = 0;
  if ( a1 && (v6 = *a1) != 0LL && !*((_QWORD *)v6 + 3) )
  {
    result = 4294967274LL;
    if ( a2 )
    {
      if ( !*((_QWORD *)v6 + 4) )
      {
        result = sub_9CCD0(v5, &v16, &v18, &v17, &v15);
        if ( !(result & 0x80000000) )
        {
          if ( v18 )
          {
            if ( v18 == 1 && v17 != 2 )
            {
              result = 4294966280LL;
              goto LABEL_5;
            }
          }
          else if ( v17 != 2 )
          {
            result = 4294966280LL;
            goto LABEL_5;
          }
          v5[1] = v5[3];
          *v4 = 0LL;
          v8 = v16;
          v9 = (unsigned __int64)v5[3];
          if ( v16 >= v9 )
          {
            v14 = 0;
LABEL_22:
            if ( v3 )
            {
              if ( *v3 == 1 )
                v3[2] = v14;
              else
                result = 0xFFFFFFFFLL;
            }
          }
          else
          {
            v10 = 0LL;
            v11 = 0;
            while ( (signed int)v10 <= 3 )
            {
              v13 = v8 + v10 + 1;
              v12 = *(_BYTE *)(v8 + v10++);
              v14 = v12 | (v11 << 8);
              v11 = v14;
              v16 = v13;
              if ( v8 + v10 >= v9 )
                goto LABEL_22;
            }
            result = 4294966283LL;
          }
        }
      }
    }
  }
  else
  {
    result = 4294967274LL;
  }
LABEL_5:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v19;
  return result;
}

//----- (000000000009D274) ----------------------------------------------------
signed __int64 __fastcall sub_9D274(signed __int64 result, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x20
  _QWORD *v4; // x22
  signed __int64 v5; // x21
  int *v6; // x8
  unsigned int v7; // w19
  unsigned __int64 v8; // x8
  char v9; // t1
  signed __int64 v10; // x9
  __int64 v11; // x9
  int v12; // [xsp+4h] [xbp-3Ch]
  char *v13; // [xsp+8h] [xbp-38h]
  int v14; // [xsp+10h] [xbp-30h]
  char v15; // [xsp+14h] [xbp-2Ch]
  __int64 v16; // [xsp+18h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = result;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v15 = 0;
  v14 = 0;
  v13 = 0LL;
  v12 = 0;
  if ( !result || (v6 = *(int **)result) == 0LL || *((_QWORD *)v6 + 3) )
  {
    v7 = -22;
    goto LABEL_5;
  }
  v7 = -22;
  if ( !a2 )
    goto LABEL_5;
  if ( *((_QWORD *)v6 + 4) )
    goto LABEL_5;
  result = sub_9CCD0((int **)result, (unsigned __int64 *)&v13, &v15, &v14, &v12);
  v7 = result;
  if ( result & 0x80000000 )
    goto LABEL_5;
  if ( v15 )
  {
    if ( v15 == 1 && v14 != 4 )
    {
      v7 = -1016;
      goto LABEL_5;
    }
  }
  else if ( v14 != 4 )
  {
    v7 = -1016;
    goto LABEL_5;
  }
  *(_QWORD *)(v5 + 8) = *(_QWORD *)(v5 + 24);
  *v4 = 0LL;
  if ( v3 )
  {
    if ( *(_DWORD *)v3 == 3 )
    {
      free(*(void **)(v3 + 16));
      result = (signed __int64)malloc(v12);
      *(_QWORD *)(v3 + 16) = result;
      if ( result )
      {
        v12 = 0;
        if ( (unsigned __int64)v13 >= *(_QWORD *)(v5 + 24) )
        {
          v10 = 0LL;
        }
        else
        {
          v9 = *v13;
          v8 = (unsigned __int64)(v13 + 1);
          v10 = 1LL;
          v12 = 1;
          *(_BYTE *)result = v9;
          if ( v8 < *(_QWORD *)(v5 + 24) )
          {
            v11 = 0LL;
            do
            {
              *(_BYTE *)(*(_QWORD *)(v3 + 16) + v11 + 1) = *(_BYTE *)(v8 + v11);
              v12 = v11++ + 2;
            }
            while ( v8 + v11 < *(_QWORD *)(v5 + 24) );
            v10 = (signed int)v11 + 1;
          }
        }
        *(_QWORD *)(v3 + 8) = v10;
      }
      else
      {
        v7 = -12;
      }
    }
    else
    {
      v7 = -1;
    }
  }
LABEL_5:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v16 )
    result = v7;
  return result;
}

//----- (000000000009D418) ----------------------------------------------------
signed __int64 __fastcall sub_9D418(signed __int64 result, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x20
  _QWORD *v4; // x22
  signed __int64 v5; // x21
  int *v6; // x8
  unsigned int v7; // w19
  _BYTE *v8; // x8
  __int64 v9; // x9
  unsigned __int64 v10; // x8
  char v11; // t1
  signed __int64 v12; // x9
  __int64 v13; // x9
  int v14; // [xsp+4h] [xbp-3Ch]
  _BYTE *v15; // [xsp+8h] [xbp-38h]
  int v16; // [xsp+10h] [xbp-30h]
  char v17; // [xsp+14h] [xbp-2Ch]
  __int64 v18; // [xsp+18h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = result;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0;
  v16 = 0;
  v15 = 0LL;
  v14 = 0;
  if ( !result || (v6 = *(int **)result) == 0LL || *((_QWORD *)v6 + 3) )
  {
    v7 = -22;
    goto LABEL_5;
  }
  v7 = -22;
  if ( !a2 )
    goto LABEL_5;
  if ( *((_QWORD *)v6 + 4) )
    goto LABEL_5;
  result = sub_9CCD0((int **)result, (unsigned __int64 *)&v15, &v17, &v16, &v14);
  v7 = result;
  if ( result & 0x80000000 )
    goto LABEL_5;
  if ( v17 )
  {
    if ( v17 == 1 && v16 != 12 )
    {
      v7 = -1016;
      goto LABEL_5;
    }
  }
  else if ( v16 != 12 )
  {
    v7 = -1016;
    goto LABEL_5;
  }
  *(_QWORD *)(v5 + 8) = *(_QWORD *)(v5 + 24);
  *v4 = 0LL;
  if ( v3 )
  {
    if ( *(_DWORD *)v3 != 3 )
    {
      if ( *(_DWORD *)v3 )
      {
        v7 = -1;
        goto LABEL_5;
      }
      free(*(void **)(v3 + 8));
      result = (signed __int64)malloc(v14 + 1LL);
      *(_QWORD *)(v3 + 8) = result;
      if ( result )
      {
        v14 = 0;
        v8 = v15;
        if ( (unsigned __int64)v15 >= *(_QWORD *)(v5 + 24) )
        {
          *(_BYTE *)result = 0;
        }
        else
        {
          v9 = 0LL;
          do
          {
            *(_BYTE *)(result + v9) = v8[v9];
            if ( (char)v8[v9] & 0x80000000 )
              *(_BYTE *)(*(_QWORD *)(v3 + 8) + v9) = 63;
            v14 = ++v9;
            result = *(_QWORD *)(v3 + 8);
          }
          while ( (unsigned __int64)&v8[v9] < *(_QWORD *)(v5 + 24) );
          *(_BYTE *)(result + (signed int)v9) = 0;
        }
        goto LABEL_5;
      }
LABEL_33:
      v7 = -12;
      goto LABEL_5;
    }
    free(*(void **)(v3 + 16));
    result = (signed __int64)malloc(v14);
    *(_QWORD *)(v3 + 16) = result;
    if ( !result )
      goto LABEL_33;
    v14 = 0;
    if ( (unsigned __int64)v15 >= *(_QWORD *)(v5 + 24) )
    {
      v12 = 0LL;
    }
    else
    {
      v11 = *v15;
      v10 = (unsigned __int64)(v15 + 1);
      v12 = 1LL;
      v14 = 1;
      *(_BYTE *)result = v11;
      if ( v10 < *(_QWORD *)(v5 + 24) )
      {
        v13 = 0LL;
        do
        {
          *(_BYTE *)(*(_QWORD *)(v3 + 16) + v13 + 1) = *(_BYTE *)(v10 + v13);
          v14 = v13++ + 2;
        }
        while ( v10 + v13 < *(_QWORD *)(v5 + 24) );
        v12 = (signed int)v13 + 1;
      }
    }
    *(_QWORD *)(v3 + 8) = v12;
  }
LABEL_5:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v18 )
    result = v7;
  return result;
}

//----- (000000000009D644) ----------------------------------------------------
__int64 __fastcall sub_9D644(__int64 *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x19
  _QWORD *v4; // x21
  __int64 v5; // x20
  __int64 v6; // x8
  unsigned int v7; // w22
  __int64 v8; // x1
  _QWORD *v10; // x23
  unsigned __int64 v11; // x24
  signed __int64 v12; // x25
  unsigned __int64 v13; // x8
  __int64 v14; // x8
  unsigned __int64 v15; // x9
  const char *v16; // x20
  size_t v17; // x21
  void *v18; // x0

  v3 = a3;
  v4 = a2;
  v5 = (__int64)a1;
  if ( !a1 )
    return (unsigned int)-22;
  v6 = *a1;
  if ( !*a1 || !*(_QWORD *)(v6 + 24) )
    return (unsigned int)-22;
  v7 = -22;
  if ( a2 )
  {
    v8 = *(_QWORD *)(v6 + 32);
    if ( v8 )
    {
      if ( a1[2] < (unsigned __int64)a1[1] )
      {
        v7 = 0;
        *v4 = 0LL;
        return v7;
      }
      v10 = sub_61740((__int64)a1, v8, 0LL);
      if ( !v10 )
      {
LABEL_21:
        sub_61844(0LL);
        return (unsigned int)-12;
      }
      v11 = 0LL;
      v12 = 40LL;
      while ( 1 )
      {
        v7 = sub_618A4(v10, 0LL);
        if ( !(v7 & 0x80000000) )
        {
          v13 = v10[1];
          if ( v10[2] == v13 )
          {
            sub_61844(v10);
            goto LABEL_19;
          }
          if ( v10[3] < v13 )
            v7 = -1016;
        }
        sub_61844(v10);
        if ( v7 != -1016 )
        {
          if ( v7 )
            return v7;
          v14 = *(_QWORD *)v5;
          if ( v11 == *(_QWORD *)(*(_QWORD *)v5 + 24LL) )
            return (unsigned int)-1016;
LABEL_27:
          *v4 = *(_QWORD *)(v14 + 32) + 40 * v11;
          if ( v3 )
          {
            if ( *(_DWORD *)v3 )
            {
              if ( *(_DWORD *)v3 == 1 )
                *(_DWORD *)(v3 + 8) = v11;
              else
                v7 = -1;
            }
            else
            {
              v16 = *(const char **)(*(_QWORD *)(*(_QWORD *)v5 + 32LL) + 40 * v11 + 8);
              v17 = strlen(v16);
              free(*(void **)(v3 + 8));
              v18 = malloc(v17 + 1);
              *(_QWORD *)(v3 + 8) = v18;
              if ( v18 )
              {
                memcpy(v18, v16, v17);
                *(_BYTE *)(*(_QWORD *)(v3 + 8) + v17) = 0;
              }
              else
              {
                v7 = -12;
              }
            }
          }
          return v7;
        }
LABEL_19:
        v14 = *(_QWORD *)v5;
        ++v11;
        v15 = *(_QWORD *)(*(_QWORD *)v5 + 24LL);
        if ( v11 >= v15 )
        {
          v7 = -1016;
          if ( v11 != v15 )
            goto LABEL_27;
          return (unsigned int)-1016;
        }
        v10 = sub_61740(v5, *(_QWORD *)(v14 + 32) + v12, 0LL);
        v12 += 40LL;
        if ( !v10 )
          goto LABEL_21;
      }
    }
  }
  return v7;
}

//----- (000000000009D830) ----------------------------------------------------
signed __int64 __fastcall sub_9D830(int **a1, _QWORD *a2, __int64 a3)
{
  int **v3; // x9
  signed __int64 result; // x0
  __int64 v5; // x20
  _QWORD *v6; // x22
  int **v7; // x21
  int *v8; // x8
  unsigned int v9; // w19
  unsigned __int64 v10; // x9
  int *v11; // x8
  unsigned __int64 v12; // x10
  unsigned __int64 v13; // x8
  char v14; // t1
  signed __int64 v15; // x9
  __int64 v16; // x9
  int v17; // [xsp+4h] [xbp-4Ch]
  int *v18; // [xsp+8h] [xbp-48h]
  int v19; // [xsp+10h] [xbp-40h]
  unsigned __int8 v20; // [xsp+14h] [xbp-3Ch]
  __int64 v21; // [xsp+18h] [xbp-38h]

  v3 = a1;
  result = 48LL;
  v5 = a3;
  v6 = a2;
  v7 = v3;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v20 = 0;
  v19 = 0;
  v18 = 0LL;
  v17 = 0;
  if ( !v3 || (v8 = *v3) == 0LL )
  {
    v9 = -22;
    goto LABEL_11;
  }
  v9 = -22;
  if ( *((_QWORD *)v8 + 3) != 1LL )
    goto LABEL_11;
  if ( !a2 )
    goto LABEL_11;
  if ( !*((_QWORD *)v8 + 4) )
    goto LABEL_11;
  result = sub_9CCD0(v3, (unsigned __int64 *)&v18, &v20, &v19, &v17);
  v9 = result;
  if ( result & 0x80000000 )
    goto LABEL_11;
  if ( v20 <= 1u && v19 != 48 )
  {
    v9 = -1016;
    goto LABEL_11;
  }
  v10 = (unsigned __int64)v7[1];
  if ( !v10 )
  {
    v11 = v18;
    goto LABEL_20;
  }
  v11 = v18;
  v12 = (unsigned __int64)v18 + v17;
  if ( v10 < (unsigned __int64)v18 && v10 < v12 )
  {
LABEL_20:
    *v6 = *((_QWORD *)*v7 + 4);
    v7[1] = v11;
    if ( !v5 )
      goto LABEL_11;
    goto LABEL_21;
  }
  if ( v10 >= v12 )
  {
    *v6 = 0LL;
    if ( !v5 )
      goto LABEL_11;
  }
  else
  {
    *v6 = *((_QWORD *)*v7 + 4);
    if ( !v5 )
      goto LABEL_11;
  }
LABEL_21:
  if ( *(_DWORD *)v5 == 3 )
  {
    free(*(void **)(v5 + 16));
    result = (signed __int64)malloc(v17);
    *(_QWORD *)(v5 + 16) = result;
    if ( result )
    {
      v17 = 0;
      if ( v18 >= v7[3] )
      {
        v15 = 0LL;
      }
      else
      {
        v14 = *(_BYTE *)v18;
        v13 = (unsigned __int64)v18 + 1;
        v15 = 1LL;
        v17 = 1;
        *(_BYTE *)result = v14;
        if ( v13 < (unsigned __int64)v7[3] )
        {
          v16 = 0LL;
          do
          {
            *(_BYTE *)(*(_QWORD *)(v5 + 16) + v16 + 1) = *(_BYTE *)(v13 + v16);
            v17 = v16++ + 2;
          }
          while ( v13 + v16 < (unsigned __int64)v7[3] );
          v15 = (signed int)v16 + 1;
        }
      }
      *(_QWORD *)(v5 + 8) = v15;
    }
    else
    {
      v9 = -12;
    }
  }
  else
  {
    v9 = -1;
  }
LABEL_11:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v21 )
    result = v9;
  return result;
}

//----- (000000000009DA44) ----------------------------------------------------
signed __int64 __fastcall sub_9DA44(int **a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // x19
  _QWORD *v4; // x20
  int **v5; // x21
  int *v6; // x8
  signed __int64 result; // x0
  unsigned int *v8; // x22
  unsigned int *v9; // x0
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x10
  unsigned __int64 v13; // x9
  unsigned int v14; // w9
  unsigned int v15; // w9
  unsigned int v16; // w10
  int *v17; // x11
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x8
  signed __int64 v20; // x11
  __int64 v21; // [xsp+8h] [xbp-48h]
  int v22; // [xsp+14h] [xbp-3Ch]
  unsigned __int64 v23; // [xsp+18h] [xbp-38h]
  int v24; // [xsp+20h] [xbp-30h]
  char v25; // [xsp+24h] [xbp-2Ch]
  __int64 v26; // [xsp+28h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v25 = 0;
  v24 = 0;
  v23 = 0LL;
  v22 = 0;
  v21 = 0LL;
  if ( !a1 || (v6 = *a1) == 0LL || !*((_QWORD *)v6 + 3) )
  {
    result = 4294967274LL;
    goto LABEL_15;
  }
  result = 4294967274LL;
  if ( a2 && *((_QWORD *)v6 + 4) )
  {
    v8 = (unsigned int *)v5[8];
    if ( !v8 )
    {
      v9 = (unsigned int *)malloc(0x10uLL);
      v8 = v9;
      v5[8] = (int *)v9;
      if ( !v9 )
      {
        result = 4294967284LL;
        goto LABEL_15;
      }
      *v9 = 0;
      *((_QWORD *)v9 + 1) = v5[2];
    }
    result = sub_9CCD0(v5, &v23, &v25, &v24, &v22);
    if ( !(result & 0x80000000) )
    {
      if ( v25 )
      {
        if ( v25 == 1 && v24 != 48 )
        {
          result = 4294966280LL;
          goto LABEL_15;
        }
      }
      else if ( v24 != 48 )
      {
        result = 4294966280LL;
        goto LABEL_15;
      }
      v10 = (unsigned __int64)v5[1];
      v11 = v23;
      if ( !v10 || (v12 = v23 + v22, v10 < v23) && v10 < v12 )
      {
        v5[1] = (int *)v23;
        *((_QWORD *)v8 + 1) = v11;
        *v8 = 0;
LABEL_23:
        result = sub_9DC6C((unsigned __int8 **)v5, v8, (int **)&v21);
        if ( result & 0x80000000 )
          goto LABEL_15;
        *v4 = v21;
        goto LABEL_25;
      }
      v13 = *((_QWORD *)v8 + 1);
      if ( v10 < v12 )
      {
        if ( v10 > v13 )
        {
          v14 = *v8;
          *((_QWORD *)v8 + 1) = v10;
          *v8 = v14 + 1;
        }
        goto LABEL_23;
      }
      if ( v10 <= v13 )
      {
        v16 = *v8;
      }
      else
      {
        v15 = *v8;
        *((_QWORD *)v8 + 1) = v10;
        v16 = v15 + 1;
        *v8 = v15 + 1;
      }
      v17 = *v5;
      v18 = v16;
      v19 = *((_QWORD *)*v5 + 3);
      if ( v16 >= v19 )
      {
LABEL_41:
        if ( v16 != v19 )
        {
          result = 4294966280LL;
          goto LABEL_15;
        }
        LODWORD(result) = 0;
        *v4 = 0LL;
LABEL_25:
        if ( v3 )
          result = 1LL;
        else
          result = (unsigned int)result;
        goto LABEL_15;
      }
      while ( 1 )
      {
        v20 = *((_QWORD *)v17 + 4) + 40 * v18;
        if ( !v20 )
          break;
        if ( *(_BYTE *)(v20 + 1) & 1 )
        {
          v18 = (unsigned int)(v18 + 1);
          *v8 = v18;
          v17 = *v5;
          v19 = *((_QWORD *)*v5 + 3);
          if ( v18 < v19 )
            continue;
        }
        v16 = v18;
        goto LABEL_41;
      }
      result = 4294966289LL;
    }
  }
LABEL_15:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v26;
  return result;
}

//----- (000000000009DC6C) ----------------------------------------------------
__int64 __fastcall sub_9DC6C(unsigned __int8 **a1, unsigned int *a2, int **a3)
{
  unsigned __int8 **v3; // x21
  unsigned __int8 *v4; // x9
  _DWORD *v5; // x20
  unsigned __int64 v6; // x8
  int **v7; // x19
  int *v8; // x1
  int v9; // w8
  _QWORD *v10; // x0
  _QWORD *v11; // x23
  unsigned int v12; // w22
  unsigned __int64 v13; // x8

  v3 = a1;
  v4 = *a1;
  v5 = a2;
  v6 = *a2;
  v7 = a3;
  if ( v6 >= *((_QWORD *)*a1 + 3) )
  {
    v12 = -1016;
  }
  else
  {
LABEL_2:
    v8 = (int *)(*((_QWORD *)v4 + 4) + 40 * v6);
    while ( 1 )
    {
      *v7 = v8;
      if ( !v8 )
        return 0;
      v9 = *v8;
      if ( !(*v8 & 0x100) || *v3[1] == (unsigned __int8)v9 )
        return 0;
      v10 = sub_61740((__int64)v3, (__int64)v8, 0LL);
      v11 = v10;
      if ( !v10 )
        break;
      v12 = sub_618A4(v10, 0LL);
      if ( v12 & 0x80000000 )
      {
        sub_61844(v11);
        if ( v12 != -1016 )
          return v12;
      }
      else
      {
        v13 = v11[1];
        if ( v11[2] != v13 && v11[3] >= v13 )
          goto LABEL_17;
        sub_61844(v11);
      }
      v8 = 0LL;
      v6 = (unsigned int)(*v5 + 1);
      *v5 = v6;
      v4 = *v3;
      if ( v6 < *((_QWORD *)*v3 + 3) )
        goto LABEL_2;
    }
    v12 = -12;
LABEL_17:
    sub_61844(v11);
  }
  return v12;
}

//----- (000000000009DD84) ----------------------------------------------------
signed __int64 __fastcall sub_9DD84(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // x8
  __int64 v3; // x9
  signed __int64 result; // x0

  v2 = a1;
  if ( !a1 )
    return 4294967274LL;
  v3 = *a1;
  if ( !*a1 )
    return 4294967274LL;
  if ( *(_QWORD *)(v3 + 24) )
    return 4294967274LL;
  result = 4294967274LL;
  if ( a2 )
  {
    if ( !*(_QWORD *)(v3 + 32) )
    {
      result = 0LL;
      v2[1] = v2[3];
      *a2 = 0LL;
    }
  }
  return result;
}

//----- (000000000009DDDC) ----------------------------------------------------
__int64 __fastcall i2c_ASN1_BIT_STRING(int *a1, char **a2)
{
  char **v2; // x19
  int v3; // w23
  __int64 v4; // x8
  __int64 v5; // x10
  int v6; // w8
  unsigned __int8 v7; // vf
  int v8; // w24
  unsigned int v9; // w20
  char *v10; // x21
  char *v11; // x21
  char *v12; // x8

  v2 = a2;
  if ( !a1 )
    return 0;
  v3 = *a1;
  if ( *a1 < 1 )
  {
LABEL_17:
    LOBYTE(v8) = 0;
    v9 = v3 + 1;
    if ( !a2 )
      return v9;
    goto LABEL_32;
  }
  v4 = *((_QWORD *)a1 + 2);
  if ( !(v4 & 8) )
  {
    v5 = v3++;
    do
    {
      v6 = *(unsigned __int8 *)(*((_QWORD *)a1 + 1) + v5 - 1);
      --v3;
      v7 = __OFSUB__(v5--, 1LL);
    }
    while ( !((v5 < 0) ^ v7) && !v6 );
    if ( !(v6 & 1) )
    {
      if ( v6 & 2 )
      {
        LOBYTE(v8) = 1;
        v9 = v3 + 1;
        if ( !a2 )
          return v9;
      }
      else if ( v6 & 4 )
      {
        LOBYTE(v8) = 2;
        v9 = v3 + 1;
        if ( !a2 )
          return v9;
      }
      else if ( v6 & 8 )
      {
        LOBYTE(v8) = 3;
        v9 = v3 + 1;
        if ( !a2 )
          return v9;
      }
      else if ( v6 & 0x10 )
      {
        LOBYTE(v8) = 4;
        v9 = v3 + 1;
        if ( !a2 )
          return v9;
      }
      else if ( v6 & 0x20 )
      {
        LOBYTE(v8) = 5;
        v9 = v3 + 1;
        if ( !a2 )
          return v9;
      }
      else if ( v6 & 0x40 )
      {
        LOBYTE(v8) = 6;
        v9 = v3 + 1;
        if ( !a2 )
          return v9;
      }
      else
      {
        v8 = (v6 << 24 >> 31) & 7;
        v9 = v3 + 1;
        if ( !a2 )
          return v9;
      }
      goto LABEL_32;
    }
    goto LABEL_17;
  }
  LOBYTE(v8) = v4 & 7;
  v9 = v3 + 1;
  if ( !a2 )
    return v9;
LABEL_32:
  v10 = *a2;
  *v10 = v8;
  v11 = v10 + 1;
  if ( v3 )
  {
    memcpy(v11, *((const void **)a1 + 1), v3);
    v12 = &v11[v3];
    if ( v3 >= 1 )
      *(v12 - 1) &= 255 << v8;
  }
  else
  {
    v12 = v11;
  }
  *v2 = v12;
  return v9;
}

//----- (000000000009DF48) ----------------------------------------------------
_DWORD *__fastcall c2i_ASN1_BIT_STRING(_DWORD **a1, _QWORD *a2, signed __int64 a3)
{
  signed __int64 v3; // x23
  _QWORD *v4; // x21
  _QWORD *v5; // x20
  signed __int64 v6; // x26
  _DWORD *v7; // x19
  char *v8; // x22
  unsigned int v9; // w27
  int v10; // w2
  __int16 v11; // w4
  char *v12; // x0
  char *v13; // x24
  void *v14; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a3 - 1;
  if ( a3 < 1 )
  {
    ERR_put_error(12, 0LL, 174, (__int64)"external/boringssl/src/crypto/asn1/a_bitstr.c", 138);
    return 0LL;
  }
  if ( a1 && (v7 = *a1) != 0LL || (v7 = ASN1_STRING_type_new(3)) != 0LL )
  {
    v8 = (char *)(*v4 + 1LL);
    v9 = *(unsigned __int8 *)*v4;
    if ( v9 >= 8 )
    {
      v10 = 141;
      v11 = 151;
LABEL_7:
      ERR_put_error(12, 0LL, v10, (__int64)"external/boringssl/src/crypto/asn1/a_bitstr.c", v11);
      if ( !v5 || (_DWORD *)*v5 != v7 )
        ASN1_STRING_free((__int64)v7);
      return 0LL;
    }
    *((_QWORD *)v7 + 2) = *((_QWORD *)v7 + 2) & 0xFFFFFFFFFFFFFFF0LL | v9 | 8;
    if ( v3 < 2 )
    {
      v13 = 0LL;
    }
    else
    {
      v12 = (char *)malloc((signed int)v6);
      v13 = v12;
      if ( !v12 )
      {
        v10 = 65;
        v11 = 165;
        goto LABEL_7;
      }
      if ( (_DWORD)v6 )
        memcpy(v12, v8, (signed int)v6);
      v8 += v6;
      v13[v3 - 2] &= 255 << v9;
    }
    v14 = (void *)*((_QWORD *)v7 + 1);
    *v7 = v6;
    if ( v14 )
      free(v14);
    *((_QWORD *)v7 + 1) = v13;
    v7[1] = 3;
    if ( v5 )
      *v5 = v7;
    *v4 = v8;
  }
  return v7;
}

//----- (000000000009E0C8) ----------------------------------------------------
signed __int64 __fastcall ASN1_BIT_STRING_set_bit(signed int *a1, int a2, int a3)
{
  int *v3; // x19
  int v4; // w8
  int v5; // w9
  signed int v6; // w21
  char v7; // w22
  size_t v8; // x1
  int v9; // w24
  _BYTE *v10; // x20
  __int64 *v11; // x23
  void *v12; // x0
  int v13; // w25
  __int64 v15; // x8
  size_t v16; // x2
  __int64 v17; // x9
  __int64 v18; // x8
  signed __int64 v19; // x9
  signed __int64 v20; // x10

  v3 = a1;
  v4 = a2 + 7;
  if ( a2 >= 0 )
    v4 = a2;
  v5 = ~a2 & 7;
  v6 = 1 << v5;
  if ( a3 )
    v7 = 1 << v5;
  else
    v7 = 0;
  if ( !a1 )
    return 0LL;
  v8 = *a1;
  v9 = v4 >> 3;
  *((_QWORD *)a1 + 2) &= 0xFFFFFFFFFFFFFFF0LL;
  if ( (signed int)v8 > v4 >> 3 )
  {
    v11 = (__int64 *)(a1 + 2);
    v10 = (_BYTE *)*((_QWORD *)a1 + 1);
    if ( v10 )
      goto LABEL_18;
  }
  if ( !a3 )
    return 1LL;
  v11 = (__int64 *)(a1 + 2);
  v12 = (void *)*((_QWORD *)a1 + 1);
  v13 = v9 + 1;
  if ( v12 )
  {
    v10 = sub_4BAEC(v12, v8, v9 + 1);
    if ( !v10 )
      goto LABEL_24;
    goto LABEL_15;
  }
  v10 = malloc(v13);
  if ( v10 )
  {
LABEL_15:
    v15 = *v3;
    v16 = v13 - v15;
    if ( (signed int)v16 >= 1 )
      memset(&v10[v15], 0, v16);
    *((_QWORD *)v3 + 1) = v10;
    *v3 = v13;
LABEL_18:
    v10[v9] = v10[v9] & ~(_BYTE)v6 | v7;
    v17 = *v3;
    if ( (signed int)v17 >= 1 )
    {
      v18 = *v11;
      v19 = v17 - 1;
      do
      {
        if ( *(_BYTE *)(v18 + v19) )
          break;
        *v3 = v19;
        v20 = v19-- + 1;
      }
      while ( v20 > 1 );
    }
    return 1LL;
  }
LABEL_24:
  ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_bitstr.c", 217);
  return 0LL;
}

//----- (000000000009E224) ----------------------------------------------------
__int64 __fastcall ASN1_BIT_STRING_get_bit(__int64 result, int a2)
{
  int v2; // w8
  int v3; // w8
  __int64 v4; // x9

  v2 = a2 + 7;
  if ( a2 >= 0 )
    v2 = a2;
  if ( result )
  {
    v3 = v2 >> 3;
    if ( *(_DWORD *)result <= v3 )
    {
      result = 0LL;
    }
    else
    {
      v4 = *(_QWORD *)(result + 8);
      if ( v4 )
        result = (*(unsigned __int8 *)(v4 + v3) & (1 << (~(_BYTE)a2 & 7))) != 0;
      else
        result = 0LL;
    }
  }
  return result;
}

//----- (000000000009E27C) ----------------------------------------------------
bool __fastcall ASN1_BIT_STRING_check(signed int *a1, __int64 a2, int a3)
{
  __int64 v3; // x8
  signed __int64 v4; // x9
  signed __int64 v5; // x10
  char v6; // w12
  int v7; // w12

  if ( !a1 )
    return 1LL;
  v3 = *((_QWORD *)a1 + 1);
  if ( !v3 )
    return 1LL;
  v4 = *a1;
  if ( (signed int)v4 < 1 )
    return 1LL;
  v5 = 0LL;
  do
  {
    if ( v5 >= a3 )
      v6 = -1;
    else
      v6 = ~*(_BYTE *)(a2 + v5);
    v7 = (unsigned __int8)(v6 & *(_BYTE *)(v3 + v5));
    if ( v7 )
      break;
    ++v5;
  }
  while ( v5 < v4 );
  return v7 == 0;
}

//----- (000000000009E2F0) ----------------------------------------------------
void __fastcall ASN1_d2i_fp(__int64 a1, void (__fastcall *a2)(__int64, __int64 *, _QWORD), __int64 a3, __int64 a4)
{
  __int64 v4; // x20
  __int64 v5; // x22
  void (__fastcall *v6)(__int64, __int64 *, _QWORD); // x21
  void *v7; // x0
  _QWORD *v8; // x0
  _QWORD *v9; // x19
  int v10; // w0
  __int64 v11; // x22
  __int64 v12; // [xsp+8h] [xbp-38h]
  __int64 v13; // [xsp+10h] [xbp-30h]
  __int64 v14; // [xsp+18h] [xbp-28h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = BIO_s_file();
  v8 = BIO_new((__int64)v7);
  v9 = v8;
  if ( v8 )
  {
    BIO_set_fp(v8, v5, 0);
    v13 = 0LL;
    sub_9E48C(v9, &v13);
    v11 = v13;
    if ( v10 & 0x80000000 )
    {
      if ( !v13 )
      {
LABEL_7:
        BIO_free((__int64)v9);
        goto LABEL_8;
      }
    }
    else
    {
      v12 = *(_QWORD *)(v13 + 8);
      v6(v4, &v12, v10);
    }
    BUF_MEM_free(v11);
    goto LABEL_7;
  }
  ERR_put_error(12, 0LL, 7, (__int64)"external/boringssl/src/crypto/asn1/a_d2i_fp.c", 76);
LABEL_8:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009E3E8) ----------------------------------------------------
void __fastcall ASN1_d2i_bio(__int64 a1, void (__fastcall *a2)(__int64, __int64 *, _QWORD), _QWORD *a3, __int64 a4)
{
  void (__fastcall *v4)(__int64, __int64 *, _QWORD); // x21
  __int64 v5; // x20
  int v6; // w0
  __int64 v7; // x19
  __int64 v8; // [xsp+8h] [xbp-38h]
  __int64 v9; // [xsp+10h] [xbp-30h]
  __int64 v10; // [xsp+18h] [xbp-28h]

  v4 = a2;
  v5 = a4;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = 0LL;
  sub_9E48C(a3, &v9);
  v7 = v9;
  if ( !(v6 & 0x80000000) )
  {
    v8 = *(_QWORD *)(v9 + 8);
    v4(v5, &v8, v6);
    if ( !v7 )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( v9 )
LABEL_5:
    BUF_MEM_free(v7);
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009E48C) ----------------------------------------------------
void __fastcall sub_9E48C(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // x23
  _QWORD *v3; // x22
  _QWORD *v4; // x19
  int v5; // w27
  unsigned __int64 v6; // x20
  __int64 v7; // x28
  unsigned __int8 v8; // cf
  __int64 v9; // x21
  signed int v10; // w0
  __int64 v11; // x8
  int v12; // w21
  int v13; // w0
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x21
  char v16; // w9
  unsigned __int64 v17; // x23
  unsigned __int64 v18; // x24
  unsigned __int64 v19; // x26
  int v20; // w0
  int v21; // w2
  __int16 v22; // w4
  _QWORD *v23; // [xsp+8h] [xbp-B8h]
  unsigned __int64 v24; // [xsp+20h] [xbp-A0h]
  int v25; // [xsp+30h] [xbp-90h]
  int v26; // [xsp+34h] [xbp-8Ch]
  __int64 v27; // [xsp+38h] [xbp-88h]
  unsigned __int64 v28; // [xsp+40h] [xbp-80h]
  __int64 v29; // [xsp+68h] [xbp-58h]

  v2 = a2;
  v3 = a1;
  v29 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = BUF_MEM_new();
  if ( !v4 )
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_d2i_fp.c", 158);
    goto LABEL_46;
  }
  ERR_clear_error();
  v5 = 0;
  v6 = 0LL;
  v7 = 0LL;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = v7 - v6;
        if ( v7 - v6 <= 8 )
        {
          if ( __CFADD__(8 - v9, v7) || !BUF_MEM_grow_clean((__int64)v4, v6 + 8) )
          {
            v21 = 65;
            v22 = 168;
            goto LABEL_44;
          }
          v10 = BIO_read(v3, v4[1] + v7, 8 - (signed int)v9);
          if ( v7 == v6 && v10 & 0x80000000 )
          {
            v21 = 162;
            v22 = 173;
            goto LABEL_44;
          }
          if ( v10 >= 1 )
          {
            v8 = __CFADD__(v7, v10);
            v7 += v10;
            if ( v8 )
            {
              v21 = 177;
              v22 = 178;
              goto LABEL_44;
            }
          }
        }
        v11 = v4[1];
        v12 = v11 + v6;
        v24 = v11 + v6;
        v13 = ASN1_get_object((unsigned __int8 **)&v24, (signed __int64 *)&v28, &v26, (int *)&v27, v7 - v6);
        v25 = v13;
        if ( v13 & 0x80 )
        {
          if ( (ERR_peek_error() & 0xFFF) != 177 )
            goto LABEL_45;
          ERR_clear_error();
          LOBYTE(v13) = v25;
        }
        v6 += (signed int)v24 - v12;
        if ( !(v13 & 1) )
          break;
        if ( (unsigned __int8)((v5 + 2 < 0) ^ __OFADD__(v5, 2)) | (v5 == -2) )
        {
          v21 = 123;
          v22 = 206;
LABEL_44:
          ERR_put_error(12, 0LL, v21, (__int64)"external/boringssl/src/crypto/asn1/a_d2i_fp.c", v22);
LABEL_45:
          BUF_MEM_free((__int64)v4);
          goto LABEL_46;
        }
        ++v5;
      }
      v14 = v28;
      if ( !v5 || v28 || v26 )
        break;
      if ( v5 < 2 )
        goto LABEL_50;
      --v5;
    }
    v15 = v28 - (v7 - v6);
    if ( v28 > v7 - v6 )
    {
      if ( __CFADD__(v15, v7) )
        v16 = 1;
      else
        v16 = 0;
      if ( v15 >> 31 || v16 & 1 )
      {
        v21 = 177;
        v22 = 225;
        goto LABEL_44;
      }
      if ( v28 != v7 - v6 )
      {
        v23 = v2;
        v17 = 0x4000LL;
        while ( 1 )
        {
          if ( v15 <= v17 )
            v18 = v15;
          else
            v18 = v17;
          if ( !BUF_MEM_grow_clean((__int64)v4, v18 + v7) )
          {
            v21 = 65;
            v22 = 238;
            goto LABEL_44;
          }
          if ( v18 )
            break;
LABEL_41:
          v15 -= v18;
          v17 <<= v17 < 0x3FFFFFFF;
          if ( !v15 )
          {
            v14 = v28;
            v2 = v23;
            goto LABEL_9;
          }
        }
        v19 = v18;
        while ( 1 )
        {
          v20 = BIO_read(v3, v4[1] + v7, v19);
          if ( v20 <= 0 )
            break;
          v7 += v20;
          v19 -= v20;
          if ( !v19 )
            goto LABEL_41;
        }
        v21 = 162;
        v22 = 245;
        goto LABEL_44;
      }
    }
LABEL_9:
    v8 = __CFADD__(v14, v6);
    v6 += v14;
    if ( v8 )
    {
      v21 = 177;
      v22 = 260;
      goto LABEL_44;
    }
  }
  while ( v5 > 0 );
LABEL_50:
  if ( v6 >> 31 )
  {
    v21 = 177;
    v22 = 272;
    goto LABEL_44;
  }
  *v2 = v4;
LABEL_46:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v29;
}

//----- (000000000009E7E0) ----------------------------------------------------
void __fastcall ASN1_item_d2i_bio(unsigned __int8 *a1, _QWORD *a2, unsigned __int64 **a3)
{
  unsigned __int8 *v3; // x21
  unsigned __int64 **v4; // x20
  int v5; // w0
  __int64 v6; // x19
  __int64 v7; // [xsp+8h] [xbp-38h]
  __int64 v8; // [xsp+10h] [xbp-30h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v3 = a1;
  v4 = a3;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = 0LL;
  sub_9E48C(a2, &v8);
  v6 = v8;
  if ( !(v5 & 0x80000000) )
  {
    v7 = *(_QWORD *)(v8 + 8);
    ASN1_item_d2i(v4, (const void **)&v7, v5, v3);
    if ( !v6 )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( v8 )
LABEL_5:
    BUF_MEM_free(v6);
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009E88C) ----------------------------------------------------
void __fastcall ASN1_item_d2i_fp(unsigned __int8 *a1, __int64 a2, unsigned __int64 **a3)
{
  unsigned __int64 **v3; // x20
  __int64 v4; // x22
  unsigned __int8 *v5; // x21
  void *v6; // x0
  _QWORD *v7; // x0
  _QWORD *v8; // x19
  int v9; // w0
  __int64 v10; // x22
  __int64 v11; // [xsp+8h] [xbp-38h]
  __int64 v12; // [xsp+10h] [xbp-30h]
  __int64 v13; // [xsp+18h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = BIO_s_file();
  v7 = BIO_new((__int64)v6);
  v8 = v7;
  if ( v7 )
  {
    BIO_set_fp(v7, v4, 0);
    v12 = 0LL;
    sub_9E48C(v8, &v12);
    v10 = v12;
    if ( v9 & 0x80000000 )
    {
      if ( !v12 )
      {
LABEL_7:
        BIO_free((__int64)v8);
        goto LABEL_8;
      }
    }
    else
    {
      v11 = *(_QWORD *)(v12 + 8);
      ASN1_item_d2i(v3, (const void **)&v11, v9, v5);
    }
    BUF_MEM_free(v10);
    goto LABEL_7;
  }
  ERR_put_error(12, 0LL, 7, (__int64)"external/boringssl/src/crypto/asn1/a_d2i_fp.c", 133);
LABEL_8:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009E988) ----------------------------------------------------
void __fastcall ASN1_dup(__int64 (__fastcall *a1)(__int64, void **), void (__fastcall *a2)(_QWORD, void **, _QWORD), __int64 a3)
{
  __int64 v3; // x20
  void (__fastcall *v4)(_QWORD, void **, _QWORD); // x19
  __int64 (__fastcall *v5)(__int64, void **); // x21
  int v6; // w0
  void *v7; // x22
  int v8; // w0
  void *v9; // [xsp+8h] [xbp-38h]
  void *v10; // [xsp+10h] [xbp-30h]
  __int64 v11; // [xsp+18h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 )
  {
    v6 = a1(a3, 0LL);
    v7 = malloc(v6 + 10);
    if ( v7 )
    {
      v10 = v7;
      v8 = v5(v3, &v10);
      v9 = v7;
      v4(0LL, &v9, v8);
      free(v7);
    }
    else
    {
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_dup.c", 75);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009EA5C) ----------------------------------------------------
void __fastcall ASN1_item_dup(unsigned __int8 *a1, __int64 a2)
{
  unsigned __int8 *v2; // x19
  int v3; // w0
  void *v4; // [xsp+8h] [xbp-28h]
  void *v5; // [xsp+10h] [xbp-20h]
  __int64 v6; // [xsp+18h] [xbp-18h]

  v2 = a1;
  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = 0LL;
  if ( a2 )
  {
    ASN1_item_i2d();
    if ( v5 )
    {
      v4 = v5;
      ASN1_item_d2i(0LL, (const void **)&v4, v3, v2);
      free(v5);
    }
    else
    {
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_dup.c", 104);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009EB18) ----------------------------------------------------
signed __int64 __fastcall ASN1_ENUMERATED_set(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  signed int v4; // w8
  _BYTE *v5; // x0
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x9
  __int64 v8; // x10
  _BYTE *v9; // x11
  char v10; // w13
  __int64 v11; // x12
  signed __int64 result; // x0
  _BYTE v13[6]; // [xsp+Ah] [xbp-26h]
  char v14[12]; // [xsp+Ch] [xbp-24h]
  __int64 v15; // [xsp+18h] [xbp-18h]

  v2 = a1;
  v3 = a2;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *(_DWORD *)a1;
  v5 = *(_BYTE **)(a1 + 8);
  *(_DWORD *)(v2 + 4) = 10;
  if ( v4 > 8 )
  {
    if ( v5 )
    {
      if ( !(a2 & 0x8000000000000000LL) )
        goto LABEL_10;
      goto LABEL_9;
    }
LABEL_21:
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_enum.c", 88);
    result = 0LL;
    goto LABEL_22;
  }
  if ( v5 )
    free(v5);
  v5 = malloc(9uLL);
  *(_QWORD *)(v2 + 8) = v5;
  if ( !v5 )
    goto LABEL_21;
  v5[8] = 0;
  *(_QWORD *)v5 = 0LL;
  if ( !(v3 & 0x8000000000000000LL) )
    goto LABEL_10;
LABEL_9:
  v3 = -v3;
  *(_DWORD *)(v2 + 4) = 266;
LABEL_10:
  if ( !v3 )
    goto LABEL_25;
  v6 = 0LL;
  do
  {
    v7 = v6++;
    v14[v7] = v3;
    if ( v6 > 7 )
      break;
    v3 >>= 8;
  }
  while ( v3 );
  if ( ((_DWORD)v6 - 1) & 0x80000000 )
  {
LABEL_25:
    LODWORD(v6) = 0;
  }
  else
  {
    *v5 = v14[(signed int)v6 - 1];
    if ( (_DWORD)v6 != 1 )
    {
      v8 = 0LL;
      v9 = v13;
      do
      {
        v10 = (v9--)[v6];
        v11 = *(_QWORD *)(v2 + 8) + v8++;
        *(_BYTE *)(v11 + 1) = v10;
      }
      while ( v7 != v8 );
    }
  }
  result = 1LL;
  *(_DWORD *)v2 = v6;
LABEL_22:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 9EB18: using guessed type char var_24[12];

//----- (000000000009EC58) ----------------------------------------------------
signed __int64 __fastcall ASN1_ENUMERATED_get(signed __int64 result)
{
  int v1; // w8
  signed int v2; // w8
  __int64 v3; // x9
  unsigned __int8 *v4; // x10
  unsigned __int64 v5; // x12
  unsigned __int8 v6; // t1
  signed __int64 v7; // x11

  if ( result )
  {
    v1 = *(_DWORD *)(result + 4);
    if ( v1 == 266 )
    {
      v2 = 1;
    }
    else
    {
      if ( v1 != 10 )
        return -1LL;
      v2 = 0;
    }
    v3 = *(unsigned int *)result;
    if ( (signed int)v3 <= 8 )
    {
      v4 = *(unsigned __int8 **)(result + 8);
      if ( v4 )
      {
        if ( (signed int)v3 < 1 )
        {
          v7 = 0LL;
        }
        else
        {
          v5 = 0LL;
          do
          {
            v6 = *v4++;
            --v3;
            v7 = v6 | (v5 << 8);
            v5 = v6 | (v5 << 8);
          }
          while ( v3 );
        }
        if ( v2 )
          result = !v7;
        else
          result = v7;
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000009ECDC) ----------------------------------------------------
int *__fastcall BN_to_ASN1_ENUMERATED(__int64 a1, int *a2)
{
  int *v2; // x20
  __int64 v3; // x21
  int *v4; // x19
  signed int v5; // w8
  int v6; // w0
  int v7; // w8
  int v8; // w9
  _BYTE *v9; // x8
  _BYTE *v10; // x0
  int v11; // w2
  __int16 v12; // w4

  v2 = a2;
  v3 = a1;
  v4 = a2;
  if ( a2 || (v4 = ASN1_STRING_type_new(10)) != 0LL )
  {
    if ( BN_is_negative(v3) )
      v5 = 266;
    else
      v5 = 10;
    v4[1] = v5;
    v6 = BN_num_bits(v3);
    if ( v6 )
    {
      v7 = v6 + 7;
      if ( v6 >= 0 )
        v7 = v6;
      v8 = (v7 >> 3) + 5;
    }
    else
    {
      v8 = 4;
    }
    v9 = (_BYTE *)*((_QWORD *)v4 + 1);
    if ( *v4 >= v8 )
      goto LABEL_14;
    v10 = realloc(*((void **)v4 + 1), v8);
    v9 = v10;
    if ( v10 )
    {
      *((_QWORD *)v4 + 1) = v10;
LABEL_14:
      *v4 = BN_bn2bin(v3, v9);
      return v4;
    }
    v11 = 65;
    v12 = 161;
  }
  else
  {
    v11 = 158;
    v12 = 149;
  }
  ERR_put_error(12, 0LL, v11, (__int64)"external/boringssl/src/crypto/asn1/a_enum.c", v12);
  if ( v4 != v2 )
    ASN1_STRING_free((__int64)v4);
  return 0LL;
}

//----- (000000000009EDE8) ----------------------------------------------------
__int64 __fastcall ASN1_ENUMERATED_to_BN(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 **v2; // x20
  __int64 v3; // x0
  __int64 v4; // x19

  v2 = a1;
  v3 = BN_bin2bn(a1[1], *(signed int *)a1, a2);
  v4 = v3;
  if ( v3 )
  {
    if ( *((_DWORD *)v2 + 1) == 266 )
      BN_set_negative(v3, 1);
  }
  else
  {
    ERR_put_error(12, 0LL, 105, (__int64)"external/boringssl/src/crypto/asn1/a_enum.c", 180);
  }
  return v4;
}

//----- (000000000009EE60) ----------------------------------------------------
__int64 __fastcall sub_9EE60(int *a1, signed int *a2)
{
  signed __int64 v2; // x9
  unsigned int v3; // w8
  __int64 v5; // x10
  __int64 v6; // x12
  signed __int64 v7; // x11
  int v8; // w3
  int v9; // w8
  int v10; // w3
  int v11; // w8
  signed int v12; // w12
  int v13; // w8
  __int64 v14; // x12
  int v15; // w15
  int v16; // w17
  signed int v17; // w8
  signed __int64 v18; // x13
  int v19; // w12
  int v20; // w14
  unsigned int v21; // w12
  signed __int64 v22; // x13
  int v23; // w10
  int v24; // w13
  unsigned int v25; // w10
  int v26; // w9
  int v27; // w0
  int v28; // [xsp+0h] [xbp-10h]
  int v29; // [xsp+8h] [xbp-8h]

  if ( a2[1] != 24 )
    return 0;
  v2 = *a2;
  if ( (signed int)v2 < 13 )
    return 0;
  v5 = *((_QWORD *)a2 + 1);
  v6 = 0LL;
  v7 = 0LL;
  while ( 1 )
  {
    v8 = *(unsigned __int8 *)(v5 + v7);
    if ( v6 == 6 && (unsigned int)(v8 - 43) <= 0x2F && (1LL << ((unsigned __int8)v8 - 43)) & 0x800000000005LL )
      break;
    v3 = 0;
    if ( v7 >= v2 || ((v8 - 48) & 0xFFu) > 9 )
      return v3;
    v9 = *(unsigned __int8 *)(v5 + 1 + v7);
    if ( (unsigned int)(v9 - 48) > 9 )
      return 0;
    v7 += 2LL;
    if ( v7 > v2 )
      return 0;
    v10 = v9 + 10 * v8;
    v11 = v10 - 528;
    if ( v10 - 528 < dword_DD4DC[v6] || v11 > dword_DD500[v6] )
      return 0;
    if ( a1 )
    {
      switch ( (_DWORD)v6 )
      {
        case 0:
          a1[5] = 100 * v11 - 1900;
          break;
        case 1:
          a1[5] += v11;
          break;
        case 2:
          a1[4] = v10 - 529;
          break;
        case 3:
          a1[3] = v11;
          break;
        case 4:
          a1[2] = v11;
          break;
        case 5:
          a1[1] = v11;
          break;
        case 6:
          *a1 = v11;
          break;
        default:
          break;
      }
    }
    if ( ++v6 >= 7 )
      goto LABEL_28;
  }
  if ( a1 )
    *a1 = 0;
LABEL_28:
  v12 = *(unsigned __int8 *)(v5 + (signed int)v7);
  if ( v12 == 46 )
  {
    if ( (signed int)v7 >= (signed int)v2 )
      return 0;
    v13 = v7 | 1;
    v14 = 0LL;
    v7 = ((signed __int64)(signed int)(v7 | 1) << 32) - 0x100000000LL;
    do
    {
      v7 += 0x100000000LL;
      v15 = v14 + 1;
      if ( v13 + v14 > v2 )
        break;
      v16 = *(unsigned __int8 *)(v5 + v13 + v14++);
    }
    while ( ((v16 - 48) & 0xFFu) < 0xA );
    if ( v15 == 1 )
      return 0;
    v12 = *(unsigned __int8 *)(v5 + (v7 >> 32));
    LODWORD(v7) = v13 - 1 + v15;
  }
  v3 = 0;
  if ( v12 > 44 )
  {
    if ( v12 != 45 )
    {
      if ( v12 != 90 )
        return v3;
      LODWORD(v7) = v7 + 1;
      return (_DWORD)v7 == (_DWORD)v2;
    }
  }
  else
  {
    if ( !v12 )
      return (_DWORD)v7 == (_DWORD)v2;
    if ( v12 != 43 )
      return v3;
  }
  if ( v12 == 45 )
    v17 = -1;
  else
    v17 = 0;
  if ( (signed int)v7 + 5 > (signed int)v2 )
    return 0;
  v18 = (signed int)v7 + 1LL;
  v19 = *(unsigned __int8 *)(v5 + v18);
  if ( (unsigned int)(v19 - 48) > 9 )
    return 0;
  v20 = *(unsigned __int8 *)(v5 + v18 + 1);
  if ( (unsigned int)(v20 - 48) > 9 )
    return 0;
  v21 = v20 + 10 * v19 - 528;
  if ( v21 > 0xC )
    return 0;
  v22 = v5 + v18;
  v23 = *(unsigned __int8 *)(v22 + 2);
  if ( (unsigned int)(v23 - 48) > 9 )
    return 0;
  v24 = *(unsigned __int8 *)(v22 + 3);
  if ( (unsigned int)(v24 - 48) > 9 )
    return 0;
  v25 = v24 + 10 * v23 - 528;
  if ( v25 > 0x3B )
    return 0;
  LODWORD(v7) = v7 + 5;
  if ( !a1 )
    return (_DWORD)v7 == (_DWORD)v2;
  v28 = v2;
  v29 = v7;
  v26 = 3600 * v21 + 60 * v25;
  if ( !v26 )
  {
    LODWORD(v2) = v28;
    return (_DWORD)v7 == (_DWORD)v2;
  }
  v27 = sub_A4A7C(a1, 0, v26 * v17);
  LODWORD(v2) = v28;
  LODWORD(v7) = v29;
  if ( v27 )
    return (_DWORD)v7 == (_DWORD)v2;
  return 0;
}

//----- (000000000009F158) ----------------------------------------------------
__int64 __fastcall ASN1_GENERALIZEDTIME_check(signed int *a1)
{
  return sub_9EE60(0LL, a1);
}

//----- (000000000009F168) ----------------------------------------------------
__int64 __fastcall ASN1_GENERALIZEDTIME_set_string(__int64 a1, const char *a2)
{
  const char *v2; // x20
  __int64 v3; // x19
  int v4; // w0
  int v5; // w21
  __int64 result; // x0
  int v7; // [xsp+0h] [xbp-40h]
  int v8; // [xsp+4h] [xbp-3Ch]
  const char *v9; // [xsp+8h] [xbp-38h]
  __int64 v10; // [xsp+18h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = 24;
  v4 = strlen(a2);
  v5 = v4;
  v7 = v4;
  v9 = v2;
  result = sub_9EE60(0LL, &v7);
  if ( (_DWORD)result )
  {
    if ( !v3 )
    {
LABEL_5:
      result = 1LL;
      goto LABEL_6;
    }
    result = ASN1_STRING_set(v3, v2, v5);
    if ( (_DWORD)result )
    {
      *(_DWORD *)(v3 + 4) = 24;
      goto LABEL_5;
    }
  }
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (000000000009F20C) ----------------------------------------------------
void __fastcall ASN1_GENERALIZEDTIME_set(_DWORD *a1, __int64 a2)
{
  ASN1_GENERALIZEDTIME_adj(a1, a2, 0, 0LL);
}

//----- (000000000009F218) ----------------------------------------------------
void __fastcall ASN1_GENERALIZEDTIME_adj(_DWORD *a1, __int64 a2, int a3, __int64 a4)
{
  _DWORD *v4; // x20
  __int64 v5; // x22
  int v6; // w23
  _DWORD *v7; // x19
  int *v8; // x0
  int *v9; // x21
  const char *v10; // x22
  __int64 v11; // [xsp+0h] [xbp-80h]
  char v12; // [xsp+8h] [xbp-78h]
  __int64 v13; // [xsp+40h] [xbp-40h]
  __int64 v14; // [xsp+48h] [xbp-38h]

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = a2;
  if ( a1 || (v7 = ASN1_GENERALIZEDTIME_new()) != 0LL )
  {
    v8 = (int *)j__gmtime_r(&v13, &v12);
    v9 = v8;
    if ( v8 && (!v6 && !v5 || (unsigned int)sub_A4A7C(v8, v6, v5)) )
    {
      v10 = (const char *)*((_QWORD *)v7 + 1);
      if ( v10 && *v7 > 0x13u )
        goto LABEL_11;
      v10 = (const char *)malloc(0x14uLL);
      if ( v10 )
      {
        free(*((void **)v7 + 1));
        *((_QWORD *)v7 + 1) = v10;
LABEL_11:
        LODWORD(v11) = *v9;
        BIO_snprintf(
          (__int64)v10,
          20LL,
          (__int64)"%04d%02d%02d%02d%02d%02dZ",
          (unsigned int)(v9[5] + 1900),
          (unsigned int)(v9[4] + 1),
          (unsigned int)v9[3],
          (unsigned int)v9[2],
          (unsigned int)v9[1],
          v11);
        *v7 = strlen(v10);
        v7[1] = 24;
        goto LABEL_15;
      }
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_gentm.c", 244);
    }
    if ( !v4 )
      ASN1_VISIBLESTRING_free(v7);
  }
LABEL_15:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);
// A4A78: using guessed type __int64 __fastcall j__gmtime_r(_QWORD, _QWORD);

//----- (000000000009F360) ----------------------------------------------------
__int64 __fastcall ASN1_i2d_fp(void (__fastcall *a1)(__int64, void **), __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x22
  void (__fastcall *v5)(__int64, void **); // x20
  void *v6; // x0
  _QWORD *v7; // x0
  _QWORD *v8; // x21
  unsigned int v9; // w0
  unsigned int v10; // w19
  __int64 result; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = BIO_s_file();
  v7 = BIO_new((__int64)v6);
  v8 = v7;
  if ( v7 )
  {
    BIO_set_fp(v7, v4, 0);
    ASN1_i2d_bio(v5, v8, v3);
    v10 = v9;
    BIO_free((__int64)v8);
    result = v10;
  }
  else
  {
    ERR_put_error(12, 0LL, 7, (__int64)"external/boringssl/src/crypto/asn1/a_i2d_fp.c", 68);
    result = 0LL;
  }
  return result;
}

//----- (000000000009F3F0) ----------------------------------------------------
void __fastcall ASN1_i2d_bio(void (__fastcall *a1)(__int64, void **), _QWORD *a2, __int64 a3)
{
  __int64 v3; // x22
  _QWORD *v4; // x19
  void (__fastcall *v5)(__int64, void **); // x23
  signed int v6; // w21
  void *v7; // x20
  signed int v8; // w0
  int v9; // w22
  void *v10; // [xsp+0h] [xbp-40h]
  __int64 v11; // [xsp+8h] [xbp-38h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = ((__int64 (__fastcall *)(__int64, _QWORD))a1)(a3, 0LL);
  v7 = malloc(v6);
  if ( v7 )
  {
    v10 = v7;
    v5(v3, &v10);
    v8 = BIO_write(v4, (__int64)v7, v6);
    if ( v6 != v8 )
    {
      v9 = 0;
      do
      {
        if ( v8 < 1 )
          break;
        v9 += v8;
        v6 -= v8;
        v8 = BIO_write(v4, (__int64)v7 + v9, v6);
      }
      while ( v6 != v8 );
    }
    free(v7);
  }
  else
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_i2d_fp.c", 86);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009F500) ----------------------------------------------------
__int64 __fastcall ASN1_item_i2d_fp(__int64 a1, __int64 a2)
{
  __int64 v2; // x22
  void *v3; // x0
  _QWORD *v4; // x0
  __int64 v5; // x21
  unsigned int v6; // w0
  unsigned int v7; // w19
  __int64 result; // x0

  v2 = a2;
  v3 = BIO_s_file();
  v4 = BIO_new((__int64)v3);
  v5 = (__int64)v4;
  if ( v4 )
  {
    BIO_set_fp(v4, v2, 0);
    ASN1_item_i2d_bio();
    v7 = v6;
    BIO_free(v5);
    result = v7;
  }
  else
  {
    ERR_put_error(12, 0LL, 7, (__int64)"external/boringssl/src/crypto/asn1/a_i2d_fp.c", 114);
    result = 0LL;
  }
  return result;
}

//----- (000000000009F590) ----------------------------------------------------
void ASN1_item_i2d_bio()
{
  __int64 v0; // ST08_8

  v0 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  ASN1_item_i2d();
  ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_i2d_fp.c", 130);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009F684) ----------------------------------------------------
__int64 __fastcall ASN1_INTEGER_cmp(__int64 a1, __int64 a2)
{
  unsigned int v2; // w19
  __int64 result; // x0

  v2 = *(_DWORD *)(a1 + 4) & 0x100;
  if ( v2 != (*(_DWORD *)(a2 + 4) & 0x100) )
    return ((v2 >> 7) ^ 2) - 1;
  LODWORD(result) = ASN1_STRING_cmp((const void **)a1, a2);
  if ( v2 )
    result = !(_DWORD)result;
  else
    result = (unsigned int)result;
  return result;
}

//----- (000000000009F6D0) ----------------------------------------------------
__int64 __fastcall i2c_ASN1_INTEGER(__int64 a1, _BYTE **a2)
{
  _QWORD *v2; // x19
  signed int v3; // w10
  int v4; // w9
  char *v5; // x8
  int v6; // w11
  bool v7; // zf
  bool v8; // w14
  int v9; // w12
  char v10; // w12
  int v11; // w11
  unsigned int v12; // w20
  char *v13; // x8
  char *v14; // x1
  char *v15; // x11
  int v16; // w13
  int v17; // w9
  char *v18; // x12
  bool v19; // nf
  unsigned __int8 v20; // vf
  __int64 v21; // x14
  char *v22; // x8
  signed __int64 v23; // x13
  signed __int64 v24; // x10
  signed __int64 v25; // x13
  signed int v26; // w15
  __int64 v27; // x15
  signed __int64 v28; // x14
  int8x16_t *v29; // x15
  int8x16_t *v30; // x11
  int8x16_t v31; // q0
  int8x16_t v32; // q1
  char *v33; // x10
  int v34; // w9
  char v35; // t1
  signed __int64 v36; // x11

  v2 = a2;
  if ( !a1 )
    return 0;
  v3 = *(_DWORD *)a1;
  v4 = *(_DWORD *)(a1 + 4) & 0x100;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(char **)(a1 + 8);
    v6 = *v5;
    if ( (_BYTE)v6 )
      v7 = 0;
    else
      v7 = v3 == 1;
    if ( v7 )
      v4 = 0;
    v8 = v6 < 0;
    if ( !v4 )
    {
      v10 = 0;
      v11 = v8 && v4 == 0;
      goto LABEL_19;
    }
    v9 = (unsigned __int8)v6;
    if ( (unsigned __int8)v6 > 0x80u )
      goto LABEL_13;
    v11 = 0;
    if ( v9 == 128 )
    {
      v10 = 0;
      if ( v3 >= 2 )
      {
        v36 = 1LL;
        while ( !v5[v36] )
        {
          if ( (signed int)++v36 >= v3 )
          {
            v11 = 0;
            v10 = 0;
            v12 = *(_DWORD *)a1;
            if ( a2 )
              goto LABEL_20;
            return v12;
          }
        }
LABEL_13:
        v10 = -1;
        v11 = 1;
        v12 = v3 + 1;
        if ( !a2 )
          return v12;
        goto LABEL_20;
      }
LABEL_19:
      v12 = v11 + v3;
      if ( !a2 )
        return v12;
      goto LABEL_20;
    }
    v10 = 0;
    v12 = *(_DWORD *)a1;
    if ( !a2 )
      return v12;
  }
  else
  {
    v11 = 0;
    v10 = 0;
    v12 = 1;
    if ( !a2 )
      return v12;
  }
LABEL_20:
  v13 = *a2;
  if ( v11 )
  {
    *v13++ = v10;
    v3 = *(_DWORD *)a1;
  }
  if ( v3 )
  {
    v14 = *(char **)(a1 + 8);
    if ( v4 )
    {
      v15 = &v14[v3];
      LOBYTE(v16) = *(v15 - 1);
      v17 = v3 - 1;
      v18 = &v13[v3 - 1];
      if ( v3 > 1 && !*(v15 - 1) )
      {
        do
        {
          *v18-- = 0;
          v16 = (unsigned __int8)*(v15 - 2);
          v20 = __OFSUB__(v17, 1);
          v7 = v17 == 1;
          v19 = v17-- - 1 < 0;
          --v15;
        }
        while ( !((unsigned __int8)(v19 ^ v20) | v7) && !v16 );
      }
      v21 = (unsigned int)(v17 - 1);
      *v18 = -(char)v16;
      if ( v17 >= 1 )
      {
        v22 = v15 - 2;
        v23 = v21 + 1;
        if ( (unsigned __int64)(v21 + 1) < 0x20 )
          goto LABEL_57;
        v24 = v23 & 0x1F;
        v25 = v23 - v24;
        if ( !v25 )
          goto LABEL_57;
        v26 = v17 >= 1 ? 1 : v17;
        v27 = (unsigned int)(v17 + ~v26 + 1);
        if ( &v18[~v27] < v15 - 1 && &v15[-2 - v27] < v18 )
          goto LABEL_57;
        v28 = v24 - 1 - v21;
        v17 -= v25;
        v29 = (int8x16_t *)(v18 - 16);
        v22 += v28;
        v18 += v28;
        v30 = (int8x16_t *)(v15 - 33);
        do
        {
          v32 = *v30;
          v31 = v30[1];
          v30 -= 2;
          v25 -= 32LL;
          v29[-1] = vmvnq_s8(v32);
          *v29 = vmvnq_s8(v31);
          v29 -= 2;
        }
        while ( v25 );
        if ( v24 )
        {
LABEL_57:
          v33 = v18 - 1;
          v34 = v17 + 1;
          do
          {
            v35 = *v22--;
            --v34;
            *v33-- = ~v35;
          }
          while ( v34 > 1 );
        }
      }
    }
    else
    {
      memcpy(v13, v14, (unsigned int)v3);
    }
  }
  else
  {
    *v13 = 0;
  }
  *v2 += (signed int)v12;
  return v12;
}

//----- (000000000009F908) ----------------------------------------------------
__int64 __fastcall c2i_ASN1_INTEGER(__int64 *a1, _BYTE **a2, __int64 a3)
{
  __int64 v3; // x22
  _BYTE **v4; // x21
  __int64 *v5; // x20
  __int64 v6; // x19
  _DWORD *v7; // x0
  _BYTE *v8; // x24
  _BYTE *v9; // x0
  _BYTE *v10; // x23
  __int64 v11; // x8
  __int64 v12; // x25
  const void *v13; // x1
  void *v14; // x0
  _BOOL4 v15; // w10
  _BOOL4 v16; // w8
  __int64 v17; // x11
  signed __int64 v18; // x8
  signed __int64 v19; // x10
  unsigned __int64 v20; // x9
  int v21; // w11
  _BYTE *v22; // x10
  __int64 v23; // x13
  int v24; // w8
  bool v25; // w12
  signed int v26; // w8
  __int64 v27; // x13
  signed __int64 v28; // x12
  signed __int64 v29; // x13
  signed __int64 v30; // x11
  signed __int64 v31; // x12
  signed __int64 v32; // x15
  int8x16_t *v33; // x14
  int8x16_t *v34; // x9
  int8x16_t v35; // q0
  int8x16_t v36; // q1
  char *v37; // x9
  _BYTE *v38; // x10
  char v39; // t1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 || (v6 = *a1) == 0 )
  {
    v7 = ASN1_STRING_type_new(2);
    v6 = (__int64)v7;
    if ( !v7 )
      return v6;
    v7[1] = 2;
  }
  v8 = *v4;
  v9 = malloc(((v3 << 32) + 0x100000000LL) >> 32);
  v10 = v9;
  if ( v9 )
  {
    if ( !v3 )
    {
      LODWORD(v12) = 0;
      *(_DWORD *)(v6 + 4) = 2;
      v14 = *(void **)(v6 + 8);
      if ( !v14 )
        goto LABEL_47;
      goto LABEL_46;
    }
    if ( !((char)*v8 & 0x80000000) )
    {
      *(_DWORD *)(v6 + 4) = 2;
      v11 = (v3 != 1) & (unsigned __int8)(*v8 == 0);
      LODWORD(v12) = v3 - v11;
      if ( (v3 - v11) & 0xFFFFFFFFLL )
      {
        if ( v3 != 1 && *v8 == 0 )
          v13 = v8 + 1;
        else
          v13 = v8;
        memcpy(v9, v13, (signed int)v12);
        v14 = *(void **)(v6 + 8);
        if ( !v14 )
        {
LABEL_47:
          *(_QWORD *)(v6 + 8) = v10;
          *(_DWORD *)v6 = v12;
          if ( v5 )
            *v5 = v6;
          *v4 = &v8[v3];
          return v6;
        }
LABEL_46:
        free(v14);
        goto LABEL_47;
      }
LABEL_45:
      v14 = *(void **)(v6 + 8);
      if ( !v14 )
        goto LABEL_47;
      goto LABEL_46;
    }
    *(_DWORD *)(v6 + 4) = 258;
    v15 = v3 != 1;
    v16 = (unsigned __int8)*v8 == 255;
    v17 = v15 & (unsigned int)v16;
    if ( v15 && v16 )
      v18 = (signed __int64)(v8 + 1);
    else
      v18 = (signed __int64)v8;
    v12 = v3 - v17;
    v19 = (((v3 - v17) << 32) - 0x100000000LL) >> 32;
    v20 = v18 + v19;
    v21 = *(unsigned __int8 *)(v18 + v19);
    v22 = &v9[v19];
    if ( !(_DWORD)v12 || v21 )
    {
      v26 = v12;
      if ( (_DWORD)v12 == 0 )
        goto LABEL_34;
    }
    else
    {
      v23 = 0LL;
      do
      {
        v22[v23] = 0;
        v21 = *(unsigned __int8 *)(v20 + v23 - 1);
        v24 = v12 + v23 - 1;
        v25 = (_DWORD)v12 + (_DWORD)v23-- != 1;
      }
      while ( v24 && !v21 );
      v26 = v12 + v23;
      v22 += v23;
      v20 += v23;
      if ( !v25 )
      {
LABEL_34:
        *v9 = 1;
        v9[v12] = 0;
        LODWORD(v12) = v12 + 1;
        v14 = *(void **)(v6 + 8);
        if ( !v14 )
          goto LABEL_47;
        goto LABEL_46;
      }
    }
    v27 = (unsigned int)(v26 - 2);
    *v22 = -(char)v21;
    if ( v26 < 2 )
      goto LABEL_45;
    v28 = v27 + 1;
    if ( (unsigned __int64)(v27 + 1) >= 0x20 )
    {
      v30 = v28 & 0x1F;
      v31 = v28 - v30;
      if ( v31 && ((unsigned __int64)&v22[~v27] >= v20 || v20 + ~v27 >= (unsigned __int64)v22) )
      {
        v32 = v30 - 1 - v27;
        v26 -= v31;
        v33 = (int8x16_t *)(v22 - 16);
        v29 = v20 + v32;
        v22 += v32;
        v34 = (int8x16_t *)(v20 - 16);
        do
        {
          v36 = v34[-1];
          v35 = *v34;
          v34 -= 2;
          v31 -= 32LL;
          v33[-1] = vmvnq_s8(v36);
          *v33 = vmvnq_s8(v35);
          v33 -= 2;
        }
        while ( v31 );
        if ( !v30 )
          goto LABEL_45;
      }
      else
      {
        v29 = v20;
      }
    }
    else
    {
      v29 = v20;
    }
    v37 = (char *)(v29 - 1);
    v38 = v22 - 1;
    do
    {
      v39 = *v37--;
      --v26;
      *v38-- = ~v39;
    }
    while ( v26 > 1 );
    goto LABEL_45;
  }
  ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_int.c", 272);
  if ( !v5 || *v5 != v6 )
    ASN1_STRING_free(v6);
  return 0LL;
}

//----- (000000000009FBC8) ----------------------------------------------------
void __fastcall d2i_ASN1_UINTEGER(__int64 *a1, char **a2, __int64 a3)
{
  __int64 v3; // x22
  char **v4; // x21
  __int64 *v5; // x20
  __int64 v6; // x19
  _DWORD *v7; // x0
  void *v8; // x0
  void *v9; // x22
  __int64 v10; // x8
  char *v11; // x1
  void *v12; // x0
  int v13; // w2
  __int64 v14; // [xsp+0h] [xbp-50h]
  int v15; // [xsp+4h] [xbp-4Ch]
  __int64 v16; // [xsp+8h] [xbp-48h]
  char *v17; // [xsp+10h] [xbp-40h]
  __int64 v18; // [xsp+18h] [xbp-38h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 || (v6 = *a1) == 0 )
  {
    v7 = ASN1_STRING_type_new(2);
    v6 = (__int64)v7;
    if ( !v7 )
      goto LABEL_26;
    v7[1] = 2;
  }
  v17 = *v4;
  if ( ASN1_get_object((unsigned __int8 **)&v17, &v16, &v15, (int *)&v14, v3) & 0x80 )
  {
    v13 = 103;
  }
  else if ( v15 == 2 )
  {
    v8 = malloc(((v16 << 32) + 0x100000000LL) >> 32);
    v9 = v8;
    if ( v8 )
    {
      *(_DWORD *)(v6 + 4) = 2;
      v10 = v16;
      if ( v16 )
      {
        v11 = v17;
        if ( v16 != 1 && !*v17 )
        {
          v11 = v17 + 1;
          v10 = v16-- - 1;
          ++v17;
        }
        if ( (_DWORD)v10 )
        {
          memcpy(v8, v11, (signed int)v10);
          v10 = v16;
          v11 = v17;
        }
        v17 = &v11[v10];
      }
      v12 = *(void **)(v6 + 8);
      if ( v12 )
      {
        free(v12);
        LODWORD(v10) = v16;
      }
      *(_QWORD *)(v6 + 8) = v9;
      *(_DWORD *)v6 = v10;
      if ( v5 )
        *v5 = v6;
      *v4 = v17;
      goto LABEL_26;
    }
    v13 = 65;
  }
  else
  {
    v13 = 115;
  }
  ERR_put_error(12, 0LL, v13, (__int64)"external/boringssl/src/crypto/asn1/a_int.c", 341);
  if ( !v5 || *v5 != v6 )
    ASN1_STRING_free(v6);
LABEL_26:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (000000000009FD60) ----------------------------------------------------
signed __int64 __fastcall ASN1_INTEGER_set(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  signed int v4; // w8
  _BYTE *v5; // x0
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x9
  __int64 v8; // x10
  _BYTE *v9; // x11
  char v10; // w13
  __int64 v11; // x12
  signed __int64 result; // x0
  _BYTE v13[6]; // [xsp+Ah] [xbp-26h]
  char v14[12]; // [xsp+Ch] [xbp-24h]
  __int64 v15; // [xsp+18h] [xbp-18h]

  v2 = a1;
  v3 = a2;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = *(_DWORD *)a1;
  v5 = *(_BYTE **)(a1 + 8);
  *(_DWORD *)(v2 + 4) = 2;
  if ( v4 > 8 )
  {
    if ( v5 )
    {
      if ( !(a2 & 0x8000000000000000LL) )
        goto LABEL_10;
      goto LABEL_9;
    }
LABEL_21:
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_int.c", 363);
    result = 0LL;
    goto LABEL_22;
  }
  if ( v5 )
    free(v5);
  v5 = malloc(9uLL);
  *(_QWORD *)(v2 + 8) = v5;
  if ( !v5 )
    goto LABEL_21;
  v5[8] = 0;
  *(_QWORD *)v5 = 0LL;
  if ( !(v3 & 0x8000000000000000LL) )
    goto LABEL_10;
LABEL_9:
  v3 = -v3;
  *(_DWORD *)(v2 + 4) = 258;
LABEL_10:
  if ( !v3 )
    goto LABEL_25;
  v6 = 0LL;
  do
  {
    v7 = v6++;
    v14[v7] = v3;
    if ( v6 > 7 )
      break;
    v3 >>= 8;
  }
  while ( v3 );
  if ( ((_DWORD)v6 - 1) & 0x80000000 )
  {
LABEL_25:
    LODWORD(v6) = 0;
  }
  else
  {
    *v5 = v14[(signed int)v6 - 1];
    if ( (_DWORD)v6 != 1 )
    {
      v8 = 0LL;
      v9 = v13;
      do
      {
        v10 = (v9--)[v6];
        v11 = *(_QWORD *)(v2 + 8) + v8++;
        *(_BYTE *)(v11 + 1) = v10;
      }
      while ( v7 != v8 );
    }
  }
  result = 1LL;
  *(_DWORD *)v2 = v6;
LABEL_22:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 9FD60: using guessed type char var_24[12];

//----- (000000000009FEA0) ----------------------------------------------------
signed __int64 __fastcall ASN1_INTEGER_get(signed __int64 result)
{
  int v1; // w8
  signed int v2; // w8
  __int64 v3; // x9
  unsigned __int8 *v4; // x10
  unsigned __int64 v5; // x12
  unsigned __int8 v6; // t1
  signed __int64 v7; // x11

  if ( result )
  {
    v1 = *(_DWORD *)(result + 4);
    if ( v1 == 258 )
    {
      v2 = 1;
    }
    else
    {
      if ( v1 != 2 )
        return -1LL;
      v2 = 0;
    }
    v3 = *(unsigned int *)result;
    if ( (signed int)v3 <= 8 )
    {
      v4 = *(unsigned __int8 **)(result + 8);
      if ( v4 )
      {
        if ( (signed int)v3 < 1 )
        {
          v7 = 0LL;
        }
        else
        {
          v5 = 0LL;
          do
          {
            v6 = *v4++;
            --v3;
            v7 = v6 | (v5 << 8);
            v5 = v6 | (v5 << 8);
          }
          while ( v3 );
        }
        if ( v2 )
          result = !v7;
        else
          result = v7;
      }
      else
      {
        result = 0LL;
      }
    }
    else
    {
      result = -1LL;
    }
  }
  return result;
}

//----- (000000000009FF24) ----------------------------------------------------
int *__fastcall BN_to_ASN1_INTEGER(__int64 a1, int *a2)
{
  int *v2; // x20
  __int64 v3; // x21
  int *v4; // x19
  signed int v5; // w8
  int v6; // w0
  int v7; // w8
  int v8; // w9
  _BYTE *v9; // x8
  _BYTE *v10; // x0
  int v11; // w0
  int v12; // w2
  __int16 v13; // w4

  v2 = a2;
  v3 = a1;
  v4 = a2;
  if ( a2 || (v4 = ASN1_STRING_type_new(2)) != 0LL )
  {
    if ( BN_is_negative(v3) && !BN_is_zero(v3) )
      v5 = 258;
    else
      v5 = 2;
    v4[1] = v5;
    v6 = BN_num_bits(v3);
    if ( v6 )
    {
      v7 = v6 + 7;
      if ( v6 >= 0 )
        v7 = v6;
      v8 = (v7 >> 3) + 5;
    }
    else
    {
      v8 = 4;
    }
    v9 = (_BYTE *)*((_QWORD *)v4 + 1);
    if ( *v4 >= v8 )
      goto LABEL_15;
    v10 = realloc(*((void **)v4 + 1), v8);
    v9 = v10;
    if ( v10 )
    {
      *((_QWORD *)v4 + 1) = v10;
LABEL_15:
      v11 = BN_bn2bin(v3, v9);
      *v4 = v11;
      if ( !v11 )
      {
        **((_BYTE **)v4 + 1) = 0;
        *v4 = 1;
      }
      return v4;
    }
    v12 = 65;
    v13 = 436;
  }
  else
  {
    v12 = 158;
    v13 = 424;
  }
  ERR_put_error(12, 0LL, v12, (__int64)"external/boringssl/src/crypto/asn1/a_int.c", v13);
  if ( v4 != v2 )
    ASN1_STRING_free((__int64)v4);
  return 0LL;
}

//----- (00000000000A0050) ----------------------------------------------------
__int64 __fastcall ASN1_INTEGER_to_BN(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 **v2; // x20
  __int64 v3; // x0
  __int64 v4; // x19

  v2 = a1;
  v3 = BN_bin2bn(a1[1], *(signed int *)a1, a2);
  v4 = v3;
  if ( v3 )
  {
    if ( *((_DWORD *)v2 + 1) == 258 )
      BN_set_negative(v3, 1);
  }
  else
  {
    ERR_put_error(12, 0LL, 105, (__int64)"external/boringssl/src/crypto/asn1/a_int.c", 459);
  }
  return v4;
}

//----- (00000000000A00CC) ----------------------------------------------------
signed __int64 __fastcall ASN1_PRINTABLE_type(_BYTE *a1, signed int a2)
{
  int v2; // w10
  signed int v3; // w9
  signed int v4; // w8
  unsigned __int8 *v5; // x11
  signed int v6; // w13
  signed __int64 result; // x0
  int v8; // w15
  int v9; // t1

  if ( !a1 )
    return 19LL;
  v2 = (unsigned __int8)*a1;
  if ( *a1 )
  {
    v3 = 0;
    v4 = 0;
    v5 = a1 + 1;
    if ( a2 < 1 )
      v6 = 1;
    else
      v6 = a2;
    do
    {
      if ( !v6 )
        break;
      --v6;
      if ( ((v2 - 97) & 0xFFu) >= 0x1A
        && ((v2 - 48) & 0xFFu) >= 0xA
        && (unsigned __int8)v2 != 32
        && ((v2 - 65) & 0xFFu) >= 0x1A
        && ((unsigned __int8)v2 > 0x3Fu || !((1LL << v2) & 0xA400FB8100000000LL)) )
      {
        v4 = 1;
      }
      v8 = (char)v2;
      v9 = *v5++;
      v2 = v9;
      if ( v8 < 0 )
        v3 = 1;
    }
    while ( v2 );
    if ( v3 )
      return 20LL;
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
    result = 22LL;
  else
    result = 19LL;
  return result;
}

//----- (00000000000A01A4) ----------------------------------------------------
__int64 __fastcall ASN1_STRING_set_default_mask(__int64 result)
{
  qword_106808 = result;
  return result;
}
// 106808: using guessed type __int64 qword_106808;

//----- (00000000000A01B0) ----------------------------------------------------
__int64 ASN1_STRING_get_default_mask()
{
  return qword_106808;
}
// 106808: using guessed type __int64 qword_106808;

//----- (00000000000A01BC) ----------------------------------------------------
signed __int64 __fastcall ASN1_STRING_set_default_mask_asc(const char *a1)
{
  const char *v1; // x19
  signed __int64 result; // x0
  unsigned int v3; // w8
  const char *v4; // x19
  unsigned int v5; // t1
  _BYTE *v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v1 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = strncmp(a1, "MASK:", 5uLL);
  if ( (_DWORD)result )
  {
    if ( (unsigned int)strcmp(v1, "nombstr") )
    {
      if ( (unsigned int)strcmp(v1, "pkix") )
      {
        if ( (unsigned int)strcmp(v1, "utf8only") )
        {
          result = strcmp(v1, "default");
          if ( (_DWORD)result )
          {
            v3 = 0;
            goto LABEL_15;
          }
          result = 0xFFFFFFFFLL;
        }
        else
        {
          result = 0x2000LL;
        }
      }
      else
      {
        result = -5LL;
      }
    }
    else
    {
      result = -10241LL;
    }
  }
  else
  {
    v5 = *((unsigned __int8 *)v1 + 5);
    v4 = v1 + 5;
    v3 = v5;
    if ( !v5 )
      goto LABEL_15;
    result = strtoul(v4, &v6, 0);
    v3 = 0;
    if ( *v6 )
      goto LABEL_15;
  }
  qword_106808 = result;
  v3 = 1;
LABEL_15:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v7 )
    result = v3;
  return result;
}
// 106808: using guessed type __int64 qword_106808;

//----- (00000000000A02C8) ----------------------------------------------------
__int64 __fastcall ASN1_STRING_set_by_NID(__int64 *a1, const char *a2, signed int a3, int a4, int a5)
{
  int v5; // w20
  signed int v6; // w21
  const char *v7; // x22
  __int64 *v8; // x19
  __int64 *v9; // x0
  signed __int64 v10; // x9
  signed int v11; // w0
  signed int v12; // w0
  __int64 result; // x0
  __int64 v14; // [xsp+0h] [xbp-70h]
  int v15; // [xsp+8h] [xbp-68h]
  unsigned __int64 v16; // [xsp+30h] [xbp-40h]
  __int64 v17; // [xsp+38h] [xbp-38h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v15 = a5;
  if ( a1 )
    v8 = a1;
  else
    v8 = &v14;
  v14 = 0LL;
  v9 = (__int64 *)bsearch(&v15, &unk_DD528, 0x13uLL, 0x28uLL, (__compar_fn_t)sub_A04A0);
  if ( v9
    || qword_1073D0
    && (unsigned int)sk_find(qword_1073D0, (signed __int64 *)&v16, (__int64)&v15)
    && (v9 = (__int64 *)sk_value((unsigned __int64 *)qword_1073D0, v16)) != 0LL )
  {
    if ( v9[4] & 2 )
      v10 = 1LL;
    else
      v10 = qword_106808;
    ASN1_mbstring_ncopy(v8, v7, v6, v5, v10 & v9[3], v9[1], v9[2]);
    if ( v11 >= 1 )
      goto LABEL_14;
LABEL_15:
    result = 0LL;
    goto LABEL_16;
  }
  ASN1_mbstring_copy(v8, v7, v6, v5, qword_106808 & 0x2806);
  if ( v12 < 1 )
    goto LABEL_15;
LABEL_14:
  result = *v8;
LABEL_16:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 106808: using guessed type __int64 qword_106808;
// 1073D0: using guessed type __int64 qword_1073D0;

//----- (00000000000A0400) ----------------------------------------------------
void *__fastcall ASN1_STRING_TABLE_get(int a1)
{
  void *result; // x0
  int v2; // [xsp+8h] [xbp-48h]
  unsigned __int64 v3; // [xsp+30h] [xbp-20h]
  __int64 v4; // [xsp+38h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = a1;
  result = bsearch(&v2, &unk_DD528, 0x13uLL, 0x28uLL, (__compar_fn_t)sub_A04A0);
  if ( !result )
  {
    result = (void *)qword_1073D0;
    if ( qword_1073D0 )
    {
      if ( (unsigned int)sk_find(qword_1073D0, (signed __int64 *)&v3, (__int64)&v2) )
        result = sk_value((unsigned __int64 *)qword_1073D0, v3);
      else
        result = 0LL;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v4;
  return result;
}
// 1073D0: using guessed type __int64 qword_1073D0;

//----- (00000000000A04A0) ----------------------------------------------------
__int64 __fastcall sub_A04A0(_DWORD *a1, _DWORD *a2)
{
  return (unsigned int)(*a1 - *a2);
}

//----- (00000000000A04B0) ----------------------------------------------------
signed __int64 __fastcall ASN1_STRING_TABLE_add(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x22
  __int64 v6; // x19
  __int64 v7; // x20
  __int64 v8; // x21
  int v9; // w23
  _QWORD *v10; // x8
  signed int v11; // w9
  signed __int64 result; // x0
  _QWORD *v13; // x0
  __int16 v14; // w4
  int v15; // [xsp+8h] [xbp-68h]
  unsigned __int64 v16; // [xsp+30h] [xbp-40h]
  __int64 v17; // [xsp+38h] [xbp-38h]

  v5 = a5;
  v6 = a4;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( !qword_1073D0 )
  {
    qword_1073D0 = (__int64)sk_new((__int64)sub_A0648);
    if ( !qword_1073D0 )
    {
      v14 = 239;
      goto LABEL_19;
    }
  }
  v15 = v9;
  v10 = bsearch(&v15, &unk_DD528, 0x13uLL, 0x28uLL, (__compar_fn_t)sub_A04A0);
  if ( !v10 )
  {
    if ( !qword_1073D0
      || !(unsigned int)sk_find(qword_1073D0, (signed __int64 *)&v16, (__int64)&v15)
      || (v10 = sk_value((unsigned __int64 *)qword_1073D0, v16)) == 0LL )
    {
      v13 = malloc(0x28uLL);
      v10 = v13;
      if ( v13 )
      {
        *(_DWORD *)v13 = v9;
        v13[4] = v5 | 1;
        v13[1] = -1LL;
        v13[2] = -1LL;
        v11 = 1;
        if ( v8 == -1 )
          goto LABEL_6;
        goto LABEL_5;
      }
      v14 = 245;
LABEL_19:
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_strnid.c", v14);
      result = 0LL;
      goto LABEL_20;
    }
  }
  v11 = 0;
  v10[4] = v10[4] & 1LL | v5 & 0xFFFFFFFFFFFFFFFELL;
  if ( v8 != -1 )
LABEL_5:
    v10[1] = v8;
LABEL_6:
  if ( v7 != -1 )
    v10[2] = v7;
  v10[3] = v6;
  if ( v11 )
    sk_push((unsigned __int64 *)qword_1073D0, (__int64)v10);
  result = 1LL;
LABEL_20:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 1073D0: using guessed type __int64 qword_1073D0;

//----- (00000000000A0648) ----------------------------------------------------
__int64 __fastcall sub_A0648(_DWORD **a1, _DWORD **a2)
{
  return (unsigned int)(**a1 - **a2);
}

//----- (00000000000A0660) ----------------------------------------------------
void ASN1_STRING_TABLE_cleanup()
{
  unsigned __int64 *v0; // x0

  v0 = (unsigned __int64 *)qword_1073D0;
  if ( qword_1073D0 )
  {
    qword_1073D0 = 0LL;
    sk_pop_free(v0, (void (*)(void))sub_A0680);
  }
}
// 1073D0: using guessed type __int64 qword_1073D0;

//----- (00000000000A0680) ----------------------------------------------------
void __fastcall sub_A0680(void *ptr)
{
  if ( *((_BYTE *)ptr + 32) & 1 )
    free(ptr);
}

//----- (00000000000A0690) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ASN1_TIME(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ASN1_TIME_it);
}

//----- (00000000000A069C) ----------------------------------------------------
void i2d_ASN1_TIME()
{
  ASN1_item_i2d();
}

//----- (00000000000A06A8) ----------------------------------------------------
__int64 ASN1_TIME_new()
{
  return ASN1_item_new((unsigned __int8 *)&ASN1_TIME_it);
}

//----- (00000000000A06B4) ----------------------------------------------------
void __fastcall ASN1_TIME_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&ASN1_TIME_it);
}

//----- (00000000000A06C0) ----------------------------------------------------
void __fastcall ASN1_TIME_set(_DWORD *a1, __int64 a2)
{
  ASN1_TIME_adj(a1, a2, 0, 0LL);
}

//----- (00000000000A06CC) ----------------------------------------------------
void __fastcall ASN1_TIME_adj(_DWORD *a1, __int64 a2, int a3, __int64 a4)
{
  _DWORD *v4; // x21
  __int64 v5; // x19
  int v6; // w20
  int *v7; // x0
  int *v8; // x22
  char v9; // [xsp+8h] [xbp-68h]
  __int64 v10; // [xsp+40h] [xbp-30h]
  __int64 v11; // [xsp+48h] [xbp-28h]

  v4 = a1;
  v5 = a4;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = a2;
  v6 = a3;
  v7 = (int *)j__gmtime_r(&v10, &v9);
  v8 = v7;
  if ( v7 )
  {
    if ( !v6 && !v5 || (unsigned int)sub_A4A7C(v7, v6, v5) )
    {
      if ( (unsigned int)(v8[5] - 50) > 0x63 )
        ASN1_GENERALIZEDTIME_adj(v4, v10, v6, v5);
      else
        ASN1_UTCTIME_adj(v4, v10, v6, v5);
    }
  }
  else
  {
    ERR_put_error(12, 0LL, 113, (__int64)"external/boringssl/src/crypto/asn1/a_time.c", 92);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// A4A78: using guessed type __int64 __fastcall j__gmtime_r(_QWORD, _QWORD);

//----- (00000000000A07A8) ----------------------------------------------------
__int64 __fastcall ASN1_TIME_check(signed int *a1)
{
  signed int v1; // w8

  v1 = a1[1];
  if ( v1 == 23 )
    return ASN1_UTCTIME_check(a1);
  if ( v1 == 24 )
    return ASN1_GENERALIZEDTIME_check(a1);
  return 0LL;
}

//----- (00000000000A07CC) ----------------------------------------------------
_DWORD *__fastcall ASN1_TIME_to_generalizedtime(signed int *a1, _DWORD **a2)
{
  signed int *v2; // x21
  signed int v3; // w8
  _DWORD **v4; // x19
  _DWORD *v5; // x20
  int v6; // w2
  _BYTE *v7; // x23
  __int64 v8; // x22
  const char *v9; // x1

  v2 = a1;
  v3 = a1[1];
  v4 = a2;
  if ( v3 == 23 )
  {
    if ( !(unsigned int)ASN1_UTCTIME_check(a1) )
      return 0LL;
  }
  else if ( v3 != 24 || !(unsigned int)ASN1_GENERALIZEDTIME_check(a1) )
  {
    return 0LL;
  }
  if ( !v4 || (v5 = *v4) == 0LL )
  {
    v5 = ASN1_GENERALIZEDTIME_new();
    if ( !v5 )
      goto LABEL_15;
  }
  v6 = *v2;
  if ( v2[1] != 24 )
  {
    if ( (unsigned int)ASN1_STRING_set((__int64)v5, 0LL, v6 + 2) )
    {
      v7 = (_BYTE *)*((_QWORD *)v5 + 1);
      v8 = *v2 + 3LL;
      if ( **((unsigned __int8 **)v2 + 1) < 0x35u )
        v9 = "20";
      else
        v9 = "19";
      BUF_strlcpy(*((_BYTE **)v5 + 1), v9, *v2 + 3LL);
      BUF_strlcat(v7, *((const char **)v2 + 1), v8);
      goto LABEL_22;
    }
LABEL_15:
    if ( !v4 || *v4 != v5 )
      ASN1_VISIBLESTRING_free(v5);
    return 0LL;
  }
  if ( !(unsigned int)ASN1_STRING_set((__int64)v5, *((const char **)v2 + 1), v6) )
    goto LABEL_15;
LABEL_22:
  if ( v4 && !*v4 )
    *v4 = v5;
  return v5;
}
// 6333C: using guessed type __int64 __fastcall ASN1_VISIBLESTRING_free(_QWORD);

//----- (00000000000A08F8) ----------------------------------------------------
signed __int64 __fastcall ASN1_TIME_set_string(__int64 a1, const char *a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  signed __int64 result; // x0
  int v5; // [xsp+0h] [xbp-30h]
  int v6; // [xsp+4h] [xbp-2Ch]
  __int64 v7; // [xsp+8h] [xbp-28h]
  __int64 v8; // [xsp+10h] [xbp-20h]
  __int64 v9; // [xsp+18h] [xbp-18h]

  v2 = (__int64)a2;
  v3 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = strlen(a2);
  v6 = 23;
  v7 = v2;
  v8 = 0LL;
  if ( (unsigned int)ASN1_UTCTIME_check(&v5) || (v6 = 24, result = ASN1_GENERALIZEDTIME_check(&v5), (_DWORD)result) )
  {
    if ( !v3 || (result = ASN1_STRING_copy(v3, (__int64)&v5), (_DWORD)result) )
      result = 1LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A0990) ----------------------------------------------------
__int64 __fastcall ASN1_TIME_diff(_DWORD *a1, int *a2, signed int *a3, signed int *a4)
{
  signed int *v4; // x21
  int *v5; // x19
  _DWORD *v6; // x20
  signed int v7; // w8
  __int64 result; // x0
  signed int v9; // w8
  __int64 v10; // [xsp+0h] [xbp-A0h]
  int v11[14]; // [xsp+38h] [xbp-68h]
  char v12; // [xsp+70h] [xbp-30h]
  __int64 v13; // [xsp+78h] [xbp-28h]

  v4 = a4;
  v5 = a2;
  v6 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a3 )
  {
    time(&v10);
    result = j__gmtime_r(&v10, v11) != 0;
    if ( !(_DWORD)result )
      goto LABEL_19;
    goto LABEL_9;
  }
  v7 = a3[1];
  if ( v7 != 24 )
  {
    if ( v7 != 23 )
    {
LABEL_14:
      result = 0LL;
      goto LABEL_19;
    }
    result = sub_A0D10(v11, a3);
    if ( !(_DWORD)result )
      goto LABEL_19;
LABEL_9:
    if ( v4 )
    {
      v9 = v4[1];
      if ( v9 != 24 )
      {
        if ( v9 == 23 )
        {
          result = sub_A0D10((int *)&v10, v4);
          if ( !(_DWORD)result )
            goto LABEL_19;
          goto LABEL_18;
        }
        goto LABEL_14;
      }
      result = sub_9EE60((int *)&v10, v4);
      if ( !(_DWORD)result )
        goto LABEL_19;
    }
    else
    {
      time((time_t *)&v12);
      result = j__gmtime_r(&v12, &v10) != 0;
      if ( !(_DWORD)result )
        goto LABEL_19;
    }
LABEL_18:
    result = sub_A4D64(v6, v5, v11, &v10);
    goto LABEL_19;
  }
  result = sub_9EE60(v11, a3);
  if ( (_DWORD)result )
    goto LABEL_9;
LABEL_19:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// A4A78: using guessed type __int64 __fastcall j__gmtime_r(_QWORD, _QWORD);

//----- (00000000000A0AC4) ----------------------------------------------------
__int64 __fastcall ASN1_TYPE_get(unsigned int *a1)
{
  bool v1; // zf
  __int64 result; // x0

  if ( *a1 == 5 )
    v1 = 0;
  else
    v1 = *((_QWORD *)a1 + 1) == 0LL;
  if ( v1 )
    result = 0LL;
  else
    result = *a1;
  return result;
}

//----- (00000000000A0ADC) ----------------------------------------------------
void __fastcall __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> ASN1_TYPE_set(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // x19
  int v4; // w20
  signed int v5; // w9
  __int64 v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v3 = a3;
  v4 = a2;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *(_QWORD *)(a1 + 8) )
    sub_A40C8((void **)&v6, 0LL);
  *(_DWORD *)a1 = v4;
  if ( v4 == 1 )
  {
    if ( v3 )
      v5 = 255;
    else
      v5 = 0;
    *(_DWORD *)(v6 + 8) = v5;
  }
  else
  {
    *(_QWORD *)(v6 + 8) = v3;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A0B6C) ----------------------------------------------------
signed __int64 __fastcall ASN1_TYPE_set1(__int64 a1, int a2, __int64 a3)
{
  _BYTE *v3; // x21
  int v4; // w19
  __int64 v5; // x20
  __int64 *v6; // x19
  __int64 v7; // x8
  signed int v8; // w9
  signed __int64 result; // x0
  __int64 v10; // [xsp+0h] [xbp-30h]
  __int64 v11; // [xsp+8h] [xbp-28h]

  v3 = (_BYTE *)a3;
  v4 = a2;
  v5 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 != 1 && a3 )
  {
    if ( a2 == 6 )
    {
      v6 = OBJ_dup(a3);
      if ( v6 )
      {
        v10 = v5;
        if ( *(_QWORD *)(v5 + 8) )
        {
          sub_A40C8((void **)&v10, 0LL);
          v5 = v10;
        }
        *(_DWORD *)v5 = 6;
        *(_QWORD *)(v10 + 8) = v6;
        goto LABEL_20;
      }
LABEL_23:
      result = 0LL;
      goto LABEL_21;
    }
    v3 = ASN1_STRING_dup(a3);
    if ( !v3 )
      goto LABEL_23;
    v10 = v5;
    if ( *(_QWORD *)(v5 + 8) )
    {
      sub_A40C8((void **)&v10, 0LL);
      v5 = v10;
    }
    *(_DWORD *)v5 = v4;
    v7 = v10;
  }
  else
  {
    v10 = a1;
    if ( *(_QWORD *)(a1 + 8) )
    {
      sub_A40C8((void **)&v10, 0LL);
      v5 = v10;
    }
    *(_DWORD *)v5 = v4;
    v7 = v10;
    if ( v4 == 1 )
    {
      if ( v3 )
        v8 = 255;
      else
        v8 = 0;
      *(_DWORD *)(v10 + 8) = v8;
      goto LABEL_20;
    }
  }
  *(_QWORD *)(v7 + 8) = v3;
LABEL_20:
  result = 1LL;
LABEL_21:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v11;
  return result;
}

//----- (00000000000A0C98) ----------------------------------------------------
signed __int64 __fastcall ASN1_TYPE_cmp(int *a1, __int64 a2)
{
  unsigned int v2; // w8
  int v3; // w8

  v2 = -1;
  if ( !a1 || !a2 )
    return v2;
  v3 = *a1;
  if ( *a1 != *(_DWORD *)a2 )
    return 0xFFFFFFFFLL;
  switch ( v3 )
  {
    case 1:
      return (unsigned int)(a1[2] - *(_DWORD *)(a2 + 8));
    case 5:
      return 0LL;
    case 6:
      return OBJ_cmp(*((_QWORD *)a1 + 1), *(_QWORD *)(a2 + 8));
  }
  return ASN1_STRING_cmp(*((const void ***)a1 + 1), *(_QWORD *)(a2 + 8));
}

//----- (00000000000A0D10) ----------------------------------------------------
__int64 __fastcall sub_A0D10(int *a1, signed int *a2)
{
  __int64 v2; // x19
  unsigned int v3; // w8
  __int64 v5; // x9
  __int64 v6; // x10
  __int64 v7; // x20
  int v8; // w18
  int v9; // w8
  int v10; // w18
  int v11; // w8
  int v12; // w18
  int v13; // w18
  int v14; // w8
  signed int v15; // w8
  __int64 v16; // x10
  int v17; // w11
  int v18; // w12
  unsigned int v19; // w11
  __int64 v20; // x12
  int v21; // w9
  int v22; // w12
  unsigned int v23; // w9
  int v24; // w9

  if ( a2[1] == 23 )
  {
    v2 = *a2;
    if ( (signed int)v2 >= 11 )
    {
      v5 = *((_QWORD *)a2 + 1);
      v6 = 0LL;
      v7 = 0LL;
      while ( 1 )
      {
        v8 = *(unsigned __int8 *)(v5 + v7);
        if ( v6 == 5 && (unsigned int)(v8 - 43) <= 0x2F && (1LL << ((unsigned __int8)v8 - 43)) & 0x800000000005LL )
          break;
        v3 = 0;
        if ( v7 >= v2 || ((v8 - 48) & 0xFFu) > 9 )
          return v3;
        v9 = *(unsigned __int8 *)(v5 + 1 + v7);
        if ( (unsigned int)(v9 - 48) > 9 )
          return 0;
        v7 += 2LL;
        if ( v7 > v2 )
          return 0;
        v10 = v9 + 10 * v8;
        v11 = v10 - 528;
        if ( v10 - 528 < dword_C1564[v6] || v11 > dword_C1584[v6] )
          return 0;
        if ( a1 )
        {
          v12 = v10 - 480;
          switch ( (_DWORD)v6 )
          {
            case 0:
              v13 = v12 + 52;
              if ( v11 < 50 )
                v11 = v13;
              a1[5] = v11;
              break;
            case 1:
              a1[4] = v12 - 49;
              break;
            case 2:
              a1[3] = v11;
              break;
            case 3:
              a1[2] = v11;
              break;
            case 4:
              a1[1] = v11;
              break;
            case 5:
              *a1 = v11;
              break;
            default:
              break;
          }
        }
        if ( ++v6 >= 6 )
          goto LABEL_29;
      }
      if ( a1 )
        *a1 = 0;
LABEL_29:
      v14 = *(unsigned __int8 *)(v5 + (signed int)v7);
      if ( v14 == 43 || v14 == 45 )
      {
        if ( v14 == 45 )
          v15 = -1;
        else
          v15 = 0;
        if ( (signed int)v7 + 5 > (signed int)v2 )
          return 0;
        v16 = (signed int)(v7 | 1);
        v17 = *(unsigned __int8 *)(v5 + v16);
        if ( (unsigned int)(v17 - 48) > 9 )
          return 0;
        v18 = *(unsigned __int8 *)(v5 + v16 + 1);
        if ( (unsigned int)(v18 - 48) > 9 )
          return 0;
        v19 = v18 + 10 * v17 - 528;
        if ( v19 > 0xC )
          return 0;
        v20 = v5 + v16;
        v21 = *(unsigned __int8 *)(v5 + v16 + 2);
        if ( (unsigned int)(v21 - 48) > 9 )
          return 0;
        v22 = *(unsigned __int8 *)(v20 + 3);
        if ( (unsigned int)(v22 - 48) > 9 )
          return 0;
        v23 = v22 + 10 * v21 - 528;
        if ( v23 > 0x3B )
          return 0;
        LODWORD(v7) = v16 + 4;
        if ( a1 )
        {
          v24 = 3600 * v19 + 60 * v23;
          if ( v24 )
          {
            if ( !(unsigned int)sub_A4A7C(a1, 0, v24 * v15) )
              return 0;
          }
        }
      }
      else if ( v14 == 90 )
      {
        LODWORD(v7) = v7 | 1;
      }
      return (_DWORD)v7 == (_DWORD)v2;
    }
  }
  return 0;
}

//----- (00000000000A0F64) ----------------------------------------------------
__int64 __fastcall ASN1_UTCTIME_check(signed int *a1)
{
  return sub_A0D10(0LL, a1);
}

//----- (00000000000A0F74) ----------------------------------------------------
__int64 __fastcall ASN1_UTCTIME_set_string(__int64 a1, const char *a2)
{
  const char *v2; // x20
  __int64 v3; // x19
  int v4; // w0
  int v5; // w21
  __int64 result; // x0
  int v7; // [xsp+0h] [xbp-40h]
  int v8; // [xsp+4h] [xbp-3Ch]
  const char *v9; // [xsp+8h] [xbp-38h]
  __int64 v10; // [xsp+18h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = 23;
  v4 = strlen(a2);
  v5 = v4;
  v7 = v4;
  v9 = v2;
  result = sub_A0D10(0LL, &v7);
  if ( (_DWORD)result )
  {
    if ( !v3 )
    {
LABEL_5:
      result = 1LL;
      goto LABEL_6;
    }
    result = ASN1_STRING_set(v3, v2, v5);
    if ( (_DWORD)result )
    {
      *(_DWORD *)(v3 + 4) = 23;
      goto LABEL_5;
    }
  }
LABEL_6:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A1018) ----------------------------------------------------
void __fastcall ASN1_UTCTIME_set(_DWORD *a1, __int64 a2)
{
  ASN1_UTCTIME_adj(a1, a2, 0, 0LL);
}

//----- (00000000000A1024) ----------------------------------------------------
void __fastcall ASN1_UTCTIME_adj(_DWORD *a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // x21
  int v5; // w22
  _DWORD *v6; // x19
  signed int v7; // w23
  int *v8; // x0
  int *v9; // x20
  int v10; // w8
  const char *v11; // x21
  void *v12; // x0
  __int64 v13; // [xsp+0h] [xbp-80h]
  char v14; // [xsp+8h] [xbp-78h]
  __int64 v15; // [xsp+40h] [xbp-40h]
  __int64 v16; // [xsp+48h] [xbp-38h]

  v4 = a4;
  v5 = a3;
  v6 = a1;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v15 = a2;
  if ( a1 )
  {
    v7 = 0;
  }
  else
  {
    v6 = ASN1_STRING_type_new(23);
    if ( !v6 )
      goto LABEL_20;
    v7 = 1;
  }
  v8 = (int *)j__gmtime_r(&v15, &v14);
  v9 = v8;
  if ( v8 && (!v5 && !v4 || (unsigned int)sub_A4A7C(v8, v5, v4)) )
  {
    v10 = v9[5];
    if ( (unsigned int)(v10 - 50) <= 0x63 )
    {
      v11 = (const char *)*((_QWORD *)v6 + 1);
      if ( v11 && *v6 > 0x13u )
      {
LABEL_16:
        LODWORD(v13) = *v9;
        BIO_snprintf(
          (__int64)v11,
          20LL,
          (__int64)"%02d%02d%02d%02d%02d%02dZ",
          v10 - 100 * ((unsigned int)(1374389535LL * v10 >> 37) + ((unsigned __int64)(1374389535LL * v10) >> 63)),
          (unsigned int)(v9[4] + 1),
          (unsigned int)v9[3],
          (unsigned int)v9[2],
          (unsigned int)v9[1],
          v13);
        *v6 = strlen(v11);
        v6[1] = 23;
        goto LABEL_20;
      }
      v11 = (const char *)malloc(0x14uLL);
      if ( v11 )
      {
        v12 = (void *)*((_QWORD *)v6 + 1);
        if ( v12 )
          free(v12);
        *((_QWORD *)v6 + 1) = v11;
        v10 = v9[5];
        goto LABEL_16;
      }
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/a_utctm.c", 221);
    }
  }
  if ( v7 )
    ASN1_STRING_free((__int64)v6);
LABEL_20:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// A4A78: using guessed type __int64 __fastcall j__gmtime_r(_QWORD, _QWORD);

//----- (00000000000A11AC) ----------------------------------------------------
signed __int64 __fastcall ASN1_UTCTIME_cmp_time_t(signed int *a1, __int64 a2)
{
  signed __int64 result; // x0
  int v3; // [xsp+8h] [xbp-88h]
  int v4; // [xsp+Ch] [xbp-84h]
  char v5; // [xsp+10h] [xbp-80h]
  int v6[14]; // [xsp+48h] [xbp-48h]
  __int64 v7; // [xsp+80h] [xbp-10h]
  __int64 v8; // [xsp+88h] [xbp-8h]

  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a2;
  if ( (unsigned int)sub_A0D10(v6, a1) && j__gmtime_r(&v7, &v5) && (unsigned int)sub_A4D64(&v4, &v3, &v5, v6) )
  {
    if ( v4 <= 0 )
    {
      if ( v4 & 0x80000000 )
      {
        result = 0xFFFFFFFFLL;
      }
      else if ( v3 <= 0 )
      {
        if ( v3 )
          result = 0xFFFFFFFFLL;
        else
          result = 0LL;
      }
      else
      {
        result = 1LL;
      }
    }
    else
    {
      result = 1LL;
    }
  }
  else
  {
    result = 4294967294LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v8;
  return result;
}
// A4A78: using guessed type __int64 __fastcall j__gmtime_r(_QWORD, _QWORD);

//----- (00000000000A1268) ----------------------------------------------------
__int64 __fastcall i2a_ASN1_INTEGER(__int64 result, __int64 a2)
{
  __int64 v2; // x21
  _QWORD *v3; // x20
  unsigned int v4; // w19
  signed int v5; // w8
  __int64 v6; // x23
  __int64 v7; // x8
  char v8; // [xsp+4h] [xbp-4Ch]
  char v9; // [xsp+5h] [xbp-4Bh]
  __int64 v10; // [xsp+8h] [xbp-48h]

  v2 = a2;
  v3 = (_QWORD *)result;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    v4 = 0;
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a2 + 5) & 1 )
  {
    v4 = 1;
    result = BIO_write((_QWORD *)result, (__int64)"-", 1u);
    if ( (_DWORD)result != 1 )
      goto LABEL_17;
    v5 = *(_DWORD *)v2;
    if ( !*(_DWORD *)v2 )
      goto LABEL_18;
  }
  else
  {
    v4 = 0;
    v5 = *(_DWORD *)a2;
    if ( !*(_DWORD *)a2 )
    {
LABEL_18:
      result = BIO_write(v3, (__int64)"00", 2u);
      if ( (_DWORD)result == 2 )
        v4 |= 2u;
      else
        v4 = 1;
      goto LABEL_21;
    }
  }
  if ( v5 < 1 )
    goto LABEL_21;
  v6 = 0LL;
  while ( 1 )
  {
    if ( v6 && !((signed int)v6 % 35) )
    {
      result = BIO_write(v3, (__int64)"\\\n", 2u);
      if ( (_DWORD)result != 2 )
        break;
      v4 += 2;
    }
    v7 = *(_QWORD *)(v2 + 8);
    v8 = a0123456789abcd_0[(unsigned __int64)*(unsigned __int8 *)(v7 + v6) >> 4];
    v9 = a0123456789abcd_0[*(_BYTE *)(v7 + v6) & 0xF];
    result = BIO_write(v3, (__int64)&v8, 2u);
    if ( (_DWORD)result != 2 )
      break;
    v4 += 2;
    if ( (signed int)++v6 >= *(_DWORD *)v2 )
      goto LABEL_21;
  }
LABEL_17:
  v4 = -1;
LABEL_21:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v10 )
    result = v4;
  return result;
}

//----- (00000000000A13FC) ----------------------------------------------------
__int64 __fastcall ASN1_tag2bit(unsigned int a1)
{
  __int64 result; // x0

  if ( a1 <= 0x1E )
    result = qword_DD8D0[a1];
  else
    result = 0LL;
  return result;
}

//----- (00000000000A141C) ----------------------------------------------------
unsigned __int64 *__fastcall ASN1_item_d2i(unsigned __int64 **a1, const void **a2, __int64 a3, unsigned __int8 *a4)
{
  __int64 v4; // x8
  unsigned __int64 **v5; // x19
  signed int v6; // w0
  unsigned __int64 *result; // x0
  __int64 v8; // [xsp+0h] [xbp-40h]
  char v9; // [xsp+8h] [xbp-38h]
  __int64 v10; // [xsp+28h] [xbp-18h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
    v5 = a1;
  else
    v5 = (unsigned __int64 **)&v8;
  v10 = v4;
  v8 = 0LL;
  v9 = 0;
  sub_A14A0(v5, a2, a3, a4, -1, 0, 0, (__int64)&v9);
  if ( v6 < 1 )
    result = 0LL;
  else
    result = *v5;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A14A0) ----------------------------------------------------
void __fastcall sub_A14A0(unsigned __int64 **a1, const void **a2, __int64 a3, unsigned __int8 *a4, signed int a5, int a6, char a7, __int64 a8)
{
  __int64 v8; // x25
  __int64 v9; // x19
  __int64 v10; // x23
  __int64 v11; // x28
  char v12; // w24
  __int16 v13; // w21
  signed int v14; // w26
  const void **v15; // x22
  __int64 *v16; // x20
  unsigned int (__fastcall *v17)(signed __int64, __int64 *, __int64, _QWORD); // x27
  __int64 v18; // x8
  int v19; // w8
  int v20; // w7
  int v21; // w0
  int v22; // w2
  __int16 v23; // w4
  int v24; // w0
  _QWORD *v25; // x26
  _QWORD *v26; // x0
  __int64 v27; // x3
  int v28; // w7
  int v29; // w0
  signed int v30; // w21
  _BYTE *v31; // x21
  char v32; // w23
  __int64 v33; // x3
  int v34; // w5
  signed __int64 v35; // x8
  _QWORD *v36; // x26
  unsigned __int64 **v37; // x0
  signed int v38; // w0
  __int64 v39; // x21
  int v40; // w1
  __int64 v41; // x8
  __int64 v42; // x0
  __int64 v43; // x24
  signed __int64 v44; // x26
  _QWORD *v45; // x25
  _QWORD *v46; // x0
  signed __int64 v47; // x8
  signed __int64 v48; // x9
  __int64 v49; // x28
  signed __int64 v50; // x21
  __int64 v51; // x3
  __int64 v52; // x5
  __int64 v53; // x6
  __int64 v54; // x7
  unsigned __int64 **v55; // x0
  unsigned __int64 **v56; // x25
  __int64 v57; // x8
  int v58; // w4
  int v59; // w0
  signed __int64 v60; // x9
  signed __int64 v61; // x28
  signed __int64 v62; // x8
  __int64 v63; // x25
  unsigned __int64 **v64; // x0
  signed int v65; // w0
  int v66; // w2
  __int16 v67; // w4
  __int64 v68; // x21
  _QWORD *v69; // x0
  _QWORD *v70; // x0
  _BYTE *v71; // x21
  __int64 v72; // x4
  __int64 v73; // [xsp+0h] [xbp-B0h]
  signed int v74; // [xsp+24h] [xbp-8Ch]
  _BYTE *v75; // [xsp+28h] [xbp-88h]
  __int16 v76; // [xsp+34h] [xbp-7Ch]
  unsigned int v77; // [xsp+38h] [xbp-78h]
  char v78; // [xsp+3Ch] [xbp-74h]
  unsigned __int8 v79; // [xsp+40h] [xbp-70h]
  char v80; // [xsp+44h] [xbp-6Ch]
  _BYTE *v81; // [xsp+48h] [xbp-68h]
  char *v82; // [xsp+50h] [xbp-60h]
  __int64 v83; // [xsp+58h] [xbp-58h]

  v8 = a3;
  v9 = (__int64)a4;
  v10 = a8;
  v83 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v82 = (char *)a3;
  v11 = *((_QWORD *)a4 + 4);
  v12 = a7;
  v13 = a6;
  v14 = a5;
  v15 = a2;
  v16 = (__int64 *)a1;
  v81 = 0LL;
  if ( !a1 )
    goto LABEL_146;
  if ( !v11 || (v17 = *(unsigned int (__fastcall **)(signed __int64, __int64 *, __int64, _QWORD))(v11 + 16)) == 0LL )
    v17 = 0LL;
  v18 = *a4;
  v19 = a6 & 0xFFFFFBFF;
  switch ( a6 & 0xFFFFFBFF )
  {
    case 0u:
      v27 = *((_QWORD *)a4 + 2);
      if ( !v27 )
      {
        v33 = v9;
        v34 = a6 & 0xFFFFFBFF;
        goto LABEL_103;
      }
      if ( a5 != -1 || a7 )
      {
        v76 = a6;
        v22 = 136;
        v23 = 202;
        goto LABEL_140;
      }
      sub_A1E88(a1, (_BYTE **)a2, a3, v27, 0, a8);
      goto LABEL_146;
    case 1u:
    case 6u:
      if ( a5 == -1 )
        v19 = 0;
      if ( a5 == -1 )
        v20 = 16;
      else
        v20 = a5;
      v81 = *a2;
      v21 = sub_A2510(&v82, 0LL, 0LL, &v79, &v78, &v81, a3, v20, v19, a7, v10);
      if ( v21 == -1 )
        goto LABEL_146;
      v76 = v13;
      if ( !v21 )
      {
        v22 = 158;
        v23 = 374;
        goto LABEL_140;
      }
      if ( v11 && *(_BYTE *)(v11 + 8) & 4 )
      {
        v30 = 1;
        v82 = (char *)*v15 + v8 - (_QWORD)v81;
        if ( !v78 )
        {
LABEL_87:
          v22 = 169;
          v23 = 386;
          goto LABEL_140;
        }
      }
      else
      {
        v30 = v79;
        if ( !v78 )
          goto LABEL_87;
      }
      if ( !*v16 && !(unsigned int)sub_A4218(v16, (unsigned __int8 *)v9) )
      {
        v22 = 158;
        v23 = 391;
        goto LABEL_140;
      }
      if ( v17 && !v17(4LL, v16, v9, 0LL) )
        goto LABEL_139;
      v43 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) < 1LL )
      {
        LODWORD(v49) = 0;
      }
      else
      {
        v74 = v30;
        v44 = 0x100000000LL;
        do
        {
          if ( *(_BYTE *)(v43 + 1) & 3 )
          {
            v45 = sub_A49B0(v16, (_QWORD *)v43, 0);
            if ( v45 )
            {
              v46 = sub_A4998(v16, (__int64)v45);
              sub_A4000((_QWORD **)v46, v45);
            }
          }
          v47 = *(_QWORD *)(v9 + 24);
          v43 += 40LL;
          v48 = v44 >> 32;
          v44 += 0x100000000LL;
        }
        while ( v48 < v47 );
        v43 = *(_QWORD *)(v9 + 16);
        if ( v47 < 1 )
        {
          LODWORD(v49) = 0;
        }
        else
        {
          v49 = 0LL;
          v50 = 0x100000000LL;
          do
          {
            v36 = sub_A49B0(v16, (_QWORD *)v43, 1);
            if ( !v36 )
              goto LABEL_141;
            v55 = (unsigned __int64 **)sub_A4998(v16, (__int64)v36);
            v56 = v55;
            if ( !v82 )
              break;
            v57 = (__int64)(v82 - 2);
            if ( (signed __int64)v82 >= 2 && !*v81 && !v81[1] )
            {
              v81 += 2;
              if ( v79 )
              {
                v30 = v74;
                v82 -= 2;
                v79 = 0;
                goto LABEL_128;
              }
              v22 = 180;
              v23 = 425;
              goto LABEL_140;
            }
            v75 = v81;
            if ( v49 == *(_QWORD *)(v9 + 24) - 1LL )
              LOBYTE(v58) = 0;
            else
              v58 = *(_DWORD *)v36 & 1;
            sub_A1E88(v55, &v81, (__int64)v82, (__int64)v36, v58, v10);
            if ( v59 == -1 )
            {
              sub_A4000(v56, v36);
            }
            else
            {
              if ( !v59 )
                goto LABEL_141;
              v82 += v75 - v81;
            }
            ++v49;
            v43 += 40LL;
            v60 = v50 >> 32;
            v50 += 0x100000000LL;
          }
          while ( v60 < *(_QWORD *)(v9 + 24) );
        }
        v30 = v74;
      }
      v57 = (__int64)v82;
      if ( v79 )
      {
        if ( (signed __int64)v82 < 2 || *v81 || v81[1] )
        {
          v22 = 153;
          v23 = 464;
          goto LABEL_140;
        }
        v81 += 2;
        if ( v30 )
          goto LABEL_131;
      }
      else
      {
LABEL_128:
        if ( v30 )
        {
LABEL_131:
          v68 = (signed int)v49;
          if ( (signed __int64)(signed int)v49 < *(_QWORD *)(v9 + 24) )
          {
            do
            {
              v69 = sub_A49B0(v16, (_QWORD *)v43, 1);
              v36 = v69;
              if ( !v69 )
                goto LABEL_141;
              if ( !(*(_BYTE *)v69 & 1) )
              {
                v66 = 121;
                v67 = 489;
LABEL_98:
                ERR_put_error(12, 0LL, v66, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v67);
                if ( !(v76 & 0x400) )
                  goto LABEL_142;
                goto LABEL_143;
              }
              v70 = sub_A4998(v16, (__int64)v69);
              sub_A4000((_QWORD **)v70, v36);
              v43 += 40LL;
            }
            while ( ++v68 < *(_QWORD *)(v9 + 24) );
          }
          v71 = v81;
          if ( (unsigned int)sub_A483C(v16, *v15, (unsigned int)v81 - (unsigned int)*v15, v9)
            && (!v17 || v17(5LL, v16, v9, 0LL)) )
          {
            *v15 = v71;
            goto LABEL_146;
          }
LABEL_139:
          v22 = 101;
          v23 = 505;
          goto LABEL_140;
        }
      }
      if ( v57 )
      {
        v22 = 168;
        v23 = 469;
        goto LABEL_140;
      }
      goto LABEL_131;
    case 2u:
      v76 = a6;
      if ( v17 && !v17(4LL, (__int64 *)a1, (__int64)a4, 0LL) )
        goto LABEL_139;
      if ( *v16 )
      {
        v24 = sub_A46E0(v16, v9);
        if ( !(v24 & 0x80000000) && (signed __int64)v24 < *(_QWORD *)(v9 + 24) )
        {
          v25 = (_QWORD *)(*(_QWORD *)(v9 + 16) + 40LL * v24);
          v26 = sub_A4998(v16, (__int64)v25);
          sub_A4000((_QWORD **)v26, v25);
          sub_A46F0(v16, -1, v9);
        }
      }
      else if ( !(unsigned int)sub_A4218(v16, (unsigned __int8 *)v9) )
      {
        v22 = 158;
        v23 = 319;
        goto LABEL_140;
      }
      v81 = *v15;
      v35 = *(_QWORD *)(v9 + 24);
      if ( v35 < 1 )
      {
        v40 = 0;
        if ( !v35 )
          goto LABEL_109;
        goto LABEL_111;
      }
      v36 = *(_QWORD **)(v9 + 16);
      v37 = (unsigned __int64 **)sub_A4998(v16, *(_QWORD *)(v9 + 16));
      sub_A1E88(v37, &v81, v8, (__int64)v36, 1, v10);
      if ( v38 != -1 )
      {
        v39 = 0LL;
        if ( v38 >= 1 )
          goto LABEL_93;
LABEL_97:
        v66 = 158;
        v67 = 338;
        goto LABEL_98;
      }
      v39 = 0LL;
      v61 = 0x100000000LL;
      do
      {
        v62 = *(_QWORD *)(v9 + 24);
        if ( v61 >> 32 >= v62 )
        {
          v40 = v39 + 1;
          if ( v61 >> 32 == v62 )
            goto LABEL_109;
LABEL_111:
          sub_A46F0(v16, v40, v9);
          if ( !v17 || v17(5LL, v16, v9, 0LL) )
          {
            *v15 = v81;
            goto LABEL_146;
          }
          goto LABEL_139;
        }
        v63 = (__int64)v82;
        v36 += 5;
        ++v39;
        v64 = (unsigned __int64 **)sub_A4998(v16, (__int64)v36);
        sub_A1E88(v64, &v81, v63, (__int64)v36, 1, v10);
        v61 += 0x100000000LL;
      }
      while ( v65 == -1 );
      if ( v65 < 1 )
        goto LABEL_97;
LABEL_93:
      v40 = v39;
      if ( v39 != *(_QWORD *)(v9 + 24) )
        goto LABEL_111;
LABEL_109:
      if ( v12 )
      {
        sub_A3FF8((void **)v16, (unsigned __int8 *)v9);
        goto LABEL_146;
      }
      v22 = 163;
      v23 = 350;
LABEL_140:
      ERR_put_error(12, 0LL, v22, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v23);
      v36 = 0LL;
LABEL_141:
      if ( !(v76 & 0x400) )
LABEL_142:
        sub_A3FF8((void **)v16, (unsigned __int8 *)v9);
LABEL_143:
      v72 = *(_QWORD *)(v9 + 48);
      if ( v36 )
        ERR_add_error_data(4u, (__int64)"Field=", v36[3], (__int64)", Type=", v72, v52, v53, v54, v73);
      else
        ERR_add_error_data(2u, (__int64)"Type=", *(_QWORD *)(v9 + 48), v51, v72, v52, v53, v54, v73);
LABEL_146:
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v83;
      return;
    case 3u:
      if ( !a7 )
        goto LABEL_39;
      v28 = a5;
      v81 = *a2;
      if ( a5 == -1 )
        v28 = *((_DWORD *)a4 + 2);
      v29 = sub_A2510(0LL, 0LL, 0LL, 0LL, 0LL, &v81, a3, v28, a6 & 0xFFFFFBFF, 1, v10);
      if ( v29 == -1 )
        goto LABEL_146;
      if ( !v29 )
      {
        v76 = v13;
        v22 = 158;
        v23 = 264;
        goto LABEL_140;
      }
LABEL_39:
      v76 = v13;
      if ( v14 == -1 )
      {
        v32 = 0;
        v31 = 0LL;
      }
      else
      {
        if ( !v81 )
        {
          v22 = 158;
          v23 = 287;
          goto LABEL_140;
        }
        v31 = *v15;
        v32 = *(_BYTE *)*v15;
        *(_BYTE *)*v15 = *v81 & 0x20 | *(_BYTE *)(v9 + 8);
      }
      v42 = (*(__int64 (__fastcall **)(__int64 *, const void **, char *))(v11 + 16))(v16, v15, v82);
      if ( v14 != -1 )
        *v31 = v32;
      if ( !v42 )
      {
        v22 = 158;
        v23 = 302;
        goto LABEL_140;
      }
      goto LABEL_146;
    case 4u:
      (*(void (**)(void))(v11 + 32))();
      goto LABEL_146;
    case 5u:
      v81 = *a2;
      if ( !(unsigned int)sub_A2510(0LL, &v77, &v80, 0LL, 0LL, &v81, a3, -1, 0, 1, a8) )
      {
        v76 = v13;
        v22 = 158;
        v23 = 218;
        goto LABEL_140;
      }
      if ( v80 )
      {
        if ( v12 )
          goto LABEL_146;
        v76 = v13;
        v22 = 156;
        v23 = 227;
      }
      else
      {
        a5 = v77;
        if ( v77 <= 0x1E )
          v41 = qword_DD8D0[v77];
        else
          v41 = 0LL;
        if ( *(_QWORD *)(v9 + 8) & v41 )
        {
          a3 = (__int64)v82;
          a1 = (unsigned __int64 **)v16;
          a2 = v15;
          v33 = v9;
          v34 = 0;
          a7 = 0;
LABEL_103:
          sub_A206C((__int64 *)a1, (__int64 *)a2, a3, v33, a5, v34, a7, v10);
          goto LABEL_146;
        }
        if ( v12 )
          goto LABEL_146;
        v76 = v13;
        v22 = 157;
        v23 = 235;
      }
      goto LABEL_140;
    default:
      goto LABEL_146;
  }
}

//----- (00000000000A1E88) ----------------------------------------------------
void __fastcall sub_A1E88(unsigned __int64 **a1, _BYTE **a2, __int64 a3, __int64 a4, char a5, __int64 a6)
{
  __int64 v6; // x22
  unsigned int *v7; // x19
  _QWORD *v8; // x21
  unsigned __int64 **v9; // x20
  unsigned int v10; // w9
  int v11; // w0
  int v12; // w2
  __int16 v13; // w4
  _BYTE *v14; // x23
  int v15; // w0
  _BYTE *v16; // x8
  __int64 v17; // x9
  int v18; // w2
  __int16 v19; // w4
  char v20; // [xsp+20h] [xbp-50h]
  char v21; // [xsp+24h] [xbp-4Ch]
  _BYTE *v22; // [xsp+28h] [xbp-48h]
  __int64 v23; // [xsp+30h] [xbp-40h]
  __int64 v24; // [xsp+38h] [xbp-38h]

  v6 = a6;
  v7 = (unsigned int *)a4;
  v8 = a2;
  v9 = a1;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v10 = *(_DWORD *)a4;
    v22 = *a2;
    if ( !(v10 & 0x10) )
    {
      sub_A2A74(a1, a2, a3, (unsigned int *)a4, a5, a6);
      goto LABEL_18;
    }
    v11 = sub_A2510(&v23, 0LL, 0LL, &v21, &v20, &v22, a3, *(_DWORD *)(a4 + 8), (unsigned __int8)v10 & 0xC0, a5, a6);
    if ( v11 == -1 )
      goto LABEL_18;
    if ( !v11 )
    {
      v12 = 158;
      v13 = 550;
LABEL_17:
      ERR_put_error(12, 0LL, v12, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v13);
      goto LABEL_18;
    }
    if ( !v20 )
    {
      v12 = 120;
      v13 = 555;
      goto LABEL_17;
    }
    v14 = v22;
    sub_A2A74(v9, &v22, v23, v7, 0, v6);
    if ( !v15 )
    {
      v12 = 158;
      v13 = 561;
      goto LABEL_17;
    }
    v16 = v22;
    v17 = v23 + v14 - v22;
    v23 += v14 - v22;
    if ( v21 )
    {
      if ( v17 < 2 || *v22 || v22[1] )
      {
        v18 = 153;
        v19 = 569;
LABEL_22:
        ERR_put_error(12, 0LL, v18, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v19);
        sub_A4000(v9, v7);
        goto LABEL_18;
      }
      v16 = v22 + 2;
      v22 += 2;
    }
    else if ( v17 )
    {
      v18 = 119;
      v19 = 577;
      goto LABEL_22;
    }
    *v8 = v16;
  }
LABEL_18:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v24;
}

//----- (00000000000A206C) ----------------------------------------------------
void __fastcall sub_A206C(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, signed int a5, int a6, char a7, __int64 a8)
{
  _BYTE *v8; // x22
  char v9; // w24
  int v10; // w25
  signed int v11; // w26
  __int64 v12; // x20
  __int64 v13; // x23
  __int64 *v14; // x19
  __int64 *v15; // x21
  signed int v16; // w8
  int v17; // w2
  __int16 v18; // w4
  int v19; // w10
  int v20; // w7
  int v21; // w0
  const char *v22; // x22
  __int64 v23; // x23
  __int64 v24; // x8
  int v25; // w9
  int v26; // w26
  _BYTE *v27; // x28
  unsigned __int8 v28; // vf
  char v29; // w0
  __int64 v30; // x27
  _BYTE *v31; // x10
  char v32; // w9
  __int64 v33; // x24
  __int64 v34; // x8
  int v35; // w2
  __int16 v36; // w4
  __int64 v37; // [xsp+20h] [xbp-B0h]
  char *v38; // [xsp+28h] [xbp-A8h]
  __int64 v39; // [xsp+30h] [xbp-A0h]
  const char *v40; // [xsp+38h] [xbp-98h]
  char v41; // [xsp+44h] [xbp-8Ch]
  char v42; // [xsp+48h] [xbp-88h]
  char v43; // [xsp+4Ch] [xbp-84h]
  __int64 v44; // [xsp+50h] [xbp-80h]
  unsigned int v45; // [xsp+5Ch] [xbp-74h]
  _BYTE *v46; // [xsp+60h] [xbp-70h]
  _BYTE *v47; // [xsp+68h] [xbp-68h]
  char v48; // [xsp+70h] [xbp-60h]
  char v49; // [xsp+74h] [xbp-5Ch]
  __int64 v50; // [xsp+78h] [xbp-58h]

  v8 = (_BYTE *)a8;
  v9 = a7;
  v10 = a6;
  v11 = a5;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  v15 = a1;
  v50 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v41 = 0;
  v38 = 0LL;
  v39 = 0LL;
  v37 = 0LL;
  if ( !a1 )
  {
    v17 = 132;
    v18 = 722;
LABEL_25:
    ERR_put_error(12, 0LL, v17, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v18);
    goto LABEL_26;
  }
  if ( *(_BYTE *)a4 == 5 )
  {
    v16 = a5;
    v11 = -1;
  }
  else
  {
    v16 = *(_DWORD *)(a4 + 8);
  }
  v45 = v16;
  if ( v16 == -4 )
  {
    if ( !(v11 & 0x80000000) )
    {
      v17 = 137;
      v18 = 736;
      goto LABEL_25;
    }
    if ( a7 )
    {
      v17 = 135;
      v18 = 740;
      goto LABEL_25;
    }
    v40 = (const char *)*a2;
    if ( !(unsigned int)sub_A2510(0LL, &v45, &v47, 0LL, 0LL, &v40, a3, -1, 0, 0, a8) )
    {
      v17 = 158;
      v18 = 747;
      goto LABEL_25;
    }
    if ( (_BYTE)v47 )
    {
      v16 = -3;
      v45 = -3;
    }
    else
    {
      v16 = v45;
    }
  }
  if ( v11 == -1 )
    v19 = 0;
  else
    v19 = v10;
  if ( v11 == -1 )
    v20 = v16;
  else
    v20 = v11;
  v40 = (const char *)*v14;
  v21 = sub_A2510(&v44, 0LL, 0LL, &v42, &v43, &v40, v13, v20, v19, v9, (__int64)v8);
  if ( v21 != -1 )
  {
    if ( !v21 )
    {
      v17 = 158;
      v18 = 762;
      goto LABEL_25;
    }
    if ( v45 - 16 >= 2 )
    {
      if ( v45 != -3 )
      {
        if ( v43 )
        {
          if ( v45 <= 0xA && (1 << v45) & 0x466 )
          {
            v17 = 179;
            v18 = 798;
            goto LABEL_25;
          }
          v41 = 1;
          if ( !(unsigned int)sub_A2DAC((signed int *)&v37, (signed __int64 *)&v40, v44, v42, 0) )
            goto LABEL_79;
          v33 = v37;
          if ( !BUF_MEM_grow_clean((__int64)&v37, v37 + 1) )
          {
            v35 = 65;
            v36 = 816;
LABEL_63:
            ERR_put_error(12, 0LL, v35, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v36);
            goto LABEL_79;
          }
          v38[v33] = 0;
          v22 = v38;
LABEL_73:
          if ( (unsigned int)sub_A2770(v15, v22, v33, v45, &v41, v12) )
          {
            *v14 = (__int64)v40;
            if ( !v41 )
              goto LABEL_26;
LABEL_80:
            if ( v38 )
              free(v38);
            goto LABEL_26;
          }
LABEL_79:
          if ( !v41 )
            goto LABEL_26;
          goto LABEL_80;
        }
        v22 = v40;
        LODWORD(v33) = v44;
        v34 = (__int64)&v40[v44];
LABEL_72:
        v40 = (const char *)v34;
        goto LABEL_73;
      }
      if ( v8 )
        *v8 = 0;
    }
    else if ( !v43 )
    {
      v17 = 178;
      v18 = 779;
      goto LABEL_25;
    }
    v22 = (const char *)*v14;
    v23 = v44;
    if ( v42 )
    {
      if ( v44 >= 1 )
      {
        v24 = (__int64)v40;
        v25 = 1;
        do
        {
          v26 = v25;
          v27 = (_BYTE *)v24;
          while ( v23 != 1 )
          {
            if ( *v27 || v27[1] )
              goto LABEL_47;
            v27 += 2;
            if ( !--v26 )
            {
              v24 = (__int64)v27;
LABEL_70:
              v40 = (const char *)v24;
              LODWORD(v33) = v24 - (_DWORD)v22;
              goto LABEL_73;
            }
            v28 = __OFSUB__(v23, 2LL);
            v23 -= 2LL;
            if ( (unsigned __int8)((v23 < 0) ^ v28) | (v23 == 0) )
              goto LABEL_62;
          }
          v23 = 1LL;
LABEL_47:
          v46 = v27;
          v29 = ASN1_get_object(&v46, (signed __int64 *)&v47, &v49, (int *)&v48, v23);
          if ( v29 & 0x80 )
          {
            ERR_put_error(12, 0LL, 103, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", 1181);
            v35 = 158;
            v36 = 1014;
            goto LABEL_63;
          }
          if ( v29 & 1 )
          {
            v24 = (__int64)v46;
            v30 = &v27[v23] - v46;
            v47 = (_BYTE *)(&v27[v23] - v46);
          }
          else
          {
            v24 = (__int64)v46;
            v30 = (__int64)v47;
          }
          if ( !(v29 & 1) )
            v24 += v30;
          v31 = &v27[v23];
          if ( v29 & 1 )
            v25 = v26 + 1;
          else
            v25 = v26;
          v23 = (__int64)&v31[-v24];
        }
        while ( (signed __int64)&v31[-v24] >= 1 );
        if ( v29 & 1 )
          v32 = 1;
        else
          v32 = 2;
        if ( !((v32 & 1) + v26) )
          goto LABEL_70;
      }
LABEL_62:
      v35 = 153;
      v36 = 1024;
      goto LABEL_63;
    }
    v33 = (__int64)&v40[v44 - (_QWORD)v22];
    v34 = (__int64)&v40[v44];
    goto LABEL_72;
  }
LABEL_26:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v50;
}

//----- (00000000000A2510) ----------------------------------------------------
signed __int64 __fastcall sub_A2510(_QWORD *a1, _DWORD *a2, _BYTE *a3, _BYTE *a4, _BYTE *a5, _QWORD *a6, __int64 a7, int a8, int a9, char a10, __int64 a11)
{
  _QWORD *v11; // x19
  int v12; // w26
  __int64 v13; // x28
  signed __int64 v14; // x25
  _BYTE *v15; // x23
  _BYTE *v16; // x24
  _BYTE *v17; // x21
  _DWORD *v18; // x20
  _QWORD *v19; // x22
  int v20; // w0
  __int64 v21; // x8
  int v22; // w9
  int v23; // w9
  signed __int64 result; // x0
  __int64 v25; // [xsp+0h] [xbp-70h]
  __int64 v26; // [xsp+8h] [xbp-68h]
  int v27; // [xsp+10h] [xbp-60h]
  int v28; // [xsp+14h] [xbp-5Ch]
  __int64 v29; // [xsp+18h] [xbp-58h]

  v11 = a6;
  v12 = a8;
  v29 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = *a6;
  v14 = a7;
  v15 = a5;
  v16 = a4;
  v17 = a3;
  v18 = a2;
  v19 = a1;
  v25 = *a6;
  if ( a11 )
  {
    if ( *(_BYTE *)a11 )
    {
      v20 = *(_DWORD *)(a11 + 4);
      v26 = *(_QWORD *)(a11 + 8);
      v27 = *(_DWORD *)(a11 + 20);
      v28 = *(_DWORD *)(a11 + 16);
      v25 = v13 + *(signed int *)(a11 + 24);
      if ( v20 & 0x80 )
        goto LABEL_29;
    }
    else
    {
      v20 = ASN1_get_object((unsigned __int8 **)&v25, &v26, &v28, &v27, a7);
      *(_DWORD *)(a11 + 4) = v20;
      v21 = v26;
      *(_QWORD *)(a11 + 8) = v26;
      *(_DWORD *)(a11 + 20) = v27;
      *(_DWORD *)(a11 + 16) = v28;
      v22 = v25;
      *(_BYTE *)a11 = 1;
      v23 = v22 - v13;
      *(_DWORD *)(a11 + 24) = v23;
      if ( !(v20 & 0x81) && v21 + v23 > v14 )
      {
        ERR_put_error(12, 0LL, 177, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", 1173);
LABEL_30:
        result = 0LL;
        *(_BYTE *)a11 = 0;
        goto LABEL_37;
      }
      if ( v20 & 0x80 )
        goto LABEL_29;
    }
  }
  else
  {
    LOBYTE(v20) = ASN1_get_object((unsigned __int8 **)&v25, &v26, &v28, &v27, a7);
    if ( v20 & 0x80 )
    {
LABEL_29:
      ERR_put_error(12, 0LL, 103, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", 1181);
      if ( a11 )
        goto LABEL_30;
LABEL_36:
      result = 0LL;
      goto LABEL_37;
    }
  }
  if ( !(v12 & 0x80000000) )
  {
    if ( v28 != v12 || v27 != a9 )
    {
      if ( a10 )
      {
        result = 0xFFFFFFFFLL;
        goto LABEL_37;
      }
      if ( a11 )
        *(_BYTE *)a11 = 0;
      ERR_put_error(12, 0LL, 190, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", 1193);
      goto LABEL_36;
    }
    if ( a11 )
      *(_BYTE *)a11 = 0;
  }
  if ( v20 & 1 )
    v26 = v13 + v14 - v25;
  if ( v16 )
    *v16 = v20 & 1;
  if ( v15 )
    *v15 = v20 & 0x20;
  if ( v19 )
    *v19 = v26;
  if ( v17 )
    *v17 = v27;
  if ( v18 )
    *v18 = v28;
  result = 1LL;
  *v11 = v25;
LABEL_37:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A2770) ----------------------------------------------------
__int64 __fastcall sub_A2770(__int64 *a1, const char *a2, int a3, int a4, _BYTE *a5, __int64 a6)
{
  const char *v6; // x24
  _BYTE *v7; // x23
  int v8; // w21
  __int64 v9; // x8
  int v10; // w22
  __int64 *v11; // x20
  __int64 (*v12)(void); // x8
  __int64 result; // x0
  __int64 v14; // x19
  __int64 v15; // x0
  __int64 *v16; // x25
  int v17; // w2
  __int16 v18; // w4
  __int64 v19; // x24
  _DWORD *v20; // x0
  void *v21; // x0
  const char *v22; // x8
  const char *v23; // [xsp+0h] [xbp-50h]
  __int64 v24; // [xsp+8h] [xbp-48h]

  v6 = a2;
  v7 = a5;
  v8 = a4;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v23 = a2;
  v9 = *(_QWORD *)(a6 + 32);
  v10 = a3;
  v11 = a1;
  if ( v9 )
  {
    v12 = *(__int64 (**)(void))(v9 + 40);
    if ( v12 )
    {
      result = v12();
      goto LABEL_47;
    }
  }
  if ( *(_QWORD *)(a6 + 8) == -4LL )
  {
    v14 = *a1;
    if ( !*a1 )
    {
      v15 = ASN1_TYPE_new();
      v14 = v15;
      if ( !v15 )
      {
        ASN1_TYPE_free(0LL);
        result = 0LL;
        goto LABEL_47;
      }
      *v11 = v15;
    }
    if ( *(_DWORD *)v14 != v8 )
      ASN1_TYPE_set(v14, v8, 0LL);
    v16 = v11;
    v11 = (__int64 *)(v14 + 8);
  }
  else
  {
    v14 = 0LL;
    v16 = 0LL;
  }
  switch ( v8 )
  {
    case 1:
      if ( v10 != 1 )
      {
        v17 = 106;
        v18 = 886;
        goto LABEL_44;
      }
      result = 1LL;
      *(_DWORD *)v11 = *(unsigned __int8 *)v6;
      goto LABEL_47;
    case 2:
    case 10:
      if ( !c2i_ASN1_INTEGER(v11, (_BYTE **)&v23, v10) )
        goto LABEL_45;
      *(_DWORD *)(*v11 + 4) = *(_DWORD *)(*v11 + 4) & 0x100 | v8;
      goto LABEL_40;
    case 3:
      if ( !c2i_ASN1_BIT_STRING((_DWORD **)v11, &v23, v10) )
        goto LABEL_45;
      result = 1LL;
      goto LABEL_47;
    case 5:
      if ( v10 )
      {
        v17 = 164;
        v18 = 878;
        goto LABEL_44;
      }
      *v11 = 1LL;
      goto LABEL_40;
    case 6:
      if ( !c2i_ASN1_OBJECT(v11, (const void **)&v23, v10) )
        goto LABEL_45;
      result = 1LL;
      goto LABEL_47;
    case 28:
      if ( !(v10 & 3) )
        goto def_A2850;
      v17 = 181;
      v18 = 932;
      goto LABEL_44;
    case 30:
      if ( !(v10 & 1) )
        goto def_A2850;
      v17 = 104;
      v18 = 928;
      goto LABEL_44;
    default:
def_A2850:
      v19 = *v11;
      if ( *v11 )
      {
        *(_DWORD *)(v19 + 4) = v8;
        if ( !*v7 )
          goto LABEL_35;
      }
      else
      {
        v20 = ASN1_STRING_type_new(v8);
        v19 = (__int64)v20;
        if ( !v20 )
        {
          v17 = 65;
          v18 = 939;
LABEL_44:
          ERR_put_error(12, 0LL, v17, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v18);
LABEL_45:
          ASN1_TYPE_free(v14);
          result = 0LL;
          if ( v16 )
            *v16 = 0LL;
          goto LABEL_47;
        }
        *v11 = (__int64)v20;
        if ( !*v7 )
        {
LABEL_35:
          if ( (unsigned int)ASN1_STRING_set(v19, v23, v10) )
          {
            result = 1LL;
            goto LABEL_47;
          }
          ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", 956);
          ASN1_STRING_free(v19);
          *v11 = 0LL;
          goto LABEL_45;
        }
      }
      v21 = *(void **)(v19 + 8);
      if ( v21 )
        free(v21);
      v22 = v23;
      *(_DWORD *)v19 = v10;
      *(_QWORD *)(v19 + 8) = v22;
      *v7 = 0;
LABEL_40:
      result = 1LL;
      if ( v8 == 5 && v14 )
      {
        *(_QWORD *)(v14 + 8) = 0LL;
        result = 1LL;
      }
LABEL_47:
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v24;
      return result;
  }
}

//----- (00000000000A2A74) ----------------------------------------------------
void __fastcall sub_A2A74(unsigned __int64 **a1, _BYTE **a2, __int64 a3, unsigned int *a4, char a5, __int64 a6)
{
  __int64 v6; // x22
  unsigned int *v7; // x19
  _BYTE **v8; // x21
  unsigned __int64 **v9; // x20
  unsigned int v10; // w11
  int v11; // w10
  unsigned int v12; // w7
  unsigned __int8 *v13; // x3
  int v14; // w0
  int v15; // w2
  __int16 v16; // w4
  int v17; // w0
  unsigned __int64 *v18; // x23
  unsigned __int64 *v19; // x0
  __int64 v20; // x2
  _BYTE *v21; // x23
  int v22; // w0
  int v23; // w0
  __int64 v24; // [xsp+18h] [xbp-58h]
  char v25; // [xsp+24h] [xbp-4Ch]
  _BYTE *v26; // [xsp+28h] [xbp-48h]
  __int64 v27; // [xsp+30h] [xbp-40h]
  __int64 v28; // [xsp+38h] [xbp-38h]

  v6 = a6;
  v7 = a4;
  v8 = a2;
  v9 = a1;
  v28 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v27 = a3;
  if ( a1 )
  {
    v10 = *a4;
    v11 = *a4 & 0xC0;
    v26 = *a2;
    if ( v10 & 6 )
    {
      if ( v10 & 8 )
      {
        v12 = a4[2];
      }
      else
      {
        v11 = 0;
        v12 = (v10 >> 1) & 1 | 0x10;
      }
      v17 = sub_A2510(&v27, 0LL, 0LL, &v25, 0LL, &v26, a3, v12, v11, a5, a6);
      if ( v17 != -1 )
      {
        if ( !v17 )
        {
          ERR_put_error(12, 0LL, 158, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", 626);
          goto LABEL_37;
        }
        v18 = *v9;
        if ( *v9 )
        {
          while ( sk_num(v18) )
          {
            v24 = sk_pop((signed __int64 *)v18);
            sub_A3FF8((void **)&v24, *((unsigned __int8 **)v7 + 4));
          }
          if ( !*v9 )
            goto LABEL_32;
        }
        else
        {
          v19 = sk_new_null();
          *v9 = v19;
          if ( !v19 )
          {
LABEL_32:
            v15 = 65;
            v16 = 645;
            goto LABEL_36;
          }
        }
        v20 = v27;
        if ( v27 >= 1 )
        {
          while ( 1 )
          {
            v21 = v26;
            if ( v20 != 1 && !*v26 && !v26[1] )
              break;
            v24 = 0LL;
            sub_A14A0((unsigned __int64 **)&v24, (const void **)&v26, v20, *((unsigned __int8 **)v7 + 4), -1, 0, 0, v6);
            if ( !v22 )
            {
              v15 = 158;
              v16 = 666;
              goto LABEL_36;
            }
            v27 += v21 - v26;
            if ( !sk_push(*v9, v24) )
            {
              sub_A3FF8((void **)&v24, *((unsigned __int8 **)v7 + 4));
              v15 = 65;
              v16 = 672;
              goto LABEL_36;
            }
            v20 = v27;
            if ( v27 <= 0 )
              goto LABEL_27;
          }
          v26 += 2;
          if ( !v25 )
          {
            v15 = 180;
            v16 = 656;
            goto LABEL_36;
          }
          v27 = v20 - 2;
          v25 = 0;
LABEL_41:
          *v8 = v26;
          goto LABEL_37;
        }
LABEL_27:
        if ( !v25 )
          goto LABEL_41;
        v15 = 153;
        v16 = 677;
LABEL_36:
        ERR_put_error(12, 0LL, v15, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v16);
        sub_A4000(v9, v7);
        goto LABEL_37;
      }
    }
    else
    {
      v13 = (unsigned __int8 *)*((_QWORD *)a4 + 4);
      if ( v10 & 8 )
      {
        sub_A14A0(a1, (const void **)&v26, a3, v13, v7[2], v11, a5, a6);
        if ( v23 == -1 )
          goto LABEL_37;
        if ( v23 )
          goto LABEL_41;
        v15 = 158;
        v16 = 686;
        goto LABEL_36;
      }
      sub_A14A0(a1, (const void **)&v26, a3, v13, -1, v10 & 0x400, a5, a6);
      if ( v14 != -1 )
      {
        if ( v14 )
          goto LABEL_41;
        v15 = 158;
        v16 = 695;
        goto LABEL_36;
      }
    }
  }
LABEL_37:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v28;
}

//----- (00000000000A2DAC) ----------------------------------------------------
__int64 __fastcall sub_A2DAC(signed int *a1, signed __int64 *a2, signed __int64 a3, char a4, signed int a5)
{
  signed __int64 *v5; // x19
  signed int v6; // w20
  __int64 v7; // x21
  signed __int64 v8; // x24
  signed int *v9; // x22
  _BYTE *v10; // x27
  signed __int64 v11; // x28
  char v12; // w0
  size_t v13; // x26
  _BYTE *v14; // x8
  char *v15; // x27
  __int64 result; // x0
  __int64 v17; // x24
  int v18; // w2
  __int16 v19; // w4
  int v20; // [xsp+0h] [xbp-80h]
  unsigned int v21; // [xsp+4h] [xbp-7Ch]
  char *v22; // [xsp+8h] [xbp-78h]
  _BYTE *v23; // [xsp+10h] [xbp-70h]
  _BYTE *v24; // [xsp+18h] [xbp-68h]
  char v25; // [xsp+20h] [xbp-60h]
  char v26; // [xsp+24h] [xbp-5Ch]
  __int64 v27; // [xsp+28h] [xbp-58h]

  v5 = a2;
  v6 = a5;
  v7 = a3;
  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *a2;
  v9 = a1;
  v22 = (char *)*a2;
  if ( !a1 && !(a4 & 1) )
  {
    *a2 = v8 + a3;
LABEL_27:
    result = 1LL;
    goto LABEL_31;
  }
  v20 = a4 & 1;
  if ( a3 < 1 )
  {
LABEL_25:
    if ( v20 )
    {
      v18 = 153;
      v19 = 1097;
      goto LABEL_30;
    }
LABEL_26:
    *v5 = v8;
    goto LABEL_27;
  }
  v10 = (_BYTE *)v8;
  v11 = v8;
  v21 = a5 + 1;
  while ( v7 == 1 || *v10 || v10[1] )
  {
    v23 = v10;
    v12 = ASN1_get_object(&v23, (signed __int64 *)&v24, &v26, (int *)&v25, v7);
    if ( v12 & 0x80 )
    {
      ERR_put_error(12, 0LL, 103, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", 1181);
      v18 = 158;
      v19 = 1080;
      goto LABEL_30;
    }
    if ( v12 & 1 )
    {
      v8 = (signed __int64)v23;
      v13 = &v10[v7] - v23;
      v24 = (_BYTE *)(&v10[v7] - v23);
    }
    else
    {
      v8 = (signed __int64)v23;
      v13 = (size_t)v24;
    }
    v14 = (_BYTE *)v8;
    v15 = (char *)v8;
    v22 = (char *)v8;
    if ( v12 & 0x20 )
    {
      if ( v6 >= 5 )
      {
        v18 = 159;
        v19 = 1087;
        goto LABEL_30;
      }
      result = sub_A2DAC(v9, &v22, v13, v12 & 1, v21);
      if ( !(_DWORD)result )
        goto LABEL_31;
      v8 = (signed __int64)v22;
LABEL_23:
      v14 = (_BYTE *)v8;
      goto LABEL_24;
    }
    if ( v13 )
    {
      if ( v9 )
      {
        v17 = *v9;
        if ( !BUF_MEM_grow_clean((__int64)v9, v17 + v13) )
        {
          v18 = 65;
          v19 = 1110;
          goto LABEL_30;
        }
        memcpy((void *)(*((_QWORD *)v9 + 1) + v17), v15, v13);
      }
      v8 = (signed __int64)&v15[v13];
      v22 = &v15[v13];
      goto LABEL_23;
    }
LABEL_24:
    v7 = v11 + v7 - (_QWORD)v14;
    v10 = v14;
    v11 = (signed __int64)v14;
    if ( v7 <= 0 )
      goto LABEL_25;
  }
  v8 = (signed __int64)(v10 + 2);
  v22 = v10 + 2;
  if ( v20 )
    goto LABEL_26;
  v18 = 180;
  v19 = 1071;
LABEL_30:
  ERR_put_error(12, 0LL, v18, (__int64)"external/boringssl/src/crypto/asn1/tasn_dec.c", v19);
  result = 0LL;
LABEL_31:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v27;
  return result;
}

//----- (00000000000A3024) ----------------------------------------------------
void __fastcall ASN1_item_ndef_i2d(__int64 a1, _BYTE **a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3; // x21
  _QWORD *v4; // x19
  signed int v5; // w0
  void *v6; // x23
  void *v7; // [xsp+8h] [xbp-48h]
  __int64 v8; // [xsp+10h] [xbp-40h]
  __int64 v9; // [xsp+18h] [xbp-38h]

  v3 = a3;
  v4 = a2;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a1;
  if ( a2 && !*a2 )
  {
    sub_A3124((unsigned __int64 **)&v8, 0LL, a3, -1, 0x800u);
    if ( v5 >= 1 )
    {
      v6 = malloc(v5);
      if ( v6 )
      {
        v7 = v6;
        sub_A3124((unsigned __int64 **)&v8, (_BYTE **)&v7, v3, -1, 0x800u);
        *v4 = v6;
      }
    }
  }
  else
  {
    sub_A3124((unsigned __int64 **)&v8, a2, a3, -1, 0x800u);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
}

//----- (00000000000A311C) ----------------------------------------------------
void ASN1_item_i2d()
{
  JUMPOUT(&loc_A302C);
}

//----- (00000000000A3124) ----------------------------------------------------
void __fastcall sub_A3124(unsigned __int64 **a1, _BYTE **a2, unsigned __int8 *a3, signed int a4, unsigned int a5)
{
  __int64 v5; // x21
  unsigned int v6; // w24
  signed int v7; // w25
  __int64 v8; // x8
  unsigned int v9; // w9
  _BYTE **v10; // x19
  unsigned __int64 **v11; // x20
  unsigned int (__fastcall *v12)(signed __int64, unsigned __int64 **); // x28
  int v13; // w22
  unsigned int *v14; // x2
  int v15; // w0
  __int64 v16; // x21
  _BYTE *v17; // x21
  int v18; // w0
  _QWORD *v19; // x26
  signed __int64 v20; // x25
  unsigned int *v21; // x27
  unsigned __int64 **v22; // x0
  int v23; // w0
  signed int v24; // w1
  signed __int64 v25; // x9
  int v26; // w23
  _QWORD *v27; // x25
  signed __int64 v28; // x27
  unsigned int *v29; // x26
  unsigned __int64 **v30; // x0
  signed __int64 v31; // x9
  signed int v32; // [xsp+0h] [xbp-60h]
  int v33; // [xsp+4h] [xbp-5Ch]
  __int64 v34; // [xsp+8h] [xbp-58h]

  v5 = (__int64)a3;
  v6 = a5;
  v7 = a4;
  v34 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *((_QWORD *)a3 + 4);
  v9 = *a3;
  v10 = a2;
  v11 = a1;
  if ( !*a3 || *a1 )
  {
    if ( v8 )
    {
      v12 = *(unsigned int (__fastcall **)(signed __int64, unsigned __int64 **))(v8 + 16);
      if ( v9 > 6 )
        goto LABEL_56;
    }
    else
    {
      v12 = 0LL;
    }
    v13 = 1;
    switch ( v9 )
    {
      case 0u:
        v14 = (unsigned int *)*((_QWORD *)a3 + 2);
        if ( v14 )
          goto LABEL_15;
        a3 = (unsigned __int8 *)v5;
        goto LABEL_44;
      case 1u:
        goto LABEL_21;
      case 2u:
        if ( !v12 || v12(6LL, a1) )
        {
          v15 = sub_A46E0(v11, v5);
          if ( v15 & 0x80000000 || (signed __int64)v15 >= *(_QWORD *)(v5 + 24) )
          {
            if ( v12 )
              ((void (__fastcall *)(signed __int64, unsigned __int64 **, __int64, _QWORD))v12)(7LL, v11, v5, 0LL);
          }
          else
          {
            v16 = *(_QWORD *)(v5 + 16) + 40LL * v15;
            a1 = (unsigned __int64 **)sub_A4998(v11, v16);
            a4 = -1;
            a2 = v10;
            v14 = (unsigned int *)v16;
LABEL_15:
            sub_A3504(a1, a2, v14, a4, v6);
          }
        }
        break;
      case 3u:
        if ( a2 )
          v17 = *a2;
        else
          v17 = 0LL;
        (*(void (__fastcall **)(unsigned __int64 *))(v8 + 24))(*a1);
        if ( v10 && v7 != -1 )
          *v17 = v6 | v7 | *v17 & 0x20;
        break;
      case 4u:
        (*(void (**)(void))(v8 + 40))();
        break;
      case 5u:
        a4 = -1;
LABEL_44:
        sub_A39E0((signed __int64)a1, (void **)a2, (__int64)a3, a4, a5);
        break;
      case 6u:
        v13 = ((a5 >> 11) & 1) + 1;
LABEL_21:
        v18 = sub_A48F0(&v33, (void **)a2, a1, (__int64)a3);
        if ( v18 & 0x80000000 || v18 )
          break;
        v33 = 0;
        if ( v7 == -1 )
          v6 &= 0xFFFFFF3F;
        if ( v7 == -1 )
          v7 = 16;
        if ( v12
          && !((unsigned int (__fastcall *)(signed __int64, unsigned __int64 **, __int64, _QWORD))v12)(
                6LL,
                v11,
                v5,
                0LL) )
        {
          break;
        }
        if ( *(_QWORD *)(v5 + 24) <= 0LL )
        {
          v24 = v33;
        }
        else
        {
          v32 = v7;
          v19 = *(_QWORD **)(v5 + 16);
          v20 = 0x100000000LL;
          do
          {
            v21 = (unsigned int *)sub_A49B0(v11, v19, 1);
            if ( !v21 )
              goto LABEL_56;
            v22 = (unsigned __int64 **)sub_A4998(v11, (__int64)v21);
            sub_A3504(v22, 0LL, v21, 0xFFFFFFFF, v6);
            if ( v23 == -1 || v23 > 0x7FFFFFFF - v33 )
              goto LABEL_56;
            v24 = v33 + v23;
            v33 += v23;
            v19 += 5;
            v25 = v20 >> 32;
            v20 += 0x100000000LL;
          }
          while ( v25 < *(_QWORD *)(v5 + 24) );
          v7 = v32;
        }
        v26 = ASN1_object_size(v13, v24, v7);
        if ( v10 && v26 != -1 )
        {
          ASN1_put_object(v10, v13, v33, v7, v6);
          if ( *(_QWORD *)(v5 + 24) >= 1LL )
          {
            v27 = *(_QWORD **)(v5 + 16);
            v28 = 0x100000000LL;
            do
            {
              v29 = (unsigned int *)sub_A49B0(v11, v27, 1);
              if ( !v29 )
                goto LABEL_56;
              v30 = (unsigned __int64 **)sub_A4998(v11, (__int64)v29);
              sub_A3504(v30, v10, v29, 0xFFFFFFFF, v6);
              v27 += 5;
              v31 = v28 >> 32;
              v28 += 0x100000000LL;
            }
            while ( v31 < *(_QWORD *)(v5 + 24) );
          }
          if ( v13 == 2 )
            ASN1_put_eoc(v10);
          if ( v12 )
            ((__int64 (__fastcall *)(signed __int64, unsigned __int64 **, __int64, _QWORD))v12)(7LL, v11, v5, 0LL);
        }
        break;
      default:
        break;
    }
  }
LABEL_56:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v34;
}

//----- (00000000000A3504) ----------------------------------------------------
void __fastcall sub_A3504(unsigned __int64 **a1, _BYTE **a2, unsigned int *a3, unsigned int a4, unsigned int a5)
{
  unsigned int *v5; // x24
  signed int v6; // w25
  _BYTE **v7; // x19
  unsigned int v8; // w28
  unsigned __int64 **v9; // x22
  unsigned int v10; // w26
  unsigned int v11; // w23
  int v12; // w27
  unsigned __int64 *v13; // x22
  int v14; // w11
  unsigned __int8 *v15; // x2
  _BOOL4 v16; // w9
  _BOOL4 v17; // w10
  signed int v18; // w8
  char v19; // w8
  signed int v20; // w27
  unsigned __int64 v21; // x20
  int v22; // w0
  signed int v23; // w20
  int v24; // w28
  int v25; // w21
  unsigned __int8 *v26; // x26
  unsigned __int64 v27; // x20
  signed int v28; // w0
  signed int v29; // w20
  int v30; // w21
  _QWORD *v31; // x0
  char *v32; // x24
  char *v33; // x25
  unsigned __int64 v34; // x20
  char *v35; // x19
  unsigned __int64 *v36; // x8
  int v37; // w0
  _QWORD *v38; // x0
  _QWORD *v39; // x0
  char *v40; // x8
  unsigned __int64 v41; // x20
  const void **v42; // x23
  size_t v43; // x2
  int v44; // w9
  _QWORD *v45; // x0
  unsigned __int64 v46; // x20
  __int64 *v47; // x19
  __int64 v48; // t1
  char v49; // [xsp+8h] [xbp-88h]
  int v50; // [xsp+Ch] [xbp-84h]
  _BYTE **v51; // [xsp+10h] [xbp-80h]
  signed int v52; // [xsp+18h] [xbp-78h]
  int v53; // [xsp+1Ch] [xbp-74h]
  unsigned __int64 *v54; // [xsp+20h] [xbp-70h]
  char *v55; // [xsp+28h] [xbp-68h]
  unsigned __int64 *v56; // [xsp+30h] [xbp-60h]
  __int64 v57; // [xsp+38h] [xbp-58h]

  v5 = a3;
  v6 = a4;
  v7 = a2;
  v57 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = *a3;
  v9 = a1;
  if ( *a3 & 0x18 )
  {
    if ( a4 != -1 )
      goto LABEL_71;
    v6 = a3[2];
    v10 = *a3 & 0xC0;
  }
  else if ( a4 == -1 )
  {
    v10 = 0;
  }
  else
  {
    v10 = a5 & 0xC0;
  }
  v11 = a5 & 0xFFFFFF3F;
  v12 = (((v8 & a5) >> 11) & 1) + 1;
  if ( v8 & 6 )
  {
    v13 = *a1;
    if ( *a1 )
    {
      if ( v8 & 2 )
        v14 = ((v8 >> 2) & 1) + 1;
      else
        v14 = 0;
      v16 = v6 != -1;
      v17 = (*a3 & 0x10) == 0;
      if ( v14 )
        v18 = 17;
      else
        v18 = 16;
      if ( v17 && v16 )
        v18 = v6;
      v52 = v18;
      v53 = (((v8 & a5) >> 11) & 1) + 1;
      if ( v17 && v16 )
        v19 = v10;
      else
        v19 = 0;
      v51 = a2;
      v49 = v19;
      v50 = v14;
      v20 = 0;
      if ( sk_num(v13) )
      {
        v21 = 0LL;
        do
        {
          v54 = sk_value(v13, v21);
          sub_A3124(&v54, 0LL, *((unsigned __int8 **)v5 + 4), -1, v11);
          if ( v22 == -1 || v20 > 0x7FFFFFFF - v22 )
            goto LABEL_71;
          v20 += v22;
        }
        while ( ++v21 < (unsigned __int64)sk_num(v13) );
      }
      v23 = ASN1_object_size(v53, v20, v52);
      if ( v23 != -1 )
      {
        v24 = v8 & 0x10;
        v25 = v23;
        if ( v24 )
          v25 = ASN1_object_size(v53, v23, v6);
        v7 = v51;
        if ( v51 && v25 != -1 )
        {
          if ( v24 )
            ASN1_put_object(v51, v53, v23, v6, v10);
          ASN1_put_object(v51, v53, v20, v52, v49);
          v26 = (unsigned __int8 *)*((_QWORD *)v5 + 4);
          v55 = 0LL;
          if ( v50 && (unsigned __int64)sk_num(v13) > 1 )
          {
            v31 = sk_num(v13);
            v32 = (char *)malloc(24LL * (_QWORD)v31);
            if ( v32 )
            {
              v33 = (char *)malloc(v20);
              if ( v33 )
              {
                v55 = v33;
                if ( sk_num(v13) )
                {
                  v34 = 0LL;
                  v35 = v32;
                  do
                  {
                    v56 = sk_value(v13, v34);
                    *(_QWORD *)v35 = v55;
                    sub_A3124(&v56, &v55, v26, -1, v11);
                    v36 = v56;
                    *((_DWORD *)v35 + 2) = v37;
                    ++v34;
                    *((_QWORD *)v35 + 2) = v36;
                    v35 += 24;
                  }
                  while ( v34 < (unsigned __int64)sk_num(v13) );
                }
                v38 = sk_num(v13);
                qsort(v32, (size_t)v38, 0x18uLL, (__compar_fn_t)sub_A3CFC);
                v55 = *v51;
                v39 = sk_num(v13);
                v40 = v55;
                if ( v39 )
                {
                  v41 = 0LL;
                  v42 = (const void **)(v32 + 8);
                  do
                  {
                    v43 = *(signed int *)v42;
                    if ( (_DWORD)v43 )
                    {
                      memcpy(v40, *(v42 - 1), v43);
                      v44 = *(_DWORD *)v42;
                      v40 = v55;
                    }
                    else
                    {
                      v44 = 0;
                    }
                    v55 = &v40[v44];
                    ++v41;
                    v45 = sk_num(v13);
                    v40 = v55;
                    v42 += 3;
                  }
                  while ( v41 < (unsigned __int64)v45 );
                }
                *v51 = v40;
                if ( v50 == 2 && sk_num(v13) )
                {
                  v46 = 0LL;
                  v47 = (__int64 *)(v32 + 16);
                  do
                  {
                    v48 = *v47;
                    v47 += 3;
                    sk_set(v13, v46++, v48);
                  }
                  while ( v46 < (unsigned __int64)sk_num(v13) );
                }
                free(v32);
                free(v33);
                v7 = v51;
              }
              else
              {
                free(v32);
              }
            }
          }
          else if ( sk_num(v13) )
          {
            v27 = 0LL;
            do
            {
              v56 = sk_value(v13, v27);
              sub_A3124(&v56, v51, v26, -1, v11);
              ++v27;
            }
            while ( v27 < (unsigned __int64)sk_num(v13) );
          }
          if ( v53 == 2 )
          {
            ASN1_put_eoc(v7);
            if ( v24 )
              goto LABEL_70;
          }
        }
      }
    }
  }
  else
  {
    v15 = (unsigned __int8 *)*((_QWORD *)a3 + 4);
    if ( !(v8 & 0x10) )
    {
      sub_A3124(a1, a2, v15, v6, v10 | v11);
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v57;
      return;
    }
    sub_A3124(a1, 0LL, v15, -1, v11);
    v29 = v28;
    if ( v28 )
    {
      v30 = ASN1_object_size(v12, v28, v6);
      if ( v7 )
      {
        if ( v30 != -1 )
        {
          ASN1_put_object(v7, v12, v29, v6, v10);
          sub_A3124(v9, v7, *((unsigned __int8 **)v5 + 4), -1, v11);
          if ( v12 == 2 )
          {
LABEL_70:
            ASN1_put_eoc(v7);
            goto LABEL_71;
          }
        }
      }
    }
  }
LABEL_71:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A39E0) ----------------------------------------------------
signed __int64 __fastcall sub_A39E0(signed __int64 a1, void **a2, __int64 a3, signed int a4, char a5)
{
  __int64 v5; // x21
  signed int v6; // w25
  void **v7; // x19
  char v8; // w24
  signed __int64 v9; // x22
  signed __int64 result; // x0
  signed int v11; // w20
  _BOOL4 v12; // w26
  unsigned int v13; // w23
  int v14; // [xsp+4h] [xbp-4Ch]
  __int64 v15; // [xsp+8h] [xbp-48h]

  v5 = a3;
  v6 = a4;
  v7 = a2;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a5;
  v9 = a1;
  v14 = *(_QWORD *)(a3 + 8);
  result = sub_A3B3C(a1, 0LL, &v14, a3);
  v11 = result;
  v12 = (unsigned int)(v14 + 3) > 0x14 || !((1 << (v14 + 3)) & 0x180001);
  v13 = 0;
  if ( (_DWORD)result != -1 )
  {
    if ( (_DWORD)result == -2 )
    {
      v11 = 0;
      v13 = 2;
    }
    if ( v6 == -1 )
      v6 = v14;
    if ( v7 )
    {
      if ( v12 )
        ASN1_put_object((_BYTE **)v7, v13, v11, v6, v8);
      result = sub_A3B3C(v9, *v7, &v14, v5);
      if ( v13 )
      {
        result = ASN1_put_eoc((_BYTE **)v7);
        if ( !v12 )
          goto LABEL_19;
        goto LABEL_18;
      }
      *v7 = (char *)*v7 + v11;
    }
    if ( !v12 )
    {
LABEL_19:
      v13 = v11;
      goto LABEL_20;
    }
LABEL_18:
    result = ASN1_object_size(v13, v11, v6);
    v13 = result;
  }
LABEL_20:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v15 )
    result = v13;
  return result;
}

//----- (00000000000A3B3C) ----------------------------------------------------
signed __int64 __fastcall sub_A3B3C(signed __int64 result, void *a2, int *a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 (*v5)(void); // x8
  signed int v6; // w19
  int v7; // w8
  int *v8; // x0
  int v9; // t1
  __int64 v10; // x0
  __int64 *v11; // x1
  char *v12; // x8
  int *v13; // x0
  char **v14; // x1
  __int64 v15; // x9
  __int64 v16; // x9
  char v17; // [xsp+Ch] [xbp-24h]
  void *v18; // [xsp+10h] [xbp-20h]
  __int64 v19; // [xsp+18h] [xbp-18h]

  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v18 = a2;
  v4 = *(_QWORD *)(a4 + 32);
  if ( v4 )
  {
    v5 = *(__int64 (**)(void))(v4 + 48);
    if ( v5 )
    {
      result = v5();
      v6 = result;
      goto LABEL_39;
    }
  }
  if ( !*(_BYTE *)a4 && *(_QWORD *)(a4 + 8) == 1LL )
    goto LABEL_43;
  if ( !*(_QWORD *)result )
    goto LABEL_38;
  if ( *(_BYTE *)a4 == 5 )
  {
    v7 = *(_DWORD *)(*(_QWORD *)result + 4LL);
    *a3 = v7;
    goto LABEL_12;
  }
  if ( *(_QWORD *)(a4 + 8) == -4LL )
  {
    v8 = *(int **)result;
    v9 = *v8;
    result = (signed __int64)(v8 + 2);
    v7 = v9;
    *a3 = v9;
  }
  else
  {
LABEL_43:
    v7 = *a3;
  }
LABEL_12:
  v6 = 0;
  switch ( v7 )
  {
    case 1:
      if ( *(_DWORD *)result == -1 )
        break;
      if ( *(_QWORD *)(a4 + 8) == -4LL )
        goto LABEL_19;
      v16 = *(_QWORD *)(a4 + 40);
      if ( *(_DWORD *)result )
      {
        if ( v16 <= 0 )
          goto LABEL_19;
      }
      else if ( v16 )
      {
LABEL_19:
        v17 = *(_DWORD *)result;
        v6 = 1;
        v12 = &v17;
        goto LABEL_29;
      }
      break;
    case 2:
    case 10:
      v10 = *(_QWORD *)result;
      if ( a2 )
        v11 = (__int64 *)&v18;
      else
        v11 = 0LL;
      result = i2c_ASN1_INTEGER(v10, (_BYTE **)v11);
      v6 = result;
      goto LABEL_39;
    case 3:
      v13 = *(int **)result;
      if ( a2 )
        v14 = (char **)&v18;
      else
        v14 = 0LL;
      result = i2c_ASN1_BIT_STRING(v13, v14);
      v6 = result;
      goto LABEL_39;
    case 5:
      goto LABEL_39;
    case 6:
      v12 = *(char **)(*(_QWORD *)result + 24LL);
      v6 = *(_DWORD *)(*(_QWORD *)result + 20LL);
      if ( v6 )
        goto LABEL_29;
      goto LABEL_39;
    default:
      v15 = *(_QWORD *)result;
      if ( *(_QWORD *)(a4 + 40) == 2048LL && *(_BYTE *)(v15 + 16) & 0x10 )
      {
        if ( a2 )
        {
          *(_QWORD *)(v15 + 8) = a2;
          *(_DWORD *)v15 = 0;
        }
        v6 = -2;
      }
      else
      {
        v12 = *(char **)(v15 + 8);
        v6 = *(_DWORD *)v15;
        if ( *(_DWORD *)v15 )
        {
LABEL_29:
          if ( a2 )
            result = (signed __int64)memcpy(a2, v12, v6);
        }
      }
      goto LABEL_39;
  }
LABEL_38:
  v6 = -1;
LABEL_39:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v19 )
    result = (unsigned int)v6;
  return result;
}

//----- (00000000000A3CFC) ----------------------------------------------------
__int64 __fastcall sub_A3CFC(__int64 a1, __int64 a2)
{
  int v2; // w8
  int v3; // w9
  unsigned int v4; // w19
  __int64 v5; // x8
  size_t v6; // x2
  __int64 result; // x0

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  v4 = v2 - v3;
  if ( v2 >= v3 )
    v5 = a2;
  else
    v5 = a1;
  v6 = *(signed int *)(v5 + 8);
  if ( !(_DWORD)v6 || (result = memcmp(*(const void **)a1, *(const void **)a2, v6), !(_DWORD)result) )
    result = v4;
  return result;
}

//----- (00000000000A3D40) ----------------------------------------------------
void __fastcall ASN1_item_free(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x19
  __int64 v3; // [xsp+0h] [xbp-20h]
  __int64 v4; // [xsp+8h] [xbp-18h]

  v2 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = *(_QWORD *)(v2 + 40);
  v3 = a1;
  sub_A3D90((void **)&v3, a2, 0);
  *(_QWORD *)(v2 + 40);
}

//----- (00000000000A3D90) ----------------------------------------------------
void __fastcall sub_A3D90(void **a1, unsigned __int8 *a2, int a3)
{
  int v3; // w21
  __int64 v4; // x20
  void **v5; // x19
  __int64 v6; // x8
  unsigned int (__fastcall *v7)(signed __int64, void **, __int64, _QWORD); // x24
  signed __int64 v8; // x8
  signed __int64 v9; // x26
  _QWORD *v10; // x22
  _QWORD *v11; // x23
  _QWORD *v12; // x0
  signed __int64 v13; // x9
  _QWORD *v14; // x1
  int v15; // w0
  _QWORD *v16; // x22
  _QWORD *v17; // x0
  void (__fastcall *v18)(void *); // x1
  void (*v19)(void); // x2

  v3 = a3;
  v4 = (__int64)a2;
  v5 = a1;
  if ( a1 )
  {
    v6 = *((_QWORD *)a2 + 4);
    if ( !*a2 || *a1 )
    {
      if ( !v6 || (v7 = *(unsigned int (__fastcall **)(signed __int64, void **, __int64, _QWORD))(v6 + 16)) == 0LL )
        v7 = 0LL;
      switch ( *a2 )
      {
        case 0u:
          v14 = (_QWORD *)*((_QWORD *)a2 + 2);
          if ( !v14 )
            goto LABEL_22;
          sub_A4000((_QWORD **)a1, v14);
          break;
        case 1u:
        case 6u:
          if ( (unsigned int)sub_A4744(a1, a2) && (!v7 || v7(2LL, v5, v4, 0LL) != 2) )
          {
            sub_A47CC(v5, v4);
            v8 = *(_QWORD *)(v4 + 24);
            if ( v8 >= 1 )
            {
              v9 = 0x100000000LL;
              v10 = (_QWORD *)(*(_QWORD *)(v4 + 16) + 40 * v8 - 40);
              do
              {
                v11 = sub_A49B0(v5, v10, 0);
                if ( v11 )
                {
                  v12 = sub_A4998(v5, (__int64)v11);
                  sub_A4000((_QWORD **)v12, v11);
                }
                v13 = v9 >> 32;
                v9 += 0x100000000LL;
                v10 -= 5;
              }
              while ( v13 < *(_QWORD *)(v4 + 24) );
            }
            if ( v7 )
              v7(3LL, v5, v4, 0LL);
            if ( !v3 )
              goto LABEL_31;
          }
          break;
        case 2u:
          if ( !v7 || v7(2LL, a1, (__int64)a2, 0LL) != 2 )
          {
            v15 = sub_A46E0(v5, v4);
            if ( !(v15 & 0x80000000) && (signed __int64)v15 < *(_QWORD *)(v4 + 24) )
            {
              v16 = (_QWORD *)(*(_QWORD *)(v4 + 16) + 40LL * v15);
              v17 = sub_A4998(v5, (__int64)v16);
              sub_A4000((_QWORD **)v17, v16);
            }
            if ( v7 )
              v7(3LL, v5, v4, 0LL);
            if ( !v3 )
            {
LABEL_31:
              free(*v5);
              *v5 = 0LL;
            }
          }
          break;
        case 3u:
          if ( v6 )
          {
            v18 = *(void (__fastcall **)(void *))(v6 + 8);
            if ( v18 )
              v18(*a1);
          }
          break;
        case 4u:
          if ( v6 )
          {
            v19 = *(void (**)(void))(v6 + 16);
            if ( v19 )
              v19();
          }
          break;
        case 5u:
LABEL_22:
          sub_A40C8(a1, v4);
          break;
        default:
          return;
      }
    }
  }
}

//----- (00000000000A3FF8) ----------------------------------------------------
void __fastcall sub_A3FF8(void **a1, unsigned __int8 *a2)
{
  sub_A3D90(a1, a2, 0);
}

//----- (00000000000A4000) ----------------------------------------------------
void __fastcall sub_A4000(_QWORD **a1, _QWORD *a2)
{
  _QWORD *v2; // x20
  _QWORD **v3; // x19
  unsigned __int64 *v4; // x21
  unsigned __int64 v5; // x22
  unsigned __int64 *v6; // [xsp+0h] [xbp-30h]
  __int64 v7; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *a2 & 6LL )
  {
    v4 = *a1;
    if ( sk_num(*a1) )
    {
      v5 = 0LL;
      do
      {
        v6 = sk_value(v4, v5);
        sub_A3D90((void **)&v6, (unsigned __int8 *)v2[4], 0);
        ++v5;
      }
      while ( v5 < (unsigned __int64)sk_num(v4) );
    }
    sk_free((void **)v4);
    *v3 = 0LL;
  }
  else
  {
    sub_A3D90((void **)a1, (unsigned __int8 *)a2[4], *a2 & 0x400);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A40C8) ----------------------------------------------------
void __fastcall sub_A40C8(void **a1, __int64 a2)
{
  void **v2; // x19
  __int64 v3; // x8
  void (*v4)(void); // x2
  int v5; // w8

  v2 = a1;
  if ( a2 )
  {
    v3 = *(_QWORD *)(a2 + 32);
    if ( v3 )
    {
      v4 = *(void (**)(void))(v3 + 24);
      if ( v4 )
      {
        v4();
        return;
      }
    }
    if ( *(_BYTE *)a2 == 5 )
    {
      if ( !*a1 )
        return;
      goto def_A4164;
    }
    v5 = *(_DWORD *)(a2 + 8);
    if ( v5 == 1 )
    {
LABEL_14:
      if ( a2 )
        *(_DWORD *)v2 = *(_DWORD *)(a2 + 40);
      else
        *(_DWORD *)v2 = -1;
      return;
    }
    if ( !*a1 )
      return;
  }
  else
  {
    v5 = *(_DWORD *)*a1;
    v2 = (void **)((char *)*a1 + 8);
    if ( !*v2 )
      return;
  }
  switch ( v5 + 4 )
  {
    case 0:
      sub_A40C8(v2, 0LL);
      free(*v2);
      goto LABEL_17;
    case 5:
      goto LABEL_14;
    case 9:
      goto LABEL_17;
    case 10:
      ASN1_OBJECT_free((void **)*v2);
      goto LABEL_17;
    default:
      break;
  }
def_A4164:
  ASN1_STRING_free((__int64)*v2);
  *v2 = 0LL;
LABEL_17:
  *v2 = 0LL;
}

//----- (00000000000A41B4) ----------------------------------------------------
__int64 __fastcall ASN1_item_new(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x19
  int v2; // w0
  __int64 v3; // x9
  __int64 result; // x0
  __int64 v5; // [xsp+0h] [xbp-20h]
  __int64 v6; // [xsp+8h] [xbp-18h]

  v1 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = *(_QWORD *)(v1 + 40);
  v5 = 0LL;
  v2 = sub_A4220(&v5, a1, 0);
  v3 = *(_QWORD *)(v1 + 40);
  if ( v2 <= 0 )
    result = 0LL;
  else
    result = v5;
  return result;
}

//----- (00000000000A4218) ----------------------------------------------------
__int64 __fastcall sub_A4218(__int64 *a1, unsigned __int8 *a2)
{
  return sub_A4220(a1, a2, 0);
}

//----- (00000000000A4220) ----------------------------------------------------
__int64 __fastcall sub_A4220(__int64 *a1, unsigned __int8 *a2, int a3)
{
  __int64 v3; // x20
  __int64 v4; // x8
  int v5; // w21
  __int64 *v6; // x19
  __int64 (__fastcall *v7)(signed __int64, __int64 *, unsigned __int8 *, _QWORD); // x22
  int v8; // w0
  unsigned int v9; // w21
  void *v10; // x0
  size_t v11; // x2
  __int64 *v12; // x21
  signed __int64 v13; // x24
  _QWORD *v14; // x0
  signed __int64 v15; // x9
  __int64 *v16; // x1
  int v17; // w0
  __int64 (*v18)(void); // x8
  __int64 v19; // x0
  unsigned int (*v20)(void); // x8
  void *v21; // x0
  size_t v22; // x2
  int v23; // w2
  __int16 v24; // w4

  v3 = (__int64)a2;
  v4 = *((_QWORD *)a2 + 4);
  v5 = a3;
  v6 = a1;
  if ( !v4 || (v7 = *(__int64 (__fastcall **)(signed __int64, __int64 *, unsigned __int8 *, _QWORD))(v4 + 16)) == 0LL )
    v7 = 0LL;
  switch ( *a2 )
  {
    case 0u:
      v16 = (__int64 *)*((_QWORD *)a2 + 2);
      if ( !v16 )
      {
        if ( !(unsigned int)sub_A45E4(a1, v3) )
          goto LABEL_49;
        goto LABEL_47;
      }
      if ( !(unsigned int)sub_A44B0(a1, v16) )
        goto LABEL_49;
      return 1;
    case 1u:
    case 6u:
      if ( !v7 )
        goto LABEL_54;
      v8 = v7(0LL, a1, a2, 0LL);
      if ( !v8 )
        goto LABEL_44;
      if ( v8 != 2 )
      {
LABEL_54:
        if ( !v5 )
        {
          v10 = malloc(*(_QWORD *)(v3 + 40));
          *v6 = (__int64)v10;
          if ( !v10 )
            goto LABEL_49;
          v11 = *(_QWORD *)(v3 + 40);
          if ( v11 )
            memset(v10, 0, v11);
          sub_A4704(v6, (unsigned __int8 *)v3);
          sub_A4784(v6, v3);
        }
        if ( *(_QWORD *)(v3 + 24) >= 1LL )
        {
          v12 = *(__int64 **)(v3 + 16);
          v13 = 0x100000000LL;
          do
          {
            v14 = sub_A4998(v6, (__int64)v12);
            if ( !(unsigned int)sub_A44B0(v14, v12) )
            {
              sub_A3FF8((void **)v6, (unsigned __int8 *)v3);
              goto LABEL_49;
            }
            v12 += 5;
            v15 = v13 >> 32;
            v13 += 0x100000000LL;
          }
          while ( v15 < *(_QWORD *)(v3 + 24) );
        }
        if ( v7 )
          goto LABEL_42;
        return 1;
      }
      return 1;
    case 2u:
      if ( !v7 )
        goto LABEL_37;
      v17 = v7(0LL, a1, a2, 0LL);
      if ( !v17 )
        goto LABEL_44;
      if ( v17 == 2 )
        return 1;
LABEL_37:
      if ( !v5 )
      {
        v21 = malloc(*(_QWORD *)(v3 + 40));
        *v6 = (__int64)v21;
        if ( !v21 )
          goto LABEL_49;
        v22 = *(_QWORD *)(v3 + 40);
        if ( v22 )
          memset(v21, 0, v22);
      }
      sub_A46F0(v6, -1, v3);
      if ( !v7 )
        goto LABEL_45;
LABEL_42:
      v9 = 1;
      if ( !(unsigned int)v7(1LL, v6, (unsigned __int8 *)v3, 0LL) )
      {
        sub_A3FF8((void **)v6, (unsigned __int8 *)v3);
LABEL_44:
        v23 = 101;
        v24 = 216;
        goto LABEL_50;
      }
      break;
    case 3u:
      if ( !v4 )
        goto LABEL_47;
      v18 = *(__int64 (**)(void))v4;
      if ( !v18 )
        goto LABEL_45;
      v19 = v18();
      *v6 = v19;
      if ( !v19 )
        goto LABEL_49;
      return 1;
    case 4u:
      if ( v4 )
      {
        v20 = *(unsigned int (**)(void))(v4 + 8);
        if ( v20 )
        {
          if ( v20() )
          {
            v9 = 1;
          }
          else
          {
LABEL_49:
            v23 = 65;
            v24 = 206;
LABEL_50:
            ERR_put_error(12, 0LL, v23, (__int64)"external/boringssl/src/crypto/asn1/tasn_new.c", v24);
            v9 = 0;
          }
        }
        else
        {
LABEL_45:
          v9 = 1;
        }
      }
      else
      {
LABEL_47:
        v9 = 1;
      }
      break;
    case 5u:
      if ( !(unsigned int)sub_A45E4(a1, (__int64)a2) )
        goto LABEL_49;
      return 1;
    default:
      return 1;
  }
  return v9;
}

//----- (00000000000A44B0) ----------------------------------------------------
__int64 __fastcall sub_A44B0(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // x8
  _QWORD *v3; // x19
  _QWORD *v5; // x0

  v2 = *a2;
  v3 = a1;
  if ( *a2 & 1 )
  {
    sub_A4544(a1, (__int64)a2);
    return 1LL;
  }
  if ( v2 & 0x300 )
  {
    *a1 = 0LL;
    return 1LL;
  }
  if ( !(v2 & 6) )
    return sub_A4220(a1, (unsigned __int8 *)a2[4], v2 & 0x400);
  v5 = sk_new_null();
  if ( v5 )
  {
    *v3 = v5;
    return 1LL;
  }
  ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/tasn_new.c", 282);
  return 0LL;
}

//----- (00000000000A4544) ----------------------------------------------------
_QWORD *__fastcall sub_A4544(_QWORD *result, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int8 *v3; // x1
  __int64 v4; // x8
  __int64 (*v5)(void); // x2
  __int64 v6; // x8
  __int64 (*v7)(void); // x2
  __int64 v8; // x8
  __int64 (*v9)(void); // x2

  v2 = a2;
  while ( 2 )
  {
    if ( *(_WORD *)v2 & 0x306 )
    {
LABEL_17:
      *result = 0LL;
    }
    else
    {
      v3 = *(unsigned __int8 **)(v2 + 32);
      switch ( *v3 )
      {
        case 0u:
          v2 = *((_QWORD *)v3 + 2);
          if ( v2 )
            continue;
          v4 = *((_QWORD *)v3 + 4);
          if ( v4 )
          {
            v5 = *(__int64 (**)(void))(v4 + 32);
            if ( !v5 )
              goto LABEL_17;
            result = (_QWORD *)v5();
          }
          else
          {
            if ( *((_DWORD *)v3 + 2) != 1 )
              goto LABEL_17;
            *(_DWORD *)result = *((_QWORD *)v3 + 5);
          }
          break;
        case 1u:
        case 2u:
        case 3u:
        case 6u:
          goto LABEL_17;
        case 4u:
          v6 = *((_QWORD *)v3 + 4);
          if ( !v6 )
            goto LABEL_17;
          v7 = *(__int64 (**)(void))(v6 + 24);
          if ( !v7 )
            goto LABEL_17;
          return (_QWORD *)v7();
        case 5u:
          if ( !v3 )
            goto LABEL_17;
          v8 = *((_QWORD *)v3 + 4);
          if ( !v8 )
            goto LABEL_17;
          v9 = *(__int64 (**)(void))(v8 + 32);
          if ( !v9 )
            goto LABEL_17;
          return (_QWORD *)v9();
        default:
          return result;
      }
    }
    return result;
  }
}

//----- (00000000000A45E4) ----------------------------------------------------
__int64 __fastcall sub_A45E4(__int64 *a1, __int64 a2)
{
  _BYTE *v2; // x20
  __int64 *v3; // x19
  __int64 v4; // x8
  __int64 (*v5)(void); // x2
  __int64 result; // x0
  int v7; // w0
  __int64 v8; // x0

  v2 = (_BYTE *)a2;
  v3 = a1;
  if ( !a2 )
    return 0LL;
  v4 = *(_QWORD *)(a2 + 32);
  if ( v4 )
  {
    v5 = *(__int64 (**)(void))(v4 + 16);
    if ( v5 )
      return v5();
  }
  if ( *(_BYTE *)a2 == 5 )
  {
    v7 = -1;
def_A4690:
    result = (__int64)ASN1_STRING_type_new(v7);
    if ( result )
    {
      if ( *v2 == 5 )
        *(_QWORD *)(result + 16) |= 0x40uLL;
    }
LABEL_10:
    *v3 = result;
    result = result != 0;
  }
  else
  {
    v7 = *(_DWORD *)(a2 + 8);
    switch ( v7 + 4 )
    {
      case 0:
        result = (__int64)malloc(0x10uLL);
        if ( !result )
          return result;
        *(_QWORD *)(result + 8) = 0LL;
        *(_DWORD *)result = -1;
        goto LABEL_10;
      case 5:
        result = 1LL;
        *(_DWORD *)v3 = *(_QWORD *)(a2 + 40);
        break;
      case 9:
        result = 1LL;
        *v3 = 1LL;
        break;
      case 10:
        OBJ_nid2obj(0);
        *v3 = v8;
        result = 1LL;
        break;
      default:
        goto def_A4690;
    }
  }
  return result;
}

//----- (00000000000A46E0) ----------------------------------------------------
__int64 __fastcall sub_A46E0(_QWORD *a1, __int64 a2)
{
  return *(unsigned int *)(*a1 + *(_QWORD *)(a2 + 8));
}

//----- (00000000000A46F0) ----------------------------------------------------
__int64 __fastcall sub_A46F0(__int64 *a1, int a2, __int64 a3)
{
  __int64 v3; // x8
  __int64 v4; // x9
  __int64 result; // x0

  v3 = *a1;
  v4 = *(_QWORD *)(a3 + 8);
  result = *(unsigned int *)(*a1 + v4);
  *(_DWORD *)(v3 + v4) = a2;
  return result;
}

//----- (00000000000A4704) ----------------------------------------------------
_QWORD *__fastcall sub_A4704(_QWORD *result, unsigned __int8 *a2)
{
  int v2; // w8
  __int64 v3; // x8
  _DWORD *v4; // x8

  v2 = *a2;
  if ( v2 == 6 || v2 == 1 )
  {
    v3 = *((_QWORD *)a2 + 4);
    if ( v3 && *(_BYTE *)(v3 + 8) & 1 )
    {
      v4 = (_DWORD *)(*result + *(signed int *)(v3 + 12));
      if ( v4 )
        *v4 = 1;
    }
  }
  return result;
}

//----- (00000000000A4744) ----------------------------------------------------
__int64 __fastcall sub_A4744(_QWORD *a1, unsigned __int8 *a2)
{
  int v2; // w8
  __int64 v3; // x8
  int *v4; // x0
  __int64 result; // x0

  v2 = *a2;
  if ( (v2 == 6 || v2 == 1)
    && (v3 = *((_QWORD *)a2 + 4)) != 0
    && *(_BYTE *)(v3 + 8) & 1
    && (v4 = (int *)(*a1 + *(signed int *)(v3 + 12))) != 0LL )
  {
    result = CRYPTO_refcount_dec_and_test_zero(v4);
  }
  else
  {
    result = 1LL;
  }
  return result;
}

//----- (00000000000A4784) ----------------------------------------------------
long double __fastcall sub_A4784(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x9
  __int64 v3; // x8
  char v4; // w9
  long double result; // q0

  if ( a1 )
  {
    if ( *a1 )
    {
      v2 = *(_QWORD *)(a2 + 32);
      if ( v2 )
      {
        if ( *(_BYTE *)(v2 + 8) & 2 )
        {
          v3 = *a1 + *(signed int *)(v2 + 24);
          if ( v3 )
          {
            v4 = *(_BYTE *)(v3 + 20);
            *(_OWORD *)&result = 0uLL;
            *(_OWORD *)v3 = 0u;
            *(_BYTE *)(v3 + 20) = v4 & 0xFC;
            *(_DWORD *)(v3 + 16) = 1;
          }
        }
      }
    }
  }
  return result;
}

//----- (00000000000A47CC) ----------------------------------------------------
void __fastcall sub_A47CC(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x9
  __int64 v3; // x19
  char v4; // w8

  if ( a1 )
  {
    if ( *a1 )
    {
      v2 = *(_QWORD *)(a2 + 32);
      if ( v2 )
      {
        if ( *(_BYTE *)(v2 + 8) & 2 )
        {
          v3 = *a1 + *(signed int *)(v2 + 24);
          if ( v3 )
          {
            if ( *(_QWORD *)v3 )
            {
              if ( !(*(_BYTE *)(v3 + 20) & 1) )
                free(*(void **)v3);
            }
            v4 = *(_BYTE *)(v3 + 20);
            *(_OWORD *)v3 = 0u;
            *(_BYTE *)(v3 + 20) = v4 & 0xFC;
            *(_DWORD *)(v3 + 16) = 1;
          }
        }
      }
    }
  }
}

//----- (00000000000A483C) ----------------------------------------------------
void *__fastcall sub_A483C(_QWORD *a1, const void *a2, int a3, __int64 a4)
{
  int v4; // w20
  const void *v5; // x19
  __int64 v6; // x9
  __int64 v7; // x22
  unsigned int v8; // w8
  __int64 v9; // x21
  void *result; // x0

  v4 = a3;
  v5 = a2;
  if ( a1 )
  {
    if ( *a1 )
    {
      v6 = *(_QWORD *)(a4 + 32);
      if ( v6 )
      {
        if ( *(_BYTE *)(v6 + 8) & 2 )
        {
          v7 = *a1 + *(signed int *)(v6 + 24);
          if ( v7 )
          {
            v8 = *(unsigned __int8 *)(v7 + 20);
            if ( !(v8 & 1) )
            {
              free(*(void **)v7);
              v8 = *(unsigned __int8 *)(v7 + 20);
            }
            *(_BYTE *)(v7 + 20) = v8 & 0xFC | (v8 >> 1) & 1;
            if ( (v8 >> 1) & 1 )
            {
              *(_QWORD *)v7 = v5;
              v9 = v4;
            }
            else
            {
              v9 = v4;
              result = malloc(v4);
              *(_QWORD *)v7 = result;
              if ( !result )
                return result;
              if ( v4 )
                memcpy(result, v5, v4);
            }
            *(_QWORD *)(v7 + 8) = v9;
            *(_DWORD *)(v7 + 16) = 0;
          }
        }
      }
    }
  }
  return &dword_0 + 1;
}
// 0: using guessed type int dword_0;

//----- (00000000000A48F0) ----------------------------------------------------
signed __int64 __fastcall sub_A48F0(_DWORD *a1, void **a2, _QWORD *a3, __int64 a4)
{
  void **v4; // x20
  _DWORD *v5; // x19
  __int64 v6; // x9
  __int64 v8; // x21
  char *v9; // x0
  size_t v10; // x2
  __int64 v11; // x8

  v4 = a2;
  v5 = a1;
  if ( !a3 )
    return 0LL;
  if ( !*a3 )
    return 0LL;
  v6 = *(_QWORD *)(a4 + 32);
  if ( !v6 || !(*(_BYTE *)(v6 + 8) & 2) )
    return 0LL;
  v8 = *a3 + *(signed int *)(v6 + 24);
  if ( !v8 || *(_DWORD *)(v8 + 16) )
    return 0LL;
  if ( a2 )
  {
    v9 = (char *)*a2;
    v10 = *(_QWORD *)(v8 + 8);
    if ( v10 )
    {
      memcpy(v9, *(const void **)v8, v10);
      v11 = *(_QWORD *)(v8 + 8);
      v9 = (char *)*v4;
    }
    else
    {
      v11 = 0LL;
    }
    *v4 = &v9[v11];
  }
  if ( v5 )
    *v5 = *(_QWORD *)(v8 + 8);
  return 1LL;
}

//----- (00000000000A4998) ----------------------------------------------------
_QWORD *__fastcall sub_A4998(_QWORD *result, __int64 a2)
{
  if ( !(*(_BYTE *)(a2 + 1) & 4) )
    result = (_QWORD *)(*result + *(_QWORD *)(a2 + 16));
  return result;
}

//----- (00000000000A49B0) ----------------------------------------------------
_QWORD *__fastcall sub_A49B0(_QWORD *a1, _QWORD *a2, int a3)
{
  int v3; // w19
  _QWORD *v4; // x20
  unsigned int *v5; // x0
  signed __int64 v6; // x0
  signed __int64 v7; // x8
  signed __int64 v8; // x10
  signed __int64 v9; // x11

  v3 = a3;
  if ( !(*a2 & 0x300LL) )
    return a2;
  v4 = (_QWORD *)a2[4];
  v5 = *(unsigned int **)(*a1 + v4[1]);
  if ( !v5 )
  {
    a2 = (_QWORD *)v4[6];
    if ( a2 )
      return a2;
    goto LABEL_13;
  }
  if ( *a2 & 0x100 )
    v6 = (signed int)OBJ_obj2nid(v5);
  else
    v6 = ASN1_INTEGER_get((signed __int64)v5);
  v7 = v4[4];
  if ( v7 < 1 )
  {
LABEL_12:
    a2 = (_QWORD *)v4[5];
    if ( a2 )
      return a2;
LABEL_13:
    if ( v3 )
      ERR_put_error(12, 0LL, 186, (__int64)"external/boringssl/src/crypto/asn1/tasn_utl.c", 277);
    return 0LL;
  }
  a2 = (_QWORD *)(v4[3] + 8LL);
  v8 = 0x100000000LL;
  while ( *(a2 - 1) != v6 )
  {
    v9 = v8 >> 32;
    v8 += 0x100000000LL;
    a2 += 6;
    if ( v9 >= v7 )
      goto LABEL_12;
  }
  return a2;
}

//----- (00000000000A4A7C) ----------------------------------------------------
signed __int64 __fastcall sub_A4A7C(int *a1, int a2, __int64 a3)
{
  unsigned __int64 v3; // x8
  int v4; // w9
  signed int v5; // w8
  int v6; // w12
  int v7; // w16
  int v8; // w10
  int v9; // w15
  signed __int64 v10; // x12
  int v11; // w14
  int v12; // w10
  signed __int64 v13; // x9
  signed __int64 v14; // x9
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x10
  signed __int64 v17; // x11
  signed __int64 v18; // x9
  unsigned __int64 v19; // x13
  unsigned __int64 v20; // x13
  signed __int64 v21; // x15
  int v22; // w10
  signed __int64 v23; // x13
  signed __int64 v24; // x9
  unsigned __int64 v25; // x11
  unsigned __int64 v26; // x11
  unsigned int v27; // w10
  unsigned __int64 v29; // x12
  unsigned __int64 v30; // x12
  int v31; // w11
  unsigned __int64 v32; // x12

  v3 = ((signed __int64)((unsigned __int128)(a3 * (signed __int128)1749024623285053783LL) >> 64) >> 13)
     + ((unsigned __int64)((unsigned __int128)(a3 * (signed __int128)1749024623285053783LL) >> 64) >> 63);
  v4 = v3 + a2;
  v5 = a3 - 86400 * v3 + 3600 * a1[2] + 60 * a1[1] + *a1;
  if ( v5 <= 86399 )
  {
    if ( v5 & 0x80000000 )
    {
      --v4;
      v5 += 86400;
    }
  }
  else
  {
    ++v4;
    v5 -= 86400;
  }
  v6 = a1[4];
  v7 = (715827883LL * (v6 - 13) >> 33) + ((unsigned __int64)(715827883LL * (v6 - 13)) >> 63);
  v8 = a1[5] + v7;
  v9 = 1461 * v8 + 9788700;
  v10 = 715827883LL * (367 * (v6 - 12 * v7) - 367);
  v11 = 1461 * v8 + 9788703;
  v12 = (1374389535LL * (v8 + 6800) >> 37) + ((unsigned __int64)(1374389535LL * (v8 + 6800)) >> 63);
  if ( v9 >= 0 )
    v11 = v9;
  v13 = (signed int)(a1[3] + (v11 >> 2) + (v10 >> 33) + ((unsigned __int64)v10 >> 63) - 3 * v12 / 4 - 32075)
      + (signed __int64)v4;
  if ( v13 & 0x8000000000000000LL )
    return 0LL;
  v14 = v13 + 68569;
  v15 = (unsigned __int128)(4 * v14 * (signed __int128)4137408090565272301LL) >> 64;
  v16 = ((signed __int64)v15 >> 15) + (v15 >> 63);
  v17 = 146097 * v16 + 6;
  if ( (signed __int64)(146097 * v16 + 3) >= 0 )
    v17 = 146097 * v16 + 3;
  v18 = v14 - (v17 >> 2);
  v19 = (unsigned __int128)((4000 * v18 + 4000) * (signed __int128)1654928120671552141LL) >> 64;
  v20 = ((signed __int64)v19 >> 17) + (v19 >> 63);
  v21 = 1461 * v20;
  v22 = v20 + 100 * v16;
  v23 = 1461 * v20 + 3;
  if ( v21 >= 0 )
    v23 = v21;
  v24 = v18 - (v23 >> 2) + 31;
  v25 = (unsigned __int128)(80 * v24 * (signed __int128)1403534266930087369LL) >> 64;
  v26 = ((signed __int64)v25 >> 11) + (v25 >> 63);
  v27 = v22 + v26 - 6800;
  if ( v27 >> 2 > 0x7E8 )
    return 0LL;
  v29 = ((unsigned __int128)(80 * v24 * (signed __int128)-3007867137478590557LL) >> 64) + 80 * v24;
  v30 = ((signed __int64)v29 >> 11) + (v29 >> 63);
  v31 = v30 - 12 * v26;
  v32 = (unsigned __int128)((signed __int64)(2447 * v30) * (signed __int128)7378697629483820647LL) >> 64;
  a1[4] = v31 + 1;
  a1[5] = v27;
  a1[2] = v5 / 3600;
  a1[3] = v24 - ((v32 >> 5) + (v32 >> 63));
  *a1 = v5 % 60;
  a1[1] = v5 / 60 % 60;
  return 1LL;
}

//----- (00000000000A4D64) ----------------------------------------------------
signed __int64 __fastcall sub_A4D64(_DWORD *a1, int *a2, _DWORD *a3, _DWORD *a4)
{
  __int64 v4; // x11
  int v5; // w10
  signed __int64 v6; // x11
  int v7; // w13
  int v8; // w15
  int v9; // w14
  int v10; // w2
  int v11; // w13
  int v12; // w18
  signed __int64 v13; // x15
  int v14; // w17
  int v15; // w13
  signed __int64 v16; // x11
  __int64 v17; // x13
  int v18; // w12
  signed __int64 v19; // x13
  int v21; // w14
  int v22; // w16
  int v23; // w15
  int v24; // w3
  int v25; // w14
  int v26; // w2
  signed __int64 v27; // x16
  int v28; // w18
  int v29; // w14
  signed __int64 v30; // x13
  signed __int64 v31; // x11
  int v32; // w10
  _BOOL4 v33; // w12
  _BOOL4 v34; // w13
  __int64 v35; // x14
  int v36; // w12
  int v37; // w9
  _BOOL4 v38; // w10
  _BOOL4 v39; // w11
  int v40; // w8

  v4 = (unsigned int)(3600 * a3[2] + 60 * a3[1] + *a3);
  if ( (signed int)v4 <= 86399 )
  {
    v5 = v4 + 86400;
    if ( (signed int)v4 >= 0 )
      v5 = v4;
    v6 = v4 << 32 >> 63;
  }
  else
  {
    v5 = v4 - 86400;
    v6 = 1LL;
  }
  v8 = a3[4];
  v7 = a3[5];
  v9 = a3[3];
  v10 = (715827883LL * (v8 - 13) >> 33) + ((unsigned __int64)(715827883LL * (v8 - 13)) >> 63);
  v11 = v7 + v10;
  v12 = 1461 * v11 + 9788700;
  v13 = 715827883LL * (367 * (v8 - 12 * v10) - 367);
  v14 = 1461 * v11 + 9788703;
  v15 = (1374389535LL * (v11 + 6800) >> 37) + ((unsigned __int64)(1374389535LL * (v11 + 6800)) >> 63);
  if ( v12 >= 0 )
    v14 = v12;
  v16 = v6 + (signed int)(v9 + (v14 >> 2) + (v13 >> 33) + ((unsigned __int64)v13 >> 63) - 3 * v15 / 4 - 32075);
  if ( v16 & 0x8000000000000000LL )
    return 0LL;
  v17 = (unsigned int)(3600 * a4[2] + 60 * a4[1] + *a4);
  if ( (signed int)v17 <= 86399 )
  {
    v18 = v17 + 86400;
    if ( (signed int)v17 >= 0 )
      v18 = v17;
    v19 = v17 << 32 >> 63;
  }
  else
  {
    v18 = v17 - 86400;
    v19 = 1LL;
  }
  v22 = a4[4];
  v21 = a4[5];
  v23 = a4[3];
  v24 = (715827883LL * (v22 - 13) >> 33) + ((unsigned __int64)(715827883LL * (v22 - 13)) >> 63);
  v25 = v21 + v24;
  v26 = 1461 * v25 + 9788700;
  v27 = 715827883LL * (367 * (v22 - 12 * v24) - 367);
  v28 = 1461 * v25 + 9788703;
  v29 = (1374389535LL * (v25 + 6800) >> 37) + ((unsigned __int64)(1374389535LL * (v25 + 6800)) >> 63);
  if ( v26 >= 0 )
    v28 = v26;
  v30 = v19 + (signed int)(v23 + (v28 >> 2) + (v27 >> 33) + ((unsigned __int64)v27 >> 63) - 3 * v29 / 4 - 32075);
  if ( v30 & 0x8000000000000000LL )
    return 0LL;
  v31 = v30 - v16;
  v32 = v18 - v5;
  v33 = v31 > 0;
  v34 = v32 < 0;
  v35 = v34 & (unsigned int)v33;
  if ( v34 && v33 )
    v36 = v32 + 86400;
  else
    v36 = v32;
  v37 = v31 - v35;
  v38 = v31 - v35 < 0;
  v39 = v36 > 0;
  v40 = v36 - 86400;
  if ( !v39 || !v38 )
    v40 = v36;
  if ( a1 )
    *a1 = (v39 && v38) + v37;
  if ( a2 )
    *a2 = v40;
  return 1LL;
}

//----- (00000000000A4FF0) ----------------------------------------------------
_QWORD *__fastcall BIO_new_file(const char *a1, const char *a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  FILE *v4; // x21
  _QWORD *v5; // x0
  _QWORD *v6; // x19
  __int64 v7; // x6
  __int64 v8; // x7
  int v9; // w2
  __int16 v10; // w4
  __int64 v12; // [xsp+0h] [xbp-20h]

  v2 = (__int64)a2;
  v3 = (__int64)a1;
  v4 = fopen(a1, a2);
  if ( v4 )
  {
    v5 = BIO_new((__int64)&unk_103C70);
    v6 = v5;
    if ( v5 )
      BIO_ctrl(v5, 0x6Au, 1LL, (__int64)v4);
    else
      fclose(v4);
  }
  else
  {
    ERR_put_error(2, 0LL, 0, (__int64)"external/boringssl/src/crypto/bio/file.c", 96);
    ERR_add_error_data(5u, (__int64)"fopen('", v3, (__int64)"','", v2, (__int64)"')", v7, v8, v12);
    if ( *(_DWORD *)__errno() == 2 )
    {
      v9 = 110;
      v10 = 100;
    }
    else
    {
      v9 = 112;
      v10 = 102;
    }
    ERR_put_error(17, 0LL, v9, (__int64)"external/boringssl/src/crypto/bio/file.c", v10);
    v6 = 0LL;
  }
  return v6;
}

//----- (00000000000A50E0) ----------------------------------------------------
void *BIO_s_file()
{
  return &unk_103C70;
}

//----- (00000000000A50EC) ----------------------------------------------------
__int64 __fastcall BIO_set_fp(_QWORD *a1, __int64 a2, int a3)
{
  return BIO_ctrl(a1, 0x6Au, a3, a2);
}

//----- (00000000000A5110) ----------------------------------------------------
_QWORD *__fastcall BIO_new_fp(__int64 a1, int a2)
{
  __int64 v2; // x20
  int v3; // w21
  _QWORD *v4; // x0
  _QWORD *v5; // x19

  v2 = a1;
  v3 = a2;
  v4 = BIO_new((__int64)&unk_103C70);
  v5 = v4;
  if ( v4 )
    BIO_ctrl(v4, 0x6Au, v3, v2);
  return v5;
}

//----- (00000000000A5164) ----------------------------------------------------
__int64 __fastcall BIO_get_fp(_QWORD *a1, __int64 a2)
{
  return BIO_ctrl(a1, 0x6Bu, 0LL, a2);
}

//----- (00000000000A5188) ----------------------------------------------------
__int64 __fastcall BIO_read_filename(_QWORD *a1, __int64 a2)
{
  return BIO_ctrl(a1, 0x6Cu, 3LL, a2);
}

//----- (00000000000A51AC) ----------------------------------------------------
__int64 __fastcall BIO_write_filename(_QWORD *a1, __int64 a2)
{
  return BIO_ctrl(a1, 0x6Cu, 5LL, a2);
}

//----- (00000000000A51D0) ----------------------------------------------------
__int64 __fastcall BIO_append_filename(_QWORD *a1, __int64 a2)
{
  return BIO_ctrl(a1, 0x6Cu, 9LL, a2);
}

//----- (00000000000A51F4) ----------------------------------------------------
__int64 __fastcall BIO_rw_filename(_QWORD *a1, __int64 a2)
{
  return BIO_ctrl(a1, 0x6Cu, 7LL, a2);
}

//----- (00000000000A5218) ----------------------------------------------------
__int64 __fastcall sub_A5218(__int64 a1, const void *a2, int a3)
{
  unsigned int v3; // w19
  __int64 result; // x0

  v3 = a3;
  if ( !*(_DWORD *)(a1 + 24) )
    return 0LL;
  LODWORD(result) = fwrite(a2, a3, 1uLL, *(FILE **)(a1 + 48));
  if ( (signed int)result <= 0 )
    result = (unsigned int)result;
  else
    result = v3;
  return result;
}

//----- (00000000000A5264) ----------------------------------------------------
__int64 __fastcall sub_A5264(__int64 a1, void *a2, int a3)
{
  __int64 v3; // x20
  size_t v4; // x0
  unsigned int v5; // w19

  v3 = a1;
  if ( *(_DWORD *)(a1 + 24) )
  {
    v4 = fread(a2, 1uLL, a3, *(FILE **)(a1 + 48));
    v5 = v4;
    if ( !v4 && (unsigned int)ferror(*(FILE **)(v3 + 48)) )
    {
      ERR_put_error(2, 0LL, 0, (__int64)"external/boringssl/src/crypto/bio/file.c", 155);
      ERR_put_error(17, 0LL, 2, (__int64)"external/boringssl/src/crypto/bio/file.c", 156);
      v5 = -1;
    }
  }
  else
  {
    v5 = 0;
  }
  return v5;
}

//----- (00000000000A52FC) ----------------------------------------------------
char *__fastcall sub_A52FC(__int64 a1, char *a2, int a3)
{
  char *v3; // x19
  char *result; // x0

  v3 = a2;
  if ( !a3 )
    return 0LL;
  result = fgets(a2, a3, *(FILE **)(a1 + 48));
  if ( result )
    return (char *)strlen(v3);
  *v3 = 0;
  return result;
}

//----- (00000000000A534C) ----------------------------------------------------
signed __int64 __fastcall sub_A534C(__int64 a1, int a2, __int64 a3, FILE **a4)
{
  __int64 v4; // x20
  const char *v5; // x19
  __int64 v6; // x21
  FILE *v7; // x8
  signed __int64 result; // x0
  const char *v9; // x1
  FILE *v10; // x0
  __int64 v11; // x6
  __int64 v12; // x7
  int v13; // w2
  __int16 v14; // w4
  __int64 v15; // [xsp+0h] [xbp-30h]
  __int64 v16; // [xsp+8h] [xbp-28h]

  v4 = a1;
  v5 = (const char *)a4;
  v6 = a3;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = *(FILE **)(a1 + 48);
  result = 0LL;
  switch ( a2 )
  {
    case 1:
      v6 = 0LL;
LABEL_10:
      LODWORD(result) = fseek(v7, v6, 0);
      goto LABEL_13;
    case 2:
      LODWORD(result) = feof(v7);
LABEL_13:
      result = (signed int)result;
      break;
    case 3:
LABEL_11:
      result = ftell(v7);
      break;
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
      break;
    case 8:
      result = *(signed int *)(v4 + 28);
      break;
    case 9:
      *(_DWORD *)(v4 + 28) = a3;
      result = 1LL;
      break;
    case 11:
      result = (unsigned int)fflush(v7) == 0;
      break;
    default:
      switch ( a2 )
      {
        case 106:
          if ( *(_DWORD *)(v4 + 28) )
          {
            if ( *(_DWORD *)(v4 + 24) && v7 )
            {
              fclose(v7);
              *(_QWORD *)(v4 + 48) = 0LL;
            }
            *(_DWORD *)(v4 + 24) = 0;
          }
          result = 1LL;
          *(_DWORD *)(v4 + 24) = 1;
          *(_DWORD *)(v4 + 28) = v6 & 1;
          *(_QWORD *)(v4 + 48) = v5;
          goto def_A53C4;
        case 107:
          if ( a4 )
            *a4 = v7;
          result = 1LL;
          goto def_A53C4;
        case 108:
          if ( *(_DWORD *)(v4 + 28) )
          {
            if ( *(_DWORD *)(v4 + 24) && v7 )
            {
              fclose(v7);
              *(_QWORD *)(v4 + 48) = 0LL;
            }
            *(_DWORD *)(v4 + 24) = 0;
          }
          *(_DWORD *)(v4 + 28) = v6 & 1;
          if ( v6 & 8 )
          {
            if ( v6 & 2 )
              v9 = "a+";
            else
              v9 = "a";
          }
          else if ( (v6 & 6) == 6 )
          {
            v9 = "r+";
          }
          else if ( v6 & 4 )
          {
            v9 = "w";
          }
          else
          {
            if ( !(v6 & 2) )
            {
              v13 = 100;
              v14 = 219;
              goto LABEL_39;
            }
            v9 = "r";
          }
          BUF_strlcpy((_BYTE *)&v15 + 4, v9, 4uLL);
          v10 = fopen(v5, (const char *)&v15 + 4);
          if ( v10 )
          {
            *(_QWORD *)(v4 + 48) = v10;
            result = 1LL;
            *(_DWORD *)(v4 + 24) = 1;
            goto def_A53C4;
          }
          ERR_put_error(2, 0LL, 0, (__int64)"external/boringssl/src/crypto/bio/file.c", 225);
          ERR_add_error_data(
            5u,
            (__int64)"fopen('",
            (__int64)v5,
            (__int64)"','",
            (__int64)&v15 + 4,
            (__int64)"')",
            v11,
            v12,
            v15);
          v13 = 2;
          v14 = 227;
LABEL_39:
          ERR_put_error(17, 0LL, v13, (__int64)"external/boringssl/src/crypto/bio/file.c", v14);
          result = 0LL;
          break;
        case 128:
          goto LABEL_10;
        case 133:
          goto LABEL_11;
        default:
          goto def_A53C4;
      }
      break;
  }
def_A53C4:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v16;
  return result;
}

//----- (00000000000A55CC) ----------------------------------------------------
signed __int64 __fastcall sub_A55CC(__int64 a1)
{
  __int64 v1; // x19
  FILE *v2; // x0

  v1 = a1;
  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( *(_DWORD *)(a1 + 24) )
    {
      v2 = *(FILE **)(a1 + 48);
      if ( v2 )
      {
        fclose(v2);
        *(_QWORD *)(v1 + 48) = 0LL;
      }
    }
    *(_DWORD *)(v1 + 24) = 0;
  }
  return 1LL;
}

//----- (00000000000A561C) ----------------------------------------------------
void BIO_printf(_QWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, ...)
{
  _QWORD *v10; // x19
  unsigned int v11; // w8
  void *v12; // x21
  unsigned int v13; // w0
  __int64 v14; // [xsp+80h] [xbp-1B0h]
  gcc_va_list va; // [xsp+B0h] [xbp-180h]
  gcc_va_list va1; // [xsp+D0h] [xbp-160h]
  char v17; // [xsp+F8h] [xbp-138h]
  __int64 v18; // [xsp+1F8h] [xbp-38h]
  __int64 v19; // [xsp+240h] [xbp+10h]

  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  va[0].__gr_offs = -48;
  va[0].__vr_offs = -128;
  va[0].__gr_top = va;
  va[0].__vr_top = &v14;
  va[0].__stack = &v19;
  v10 = a1;
  *(_OWORD *)&va1[0].__stack = *(_OWORD *)&va[0].__stack;
  *(_OWORD *)&va1[0].__vr_top = *(_OWORD *)&va[0].__vr_top;
  v11 = __vsnprintf_chk();
  if ( !(v11 & 0x80000000) )
  {
    if ( v11 < 0x100 )
    {
      BIO_write(v10, (__int64)&v17, v11);
    }
    else
    {
      v12 = malloc((signed int)(v11 + 1));
      if ( v12 )
      {
        va[0].__vr_offs = -128;
        va_start(va, a10);
        va_copy(va1, va);
        v13 = __vsnprintf_chk();
        BIO_write(v10, (__int64)v12, v13);
        free(v12);
      }
      else
      {
        ERR_put_error(17, 0LL, 65, (__int64)"external/boringssl/src/crypto/bio/printf.c", 102);
      }
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A57B8) ----------------------------------------------------
__int64 __fastcall BN_kronecker(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x23
  __int64 v5; // x21
  __int64 **v6; // x20
  _QWORD *v7; // x22
  unsigned int v8; // w20
  unsigned int v9; // w21
  signed int v10; // w23
  signed __int64 v11; // x8
  __int64 v12; // x21
  unsigned int v13; // w22
  __int64 v14; // x8
  int v15; // w8
  __int64 v16; // x8
  __int64 v17; // x22
  __int64 v18; // x25

  v3 = a3;
  v4 = a1;
  v5 = a2;
  BN_CTX_start(a3);
  v6 = (__int64 **)BN_CTX_get(v3);
  v7 = BN_CTX_get(v3);
  if ( !v7 || !BN_copy((__int64)v6, v4) || !BN_copy((__int64)v7, v5) )
    goto LABEL_51;
  if ( BN_is_zero((__int64)v7) )
  {
    v8 = BN_abs_is_word((__int64)v6, 1LL);
    goto LABEL_52;
  }
  if ( !(unsigned int)BN_is_odd((__int64)v6) && !(unsigned int)BN_is_odd((__int64)v7) )
  {
    v8 = 0;
    goto LABEL_52;
  }
  v9 = -1;
  do
    ++v9;
  while ( !(unsigned int)BN_is_bit_set((__int64)v7, v9) );
  if ( !(unsigned int)BN_rshift((__int64)v7, (__int64)v7, v9) )
  {
LABEL_51:
    v8 = -2;
    goto LABEL_52;
  }
  if ( v9 & 1 )
  {
    if ( *((_DWORD *)v6 + 2) )
      v11 = **v6 & 7;
    else
      v11 = 0LL;
    v10 = dword_C15A4[v11];
    if ( !*((_DWORD *)v7 + 4) )
      goto LABEL_21;
  }
  else
  {
    v10 = 1;
    if ( !*((_DWORD *)v7 + 4) )
      goto LABEL_21;
  }
  *((_DWORD *)v7 + 4) = 0;
  if ( *((_DWORD *)v6 + 4) )
    v10 = !v10;
LABEL_21:
  if ( !BN_is_zero((__int64)v6) )
  {
    while ( 1 )
    {
      v12 = (__int64)v6;
      v6 = (__int64 **)v7;
      v13 = -1;
      do
        ++v13;
      while ( !(unsigned int)BN_is_bit_set(v12, v13) );
      if ( !(unsigned int)BN_rshift(v12, v12, v13) )
        goto LABEL_51;
      if ( v13 & 1 )
      {
        if ( *((_DWORD *)v6 + 2) )
          v14 = **v6;
        else
          LOBYTE(v14) = 0;
        v10 *= dword_C15A4[v14 & 7];
      }
      v15 = *(_DWORD *)(v12 + 8);
      if ( *(_DWORD *)(v12 + 16) )
      {
        if ( v15 )
          v16 = **(_QWORD **)v12;
        else
          LODWORD(v16) = 0;
        LODWORD(v17) = ~(_DWORD)v16;
        if ( !*((_DWORD *)v6 + 2) )
        {
LABEL_45:
          LODWORD(v18) = 0;
          goto LABEL_46;
        }
      }
      else if ( v15 )
      {
        v17 = **(_QWORD **)v12;
        if ( !*((_DWORD *)v6 + 2) )
          goto LABEL_45;
      }
      else
      {
        LODWORD(v17) = 0;
        if ( !*((_DWORD *)v6 + 2) )
          goto LABEL_45;
      }
      v18 = **v6;
LABEL_46:
      if ( !(unsigned int)BN_nnmod((__int64)v6, (__int64)v6, v12, v3) )
        goto LABEL_51;
      if ( (unsigned int)v17 & (unsigned int)v18 & 2LL )
        v10 = !v10;
      *(_DWORD *)(v12 + 16) = 0;
      v7 = (_QWORD *)v12;
      if ( BN_is_zero((__int64)v6) )
        goto LABEL_23;
    }
  }
  v12 = (__int64)v7;
LABEL_23:
  if ( BN_is_one(v12) )
    v8 = v10;
  else
    v8 = 0;
LABEL_52:
  BN_CTX_end(v3);
  return v8;
}

//----- (00000000000A5A2C) ----------------------------------------------------
_QWORD *__fastcall NCONF_new(__int64 a1)
{
  _QWORD *v1; // x19
  _QWORD *v3; // x0

  if ( a1 )
    return 0LL;
  v1 = malloc(8uLL);
  if ( v1 )
  {
    v3 = lh_new((__int64)sub_A5A88, (__int64)sub_A5AC0);
    *v1 = v3;
    if ( !v3 )
    {
      free(v1);
      return 0LL;
    }
  }
  return v1;
}

//----- (00000000000A5A88) ----------------------------------------------------
__int64 __fastcall sub_A5A88(_BYTE **a1)
{
  _BYTE **v1; // x19
  int v2; // w0

  v1 = a1;
  v2 = (unsigned __int64)lh_strhash(*a1);
  return (unsigned int)lh_strhash(v1[1]) ^ 4 * v2;
}

//----- (00000000000A5AC0) ----------------------------------------------------
__int64 __fastcall sub_A5AC0(const char **a1, const char **a2)
{
  const char **v2; // x19
  const char **v3; // x20
  const char *v4; // x0
  const char *v5; // x1
  __int64 result; // x0
  const char *v7; // x0
  const char *v8; // x1
  unsigned int v9; // w8

  v2 = a2;
  v3 = a1;
  v4 = *a1;
  v5 = *a2;
  if ( v4 == v5 || (result = strcmp(v4, v5), !(_DWORD)result) )
  {
    v7 = v3[1];
    v8 = v2[1];
    if ( v7 && v8 )
    {
      result = strcmp(v7, v8);
    }
    else
    {
      if ( v7 )
        v9 = 0;
      else
        v9 = -1;
      if ( v7 == v8 )
        result = 0LL;
      else
        result = v9;
    }
  }
  return result;
}

//----- (00000000000A5B28) ----------------------------------------------------
_QWORD *sub_A5B28()
{
  _QWORD *result; // x0

  result = malloc(0x18uLL);
  if ( result )
  {
    result[1] = 0LL;
    result[2] = 0LL;
    *result = 0LL;
  }
  else
  {
    ERR_put_error(13, 0LL, 65, (__int64)"external/boringssl/src/crypto/conf/conf.c", 123);
    result = 0LL;
  }
  return result;
}

//----- (00000000000A5B74) ----------------------------------------------------
void __fastcall NCONF_free(__int64 *a1)
{
  __int64 *v1; // x19
  __int64 v2; // x0

  v1 = a1;
  if ( a1 )
  {
    v2 = *a1;
    if ( *v1 )
    {
      lh_doall(v2, (void (__fastcall *)(__int64, _QWORD, __int64, __int64))sub_A5BC0);
      lh_free((_QWORD *)*v1);
      free(v1);
    }
  }
}

//----- (00000000000A5BC0) ----------------------------------------------------
void __fastcall sub_A5BC0(void **a1)
{
  void **v1; // x19
  void *v2; // x0
  void *v3; // x0
  void *v4; // x0
  void **v5; // x0

  v1 = a1;
  v2 = *a1;
  if ( v2 )
    free(v2);
  v3 = v1[1];
  if ( v3 )
  {
    free(v3);
    v4 = v1[2];
    if ( v4 )
      free(v4);
  }
  else
  {
    v5 = (void **)v1[2];
    if ( v5 )
      sk_free(v5);
  }
  free(v1);
}

//----- (00000000000A5C14) ----------------------------------------------------
__int64 __fastcall sub_A5C14(__int64 *a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v3; // [xsp+0h] [xbp-20h]
  __int64 v4; // [xsp+8h] [xbp-18h]
  __int64 v5; // [xsp+10h] [xbp-10h]
  __int64 v6; // [xsp+18h] [xbp-8h]

  v6 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = 0LL;
  v5 = 0LL;
  v3 = a2;
  result = lh_retrieve(*a1, (__int64)&v3);
  if ( result )
    result = *(_QWORD *)(result + 16);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A5C6C) ----------------------------------------------------
__int64 __fastcall sub_A5C6C(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 result; // x0
  __int64 v4; // [xsp+0h] [xbp-20h]
  __int64 v5; // [xsp+8h] [xbp-18h]
  __int64 v6; // [xsp+10h] [xbp-10h]
  __int64 v7; // [xsp+18h] [xbp-8h]

  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = a3;
  v6 = 0LL;
  v4 = a2;
  result = lh_retrieve(*a1, (__int64)&v4);
  if ( result )
    result = *(_QWORD *)(result + 16);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A5CC4) ----------------------------------------------------
__int64 __fastcall sub_A5CC4(const char *a1, unsigned __int8 a2, int a3, __int64 (__fastcall *a4)(const char *, __int64, __int64), __int64 a5)
{
  __int64 v5; // x19
  __int64 (__fastcall *v6)(const char *, __int64, __int64); // x20
  int v7; // w21
  const char *v8; // x23
  int v9; // w22
  unsigned __int8 v10; // w8
  int v11; // t1
  char *v12; // x0
  char *v13; // x24
  size_t v14; // x26
  int v15; // t1
  const char *v16; // x0
  __int64 v17; // x1
  __int64 result; // x0

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a1;
  if ( a1 )
  {
    v9 = a2;
    while ( 1 )
    {
      if ( v7 )
      {
        v10 = *v8;
        if ( *v8 )
        {
          do
          {
            if ( !(unsigned int)isspace(v10) )
              break;
            v11 = *((unsigned __int8 *)v8++ + 1);
            v10 = v11;
          }
          while ( v11 );
        }
      }
      v12 = strchr(v8, v9);
      v13 = v12;
      if ( v12 != v8 && *v8 )
      {
        v14 = (size_t)v12;
        if ( !v12 )
          v14 = (size_t)&v8[strlen(v8)];
        if ( v7 )
        {
          do
            v15 = *(unsigned __int8 *)(v14-- - 1);
          while ( (unsigned int)isspace(v15) );
        }
        else
        {
          LODWORD(v14) = v14 - 1;
        }
        v17 = (unsigned int)(1 - (_DWORD)v8 + v14);
        v16 = v8;
      }
      else
      {
        v16 = 0LL;
        v17 = 0LL;
      }
      result = v6(v16, v17, v5);
      if ( (signed int)result < 1 )
        break;
      v8 = v13 + 1;
      if ( !v13 )
        return 1LL;
    }
  }
  else
  {
    ERR_put_error(13, 0LL, 100, (__int64)"external/boringssl/src/crypto/conf/conf.c", 757);
    result = 0LL;
  }
  return result;
}

//----- (00000000000A5DD4) ----------------------------------------------------
char *DH_new()
{
  char *v0; // x0
  char *v1; // x19

  v0 = (char *)malloc(0xA0uLL);
  v1 = v0;
  if ( v0 )
  {
    memset(v0, 0, 0xA0uLL);
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v1 + 40));
    *((_DWORD *)v1 + 37) = 1;
    CRYPTO_new_ex_data((_QWORD *)v1 + 19);
  }
  else
  {
    ERR_put_error(5, 0LL, 65, (__int64)"external/boringssl/src/crypto/dh/dh.c", 78);
  }
  return v1;
}

//----- (00000000000A5E48) ----------------------------------------------------
void __fastcall DH_free(__int64 a1)
{
  __int64 v1; // x19

  v1 = a1;
  if ( a1 )
  {
    if ( (unsigned int)CRYPTO_refcount_dec_and_test_zero((int *)(a1 + 148)) )
    {
      CRYPTO_free_ex_data((pthread_rwlock_t *)&unk_1073D8, v1, (unsigned __int64 **)(v1 + 152));
      BN_MONT_CTX_free(*(_DWORD **)(v1 + 96));
      BN_clear_free(*(void ***)v1);
      BN_clear_free(*(void ***)(v1 + 8));
      BN_clear_free(*(void ***)(v1 + 104));
      BN_clear_free(*(void ***)(v1 + 112));
      free(*(void **)(v1 + 120));
      BN_clear_free(*(void ***)(v1 + 136));
      BN_clear_free(*(void ***)(v1 + 16));
      BN_clear_free(*(void ***)(v1 + 24));
      CRYPTO_MUTEX_cleanup(v1 + 40);
      free((void *)v1);
    }
  }
}
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);

//----- (00000000000A5EE8) ----------------------------------------------------
__int64 __fastcall DH_get0_key(__int64 result, _QWORD *a2, _QWORD *a3)
{
  if ( a2 )
    *a2 = *(_QWORD *)(result + 16);
  if ( a3 )
    *a3 = *(_QWORD *)(result + 24);
  return result;
}

//----- (00000000000A5F04) ----------------------------------------------------
_QWORD *__fastcall DH_get0_pqg(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if ( a2 )
    *a2 = *result;
  if ( a3 )
    *a3 = result[13];
  if ( a4 )
    *a4 = result[1];
  return result;
}

//----- (00000000000A5F2C) ----------------------------------------------------
__int64 __fastcall DH_generate_parameters_ex(__int64 a1, signed int a2, int a3, __int64 a4)
{
  __int64 v4; // x21
  __int64 v5; // x25
  signed int v6; // w22
  __int64 v7; // x20
  _DWORD *v8; // x0
  __int64 v9; // x19
  _QWORD *v10; // x23
  _QWORD *v11; // x0
  __int64 v12; // x24
  _QWORD *v13; // x0
  _QWORD *v14; // x0
  unsigned int v15; // w20
  int v17; // w0

  v4 = a4;
  LODWORD(v5) = a3;
  v6 = a2;
  v7 = a1;
  v8 = BN_CTX_new();
  v9 = (__int64)v8;
  if ( !v8 )
  {
    ERR_put_error(5, 0LL, 3, (__int64)"external/boringssl/src/crypto/dh/dh.c", 246);
    return 0;
  }
  BN_CTX_start((__int64)v8);
  v10 = BN_CTX_get(v9);
  v11 = BN_CTX_get(v9);
  v12 = (__int64)v11;
  if ( !v10 )
    goto LABEL_10;
  if ( !v11 )
    goto LABEL_10;
  if ( !*(_QWORD *)v7 )
  {
    v13 = BN_new();
    *(_QWORD *)v7 = v13;
    if ( !v13 )
      goto LABEL_10;
  }
  if ( !*(_QWORD *)(v7 + 8) )
  {
    v14 = BN_new();
    *(_QWORD *)(v7 + 8) = v14;
    if ( !v14 )
      goto LABEL_10;
  }
  if ( (signed int)v5 > 1 )
  {
    if ( (_DWORD)v5 == 5 )
    {
      if ( !(unsigned int)BN_set_word((__int64)v10, 10LL) || !(unsigned int)BN_set_word(v12, 3LL) )
        goto LABEL_10;
      v5 = 5LL;
    }
    else if ( (_DWORD)v5 == 2 )
    {
      if ( !(unsigned int)BN_set_word((__int64)v10, 24LL) || !(unsigned int)BN_set_word(v12, 11LL) )
        goto LABEL_10;
      v5 = 2LL;
    }
    else
    {
      if ( !(unsigned int)BN_set_word((__int64)v10, 2LL) || !(unsigned int)BN_set_word(v12, 1LL) )
        goto LABEL_10;
      v5 = (signed int)v5;
    }
    BN_generate_prime_ex(*(__int64 **)v7, v6, 1, (__int64)v10, v12, v4);
    if ( v17 && (unsigned int)BN_GENCB_call(v4, 3u, 0) && (unsigned int)BN_set_word(*(_QWORD *)(v7 + 8), v5) )
    {
      v15 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    ERR_put_error(5, 0LL, 100, (__int64)"external/boringssl/src/crypto/dh/dh.c", 198);
  }
LABEL_10:
  ERR_put_error(5, 0LL, 3, (__int64)"external/boringssl/src/crypto/dh/dh.c", 246);
  v15 = 0;
LABEL_11:
  BN_CTX_end(v9);
  BN_CTX_free(v9);
  return v15;
}

//----- (00000000000A6114) ----------------------------------------------------
__int64 __fastcall DH_generate_key(__int64 *a1)
{
  __int64 *v1; // x19
  _DWORD *v2; // x20
  _QWORD *v3; // x21
  signed int v4; // w23
  _QWORD *v5; // x22
  unsigned int v6; // w23
  __int64 v8; // x2
  signed int v9; // w1
  int v10; // w0
  int v11; // w0

  v1 = a1;
  if ( (unsigned int)BN_num_bits(*a1) >= 0x2711 )
  {
    ERR_put_error(5, 0LL, 102, (__int64)"external/boringssl/src/crypto/dh/dh.c", 263);
    v2 = 0LL;
LABEL_7:
    v5 = 0LL;
    v3 = 0LL;
    goto LABEL_8;
  }
  v2 = BN_CTX_new();
  if ( !v2 )
    goto LABEL_7;
  v3 = (_QWORD *)v1[3];
  if ( !v3 )
  {
    v3 = BN_new();
    if ( !v3 )
    {
      v5 = 0LL;
      goto LABEL_8;
    }
    v4 = 1;
    v5 = (_QWORD *)v1[2];
    if ( v5 )
      goto LABEL_16;
    goto LABEL_15;
  }
  v4 = 0;
  v5 = (_QWORD *)v1[2];
  if ( !v5 )
  {
LABEL_15:
    v5 = BN_new();
    if ( !v5 )
      goto LABEL_8;
  }
LABEL_16:
  if ( !sub_6BAC4(v1 + 12, (pthread_rwlock_t *)(v1 + 5), *v1) )
    goto LABEL_8;
  if ( !v4 )
    goto LABEL_26;
  v8 = v1[13];
  if ( v8 )
  {
    if ( !(unsigned int)BN_rand_range_ex((__int64)v3, 2uLL, v8) )
      goto LABEL_8;
    goto LABEL_26;
  }
  v9 = *((_DWORD *)v1 + 8);
  if ( !v9 )
  {
    v10 = BN_num_bits(*v1);
    if ( !v10 )
      goto LABEL_8;
    v9 = v10 - 1;
  }
  if ( (unsigned int)BN_rand((__int64)v3, v9, 0, 0) )
  {
LABEL_26:
    BN_mod_exp_mont_consttime((__int64)v5, v1[1], (__int64)v3, *v1, (__int64)v2, v1[12]);
    if ( v11 )
    {
      v1[2] = (__int64)v5;
      v1[3] = (__int64)v3;
      v6 = 1;
      if ( v1[3] )
        goto LABEL_12;
      goto LABEL_11;
    }
  }
LABEL_8:
  ERR_put_error(5, 0LL, 3, (__int64)"external/boringssl/src/crypto/dh/dh.c", 330);
  v6 = 0;
  if ( !v1[2] )
  {
    BN_free(v5);
    v6 = 0;
  }
  if ( !v1[3] )
LABEL_11:
    BN_free(v3);
LABEL_12:
  BN_CTX_free((__int64)v2);
  return v6;
}

//----- (00000000000A62B4) ----------------------------------------------------
void __fastcall DH_compute_key(_BYTE *a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // x22
  _BYTE *v4; // x20
  __int64 v5; // x21
  _DWORD *v6; // x0
  __int64 v7; // x19
  _QWORD *v8; // x23
  int v9; // w0
  int v10; // w2
  __int16 v11; // w4
  int v12; // [xsp+4h] [xbp-3Ch]
  __int64 v13; // [xsp+8h] [xbp-38h]

  v3 = a3;
  v4 = a1;
  v5 = a2;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)BN_num_bits(*a3) < 0x2711 )
  {
    v6 = BN_CTX_new();
    v7 = (__int64)v6;
    if ( !v6 )
      goto LABEL_17;
    BN_CTX_start((__int64)v6);
    v8 = BN_CTX_get(v7);
    if ( !v8 )
      goto LABEL_16;
    if ( v3[3] )
    {
      if ( !sub_6BAC4(v3 + 12, (pthread_rwlock_t *)(v3 + 5), *v3) )
      {
LABEL_16:
        BN_CTX_end(v7);
        BN_CTX_free(v7);
        goto LABEL_17;
      }
      if ( !(unsigned int)DH_check_pub_key(v3, v5, &v12) || v12 )
      {
        v10 = 101;
        v11 = 375;
      }
      else
      {
        BN_mod_exp_mont_consttime((__int64)v8, v5, v3[3], *v3, v7, v3[12]);
        if ( v9 )
        {
          BN_bn2bin((__int64)v8, v4);
          goto LABEL_16;
        }
        v10 = 3;
        v11 = 381;
      }
    }
    else
    {
      v10 = 103;
      v11 = 365;
    }
    ERR_put_error(5, 0LL, v10, (__int64)"external/boringssl/src/crypto/dh/dh.c", v11);
    goto LABEL_16;
  }
  ERR_put_error(5, 0LL, 102, (__int64)"external/boringssl/src/crypto/dh/dh.c", 350);
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A6450) ----------------------------------------------------
__int64 __fastcall DH_size(__int64 *a1)
{
  return BN_num_bytes(*a1);
}

//----- (00000000000A6458) ----------------------------------------------------
__int64 __fastcall DH_num_bits(__int64 *a1)
{
  return BN_num_bits(*a1);
}

//----- (00000000000A6460) ----------------------------------------------------
signed __int64 __fastcall DH_up_ref(__int64 a1)
{
  CRYPTO_refcount_inc((_DWORD *)(a1 + 148));
  return 1LL;
}

//----- (00000000000A647C) ----------------------------------------------------
__int64 __fastcall DHparams_dup(__int64 a1)
{
  __int64 v1; // x20
  void *v2; // x0
  __int64 v3; // x19
  __int64 v4; // x22
  signed int *v5; // x21
  signed int *v6; // x0
  signed int *v7; // x21
  signed int *v8; // x0
  signed int *v9; // x21
  signed int *v10; // x0
  signed int *v11; // x21
  void *v12; // x0
  const void *v13; // x0
  void *v14; // x0

  v1 = a1;
  v2 = malloc(0xA0uLL);
  v3 = (__int64)v2;
  if ( v2 )
  {
    memset(v2, 0, 0xA0uLL);
    CRYPTO_MUTEX_init((pthread_rwlock_t *)(v3 + 40));
    *(_DWORD *)(v3 + 148) = 1;
    CRYPTO_new_ex_data((_QWORD *)(v3 + 152));
    v4 = *(_QWORD *)(v1 + 104);
    if ( *(_QWORD *)v1 )
    {
      v5 = BN_dup(*(signed int **)v1);
      if ( !v5 )
        goto LABEL_23;
    }
    else
    {
      v5 = 0LL;
    }
    BN_free(*(_DWORD **)v3);
    *(_QWORD *)v3 = v5;
    v6 = *(signed int **)(v1 + 8);
    if ( v6 )
    {
      v7 = BN_dup(v6);
      if ( !v7 )
        goto LABEL_23;
    }
    else
    {
      v7 = 0LL;
    }
    BN_free(*(_DWORD **)(v3 + 8));
    *(_QWORD *)(v3 + 8) = v7;
    if ( v4 )
    {
      v8 = *(signed int **)(v1 + 104);
      if ( v8 )
      {
        v9 = BN_dup(v8);
        if ( !v9 )
          goto LABEL_23;
      }
      else
      {
        v9 = 0LL;
      }
      BN_free(*(_DWORD **)(v3 + 104));
      *(_QWORD *)(v3 + 104) = v9;
      v10 = *(signed int **)(v1 + 112);
      if ( v10 )
      {
        v11 = BN_dup(v10);
        if ( !v11 )
          goto LABEL_23;
      }
      else
      {
        v11 = 0LL;
      }
      BN_free(*(_DWORD **)(v3 + 112));
      v12 = *(void **)(v3 + 120);
      *(_QWORD *)(v3 + 112) = v11;
      free(v12);
      *(_QWORD *)(v3 + 120) = 0LL;
      *(_DWORD *)(v3 + 128) = 0;
      v13 = *(const void **)(v1 + 120);
      if ( v13 )
      {
        v14 = BUF_memdup(v13, *(signed int *)(v1 + 128));
        *(_QWORD *)(v3 + 120) = v14;
        if ( !v14 )
        {
LABEL_23:
          DH_free(v3);
          return 0LL;
        }
        *(_DWORD *)(v3 + 128) = *(_DWORD *)(v1 + 128);
      }
    }
  }
  else
  {
    ERR_put_error(5, 0LL, 65, (__int64)"external/boringssl/src/crypto/dh/dh.c", 78);
  }
  return v3;
}

//----- (00000000000A65E4) ----------------------------------------------------
signed __int64 __fastcall DH_get_ex_new_index(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // x19
  int v6; // w0
  __int64 v7; // x9
  signed __int64 result; // x0
  unsigned int v9; // [xsp+4h] [xbp-1Ch]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = *(_QWORD *)(v5 + 40);
  v6 = CRYPTO_get_ex_new_index((pthread_rwlock_t *)&unk_1073D8, &v9, a1, a2, a4, a5);
  v7 = *(_QWORD *)(v5 + 40);
  if ( v6 )
    result = v9;
  else
    result = 1LL;
  return result;
}

//----- (00000000000A6660) ----------------------------------------------------
void __fastcall EVP_parse_public_key(unsigned __int8 **a1)
{
  char *v1; // x0
  char *v2; // x19
  unsigned int (__fastcall *v3)(char *, unsigned __int8 **, char *); // x8
  char v4; // [xsp+0h] [xbp-50h]
  unsigned int v5; // [xsp+4h] [xbp-4Ch]
  char v6; // [xsp+8h] [xbp-48h]
  unsigned __int8 *v7[2]; // [xsp+18h] [xbp-38h]
  unsigned __int8 *v8[2]; // [xsp+28h] [xbp-28h]
  __int64 v9; // [xsp+38h] [xbp-18h]

  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a1, (char *)v8, 48)
    && (unsigned int)CBS_get_asn1(v8, (char *)v7, 48)
    && (unsigned int)sub_A679C(v7, (int *)&v5)
    && (unsigned int)CBS_get_asn1(v8, &v6, 3)
    && !EVP_CIPHER_CTX_get_app_data((__int64)v8)
    && (unsigned int)CBS_get_u8((__int64)&v6, &v4)
    && !v4 )
  {
    v1 = EVP_PKEY_new();
    v2 = v1;
    if ( !v1 || !(unsigned int)EVP_PKEY_set_type((__int64)v1, v5) )
      goto LABEL_17;
    v3 = *(unsigned int (__fastcall **)(char *, unsigned __int8 **, char *))(*((_QWORD *)v2 + 2) + 16LL);
    if ( !v3 )
    {
      ERR_put_error(6, 0LL, 128, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 123);
LABEL_17:
      EVP_PKEY_free((int *)v2);
      goto LABEL_7;
    }
    if ( !v3(v2, v7, &v6) )
      goto LABEL_17;
  }
  else
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 110);
  }
LABEL_7:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
}

//----- (00000000000A679C) ----------------------------------------------------
signed __int64 __fastcall sub_A679C(unsigned __int8 **a1, int *a2)
{
  int *v2; // x19
  signed __int64 result; // x0
  const void *v4; // x0
  int *v5; // x21
  const void *v6; // x0
  const void *v7; // x0
  char v8; // [xsp+8h] [xbp-38h]
  __int64 v9; // [xsp+18h] [xbp-28h]

  v2 = a2;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = CBS_get_asn1(a1, &v8, 6);
  if ( (_DWORD)result )
  {
    if ( (EVP_CIPHER_CTX_get_app_data((__int64)&v8) != 9
       || (v4 = (const void *)lh_num_items((__int64)&v8), v5 = &dword_F72A8, (unsigned int)memcmp(v4, &unk_F72AC, 9uLL)))
      && (EVP_CIPHER_CTX_get_app_data((__int64)&v8) != 7
       || (v6 = (const void *)lh_num_items((__int64)&v8), v5 = &dword_F71D0, (unsigned int)memcmp(v6, &unk_F71D4, 7uLL)))
      && (EVP_CIPHER_CTX_get_app_data((__int64)&v8) != 7
       || (v7 = (const void *)lh_num_items((__int64)&v8), v5 = &dword_F70F8, (unsigned int)memcmp(v7, &unk_F70FC, 7uLL))) )
    {
      result = 0LL;
    }
    else
    {
      result = 1LL;
      *v2 = *v5;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// F70F8: using guessed type int dword_F70F8;
// F71D0: using guessed type int dword_F71D0;
// F72A8: using guessed type int dword_F72A8;

//----- (00000000000A68DC) ----------------------------------------------------
__int64 __fastcall EVP_marshal_public_key(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 (*v3)(void); // x2

  v2 = *(_QWORD *)(a2 + 16);
  if ( v2 )
  {
    v3 = *(__int64 (**)(void))(v2 + 24);
    if ( v3 )
      return v3();
  }
  ERR_put_error(6, 0LL, 128, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 139);
  return 0LL;
}

//----- (00000000000A6920) ----------------------------------------------------
void __fastcall EVP_parse_private_key(unsigned __int8 **a1)
{
  char *v1; // x0
  char *v2; // x19
  unsigned int (__fastcall *v3)(char *, unsigned __int8 **, char *); // x8
  unsigned int v4; // [xsp+Ch] [xbp-54h]
  __int64 v5; // [xsp+10h] [xbp-50h]
  char v6; // [xsp+18h] [xbp-48h]
  unsigned __int8 *v7[2]; // [xsp+28h] [xbp-38h]
  unsigned __int8 *v8[2]; // [xsp+38h] [xbp-28h]
  __int64 v9; // [xsp+48h] [xbp-18h]

  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a1, (char *)v8, 48)
    && (unsigned int)CBS_get_asn1_uint64(v8, (unsigned __int64 *)&v5)
    && !v5
    && (unsigned int)CBS_get_asn1(v8, (char *)v7, 48)
    && (unsigned int)sub_A679C(v7, (int *)&v4)
    && (unsigned int)CBS_get_asn1(v8, &v6, 4) )
  {
    v1 = EVP_PKEY_new();
    v2 = v1;
    if ( !v1 || !(unsigned int)EVP_PKEY_set_type((__int64)v1, v4) )
      goto LABEL_16;
    v3 = *(unsigned int (__fastcall **)(char *, unsigned __int8 **, char *))(*((_QWORD *)v2 + 2) + 40LL);
    if ( !v3 )
    {
      ERR_put_error(6, 0LL, 128, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 172);
LABEL_16:
      EVP_PKEY_free((int *)v2);
      goto LABEL_13;
    }
    if ( !v3(v2, v7, &v6) )
      goto LABEL_16;
  }
  else
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 157);
  }
LABEL_13:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
}

//----- (00000000000A6A50) ----------------------------------------------------
__int64 __fastcall EVP_marshal_private_key(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  __int64 (*v3)(void); // x2

  v2 = *(_QWORD *)(a2 + 16);
  if ( v2 )
  {
    v3 = *(__int64 (**)(void))(v2 + 48);
    if ( v3 )
      return v3();
  }
  ERR_put_error(6, 0LL, 128, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 188);
  return 0LL;
}

//----- (00000000000A6A94) ----------------------------------------------------
void __fastcall d2i_PrivateKey(int a1, int **a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // x23
  __int64 *v5; // x19
  int **v6; // x21
  int v7; // w22
  int *v8; // x20
  __int64 v9; // x0
  __int64 v10; // x24
  int *v11; // x24
  __int64 v12; // x0
  __int64 v13; // x24
  int *v14; // x0
  unsigned __int8 *v15[2]; // [xsp+8h] [xbp-48h]
  __int64 v16; // [xsp+18h] [xbp-38h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a4 & 0x8000000000000000LL )
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 239);
    goto LABEL_24;
  }
  CBS_init(v15, *a3, a4);
  v8 = (int *)EVP_PKEY_new();
  if ( !v8 )
    goto LABEL_18;
  switch ( v7 )
  {
    case 6:
      v11 = RSA_parse_private_key(v15);
      if ( !v11 || !EVP_PKEY_assign_RSA((__int64)v8, (__int64)v11) )
      {
        RSA_free(v11);
        goto LABEL_17;
      }
      break;
    case 116:
      DSA_parse_private_key(v15);
      v13 = v12;
      if ( !v12 || !EVP_PKEY_assign_DSA((__int64)v8, v12) )
      {
        DSA_free(v13);
        goto LABEL_17;
      }
      break;
    case 408:
      EC_KEY_parse_private_key(v15, 0LL);
      v10 = v9;
      if ( !v9 || !EVP_PKEY_assign_EC_KEY((__int64)v8, v9) )
      {
        EC_KEY_free(v10);
LABEL_17:
        EVP_PKEY_free(v8);
LABEL_18:
        ERR_clear_error();
        CBS_init(v15, *v5, v4);
        EVP_parse_private_key(v15);
        v8 = v14;
        if ( !v14 )
          goto LABEL_24;
        if ( v14[1] != v7 )
        {
          ERR_put_error(6, 0LL, 103, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 256);
          EVP_PKEY_free(v8);
          goto LABEL_24;
        }
        break;
      }
      break;
    default:
      ERR_put_error(6, 0LL, 127, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 227);
      goto LABEL_17;
  }
  if ( v6 )
  {
    EVP_PKEY_free(*v6);
    *v6 = v8;
  }
  *v5 = lh_num_items((__int64)v15);
LABEL_24:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A6C78) ----------------------------------------------------
void __fastcall d2i_AutoPrivateKey(int **a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // x21
  __int64 *v4; // x19
  int **v5; // x20
  int *v6; // x0
  int *v7; // x22
  signed __int64 v8; // x22
  int v9; // w0
  unsigned __int8 *v10[2]; // [xsp+8h] [xbp-58h]
  unsigned __int8 *v11[2]; // [xsp+18h] [xbp-48h]
  unsigned __int8 *v12[2]; // [xsp+28h] [xbp-38h]
  __int64 v13; // [xsp+38h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 & 0x8000000000000000LL )
  {
    ERR_put_error(6, 0LL, 102, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 294);
  }
  else
  {
    CBS_init(v10, *a2, a3);
    EVP_parse_private_key(v10);
    v7 = v6;
    if ( v6 )
    {
      if ( v5 )
      {
        EVP_PKEY_free(*v5);
        *v5 = v7;
      }
      *v4 = lh_num_items((__int64)v10);
    }
    else
    {
      ERR_clear_error();
      CBS_init(v12, *v4, v3);
      if ( (unsigned int)CBS_get_asn1(v12, (char *)v11, 48) && EVP_CIPHER_CTX_get_app_data((__int64)v11) )
      {
        v8 = -1LL;
        while ( (unsigned int)CBS_get_any_asn1_element(v11, 0LL, 0LL, 0LL) )
        {
          ++v8;
          if ( !EVP_CIPHER_CTX_get_app_data((__int64)v11) )
          {
            if ( v8 == 5 )
            {
              v9 = 116;
            }
            else
            {
              if ( v8 != 3 )
                break;
              v9 = 408;
            }
            goto LABEL_16;
          }
        }
      }
      v9 = 6;
LABEL_16:
      d2i_PrivateKey(v9, v5, v4, v3);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v13;
}

//----- (00000000000A6DD4) ----------------------------------------------------
__int64 __fastcall i2d_PublicKey(__int64 a1, void **a2)
{
  int v2; // w8

  v2 = *(_DWORD *)(a1 + 4);
  switch ( v2 )
  {
    case 408:
      return i2o_ECPublicKey(*(_QWORD *)(a1 + 8), a2);
    case 116:
      return i2d_DSAPublicKey(*(_QWORD **)(a1 + 8), a2);
    case 6:
      return i2d_RSAPublicKey(*(_QWORD *)(a1 + 8), a2);
  }
  ERR_put_error(6, 0LL, 129, (__int64)"external/boringssl/src/crypto/evp/evp_asn1.c", 334);
  return 0xFFFFFFFFLL;
}

//----- (00000000000A6E38) ----------------------------------------------------
_QWORD *__fastcall lh_new(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x21
  _QWORD *v4; // x19
  void *v5; // x0

  v2 = a1;
  v3 = a2;
  v4 = malloc(0x30uLL);
  if ( v4 )
  {
    v4[4] = 0LL;
    v4[5] = 0LL;
    v4[2] = 0LL;
    v4[3] = 0LL;
    *v4 = 0LL;
    v4[1] = 0LL;
    v4[2] = 16LL;
    v5 = malloc(0x80uLL);
    v4[1] = v5;
    if ( v5 )
    {
      memset(v5, 0, 0x80uLL);
      v4[4] = v3;
      v4[5] = v2;
    }
    else
    {
      free(v4);
      v4 = 0LL;
    }
  }
  return v4;
}

//----- (00000000000A6EB8) ----------------------------------------------------
void __fastcall lh_free(_QWORD *a1)
{
  _QWORD *v1; // x19
  _QWORD *v2; // x0
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x20
  _QWORD *v5; // x8
  _QWORD *v6; // x21

  v1 = a1;
  if ( a1 )
  {
    v2 = (_QWORD *)a1[1];
    v3 = v1[2];
    if ( v3 )
    {
      v4 = 0LL;
      do
      {
        v5 = (_QWORD *)v2[v4];
        if ( v5 )
        {
          do
          {
            v6 = (_QWORD *)v5[1];
            free(v5);
            v5 = v6;
          }
          while ( v6 );
          v2 = (_QWORD *)v1[1];
          v3 = v1[2];
        }
        ++v4;
      }
      while ( v4 < v3 );
    }
    free(v2);
    free(v1);
  }
}

//----- (00000000000A6F30) ----------------------------------------------------
__int64 __fastcall lh_retrieve(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  unsigned int v4; // w0
  __int64 **v5; // x21
  __int64 *v6; // x8
  __int64 **v7; // x22
  __int64 result; // x0

  v2 = a1;
  v3 = a2;
  v4 = (*(__int64 (__fastcall **)(__int64))(a1 + 40))(a2);
  v5 = (__int64 **)(*(_QWORD *)(v2 + 8) + 8 * (v4 - (unsigned __int64)v4 / *(_QWORD *)(v2 + 16) * *(_QWORD *)(v2 + 16)));
  v6 = *v5;
  if ( !*v5 )
    goto LABEL_7;
  while ( 1 )
  {
    v7 = (__int64 **)(v6 + 1);
    if ( !(*(unsigned int (__fastcall **)(__int64, __int64))(v2 + 32))(*v6, v3) )
      break;
    v6 = *v7;
    v5 = v7;
    if ( !*v7 )
      goto LABEL_7;
  }
  if ( *v5 )
    result = **v5;
  else
LABEL_7:
    result = 0LL;
  return result;
}

//----- (00000000000A6FBC) ----------------------------------------------------
_DWORD *__fastcall lh_insert(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // x22
  __int64 v4; // x19
  __int64 v5; // x20
  unsigned int v6; // w21
  _QWORD **v7; // x24
  _QWORD *v8; // x8
  _QWORD *v9; // x23
  _DWORD *result; // x0
  int v11; // w10
  unsigned __int64 v12; // x9
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x1
  unsigned __int64 v15; // x8

  v3 = a2;
  v4 = a1;
  *a2 = 0LL;
  v5 = a3;
  v6 = (*(__int64 (__fastcall **)(__int64))(a1 + 40))(a3);
  v7 = (_QWORD **)(*(_QWORD *)(v4 + 8) + 8 * (v6 - (unsigned __int64)v6 / *(_QWORD *)(v4 + 16) * *(_QWORD *)(v4 + 16)));
  v8 = *v7;
  if ( *v7 )
  {
    while ( 1 )
    {
      v9 = v8 + 1;
      if ( !(*(unsigned int (__fastcall **)(_QWORD, __int64))(v4 + 32))(*v8, v5) )
        break;
      v8 = (_QWORD *)*v9;
      v7 = (_QWORD **)v9;
      if ( !*v9 )
        goto LABEL_8;
    }
    if ( *v7 )
    {
      *v3 = **v7;
      **v7 = v5;
      return &dword_0 + 1;
    }
  }
  v9 = v7;
LABEL_8:
  result = malloc(0x18uLL);
  if ( result )
  {
    result[4] = v6;
    *(_QWORD *)result = v5;
    *((_QWORD *)result + 1) = 0LL;
    *v9 = result;
    v11 = *(_DWORD *)(v4 + 24);
    v12 = *(_QWORD *)v4 + 1LL;
    *(_QWORD *)v4 = v12;
    if ( v11 )
      return &dword_0 + 1;
    v13 = *(_QWORD *)(v4 + 16);
    if ( v12 / v13 >= 3 )
    {
      v14 = 2 * v13;
      if ( 2 * v13 <= v13 )
        return &dword_0 + 1;
      goto LABEL_18;
    }
    result = &dword_0 + 1;
    if ( v13 > v12 && v13 >= 0x11 )
    {
      v15 = v13 >> 1;
      if ( v15 >= 0x10 )
        v14 = v15;
      else
        v14 = 16LL;
LABEL_18:
      sub_A7380(v4, v14);
      return &dword_0 + 1;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000A70E4) ----------------------------------------------------
__int64 __fastcall lh_delete(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  unsigned int v4; // w0
  __int64 **v5; // x21
  __int64 *v6; // x8
  __int64 **v7; // x22
  __int64 v8; // x20
  __int64 *v10; // x0
  int v11; // w10
  unsigned __int64 v12; // x9
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x1
  unsigned __int64 v15; // x8

  v2 = a1;
  v3 = a2;
  v4 = (*(__int64 (__fastcall **)(__int64))(a1 + 40))(a2);
  v5 = (__int64 **)(*(_QWORD *)(v2 + 8) + 8 * (v4 - (unsigned __int64)v4 / *(_QWORD *)(v2 + 16) * *(_QWORD *)(v2 + 16)));
  v6 = *v5;
  if ( !*v5 )
    return 0LL;
  while ( 1 )
  {
    v7 = (__int64 **)(v6 + 1);
    if ( !(*(unsigned int (__fastcall **)(__int64, __int64))(v2 + 32))(*v6, v3) )
      break;
    v6 = *v7;
    v5 = v7;
    if ( !*v7 )
      return 0LL;
  }
  v10 = *v5;
  if ( !*v5 )
    return 0LL;
  *v5 = (__int64 *)v10[1];
  v8 = *v10;
  free(v10);
  v11 = *(_DWORD *)(v2 + 24);
  v12 = *(_QWORD *)v2 - 1LL;
  *(_QWORD *)v2 = v12;
  if ( !v11 )
  {
    v13 = *(_QWORD *)(v2 + 16);
    if ( v12 / v13 >= 3 )
    {
      v14 = 2 * v13;
      if ( 2 * v13 <= v13 )
        return v8;
      goto LABEL_17;
    }
    if ( v13 > v12 && v13 >= 0x11 )
    {
      v15 = v13 >> 1;
      if ( v15 >= 0x10 )
        v14 = v15;
      else
        v14 = 16LL;
LABEL_17:
      sub_A7380(v2, v14);
      return v8;
    }
  }
  return v8;
}

//----- (00000000000A71E0) ----------------------------------------------------
void __fastcall lh_doall(__int64 a1, void (__fastcall *a2)(__int64, _QWORD, __int64, __int64))
{
  __int64 v2; // x2
  __int64 v3; // x3
  void (__fastcall *v4)(__int64, _QWORD, __int64, __int64); // x22
  __int64 v5; // x19
  int v6; // w8
  int v7; // w9
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x23
  __int64 *v10; // x24
  __int64 v11; // x0
  int v16; // w9
  unsigned __int64 v17; // x1
  unsigned __int64 v18; // x8

  v2 = 0LL;
  v3 = 0LL;
  v4 = a2;
  v5 = a1;
  if ( !a1 )
    return;
  v6 = *(_DWORD *)(a1 + 24);
  if ( v6 == -1 )
  {
    v7 = -1;
    v8 = *(_QWORD *)(a1 + 16);
    if ( !v8 )
      goto LABEL_15;
  }
  else
  {
    v7 = v6 + 1;
    *(_DWORD *)(a1 + 24) = v6 + 1;
    v8 = *(_QWORD *)(a1 + 16);
    if ( !v8 )
      goto LABEL_15;
  }
  v9 = 0LL;
  do
  {
    v10 = *(__int64 **)(*(_QWORD *)(v5 + 8) + 8 * v9);
    if ( v10 )
    {
      do
      {
        v11 = *v10;
        v10 = (__int64 *)v10[1];
        v4(v11, a2, v2, v3);
      }
      while ( v10 );
      v8 = *(_QWORD *)(v5 + 16);
    }
    ++v9;
  }
  while ( v9 < v8 );
  v7 = *(_DWORD *)(v5 + 24);
LABEL_15:
  if ( v7 != -1 )
  {
    v16 = v7 - 1;
    *(_DWORD *)(v5 + 24) = v16;
    if ( !v16 )
    {
      if ( *(_QWORD *)v5 / v8 < 3 )
      {
        if ( v8 <= *(_QWORD *)v5 || v8 < 0x11 )
          return;
        v18 = v8 >> 1;
        if ( v18 >= 0x10 )
          v17 = v18;
        else
          v17 = 16LL;
      }
      else
      {
        v17 = 2 * v8;
        if ( 2 * v8 <= v8 )
          return;
      }
      sub_A7380(v5, v17);
      return;
    }
  }
}
// 0: using guessed type int dword_0;

//----- (00000000000A7304) ----------------------------------------------------
void lh_doall_arg()
{
  JUMPOUT(&loc_A71EC);
}

//----- (00000000000A731C) ----------------------------------------------------
_BYTE *__fastcall lh_strhash(_BYTE *result)
{
  unsigned int v1; // w12
  unsigned __int64 v2; // x8
  unsigned __int8 *v3; // x9
  signed __int64 v4; // x10
  int v5; // w14
  __int64 v6; // x13
  unsigned int v7; // t1
  signed __int64 v8; // x13

  if ( result )
  {
    v1 = (unsigned __int8)*result;
    if ( *result )
    {
      v2 = 0LL;
      v3 = result + 1;
      v4 = 256LL;
      do
      {
        v5 = (v1 ^ (v1 >> 2)) & 0xF;
        v6 = (unsigned __int8)v1;
        v7 = *v3++;
        v1 = v7;
        v8 = (v6 | v4) * (v6 | v4);
        v4 += 256LL;
        v2 = ((unsigned int)(v2 >> (32 - (unsigned __int8)v5)) | (unsigned int)(v2 << v5)) ^ (unsigned __int64)v8;
      }
      while ( v7 );
      result = (_BYTE *)((unsigned int)(v2 >> 16) ^ (unsigned int)v2);
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (00000000000A7380) ----------------------------------------------------
void __fastcall sub_A7380(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x19
  __int64 v3; // x20
  signed __int64 v4; // x22
  char *v5; // x0
  char *v6; // x21
  _QWORD *v7; // x0
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x8
  __int64 v10; // x10
  __int64 v11; // x12
  unsigned __int64 v12; // x9

  v2 = a2;
  v3 = a1;
  if ( (a2 & 0x1FFFFFFFFFFFFFFFLL) == a2 )
  {
    v4 = 8 * a2;
    v5 = (char *)malloc(8 * a2);
    v6 = v5;
    if ( v5 )
    {
      if ( v4 )
        memset(v5, 0, 8 * v2);
      v7 = *(_QWORD **)(v3 + 8);
      v8 = *(_QWORD *)(v3 + 16);
      if ( v8 )
      {
        v9 = 0LL;
        do
        {
          v10 = v7[v9];
          if ( v10 )
          {
            do
            {
              v11 = *(_QWORD *)(v10 + 8);
              v12 = 8 * (*(unsigned int *)(v10 + 16) - *(unsigned int *)(v10 + 16) / v2 * v2);
              *(_QWORD *)(v10 + 8) = *(_QWORD *)&v6[v12];
              *(_QWORD *)&v6[v12] = v10;
              v10 = v11;
            }
            while ( v11 );
            v7 = *(_QWORD **)(v3 + 8);
            v8 = *(_QWORD *)(v3 + 16);
          }
          ++v9;
        }
        while ( v9 < v8 );
      }
      free(v7);
      *(_QWORD *)(v3 + 8) = v6;
      *(_QWORD *)(v3 + 16) = v2;
    }
  }
}

//----- (00000000000A7430) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_PKCS8_PRIV_KEY_INFO(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&PKCS8_PRIV_KEY_INFO_it);
}

//----- (00000000000A743C) ----------------------------------------------------
void i2d_PKCS8_PRIV_KEY_INFO()
{
  ASN1_item_i2d();
}

//----- (00000000000A7448) ----------------------------------------------------
__int64 PKCS8_PRIV_KEY_INFO_new()
{
  return ASN1_item_new((unsigned __int8 *)&PKCS8_PRIV_KEY_INFO_it);
}

//----- (00000000000A7454) ----------------------------------------------------
void __fastcall PKCS8_PRIV_KEY_INFO_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&PKCS8_PRIV_KEY_INFO_it);
}

//----- (00000000000A7460) ----------------------------------------------------
void EVP_PKCS82PKEY()
{
  int v0; // w0
  int *v1; // x0
  int *v2; // x19
  __int64 v3; // [xsp+0h] [xbp-30h]
  void *v4; // [xsp+10h] [xbp-20h]
  __int64 v5; // [xsp+18h] [xbp-18h]

  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = 0LL;
  ASN1_item_i2d();
  if ( !(v0 & 0x80000000) )
  {
    CBS_init(&v3, (__int64)v4, v0);
    EVP_parse_private_key((unsigned __int8 **)&v3);
    v2 = v1;
    if ( v1 && !EVP_CIPHER_CTX_get_app_data((__int64)&v3) )
    {
      free(v4);
    }
    else
    {
      ERR_put_error(19, 0LL, 104, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 113);
      EVP_PKEY_free(v2);
      free(v4);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v5;
}

//----- (00000000000A7528) ----------------------------------------------------
void __fastcall EVP_PKEY2PKCS8(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int64 *v2; // x19
  int v3; // w2
  __int16 v4; // w4
  char *v5; // [xsp+0h] [xbp-50h]
  __int64 v6; // [xsp+8h] [xbp-48h]
  char *v7; // [xsp+10h] [xbp-40h]
  __int64 v8[4]; // [xsp+18h] [xbp-38h]
  __int64 v9; // [xsp+38h] [xbp-18h]

  v1 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = 0LL;
  if ( (unsigned int)CBB_init(v8, 0LL)
    && (unsigned int)EVP_marshal_private_key((__int64)v8, v1)
    && (unsigned int)CBB_finish((__int64)v8, &v7, &v6)
    && !(v6 & 0x8000000000000000LL) )
  {
    v5 = v7;
    v2 = ASN1_item_d2i(0LL, (const void **)&v5, v6, (unsigned __int8 *)&PKCS8_PRIV_KEY_INFO_it);
    if ( v2 && v5 == &v7[v6] )
    {
      free(v7);
      goto LABEL_10;
    }
    ASN1_item_free((__int64)v2, (unsigned __int8 *)&PKCS8_PRIV_KEY_INFO_it);
    v3 = 104;
    v4 = 140;
  }
  else
  {
    CBB_cleanup(v8);
    v3 = 105;
    v4 = 132;
  }
  ERR_put_error(19, 0LL, v3, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", v4);
  free(v7);
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v9;
}

//----- (00000000000A764C) ----------------------------------------------------
void __fastcall PKCS8_decrypt(__int64 a1, const char *a2, int a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  int v5; // w0
  int *v6; // x0
  int *v7; // x19
  __int64 v8; // [xsp+0h] [xbp-40h]
  void *v9; // [xsp+10h] [xbp-30h]
  __int64 v10; // [xsp+18h] [xbp-28h]

  v3 = (__int64)a2;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 && a3 == -1 )
    v4 = strlen(a2);
  else
    v4 = a3;
  v9 = 0LL;
  i2d_X509_SIG();
  if ( v5 & 0x80000000 )
  {
    v7 = 0LL;
  }
  else
  {
    CBS_init(&v8, (__int64)v9, v5);
    PKCS8_parse_encrypted_private_key((unsigned __int8 **)&v8, v3, v4);
    v7 = v6;
    if ( v6 && !EVP_CIPHER_CTX_get_app_data((__int64)&v8) )
      EVP_PKEY2PKCS8((__int64)v7);
  }
  free(v9);
  EVP_PKEY_free(v7);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A7744) ----------------------------------------------------
void __fastcall PKCS8_encrypt(int a1, __int64 a2, const char *a3, int a4, const void *a5, size_t a6, unsigned int a7)
{
  unsigned int v7; // w20
  size_t v8; // x21
  const void *v9; // x22
  __int64 v10; // x23
  __int64 v11; // x24
  int v12; // w25
  unsigned __int64 v13; // x26
  int *v14; // x0
  int *v15; // x19
  unsigned __int64 *v16; // x20
  char *v17; // [xsp+10h] [xbp-80h]
  __int64 v18[4]; // [xsp+18h] [xbp-78h]
  __int64 v19; // [xsp+38h] [xbp-58h]
  char *v20; // [xsp+40h] [xbp-50h]
  __int64 v21; // [xsp+48h] [xbp-48h]

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = (__int64)a3;
  v11 = a2;
  v12 = a1;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 && a4 == -1 )
    v13 = strlen(a3);
  else
    v13 = a4;
  EVP_PKCS82PKEY();
  v15 = v14;
  if ( v14 )
  {
    v20 = 0LL;
    if ( (unsigned int)CBB_init(v18, 0x80uLL)
      && (unsigned int)PKCS8_marshal_encrypted_private_key(v18, v12, v11, v10, v13, v9, v8, v7, (__int64)v15)
      && (unsigned int)CBB_finish((__int64)v18, &v20, &v19) )
    {
      v17 = v20;
      v16 = d2i_X509_SIG(0LL, (const void **)&v17, v19);
      if ( !v16 || v17 != &v20[v19] )
      {
        ERR_put_error(19, 0LL, 68, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 219);
        X509_SIG_free((__int64)v16);
      }
    }
    else
    {
      CBB_cleanup(v18);
    }
    free(v20);
    EVP_PKEY_free(v15);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A78C0) ----------------------------------------------------
signed __int64 __fastcall PKCS12_get_key_and_certs(int **a1, signed __int64 *a2, __int64 a3, const char *a4)
{
  signed __int64 *v4; // x19
  int **v5; // x21
  const char *v6; // x22
  __int64 v7; // x23
  _QWORD *v8; // x20
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x24
  int v12; // w2
  __int16 v13; // w4
  __int64 v14; // x0
  signed __int64 result; // x0
  unsigned __int64 v16; // x23
  __int64 v17; // x0
  __int64 v18; // x22
  __int64 v19; // x24
  __int64 v20; // x25
  __int64 v21; // x0
  unsigned int v22; // w26
  unsigned __int64 v23; // x27
  __int64 v24; // x0
  int v25; // w0
  __int64 v26; // x23
  __int64 v27; // x24
  __int64 v28; // x0
  int v29; // w0
  unsigned int v30; // [xsp+24h] [xbp-1BCh]
  unsigned __int64 v31; // [xsp+28h] [xbp-1B8h]
  __int64 v32[2]; // [xsp+30h] [xbp-1B0h]
  char v33; // [xsp+40h] [xbp-1A0h]
  unsigned __int8 *v34[2]; // [xsp+50h] [xbp-190h]
  int **v35; // [xsp+60h] [xbp-180h]
  signed __int64 *v36; // [xsp+68h] [xbp-178h]
  const char *v37; // [xsp+70h] [xbp-170h]
  unsigned __int64 v38; // [xsp+78h] [xbp-168h]
  unsigned __int64 v39; // [xsp+80h] [xbp-160h]
  char v40; // [xsp+88h] [xbp-158h]
  unsigned __int8 *v41[2]; // [xsp+98h] [xbp-148h]
  __int64 v42[2]; // [xsp+A8h] [xbp-138h]
  unsigned __int8 *v43[2]; // [xsp+B8h] [xbp-128h]
  unsigned __int8 *v44[2]; // [xsp+C8h] [xbp-118h]
  unsigned __int8 *v45[2]; // [xsp+D8h] [xbp-108h]
  unsigned __int8 *v46[2]; // [xsp+E8h] [xbp-F8h]
  char v47; // [xsp+F8h] [xbp-E8h]
  void *v48; // [xsp+100h] [xbp-E0h]
  char v49; // [xsp+108h] [xbp-D8h]
  char v50; // [xsp+148h] [xbp-98h]
  __int64 v51; // [xsp+188h] [xbp-58h]

  v4 = a2;
  v5 = a1;
  v6 = a4;
  v7 = a3;
  v51 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v48 = 0LL;
  v8 = sk_num(a2);
  if ( (unsigned int)CBS_asn1_ber_to_der(v7, &v48, &v47) )
  {
    v9 = (__int64)v48;
    if ( v48 )
    {
      v10 = *(_QWORD *)&v47;
    }
    else
    {
      v11 = lh_num_items(v7);
      v10 = EVP_CIPHER_CTX_get_app_data(v7);
      v9 = v11;
    }
    CBS_init(v46, v9, v10);
    *v5 = 0LL;
    v37 = 0LL;
    v38 = 0LL;
    v35 = 0LL;
    v36 = 0LL;
    if ( (unsigned int)CBS_get_asn1(v46, (char *)v45, 48)
      && !EVP_CIPHER_CTX_get_app_data((__int64)v46)
      && (unsigned int)CBS_get_asn1_uint64(v45, &v39) )
    {
      if ( v39 > 2 )
      {
        if ( (unsigned int)CBS_get_asn1(v45, (char *)v43, 48) )
        {
          if ( EVP_CIPHER_CTX_get_app_data((__int64)v45) )
          {
            if ( (unsigned int)CBS_get_asn1(v45, (char *)v44, 48) )
            {
              if ( (unsigned int)CBS_get_asn1(v43, (char *)v42, 6) && (unsigned int)CBS_get_asn1(v43, (char *)v41, 160) )
              {
                if ( CBS_mem_equal(v42, (__int64)&unk_DDB5C, 9LL) )
                {
                  if ( (unsigned int)CBS_get_asn1(v41, &v40, 4) )
                  {
                    v35 = v5;
                    v36 = v4;
                    v37 = v6;
                    if ( v6 )
                      v16 = strlen(v6);
                    else
                      v16 = 0LL;
                    v38 = v16;
                    if ( (unsigned int)CBS_get_asn1(v44, (char *)v34, 48) )
                    {
                      sub_486EC(v34);
                      v18 = v17;
                      if ( !v17 )
                      {
LABEL_10:
                        free(v48);
                        EVP_PKEY_free(*v5);
                        *v5 = 0LL;
                        while ( sk_num(v4) > v8 )
                        {
                          v14 = sk_pop(v4);
                          X509_free(v14);
                        }
                        goto LABEL_13;
                      }
                      if ( (unsigned int)CBS_get_asn1(v34, (char *)v32, 4) && (unsigned int)CBS_get_asn1(v44, &v33, 4) )
                      {
                        v31 = 1LL;
                        if ( EVP_CIPHER_CTX_get_app_data((__int64)v44) )
                        {
                          if ( !(unsigned int)CBS_get_asn1_uint64(v44, &v31) || v31 >> 32 )
                          {
                            v12 = 100;
                            v13 = 574;
                            goto LABEL_9;
                          }
                          v16 = v38;
                        }
                        v19 = (__int64)v37;
                        v20 = lh_num_items((__int64)&v33);
                        v21 = EVP_CIPHER_CTX_get_app_data((__int64)&v33);
                        v22 = v31;
                        v23 = v21;
                        v24 = X509_TRUST_get_flags(v18);
                        sub_B2FE8(v19, v16, v20, v23, 3LL, v22, v24, &v50, v18);
                        if ( !v25 )
                          goto LABEL_10;
                        v26 = X509_TRUST_get_flags(v18);
                        v27 = lh_num_items((__int64)&v40);
                        v28 = EVP_CIPHER_CTX_get_app_data((__int64)&v40);
                        if ( !HMAC(v18, (__int64)&v50, v26, v27, v28, &v49, &v30) )
                          goto LABEL_10;
                        if ( CBS_mem_equal(v32, (__int64)&v49, v30) )
                        {
                          sub_A7D58(
                            (__int64)&v40,
                            (__int64)&v35,
                            (unsigned int (__fastcall *)(char *, __int64))sub_A7EC0);
                          if ( v29 )
                          {
                            free(v48);
                            result = 1LL;
                            goto LABEL_14;
                          }
                          goto LABEL_10;
                        }
                        v12 = 108;
                        v13 = 594;
                        goto LABEL_9;
                      }
                      v12 = 100;
                      v13 = 565;
                    }
                    else
                    {
                      v12 = 100;
                      v13 = 554;
                    }
                  }
                  else
                  {
                    v12 = 100;
                    v13 = 541;
                  }
                }
                else
                {
                  v12 = 114;
                  v13 = 536;
                }
              }
              else
              {
                v12 = 100;
                v13 = 529;
              }
            }
            else
            {
              v12 = 100;
              v13 = 520;
            }
          }
          else
          {
            v12 = 112;
            v13 = 515;
          }
        }
        else
        {
          v12 = 100;
          v13 = 510;
        }
      }
      else
      {
        v12 = 101;
        v13 = 505;
      }
    }
    else
    {
      v12 = 100;
      v13 = 500;
    }
LABEL_9:
    ERR_put_error(19, 0LL, v12, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", v13);
    goto LABEL_10;
  }
  ERR_put_error(19, 0LL, 100, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 483);
LABEL_13:
  result = 0LL;
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v51;
  return result;
}

//----- (00000000000A7D58) ----------------------------------------------------
void __fastcall sub_A7D58(__int64 a1, __int64 a2, unsigned int (__fastcall *a3)(char *, __int64))
{
  unsigned int (__fastcall *v3)(char *, __int64); // x19
  __int64 v4; // x20
  __int64 v5; // x21
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x22
  __int16 v9; // w4
  char v10; // [xsp+8h] [xbp-68h]
  unsigned __int8 *v11[2]; // [xsp+18h] [xbp-58h]
  unsigned __int8 *v12[2]; // [xsp+28h] [xbp-48h]
  __int64 v13; // [xsp+38h] [xbp-38h]
  void *v14; // [xsp+40h] [xbp-30h]
  __int64 v15; // [xsp+48h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v14 = 0LL;
  if ( (unsigned int)CBS_asn1_ber_to_der(a1, &v14, &v13) )
  {
    v6 = (__int64)v14;
    if ( v14 )
    {
      v7 = v13;
    }
    else
    {
      v8 = lh_num_items(v5);
      v7 = EVP_CIPHER_CTX_get_app_data(v5);
      v6 = v8;
    }
    CBS_init(v12, v6, v7);
    if ( (unsigned int)CBS_get_asn1(v12, (char *)v11, 48) && !EVP_CIPHER_CTX_get_app_data((__int64)v12) )
    {
      while ( EVP_CIPHER_CTX_get_app_data((__int64)v11) )
      {
        if ( !(unsigned int)CBS_get_asn1(v11, &v10, 48) )
        {
          v9 = 272;
          goto LABEL_9;
        }
        if ( !v3(&v10, v4) )
          break;
      }
    }
    else
    {
      v9 = 265;
LABEL_9:
      ERR_put_error(19, 0LL, 100, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", v9);
    }
    free(v14);
  }
  else
  {
    ERR_put_error(19, 0LL, 100, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 252);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v15;
}

//----- (00000000000A7EC0) ----------------------------------------------------
void __fastcall sub_A7EC0(unsigned __int8 **a1, __int64 a2)
{
  __int64 v2; // x19
  unsigned __int8 **v3; // x20
  __int16 v4; // w4
  __int64 v5; // x20
  __int64 v6; // x21
  char *v7; // x22
  __int64 v8; // x0
  __int64 v9; // [xsp+0h] [xbp-D0h]
  __int64 v10; // [xsp+10h] [xbp-C0h]
  void *v11; // [xsp+18h] [xbp-B8h]
  char v12; // [xsp+20h] [xbp-B0h]
  unsigned __int8 *v13[2]; // [xsp+30h] [xbp-A0h]
  __int64 v14[2]; // [xsp+40h] [xbp-90h]
  unsigned __int8 *v15[2]; // [xsp+50h] [xbp-80h]
  char v16; // [xsp+60h] [xbp-70h]
  void *v17; // [xsp+70h] [xbp-60h]
  unsigned __int8 *v18[2]; // [xsp+78h] [xbp-58h]
  unsigned __int8 *v19[2]; // [xsp+88h] [xbp-48h]
  __int64 v20[2]; // [xsp+98h] [xbp-38h]
  __int64 v21; // [xsp+A8h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = 0LL;
  if ( !(unsigned int)CBS_get_asn1(a1, (char *)v20, 6)
    || !(unsigned int)CBS_get_asn1(v3, (char *)v19, 160)
    || EVP_CIPHER_CTX_get_app_data((__int64)v3) )
  {
    v4 = 404;
LABEL_5:
    ERR_put_error(19, 0LL, 100, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", v4);
    goto LABEL_6;
  }
  if ( !CBS_mem_equal(v20, (__int64)&unk_DDB65, 9LL) )
  {
    if ( !CBS_mem_equal(v20, (__int64)&unk_DDB5C, 9LL) )
      goto LABEL_6;
    if ( (unsigned int)CBS_get_asn1(v19, (char *)v18, 4) )
    {
      sub_A7D58((__int64)v18, v2, (unsigned int (__fastcall *)(char *, __int64))sub_A85A8);
      goto LABEL_6;
    }
    v4 = 455;
    goto LABEL_5;
  }
  if ( !(unsigned int)CBS_get_asn1(v19, (char *)v18, 48)
    || !(unsigned int)CBS_get_asn1(v18, &v16, 2)
    || !(unsigned int)CBS_get_asn1(v18, (char *)v15, 48)
    || !(unsigned int)CBS_get_asn1(v15, (char *)v14, 6)
    || !(unsigned int)CBS_get_asn1(v15, (char *)v13, 48)
    || !(unsigned int)CBS_get_asn1_implicit_string(v15, &v12, &v17, 128, 4) )
  {
    v4 = 431;
    goto LABEL_5;
  }
  if ( !CBS_mem_equal(v14, (__int64)&unk_DDB5C, 9LL) )
  {
    v4 = 436;
    goto LABEL_5;
  }
  v5 = *(_QWORD *)(v2 + 16);
  v6 = *(_QWORD *)(v2 + 24);
  v7 = (char *)lh_num_items((__int64)&v12);
  v8 = EVP_CIPHER_CTX_get_app_data((__int64)&v12);
  if ( (unsigned int)sub_B35E0(&v11, &v10, v13, v5, v6, v7, v8) )
  {
    CBS_init(&v9, (__int64)v11, v10);
    sub_A7D58((__int64)&v9, v2, (unsigned int (__fastcall *)(char *, __int64))sub_A85A8);
    free(v11);
  }
LABEL_6:
  free(v17);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v21;
}
// A85A8: using guessed type __int64 __fastcall sub_A85A8();

//----- (00000000000A812C) ----------------------------------------------------
void **__fastcall d2i_PKCS12(void ***a1, const void **a2, size_t a3)
{
  void ***v3; // x20
  size_t v4; // x22
  const void **v5; // x21
  void **v6; // x19
  void *v7; // x0
  void **v8; // x21

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = (void **)malloc(0x10uLL);
  if ( v6 )
  {
    v7 = malloc(v4);
    *v6 = v7;
    if ( v7 )
    {
      if ( v4 )
        memcpy(v7, *v5, v4);
      v6[1] = (void *)v4;
      *v5 = (char *)*v5 + v4;
      if ( v3 )
      {
        v8 = *v3;
        if ( *v3 )
        {
          free(*v8);
          free(v8);
        }
        *v3 = v6;
      }
    }
    else
    {
      free(v6);
      v6 = 0LL;
    }
  }
  return v6;
}

//----- (00000000000A81CC) ----------------------------------------------------
void __fastcall PKCS12_free(void **a1)
{
  void **v1; // x19

  v1 = a1;
  if ( a1 )
  {
    free(*a1);
    free(v1);
  }
}

//----- (00000000000A8204) ----------------------------------------------------
void __fastcall d2i_PKCS12_bio(_QWORD *a1, void ***a2)
{
  void ***v2; // x20
  _QWORD *v3; // x21
  _QWORD *v4; // x0
  __int64 v5; // x19
  int v6; // w0
  size_t v7; // x22
  unsigned __int64 v8; // x8
  __int64 v9; // [xsp+0h] [xbp-30h]
  __int64 v10; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v3 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = BUF_MEM_new();
  v5 = (__int64)v4;
  if ( v4 )
  {
    if ( BUF_MEM_grow((__int64)v4, 0x2000uLL) )
    {
      v6 = BIO_read(v3, *(_QWORD *)(v5 + 8), *(_DWORD *)v5);
      if ( !(v6 & 0x80000000) )
      {
        v7 = 0LL;
        while ( v6 )
        {
          v8 = *(_QWORD *)v5;
          v7 += v6;
          if ( v7 >= *(_QWORD *)v5 )
          {
            if ( v8 > 0x40000 || !BUF_MEM_grow(v5, 2 * v8) )
              goto LABEL_13;
            v8 = *(_QWORD *)v5;
          }
          v6 = BIO_read(v3, *(_QWORD *)(v5 + 8) + v7, (signed int)v8 - (signed int)v7);
          if ( v6 & 0x80000000 )
          {
            if ( !v7 )
              goto LABEL_13;
            break;
          }
        }
        v9 = *(_QWORD *)(v5 + 8);
        d2i_PKCS12(v2, (const void **)&v9, v7);
      }
    }
LABEL_13:
    BUF_MEM_free(v5);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A8310) ----------------------------------------------------
__int64 __fastcall d2i_PKCS12_fp(__int64 a1, void ***a2)
{
  void ***v2; // x19
  _QWORD *v3; // x0
  __int64 v4; // x20
  __int64 v5; // x0
  __int64 v6; // x19

  v2 = a2;
  v3 = BIO_new_fp(a1, 0);
  v4 = (__int64)v3;
  if ( !v3 )
    return 0LL;
  d2i_PKCS12_bio(v3, v2);
  v6 = v5;
  BIO_free(v4);
  return v6;
}

//----- (00000000000A8360) ----------------------------------------------------
signed __int64 __fastcall PKCS12_parse(__int64 *a1, const char *a2, int **a3, __int64 *a4, signed __int64 **a5)
{
  signed __int64 **v5; // x19
  __int64 *v6; // x20
  int **v7; // x22
  const char *v8; // x23
  __int64 *v9; // x24
  signed __int64 *v10; // x21
  signed int v11; // w25
  signed __int64 result; // x0
  char v13; // [xsp+8h] [xbp-58h]
  __int64 v14; // [xsp+18h] [xbp-48h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a5 && (v10 = *a5) != 0LL )
  {
    v11 = 0;
  }
  else
  {
    v10 = sk_new_null();
    if ( !v10 )
    {
      ERR_put_error(19, 0LL, 65, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 731);
      result = 0LL;
      goto LABEL_17;
    }
    v11 = 1;
  }
  CBS_init(&v13, *v9, v9[1]);
  if ( (unsigned int)PKCS12_get_key_and_certs(v7, v10, (__int64)&v13, v8) )
  {
    *v6 = 0LL;
    if ( sk_num(v10) )
      *v6 = sk_shift(v10);
    if ( v5 )
      *v5 = v10;
    else
      sk_pop_free((unsigned __int64 *)v10, (void (*)(void))X509_free);
    result = 1LL;
  }
  else
  {
    if ( v11 )
      sk_free((void **)v10);
    result = 0LL;
  }
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v14;
  return result;
}

//----- (00000000000A8494) ----------------------------------------------------
signed __int64 __fastcall PKCS12_verify_mac(__int64 *a1, const char *a2, int a3)
{
  const char *v3; // x19
  __int64 *v4; // x20
  void *v5; // x8
  signed __int64 result; // x0
  __int64 v7; // [xsp+8h] [xbp-28h]
  int *v8; // [xsp+10h] [xbp-20h]
  __int64 v9; // [xsp+18h] [xbp-18h]

  v3 = a2;
  v4 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    if ( a3 )
      goto LABEL_11;
    goto LABEL_8;
  }
  if ( a3 == -1 )
    goto LABEL_8;
  if ( a2[a3] )
    goto LABEL_11;
  if ( !a3 || (v5 = memchr(a2, 0, a3), result = 0LL, !v5) )
  {
LABEL_8:
    v7 = 0LL;
    v8 = 0LL;
    if ( (unsigned int)PKCS12_parse(v4, v3, &v8, &v7, 0LL) )
    {
      EVP_PKEY_free(v8);
      X509_free(v7);
      result = 1LL;
      goto LABEL_12;
    }
    ERR_clear_error();
LABEL_11:
    result = 0LL;
  }
LABEL_12:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A8560) ----------------------------------------------------
signed __int64 __fastcall sub_A8560(int a1, __int64 a2)
{
  __int64 v2; // x8
  void **v3; // x8

  if ( a1 == 2 )
  {
    v2 = *(_QWORD *)(*(_QWORD *)a2 + 24LL);
    if ( v2 )
    {
      if ( *(_DWORD *)v2 == 4 )
      {
        v3 = *(void ***)(v2 + 8);
        if ( v3 )
          OPENSSL_cleanse(v3[1], *(signed int *)v3);
      }
    }
  }
  return 1LL;
}

//----- (00000000000A8834) ----------------------------------------------------
char *CRYPTO_BUFFER_POOL_new()
{
  char *v0; // x19
  _QWORD *v1; // x0

  v0 = (char *)malloc(0x40uLL);
  if ( v0 )
  {
    *((_QWORD *)v0 + 6) = 0LL;
    *((_QWORD *)v0 + 7) = 0LL;
    *((_QWORD *)v0 + 4) = 0LL;
    *((_QWORD *)v0 + 5) = 0LL;
    *((_QWORD *)v0 + 2) = 0LL;
    *((_QWORD *)v0 + 3) = 0LL;
    *(_QWORD *)v0 = 0LL;
    *((_QWORD *)v0 + 1) = 0LL;
    v1 = lh_new((__int64)sub_A88A4, (__int64)sub_A88B0);
    *(_QWORD *)v0 = v1;
    if ( v1 )
    {
      CRYPTO_MUTEX_init((pthread_rwlock_t *)(v0 + 8));
    }
    else
    {
      free(v0);
      v0 = 0LL;
    }
  }
  return v0;
}

//----- (00000000000A88A4) ----------------------------------------------------
signed __int64 __fastcall sub_A88A4(__int64 a1)
{
  return OPENSSL_hash32(*(unsigned __int8 **)(a1 + 8), *(_QWORD *)(a1 + 16));
}

//----- (00000000000A88B0) ----------------------------------------------------
__int64 __fastcall sub_A88B0(__int64 a1, __int64 a2)
{
  size_t v2; // x2

  v2 = *(_QWORD *)(a1 + 16);
  if ( v2 != *(_QWORD *)(a2 + 16) )
    return 1LL;
  if ( v2 )
    return memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v2);
  return 0LL;
}

//----- (00000000000A88E0) ----------------------------------------------------
void __fastcall CRYPTO_BUFFER_POOL_free(char *a1)
{
  char *v1; // x19

  v1 = a1;
  if ( a1 )
  {
    lh_free(*(_QWORD **)a1);
    CRYPTO_MUTEX_cleanup(v1 + 8);
    free(v1);
  }
}
// 4F8F4: using guessed type __int64 __fastcall CRYPTO_MUTEX_cleanup(_QWORD);

//----- (00000000000A8924) ----------------------------------------------------
void __fastcall CRYPTO_BUFFER_new(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  size_t v4; // x21
  const void *v5; // x22
  __int64 v6; // x0
  void *v7; // x19
  void *v8; // x0
  pthread_rwlock_t *v9; // x22
  __int64 v10; // x0
  int v11; // w20
  __int64 v12; // [xsp+8h] [xbp-58h]
  __int64 v13; // [xsp+10h] [xbp-50h]
  __int64 v14; // [xsp+18h] [xbp-48h]
  __int64 v15; // [xsp+28h] [xbp-38h]

  v3 = a3;
  v4 = a2;
  v5 = (const void *)a1;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 )
  {
    v13 = a1;
    v14 = a2;
    CRYPTO_STATIC_MUTEX_lock_read((pthread_rwlock_t *)(a3 + 8));
    v6 = lh_retrieve(*(_QWORD *)v3, (__int64)&v12);
    if ( v6 )
    {
      CRYPTO_refcount_inc((_DWORD *)(v6 + 24));
      CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v3 + 8));
      goto LABEL_14;
    }
    CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v3 + 8));
  }
  v7 = malloc(0x20uLL);
  if ( v7 )
  {
    *((_QWORD *)v7 + 2) = 0LL;
    *((_QWORD *)v7 + 3) = 0LL;
    *(_QWORD *)v7 = 0LL;
    *((_QWORD *)v7 + 1) = 0LL;
    v8 = BUF_memdup(v5, v4);
    *((_QWORD *)v7 + 1) = v8;
    if ( !v4 || v8 )
    {
      *((_QWORD *)v7 + 2) = v4;
      *((_DWORD *)v7 + 6) = 1;
      if ( v3 )
      {
        v9 = (pthread_rwlock_t *)(v3 + 8);
        *(_QWORD *)v7 = v3;
        CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(v3 + 8));
        v10 = lh_retrieve(*(_QWORD *)v3, (__int64)v7);
        if ( v10 )
        {
          CRYPTO_refcount_inc((_DWORD *)(v10 + 24));
          CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(v3 + 8));
        }
        else
        {
          v12 = 0LL;
          v11 = (unsigned __int64)lh_insert(*(_QWORD *)v3, &v12, (__int64)v7);
          CRYPTO_STATIC_MUTEX_unlock_write(v9);
          if ( v11 )
            goto LABEL_14;
        }
        free(*((void **)v7 + 1));
        free(v7);
      }
    }
    else
    {
      free(v7);
    }
  }
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A8A8C) ----------------------------------------------------
void __fastcall CRYPTO_BUFFER_new_from_CBS(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x21
  __int64 v5; // x0

  v2 = a2;
  v3 = a1;
  v4 = lh_num_items(a1);
  v5 = EVP_CIPHER_CTX_get_app_data(v3);
  CRYPTO_BUFFER_new(v4, v5, v2);
}

//----- (00000000000A8AD0) ----------------------------------------------------
void __fastcall CRYPTO_BUFFER_free(int *a1)
{
  int *v1; // x19
  __int64 v2; // x20

  v1 = a1;
  if ( a1 )
  {
    v2 = *(_QWORD *)a1;
    if ( *(_QWORD *)a1 )
    {
      CRYPTO_STATIC_MUTEX_lock_write((pthread_rwlock_t *)(v2 + 8));
      if ( (unsigned int)CRYPTO_refcount_dec_and_test_zero(v1 + 6) )
      {
        lh_delete(*(_QWORD *)v2, (__int64)v1);
        CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*(_QWORD *)v1 + 8LL));
LABEL_6:
        free(*((void **)v1 + 1));
        free(v1);
        return;
      }
      CRYPTO_STATIC_MUTEX_unlock_write((pthread_rwlock_t *)(*(_QWORD *)v1 + 8LL));
    }
    else if ( (unsigned int)CRYPTO_refcount_dec_and_test_zero(a1 + 6) )
    {
      goto LABEL_6;
    }
  }
}

//----- (00000000000A8B60) ----------------------------------------------------
_QWORD *__fastcall CRYPTO_BUFFER_init_CBS(__int64 a1, _QWORD *a2)
{
  return CBS_init(a2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
}

//----- (00000000000A8B70) ----------------------------------------------------
void __fastcall ASN1_digest(void (__fastcall *a1)(__int64, void **), __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  __int64 v5; // x22
  __int64 v6; // x20
  void (__fastcall *v7)(__int64, void **); // x23
  _DWORD *v8; // x19
  __int64 v9; // x21
  size_t v10; // x25
  void *v11; // x24
  void *v12; // [xsp+0h] [xbp-50h]
  __int64 v13; // [xsp+8h] [xbp-48h]

  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = a5;
  v9 = a4;
  v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10 = ((signed int (__fastcall *)(__int64, _QWORD))a1)(a3, 0LL);
  v11 = malloc(v10);
  if ( v11 )
  {
    v12 = v11;
    v7(v5, &v12);
    EVP_Digest((__int64)v11, v10, v9, v8, v6);
    free(v11);
  }
  else
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/a_digest.c", 72);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A8C60) ----------------------------------------------------
void ASN1_item_digest()
{
  __int64 v0; // ST08_8

  v0 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  ASN1_item_i2d();
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A8D10) ----------------------------------------------------
__int64 __fastcall ASN1_item_sign(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // x23
  __int64 v8; // x24
  __int64 v9; // x25
  __int64 v10; // x19
  __int64 v11; // x20
  __int64 v12; // x21
  __int64 v13; // x22
  __int64 result; // x0
  char v15; // [xsp+8h] [xbp-68h]
  __int64 v16; // [xsp+28h] [xbp-48h]

  v7 = a1;
  v8 = a7;
  v9 = a6;
  v10 = a5;
  v11 = a4;
  v12 = a3;
  v13 = a2;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(&v15);
  if ( (unsigned int)EVP_DigestSignInit((__int64)&v15, 0LL, v8, 0LL, v9) )
  {
    result = ASN1_item_sign_ctx(v7, v13, v12, v11, v10, &v15);
  }
  else
  {
    EVP_MD_CTX_cleanup(&v15);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000A8DD8) ----------------------------------------------------
__int64 __fastcall ASN1_item_sign_ctx(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, _QWORD *a6)
{
  _QWORD *v6; // x19
  __int64 v7; // ST18_8
  __int64 v8; // x24
  __int64 v9; // x25
  __int64 v10; // x22
  int v11; // w0
  int v12; // w0
  unsigned int v13; // w0
  size_t v14; // x20
  void *v15; // x22
  __int64 result; // x0

  v6 = a6;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a3;
  v9 = a2;
  v10 = X509_TRUST_get0_name(a6[2]);
  if ( v9 && (sub_A9EA4(v6, v9), !v11) || v8 && (sub_A9EA4(v6, v8), !v12) )
  {
    v15 = 0LL;
    v14 = 0LL;
  }
  else
  {
    ASN1_item_i2d();
    v13 = EVP_PKEY_size(v10);
    v14 = (signed int)v13;
    v15 = malloc(v13);
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/a_sign.c", 103);
  }
  EVP_MD_CTX_cleanup(v6);
  if ( v15 )
  {
    OPENSSL_cleanse(v15, v14);
    free(v15);
  }
  result = 0LL;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// B1E50: using guessed type __int64 __fastcall EVP_DigestVerifyUpdate(_QWORD);

//----- (00000000000A8FA0) ----------------------------------------------------
void __fastcall X509_NAME_print_ex(_QWORD *a1, unsigned __int64 **a2, signed int a3, __int64 a4)
{
  __int64 v4; // x19
  __int64 v5; // x20
  __int64 v6; // x21
  __int64 v7; // x22
  __int64 v8; // x23
  __int64 v9; // x24
  __int64 v10; // x25
  __int64 v11; // x26
  __int64 v12; // x27
  __int64 v13; // x28
  __int64 v14; // x29
  __int64 v15; // x30
  __int64 v16; // x8
  int v17; // w25
  unsigned __int64 **v18; // x24
  _QWORD *v19; // x22
  signed int v20; // w19
  signed int v21; // w20
  signed int v22; // w26
  signed int v23; // w21
  const char *v24; // x20
  const char *v25; // x27
  signed int v26; // w28
  const char *v27; // x8
  int v28; // w20
  signed int v29; // w27
  int v30; // w1
  unsigned __int64 *v31; // x0
  __int64 v32; // x24
  int v33; // w21
  unsigned int *v34; // x26
  signed int *v35; // x21
  unsigned int v36; // w0
  __int64 v37; // x4
  __int64 v38; // x5
  __int64 v39; // x6
  __int64 v40; // x7
  unsigned int v41; // w24
  const char *v42; // x0
  const char *v43; // x21
  signed int v44; // w25
  const char *v45; // x0
  signed int v46; // w26
  int v47; // w21
  int v48; // w25
  bool v49; // zf
  signed __int16 v50; // w8
  int v51; // w0
  int v52; // [xsp+Ch] [xbp-124h]
  __int64 v53; // [xsp+10h] [xbp-120h]
  unsigned int v54; // [xsp+1Ch] [xbp-114h]
  __int64 v55; // [xsp+20h] [xbp-110h]
  unsigned int v56; // [xsp+28h] [xbp-108h]
  unsigned int v57; // [xsp+2Ch] [xbp-104h]
  __int16 v58; // [xsp+30h] [xbp-100h]
  __int64 v59; // [xsp+38h] [xbp-F8h]
  __int64 v60; // [xsp+40h] [xbp-F0h]
  signed int *v61; // [xsp+48h] [xbp-E8h]
  __int64 v62; // [xsp+50h] [xbp-E0h]
  unsigned __int64 **v63; // [xsp+58h] [xbp-D8h]
  int v64; // [xsp+60h] [xbp-D0h]
  signed int v65; // [xsp+64h] [xbp-CCh]
  signed __int64 v66; // [xsp+68h] [xbp-C8h]
  char v67; // [xsp+78h] [xbp-B8h]
  __int64 v68; // [xsp+C8h] [xbp-68h]
  __int64 v69; // [xsp+D0h] [xbp-60h]
  __int64 v70; // [xsp+D8h] [xbp-58h]
  __int64 v71; // [xsp+E0h] [xbp-50h]
  __int64 v72; // [xsp+E8h] [xbp-48h]
  __int64 v73; // [xsp+F0h] [xbp-40h]
  __int64 v74; // [xsp+F8h] [xbp-38h]
  __int64 v75; // [xsp+100h] [xbp-30h]
  __int64 v76; // [xsp+108h] [xbp-28h]
  __int64 v77; // [xsp+110h] [xbp-20h]
  __int64 v78; // [xsp+118h] [xbp-18h]
  __int64 v79; // [xsp+120h] [xbp-10h]
  __int64 v80; // [xsp+128h] [xbp-8h]

  if ( !a4 )
  {
    X509_NAME_print(a1, a2);
    return;
  }
  v69 = v13;
  v70 = v12;
  v71 = v11;
  v72 = v10;
  v73 = v9;
  v74 = v8;
  v75 = v7;
  v76 = v6;
  v77 = v5;
  v78 = v4;
  v79 = v14;
  v80 = v15;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = a4;
  v18 = a2;
  v19 = a1;
  if ( a3 >= 0 )
    v20 = a3;
  else
    v20 = 0;
  v68 = v16;
  if ( v20 >= 1 )
  {
    v21 = 0;
    do
    {
      if ( !sub_A93D0(v19, (__int64)" ", 1u) )
        goto LABEL_57;
      ++v21;
    }
    while ( v21 < v20 );
  }
  v22 = 3;
  v23 = 1;
  v24 = " + ";
  v25 = "\n";
  v26 = v20;
  switch ( ((*(_QWORD *)&v17 & 0xF0000uLL) - 0x10000) >> 16 )
  {
    case 0uLL:
      v26 = 0;
      v23 = 1;
      v24 = "+";
      v25 = ",";
      v22 = 1;
      goto LABEL_14;
    case 1uLL:
      v26 = 0;
      v22 = 3;
      v23 = 2;
      v24 = " + ";
      v25 = ", ";
      goto LABEL_14;
    case 2uLL:
      v26 = 0;
      v22 = 3;
      v23 = 2;
      v24 = " + ";
      v25 = "; ";
      goto LABEL_14;
    case 3uLL:
LABEL_14:
      v27 = " = ";
      if ( !(*(_QWORD *)&v17 & 0x800000LL) )
        v27 = "=";
      v60 = (__int64)v27;
      v65 = (unsigned __int64)X509_NAME_entry_count(v18);
      if ( v65 < 1 )
        goto LABEL_57;
      v64 = v17 & 0x600000;
      v66 = *(_QWORD *)&v17 & 0x100000LL;
      v62 = v17 & 0x1000000;
      v63 = v18;
      v53 = (__int64)v25;
      v55 = (__int64)v24;
      v28 = 0;
      v58 = v17;
      v59 = v17 & 0x2000000;
      v29 = -1;
      v54 = v22;
      v52 = v23 + v26;
      v56 = v23;
      v57 = ((v17 & 0x800000u) >> 22) | 1;
      break;
    default:
      goto LABEL_57;
  }
  while ( 1 )
  {
    if ( v66 )
      v30 = v65 - 1 - v28;
    else
      v30 = v28;
    v31 = X509_NAME_get_entry(v18, v30);
    v32 = (__int64)v31;
    if ( v29 == -1 )
      goto LABEL_31;
    if ( v29 != *((_DWORD *)v31 + 4) )
      break;
    if ( !sub_A93D0(v19, v55, v54) )
      goto LABEL_57;
    v20 += v54;
LABEL_31:
    v29 = *(_DWORD *)(v32 + 16);
    v34 = (unsigned int *)sk_num((_QWORD *)v32);
    v35 = (signed int *)X509_policy_node_get0_parent(v32);
    v36 = (unsigned __int64)OBJ_obj2nid(v34);
    v41 = v36;
    if ( v64 != 6291456 )
    {
      v61 = v35;
      if ( v64 != 0x400000 && v36 )
      {
        if ( (v64 & 0x7FFFFF) == 0x200000 )
        {
          OBJ_nid2ln(v36);
          v43 = v45;
          v44 = 25;
        }
        else if ( v64 & 0x7FFFFF )
        {
          v44 = 0;
          v43 = (const char *)&unk_B8A4C;
        }
        else
        {
          OBJ_nid2sn(v36);
          v43 = v42;
          v44 = 10;
        }
      }
      else
      {
        v43 = &v67;
        OBJ_obj2txt(&v67, 80, v34, 1);
        v44 = 0;
      }
      v46 = strlen(v43);
      if ( !sub_A93D0(v19, (__int64)v43, v46) )
        goto LABEL_57;
      if ( v59 )
      {
        v47 = v44 - v46;
        if ( v44 > v46 )
        {
          if ( v47 >= 1 )
          {
            v48 = 0;
            while ( sub_A93D0(v19, (__int64)" ", 1u) )
            {
              if ( ++v48 >= v47 )
                goto LABEL_47;
            }
            goto LABEL_57;
          }
LABEL_47:
          v20 += v47;
        }
      }
      LOWORD(v17) = v58;
      if ( !sub_A93D0(v19, v60, v57) )
        goto LABEL_57;
      v35 = v61;
      v20 += v46 + v57;
    }
    if ( v41 )
      v49 = 1;
    else
      v49 = v62 == 0;
    v50 = 128;
    if ( v49 )
      v50 = 0;
    sub_A950C(
      (unsigned int (__fastcall *)(__int64, const char *, signed __int64))sub_A93D0,
      (__int64)v19,
      v50 | v17,
      v35,
      v37,
      v38,
      v39,
      v40);
    v18 = v63;
    if ( !(v51 & 0x80000000) )
    {
      v20 += v51;
      if ( v65 > ++v28 )
        continue;
    }
    goto LABEL_57;
  }
  if ( !sub_A93D0(v19, v53, v56) )
    goto LABEL_57;
  if ( !v26 )
  {
LABEL_30:
    v20 += v52;
    goto LABEL_31;
  }
  v33 = 0;
  while ( sub_A93D0(v19, (__int64)" ", 1u) )
  {
    if ( ++v33 >= v26 )
      goto LABEL_30;
  }
LABEL_57:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A93D0) ----------------------------------------------------
bool __fastcall sub_A93D0(_QWORD *a1, __int64 a2, unsigned int a3)
{
  _BOOL8 result; // x0

  if ( a1 )
    result = (unsigned int)BIO_write(a1, a2, a3) == a3;
  else
    result = 1LL;
  return result;
}

//----- (00000000000A9408) ----------------------------------------------------
signed __int64 __fastcall X509_NAME_print_ex_fp(__int64 a1, unsigned __int64 **a2, __int64 a3, __int64 a4)
{
  unsigned __int64 **v4; // x20
  _QWORD *v5; // x0
  __int64 v6; // x21
  unsigned int v7; // w19

  v4 = a2;
  if ( a4 )
    JUMPOUT(&loc_A8FE0);
  v5 = BIO_new_fp(a1, 0);
  v6 = (__int64)v5;
  if ( !v5 )
    return 0xFFFFFFFFLL;
  v7 = X509_NAME_print(v5, v4);
  BIO_free(v6);
  return v7;
}

//----- (00000000000A94A0) ----------------------------------------------------
bool __fastcall sub_A94A0(FILE *a1, const void *a2, int a3)
{
  _BOOL8 result; // x0

  if ( a1 )
    result = fwrite(a2, 1uLL, a3, a1) == a3;
  else
    result = 1LL;
  return result;
}

//----- (00000000000A94EC) ----------------------------------------------------
void __fastcall ASN1_STRING_print_ex(__int64 a1, signed int *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  sub_A950C((unsigned int (__fastcall *)(__int64, const char *, signed __int64))sub_A93D0, a1, a3, a2, a5, a6, a7, a8);
}

//----- (00000000000A950C) ----------------------------------------------------
void __fastcall sub_A950C(unsigned int (__fastcall *a1)(__int64, const char *, signed __int64), __int64 a2, __int16 a3, signed int *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  signed int *v8; // x21
  __int16 v9; // w22
  __int64 v10; // x19
  __int64 v11; // x23
  unsigned int (__fastcall *v12)(__int64, const char *, signed __int64); // x20
  const char *v13; // x25
  unsigned int v14; // w24
  signed int v15; // w8
  signed int v16; // w23
  int v17; // w24
  __int64 v18; // x22
  unsigned __int8 *v19; // x21
  __int64 v20; // x24
  unsigned int v21; // t1
  char v22; // w8
  __int64 v23; // x7
  int v24; // w8
  int v25; // w0
  __int64 v26; // x22
  unsigned __int8 *v27; // x21
  __int64 v28; // x24
  unsigned __int8 *v29; // x26
  unsigned int v30; // t1
  char v31; // w8
  char v32; // [xsp+4h] [xbp-6Ch]
  unsigned __int8 *v33; // [xsp+8h] [xbp-68h]
  int v34; // [xsp+10h] [xbp-60h]
  signed int *v35; // [xsp+18h] [xbp-58h]
  char v36; // [xsp+24h] [xbp-4Ch]
  char v37; // [xsp+25h] [xbp-4Bh]
  __int64 v38; // [xsp+28h] [xbp-48h]

  v8 = a4;
  v9 = a3;
  v10 = a2;
  v38 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v32 = 0;
  v11 = a4[1];
  v12 = a1;
  if ( a3 & 0x40 )
  {
    v13 = ASN1_tag2str(v11);
    v14 = strlen(v13);
    if ( !v12(v10, v13, v14) || !v12(v10, ":", 1LL) )
      goto LABEL_43;
  }
  if ( v9 & 0x80 )
    goto LABEL_16;
  if ( v9 & 0x20 )
  {
    v16 = 1;
    v17 = v9 & 0xF;
    if ( v9 & 0x10 )
    {
LABEL_25:
      if ( v16 )
        LOBYTE(v16) = v16 | 8;
      else
        LOBYTE(v16) = 1;
      goto LABEL_28;
    }
  }
  else
  {
    if ( (unsigned int)(v11 - 1) > 0x1D )
      v15 = -1;
    else
      v15 = byte_DDBB4[v11];
    if ( (v9 & 0x100) == 0LL && v15 == -1 )
      v16 = 1;
    else
      v16 = v15;
    if ( ((v9 & 0x100) != 0LL || v15 != -1) && v15 == -1 )
    {
LABEL_16:
      if ( v12(v10, "#", 1LL) )
      {
        if ( v9 & 0x200 )
        {
          v24 = v8[1];
          v35 = v8;
          v34 = v24;
          i2d_ASN1_TYPE();
          v26 = v25;
          v27 = (unsigned __int8 *)malloc(v25);
          if ( v27 )
          {
            v33 = v27;
            i2d_ASN1_TYPE();
            if ( v10 && (_DWORD)v26 )
            {
              v28 = v26;
              v29 = v27;
              do
              {
                v30 = *v29++;
                v31 = a0123456789abcd_0[v30 & 0xF];
                v36 = a0123456789abcd_0[(unsigned __int64)v30 >> 4];
                v37 = v31;
                if ( !v12(v10, &v36, 2LL) )
                  break;
                --v28;
              }
              while ( v28 );
            }
            free(v27);
          }
        }
        else
        {
          v18 = *v8;
          if ( v10 && (_DWORD)v18 )
          {
            v19 = (unsigned __int8 *)*((_QWORD *)v8 + 1);
            v20 = v18;
            do
            {
              v21 = *v19++;
              v22 = a0123456789abcd_0[v21 & 0xF];
              v36 = a0123456789abcd_0[(unsigned __int64)v21 >> 4];
              v37 = v22;
              if ( !v12(v10, &v36, 2LL) )
                break;
              --v20;
            }
            while ( v20 );
          }
        }
      }
      goto LABEL_43;
    }
    v17 = v9 & 0xF;
    if ( v9 & 0x10 )
      goto LABEL_25;
  }
LABEL_28:
  if ( !(sub_A9910(*((unsigned __int8 **)v8 + 1), *v8, v16, v17, &v32, (__int64)v12, 0LL, a8) & 0x80000000)
    && v10
    && (!v32 || v12(v10, "\"", 1LL))
    && !(sub_A9910(*((unsigned __int8 **)v8 + 1), *v8, v16, v17, 0LL, (__int64)v12, v10, v23) & 0x80000000)
    && v32 )
  {
    v12(v10, "\"", 1LL);
  }
LABEL_43:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v38;
}

//----- (00000000000A9838) ----------------------------------------------------
void __fastcall ASN1_STRING_print_ex_fp(__int64 a1, signed int *a2, __int16 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  sub_A950C((unsigned int (__fastcall *)(__int64, const char *, signed __int64))sub_A94A0, a1, a3, a2, a5, a6, a7, a8);
}

//----- (00000000000A9858) ----------------------------------------------------
void __fastcall ASN1_STRING_to_UTF8(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // x19
  __int64 v3; // x8
  int v4; // w0
  int *v5; // [xsp+8h] [xbp-38h]
  int v6; // [xsp+10h] [xbp-30h]
  __int64 v7; // [xsp+18h] [xbp-28h]
  __int64 v8; // [xsp+20h] [xbp-20h]
  __int64 v9; // [xsp+28h] [xbp-18h]

  v2 = a1;
  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = &v6;
  if ( a2 )
  {
    v3 = *(signed int *)(a2 + 4);
    if ( (unsigned int)v3 <= 0x1E && !((0x2A23EFFFuLL >> v3) & 1) )
    {
      v6 = 0;
      v7 = 0LL;
      v8 = 0LL;
      ASN1_mbstring_copy((__int64 *)&v5, *(const char **)(a2 + 8), *(_DWORD *)a2, byte_DDBB4[v3] | 0x1000, 0x2000LL);
      if ( !(v4 & 0x80000000) )
        *v2 = v7;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000A9910) ----------------------------------------------------
signed __int64 __fastcall sub_A9910(unsigned __int8 *a1, signed int a2, char a3, int a4, _BYTE *a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v8; // x19
  unsigned int (__fastcall *v9)(__int64, const char *, signed __int64); // x20
  _BYTE *v10; // x21
  int v11; // w25
  char v12; // w22
  unsigned __int8 *v13; // x9
  unsigned int v14; // w28
  unsigned __int8 *v15; // x24
  unsigned __int8 *v16; // x26
  signed __int64 result; // x0
  bool v18; // zf
  char v19; // w27
  int v20; // w0
  __int64 v21; // x8
  unsigned int v22; // t1
  __int64 v23; // x8
  __int64 v24; // x9
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x8
  __int64 v27; // x9
  unsigned __int8 *v28; // x23
  bool v29; // zf
  char v30; // w24
  int v31; // w0
  int v32; // w22
  signed int v33; // w0
  __int64 v34; // x25
  char v35; // w27
  __int64 v36; // x24
  int v37; // w0
  signed int v38; // [xsp+0h] [xbp-80h]
  char v39; // [xsp+4h] [xbp-7Ch]
  unsigned __int8 *v40; // [xsp+8h] [xbp-78h]
  int v41; // [xsp+10h] [xbp-70h]
  int v42; // [xsp+14h] [xbp-6Ch]
  unsigned __int64 v43; // [xsp+18h] [xbp-68h]
  char v44[8]; // [xsp+20h] [xbp-60h]
  __int64 v45; // [xsp+28h] [xbp-58h]

  v8 = a7;
  v9 = (unsigned int (__fastcall *)(__int64, const char *, signed __int64))a6;
  v10 = a5;
  v11 = a4;
  v12 = a3;
  v13 = a1;
  v45 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
  {
    result = 0LL;
    goto def_A99B0;
  }
  v14 = 0;
  v15 = &a1[a2];
  v42 = a4 & 1;
  v16 = a1;
  v38 = a2;
  v39 = a3;
  v41 = a3 & 8;
  v40 = a1;
  while ( 2 )
  {
    result = 0xFFFFFFFFLL;
    if ( v16 == v13 )
      v18 = v42 == 0;
    else
      v18 = 1;
    if ( v18 )
      v19 = 0;
    else
      v19 = 32;
    switch ( v12 & 7 )
    {
      case 0:
        v20 = UTF8_getc((char *)v16, v38, &v43);
        if ( v20 & 0x80000000 )
          goto LABEL_32;
        v16 += v20;
        goto LABEL_16;
      case 1:
        v22 = *v16++;
        v21 = v22;
        goto LABEL_15;
      case 2:
        v23 = *v16;
        v43 = v23 << 8;
        v24 = v16[1];
        v16 += 2;
        v43 = v24 & 0xFFFFFFFFFFFF00FFLL | ((unsigned __int64)(unsigned __int8)v23 << 8);
        goto LABEL_16;
      case 4:
        v25 = (unsigned __int64)*v16 << 24;
        v43 = v25;
        v26 = v25 & 0xFFFFFFFFFF00FFFFLL | ((unsigned __int64)v16[1] << 16);
        v43 = v26;
        v43 = v26 & 0xFFFFFFFFFFFF00FFLL | ((unsigned __int64)v16[2] << 8);
        v27 = v16[3];
        v16 += 4;
        v21 = v43 | v27;
LABEL_15:
        v43 = v21;
LABEL_16:
        v28 = v15;
        if ( v16 == v15 )
          v29 = v42 == 0;
        else
          v29 = 1;
        if ( v29 )
          v30 = v19;
        else
          v30 = 64;
        if ( !v41 )
        {
          v31 = sub_A9B2C(v43, v30 | (unsigned __int8)v11, v10, v9, v8, a6, a7, a8);
          if ( v31 & 0x80000000 )
            goto LABEL_32;
          v14 += v31;
          goto LABEL_30;
        }
        v32 = v11;
        v33 = UTF8_putc(v44, 6, v43);
        if ( v33 < 1 )
        {
LABEL_29:
          v11 = v32;
          v12 = v39;
LABEL_30:
          v13 = v40;
          v15 = v28;
          result = v14;
          if ( v16 == v28 )
            goto def_A99B0;
          continue;
        }
        v34 = 0LL;
        v35 = v30 | v32;
        v36 = v33;
        while ( 1 )
        {
          v37 = sub_A9B2C((unsigned __int8)v44[v34], v35, v10, v9, v8, a6, a7, a8);
          if ( v37 & 0x80000000 )
            break;
          v14 += v37;
          if ( ++v34 >= v36 )
            goto LABEL_29;
        }
LABEL_32:
        result = 0xFFFFFFFFLL;
def_A99B0:
        *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
        return result;
      default:
        goto def_A99B0;
    }
  }
}
// A9910: using guessed type char var_60[8];

//----- (00000000000A9B2C) ----------------------------------------------------
signed __int64 __fastcall sub_A9B2C(unsigned __int64 a1, char a2, _BYTE *a3, unsigned int (__fastcall *a4)(__int64, const char *, signed __int64), __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v8; // x20
  unsigned int (__fastcall *v9)(__int64, const char *, signed __int64); // x19
  signed __int64 result; // x0
  const char *v11; // x1
  signed __int64 v12; // x2
  unsigned int v13; // w21
  char v14; // w9
  __int64 v15; // [xsp+0h] [xbp-40h]
  __int64 v16; // [xsp+18h] [xbp-28h]

  v8 = a5;
  v9 = a4;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 >> 32 )
  {
    result = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  if ( a1 >= 0x10000 )
  {
    BIO_snprintf((__int64)&v15 + 4, 19LL, (__int64)"\\W%08lX", a1, a5, a6, a7, a8, v15);
    v11 = (char *)&v15 + 4;
    v12 = 10LL;
    v13 = 10;
    goto LABEL_7;
  }
  if ( a1 >= 0x100 )
  {
    BIO_snprintf((__int64)&v15 + 4, 19LL, (__int64)"\\U%04lX", a1, a5, a6, a7, a8, v15);
    v11 = (char *)&v15 + 4;
    v12 = 6LL;
    v13 = 6;
    goto LABEL_7;
  }
  LOBYTE(v15) = a1;
  if ( (a1 & 0x80) < 0x80 )
    v14 = byte_DDBD3[(unsigned __int8)a1] & a2;
  else
    v14 = a2 & 4;
  if ( !(v14 & 0x61) )
  {
    if ( v14 & 6 )
    {
      BIO_snprintf((__int64)&v15 + 4, 11LL, (__int64)"\\%02X", (unsigned __int8)a1, a5, a6, a7, a8, v15);
      v11 = (char *)&v15 + 4;
      v12 = 3LL;
      v13 = 3;
    }
    else
    {
      if ( !(a2 & 0xF) || (unsigned __int8)a1 != 92 )
        goto LABEL_26;
      v11 = "\\\\";
      v12 = 2LL;
      v13 = 2;
    }
LABEL_7:
    if ( v9(v8, v11, v12) )
      result = v13;
    else
      result = 1LL;
    goto LABEL_10;
  }
  if ( !(v14 & 8) )
  {
    if ( a4(a5, "\\", 1LL) )
    {
      if ( v9(v8, (const char *)&v15, 1LL) )
        result = 2LL;
      else
        result = 1LL;
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
    goto LABEL_10;
  }
  if ( a3 )
    *a3 = 1;
LABEL_26:
  if ( a4(a5, (const char *)&v15, 1LL) )
    result = 0LL;
  else
    result = 0xFFFFFFFFLL;
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v16;
  return result;
}

//----- (00000000000A9D04) ----------------------------------------------------
void __fastcall ASN1_item_verify(__int64 a1, unsigned int **a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x22
  unsigned int **v6; // x23
  int v7; // w2
  __int16 v8; // w4
  int v9; // w0
  char v10; // [xsp+8h] [xbp-58h]
  __int64 v11; // [xsp+28h] [xbp-38h]

  v5 = a5;
  v6 = a2;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a5 )
  {
    v7 = 67;
    v8 = 81;
    goto LABEL_8;
  }
  if ( *(_DWORD *)(a3 + 4) == 3 && *(_BYTE *)(a3 + 16) & 7 )
  {
    v7 = 109;
    v8 = 86;
LABEL_8:
    ERR_put_error(11, 0LL, v7, (__int64)"external/boringssl/src/crypto/x509/a_verify.c", v8);
    goto LABEL_10;
  }
  EVP_MD_CTX_init(&v10);
  sub_A9FF0((__int64)&v10, v6, v5);
  if ( v9 )
  {
    ASN1_item_i2d();
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/a_verify.c", 99);
  }
  EVP_MD_CTX_cleanup(&v10);
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// B1E50: using guessed type __int64 __fastcall EVP_DigestVerifyUpdate(_QWORD);

//----- (00000000000A9EA4) ----------------------------------------------------
void __fastcall sub_A9EA4(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x19
  __int64 v3; // x21
  unsigned int *v4; // x22
  __int64 v5; // x0
  __int64 v6; // x20
  int v7; // w2
  __int16 v8; // w4
  int v9; // w21
  int v10; // w0
  int v11; // w20
  __int64 v12; // x0
  unsigned int v13; // [xsp+4h] [xbp-2Ch]
  __int64 v14; // [xsp+8h] [xbp-28h]

  v2 = a2;
  v3 = (__int64)a1;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = (unsigned int *)sk_num(a1);
  v5 = X509_TRUST_get0_name(*(_QWORD *)(v3 + 16));
  v6 = v5;
  if ( !v4 || !v5 )
  {
    v7 = 108;
    v8 = 72;
LABEL_8:
    ERR_put_error(12, 0LL, v7, (__int64)"external/boringssl/src/crypto/x509/algorithm.c", v8);
    goto LABEL_14;
  }
  if ( (unsigned int)X509_TRUST_get_flags(v5) == 6 )
  {
    if ( !(unsigned int)EVP_PKEY_CTX_get_rsa_padding(*(__int64 **)(v3 + 16)) )
      goto LABEL_14;
    if ( v13 == 6 )
    {
      sub_AA200(v3, v2);
      goto LABEL_14;
    }
  }
  v9 = X509_TRUST_get_trust(v4);
  v10 = X509_TRUST_get_flags(v6);
  if ( !(unsigned int)OBJ_find_sigid_by_algs(&v13, v9, v10) )
  {
    v7 = 111;
    v8 = 92;
    goto LABEL_8;
  }
  if ( (unsigned int)X509_TRUST_get_flags(v6) == 6 )
    v11 = 5;
  else
    v11 = 1;
  OBJ_nid2obj(v13);
  X509_ALGOR_set0(v2, v12, v11, 0LL);
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v14;
}

//----- (00000000000A9FF0) ----------------------------------------------------
void __fastcall sub_A9FF0(__int64 a1, unsigned int **a2, __int64 a3)
{
  unsigned __int64 *v3; // x21
  __int64 v4; // x20
  __int64 v5; // x19
  signed int v6; // w22
  int v7; // w23
  int v8; // w2
  __int16 v9; // w4
  int v10; // [xsp+0h] [xbp-40h]
  int v11; // [xsp+4h] [xbp-3Ch]
  __int64 v12; // [xsp+8h] [xbp-38h]

  v3 = (unsigned __int64 *)a2;
  v4 = a1;
  v5 = a3;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = (unsigned __int64)OBJ_obj2nid(*a2);
  if ( !(unsigned int)OBJ_find_sigid_algs(v6, &v11, &v10) )
  {
    v8 = 184;
    v9 = 110;
LABEL_8:
    ERR_put_error(12, 0LL, v8, (__int64)"external/boringssl/src/crypto/x509/algorithm.c", v9);
    goto LABEL_9;
  }
  v7 = v10;
  if ( v7 != (unsigned int)X509_TRUST_get_flags(v5) )
  {
    v8 = 189;
    v9 = 116;
    goto LABEL_8;
  }
  if ( !v11 )
  {
    if ( v6 == 912 )
    {
      sub_AA47C(v4, v3);
      goto LABEL_9;
    }
    v8 = 184;
    v9 = 123;
    goto LABEL_8;
  }
  if ( !EVP_get_digestbynid(v11) )
  {
    v8 = 183;
    v9 = 132;
    goto LABEL_8;
  }
  EVP_DigestVerifyInit();
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v12;
}

//----- (00000000000AA138) ----------------------------------------------------
signed __int64 __fastcall i2d_PrivateKey(__int64 a1, void **a2)
{
  void **v2; // x19
  __int64 v3; // x20
  int v4; // w0

  v2 = a2;
  v3 = a1;
  v4 = X509_TRUST_get_flags(a1);
  switch ( v4 )
  {
    case 408:
      return i2d_ECPrivateKey(*(_QWORD **)(v3 + 8), v2);
    case 116:
      return i2d_DSAPrivateKey(*(_QWORD **)(v3 + 8), v2);
    case 6:
      return i2d_RSAPrivateKey(*(_QWORD *)(v3 + 8), v2);
  }
  ERR_put_error(12, 0LL, 187, (__int64)"external/boringssl/src/crypto/x509/i2d_pr.c", 80);
  return 0xFFFFFFFFLL;
}

//----- (00000000000AA1D0) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_RSA_PSS_PARAMS(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&RSA_PSS_PARAMS_it);
}

//----- (00000000000AA1DC) ----------------------------------------------------
void i2d_RSA_PSS_PARAMS()
{
  ASN1_item_i2d();
}

//----- (00000000000AA1E8) ----------------------------------------------------
__int64 RSA_PSS_PARAMS_new()
{
  return ASN1_item_new((unsigned __int8 *)&RSA_PSS_PARAMS_it);
}

//----- (00000000000AA1F4) ----------------------------------------------------
void __fastcall RSA_PSS_PARAMS_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&RSA_PSS_PARAMS_it);
}

//----- (00000000000AA200) ----------------------------------------------------
void __fastcall sub_AA200(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 v4; // x0
  __int64 v5; // x20
  int v6; // w21
  _QWORD *v7; // x20
  _DWORD *v8; // x0
  unsigned int *v9; // x21
  __int64 v10; // x0
  unsigned int *v11; // x22
  __int64 v12; // x21
  __int64 v13; // x0
  __int64 v14; // x22
  __int64 v15; // x0
  __int64 v16; // x0
  __int64 v17; // [xsp+0h] [xbp-50h]
  int v18; // [xsp+Ch] [xbp-44h]
  unsigned int *v19; // [xsp+10h] [xbp-40h]
  unsigned int *v20; // [xsp+18h] [xbp-38h]
  __int64 v21; // [xsp+20h] [xbp-30h]
  __int64 v22; // [xsp+28h] [xbp-28h]

  v2 = a1;
  v3 = a2;
  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)EVP_PKEY_CTX_get_signature_md(*(__int64 **)(a1 + 16))
    && (unsigned int)EVP_PKEY_CTX_get_rsa_mgf1_md(*(__int64 **)(v2 + 16))
    && (unsigned int)EVP_PKEY_CTX_get_rsa_pss_saltlen(*(__int64 **)(v2 + 16)) )
  {
    v4 = X509_TRUST_get0_name(*(_QWORD *)(v2 + 16));
    v5 = v4;
    if ( v18 == -2 )
    {
      v6 = EVP_PKEY_size(v4);
      v18 = v6 - 2 - (unsigned __int64)X509_TRUST_get_flags((__int64)v20);
      if ( !(((unsigned int)EVP_PKEY_bits(v5) + 7) & 7) )
        --v18;
    }
    else
    {
      if ( v18 != -1 )
        goto LABEL_7;
      v18 = X509_TRUST_get_flags((__int64)v20);
    }
    v17 = 0LL;
    v7 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&RSA_PSS_PARAMS_it);
    if ( !v7 )
      goto LABEL_30;
    if ( v18 != 20 )
    {
      v8 = ASN1_INTEGER_new();
      v7[2] = v8;
      if ( !v8 || !(unsigned int)ASN1_INTEGER_set((__int64)v8, v18) )
        goto LABEL_30;
    }
    v9 = v20;
    if ( (unsigned int)X509_TRUST_get_trust(v20) != 64 )
    {
      v10 = X509_ALGOR_new();
      *v7 = v10;
      if ( !v10 )
        goto LABEL_30;
      X509_ALGOR_set_md(v10, (__int64)v9);
    }
    v11 = v19;
    v21 = 0LL;
    v7[1] = 0LL;
    if ( (unsigned int)X509_TRUST_get_trust(v11) == 64 )
      goto LABEL_28;
    if ( (unsigned int)X509_TRUST_get_trust(v11) == 64 )
    {
      v12 = 0LL;
    }
    else
    {
      v13 = X509_ALGOR_new();
      v12 = v13;
      if ( !v13 )
        goto LABEL_27;
      X509_ALGOR_set_md(v13, (__int64)v11);
    }
    if ( ASN1_item_pack(v12, (__int64)&X509_ALGOR_it, &v21) )
    {
      v14 = X509_ALGOR_new();
      v7[1] = v14;
      if ( v14 )
      {
        OBJ_nid2obj(0x38Fu);
        X509_ALGOR_set0(v14, v15, 16, v21);
        v21 = 0LL;
      }
    }
LABEL_27:
    ASN1_STRING_free(v21);
    X509_ALGOR_free(v12);
    if ( v7[1] )
    {
LABEL_28:
      if ( ASN1_item_pack((__int64)v7, (__int64)&RSA_PSS_PARAMS_it, &v17) )
      {
        OBJ_nid2obj(0x390u);
        X509_ALGOR_set0(v3, v16, 16, v17);
        v17 = 0LL;
      }
    }
LABEL_30:
    ASN1_item_free((__int64)v7, (unsigned __int8 *)&RSA_PSS_PARAMS_it);
    ASN1_STRING_free(v17);
  }
LABEL_7:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v22;
}

//----- (00000000000AA47C) ----------------------------------------------------
void __fastcall sub_AA47C(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // x0
  unsigned __int64 *v3; // x19
  unsigned int **v4; // x8
  __int64 *v5; // x20
  int v6; // w0
  __int64 v7; // x23
  __int64 *v8; // x8
  __int64 v9; // x24
  __int16 v10; // w4
  signed __int64 v11; // x0
  signed __int64 v12; // x0
  int v13; // w0
  _BOOL4 v14; // w25
  __int64 *v15; // [xsp+8h] [xbp-58h]
  __int64 *v16; // [xsp+10h] [xbp-50h]
  __int64 v17; // [xsp+18h] [xbp-48h]

  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = sub_AA6C0(a2, (unsigned __int64 **)&v16);
  v3 = v2;
  if ( !v2 )
  {
    ERR_put_error(11, 0LL, 112, (__int64)"external/boringssl/src/crypto/x509/rsa_pss.c", 253);
    v5 = v16;
    goto LABEL_29;
  }
  v4 = (unsigned int **)v2[1];
  v5 = v16;
  if ( !v4 )
  {
    v7 = (__int64)EVP_sha1();
    v8 = (__int64 *)*v3;
    if ( !*v3 )
      goto LABEL_15;
    goto LABEL_13;
  }
  v6 = (unsigned __int64)OBJ_obj2nid(*v4);
  if ( v5 && v6 == 911 )
  {
    v7 = EVP_get_digestbyobj(*v5);
    if ( !v7 )
    {
      ERR_put_error(11, 0LL, 112, (__int64)"external/boringssl/src/crypto/x509/rsa_pss.c", 183);
      v8 = (__int64 *)*v3;
      if ( !*v3 )
        goto LABEL_15;
LABEL_13:
      v9 = EVP_get_digestbyobj(*v8);
      if ( !v9 )
      {
        v10 = 164;
LABEL_28:
        ERR_put_error(11, 0LL, 112, (__int64)"external/boringssl/src/crypto/x509/rsa_pss.c", v10);
        goto LABEL_29;
      }
      goto LABEL_16;
    }
  }
  else
  {
    ERR_put_error(11, 0LL, 112, (__int64)"external/boringssl/src/crypto/x509/rsa_pss.c", 178);
    v7 = 0LL;
  }
  v8 = (__int64 *)*v3;
  if ( *v3 )
    goto LABEL_13;
LABEL_15:
  v9 = (__int64)EVP_sha1();
LABEL_16:
  if ( v7 && v9 )
  {
    v11 = v3[2];
    if ( v11 && ASN1_INTEGER_get(v11) & 0x80000000 )
    {
      v10 = 270;
      goto LABEL_28;
    }
    v12 = v3[3];
    if ( v12 && ASN1_INTEGER_get(v12) != 1 )
    {
      v10 = 278;
      goto LABEL_28;
    }
    EVP_DigestVerifyInit();
    if ( v13 && (unsigned int)EVP_PKEY_CTX_set_rsa_padding(v15) && (unsigned int)EVP_PKEY_CTX_set_rsa_pss_saltlen(v15) )
      v14 = (unsigned __int64)EVP_PKEY_CTX_set_rsa_mgf1_md(v15) != 0;
  }
LABEL_29:
  ASN1_item_free((__int64)v3, (unsigned __int8 *)&RSA_PSS_PARAMS_it);
  X509_ALGOR_free((__int64)v5);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000AA6C0) ----------------------------------------------------
unsigned __int64 *__fastcall sub_AA6C0(unsigned __int64 *result, unsigned __int64 **a2)
{
  unsigned __int64 **v2; // x19
  unsigned __int64 v3; // x8
  signed int *v4; // x8
  unsigned __int64 *v5; // x20
  unsigned __int64 v6; // x21
  __int64 v7; // x8
  signed int *v8; // x8
  __int64 v9; // [xsp+8h] [xbp-38h]
  __int64 v10; // [xsp+10h] [xbp-30h]
  __int64 v11; // [xsp+18h] [xbp-28h]

  v2 = a2;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *a2 = 0LL;
  v3 = result[1];
  if ( v3 && *(_DWORD *)v3 == 16 )
  {
    v4 = *(signed int **)(v3 + 8);
    v9 = *((_QWORD *)v4 + 1);
    result = ASN1_item_d2i(0LL, (const void **)&v9, *v4, (unsigned __int8 *)&RSA_PSS_PARAMS_it);
    v5 = result;
    if ( result )
    {
      v6 = result[1];
      if ( v6
        && *(_QWORD *)(v6 + 8)
        && (unsigned int)OBJ_obj2nid(*(unsigned int **)v6) == 911
        && (v7 = *(_QWORD *)(v6 + 8), *(_DWORD *)v7 == 16) )
      {
        v8 = *(signed int **)(v7 + 8);
        v10 = *((_QWORD *)v8 + 1);
        result = d2i_X509_ALGOR(0LL, (const void **)&v10, *v8);
      }
      else
      {
        result = 0LL;
      }
      *v2 = result;
    }
  }
  else
  {
    v5 = 0LL;
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v11 )
    result = v5;
  return result;
}

//----- (00000000000AA7B8) ----------------------------------------------------
void __fastcall sub_AA7B8(_QWORD *a1, unsigned __int64 *a2, int a3)
{
  _QWORD *v3; // x20
  int v4; // w21
  unsigned __int64 *v5; // x19
  signed int v6; // w0
  _BOOL4 v7; // w20
  __int64 *v8; // x8
  signed int v9; // w0
  signed int v10; // w0
  __int64 v11; // x1
  __int64 v12; // x1
  __int64 *v13; // [xsp+0h] [xbp-30h]
  __int64 v14; // [xsp+8h] [xbp-28h]

  v3 = a1;
  v4 = a3;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v5 = sub_AA6C0(a2, (unsigned __int64 **)&v13);
  if ( !v5 )
  {
    v7 = (signed int)BIO_puts(v3, " (INVALID PSS PARAMETERS)\n") > 0;
    goto LABEL_19;
  }
  if ( (signed int)BIO_puts(v3, "\n") >= 1
    && (unsigned int)BIO_indent(v3, v4, 128)
    && (signed int)BIO_puts(v3, "Hash Algorithm: ") >= 1 )
  {
    if ( *v5 )
    {
      i2a_ASN1_OBJECT(v3, *(_QWORD *)*v5);
      if ( v6 < 1 )
        goto LABEL_19;
    }
    else if ( (signed int)BIO_puts(v3, "sha1 (default)") < 1 )
    {
      goto LABEL_19;
    }
    if ( (signed int)BIO_puts(v3, "\n") >= 1
      && (unsigned int)BIO_indent(v3, v4, 128)
      && (signed int)BIO_puts(v3, "Mask Algorithm: ") >= 1 )
    {
      v8 = (__int64 *)v5[1];
      if ( v8 )
      {
        i2a_ASN1_OBJECT(v3, *v8);
        if ( v9 < 1 || (signed int)BIO_puts(v3, " with ") < 1 )
          goto LABEL_19;
        if ( v13 )
        {
          i2a_ASN1_OBJECT(v3, *v13);
          if ( v10 < 1 )
            goto LABEL_19;
        }
        else if ( (signed int)BIO_puts(v3, "INVALID") < 1 )
        {
          goto LABEL_19;
        }
      }
      else if ( (signed int)BIO_puts(v3, "mgf1 with sha1 (default)") < 1 )
      {
        goto LABEL_19;
      }
      BIO_puts(v3, "\n");
      if ( (unsigned int)BIO_indent(v3, v4, 128) && (signed int)BIO_puts(v3, "Salt Length: 0x") >= 1 )
      {
        v11 = v5[2];
        if ( v11 )
        {
          if ( (signed int)i2a_ASN1_INTEGER((__int64)v3, v11) < 1 )
            goto LABEL_19;
        }
        else if ( (signed int)BIO_puts(v3, "14 (default)") < 1 )
        {
          goto LABEL_19;
        }
        BIO_puts(v3, "\n");
        if ( (unsigned int)BIO_indent(v3, v4, 128) && (signed int)BIO_puts(v3, "Trailer Field: 0x") >= 1 )
        {
          v12 = v5[3];
          if ( v12 )
          {
            if ( (signed int)i2a_ASN1_INTEGER((__int64)v3, v12) < 1 )
              goto LABEL_19;
          }
          else if ( (signed int)BIO_puts(v3, "BC (default)") < 1 )
          {
            goto LABEL_19;
          }
          BIO_puts(v3, "\n");
        }
      }
    }
  }
LABEL_19:
  ASN1_item_free((__int64)v5, (unsigned __int8 *)&RSA_PSS_PARAMS_it);
  X509_ALGOR_free((__int64)v13);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v14;
}

//----- (00000000000AAABC) ----------------------------------------------------
__int64 __fastcall X509_print_ex_fp(__int64 a1, signed __int64 **a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // w19
  __int64 v5; // x20
  signed __int64 **v6; // x21
  __int64 v7; // x23
  void *v8; // x0
  _QWORD *v9; // x0
  _QWORD *v10; // x22
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  unsigned int v19; // w0
  unsigned int v20; // w19
  __int64 result; // x0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = BIO_s_file();
  v9 = BIO_new((__int64)v8);
  v10 = v9;
  if ( v9 )
  {
    BIO_set_fp(v9, v7, 0);
    X509_print_ex(v10, v6, v5, v4, v11, v12, v13, v14, v15, v16, v17, v18);
    v20 = v19;
    BIO_free((__int64)v10);
    result = v20;
  }
  else
  {
    ERR_put_error(11, 0LL, 7, (__int64)"external/boringssl/src/crypto/x509/t_x509.c", 79);
    result = 0LL;
  }
  return result;
}

//----- (00000000000AAB5C) ----------------------------------------------------
void __fastcall X509_print_ex(_QWORD *a1, signed __int64 **a2, __int64 a3, unsigned int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v12; // x22
  signed __int64 **v13; // x24
  unsigned int v14; // w21
  _QWORD *v15; // x19
  signed __int64 *v16; // x27
  unsigned __int8 v17; // w20
  signed int v18; // w8
  signed int v19; // w23
  signed __int64 v20; // x0
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  signed int v29; // w0
  __int64 v30; // x0
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  signed int *v39; // x24
  signed int v40; // w8
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  signed int v49; // w0
  signed int v50; // w0
  __int64 v51; // x28
  __int64 v52; // x8
  __int64 v53; // x2
  signed __int64 v54; // x3
  signed int v55; // w0
  signed int v56; // w0
  signed int v57; // w0
  unsigned __int64 **v58; // x0
  int v59; // w0
  double v60; // d0
  double v61; // d1
  double v62; // d2
  double v63; // d3
  double v64; // d4
  double v65; // d5
  double v66; // d6
  double v67; // d7
  signed int *v68; // x1
  signed int v69; // w8
  double v70; // d0
  double v71; // d1
  double v72; // d2
  double v73; // d3
  double v74; // d4
  double v75; // d5
  double v76; // d6
  double v77; // d7
  signed int *v78; // x1
  signed int v79; // w8
  signed int v80; // w0
  unsigned __int64 **v81; // x0
  int v82; // w0
  double v83; // d0
  double v84; // d1
  double v85; // d2
  double v86; // d3
  double v87; // d4
  double v88; // d5
  double v89; // d6
  double v90; // d7
  signed int v91; // w0
  signed int v92; // w0
  __int64 v93; // x0
  double v94; // d0
  double v95; // d1
  double v96; // d2
  double v97; // d3
  double v98; // d4
  double v99; // d5
  double v100; // d6
  double v101; // d7
  int *v102; // x22
  double v103; // d0
  double v104; // d1
  double v105; // d2
  double v106; // d3
  double v107; // d4
  double v108; // d5
  double v109; // d6
  double v110; // d7
  signed int v111; // w0
  double v112; // d0
  double v113; // d1
  double v114; // d2
  double v115; // d3
  double v116; // d4
  double v117; // d5
  double v118; // d6
  double v119; // d7
  signed int v120; // w0
  signed int v121; // w0
  __int64 v122; // [xsp+8h] [xbp-58h]

  v12 = a3;
  v13 = a2;
  v14 = a4;
  v15 = a1;
  v16 = *a2;
  if ( (a3 & 0xF0000) == 0x40000 )
    v17 = 10;
  else
    v17 = 32;
  if ( (a3 & 0xF0000) == 0x40000 )
    v18 = 12;
  else
    v18 = 0;
  if ( a3 )
    v19 = v18;
  else
    v19 = 16;
  if ( a4 & 1
    || (signed int)BIO_write(a1, (__int64)"Certificate:\n", 0xDu) >= 1
    && (signed int)BIO_write(v15, (__int64)"    Data:\n", 0xAu) >= 1 )
  {
    if ( v14 & 2
      || (v20 = ASN1_INTEGER_get(**v13),
          BIO_printf(
            v15,
            (__int64)"%8sVersion: %lu (0x%lx)\n",
            v21,
            v22,
            v23,
            v24,
            v25,
            v26,
            v27,
            v28,
            &unk_B8A4C,
            v20 + 1,
            v20),
          v29 >= 1) )
    {
      v122 = (__int64)v13;
      if ( !(v14 & 4) )
      {
        if ( (signed int)BIO_write(v15, (__int64)"        Serial Number:", 0x16u) < 1 )
          return;
        v30 = X509_get_serialNumber((__int64)v13);
        v39 = (signed int *)v30;
        if ( *(_DWORD *)v30 >= 8 && (*(_DWORD *)v30 != 8 || **(char **)(v30 + 8) & 0x80000000) )
        {
          *(_DWORD *)(v30 + 4);
          BIO_printf(v15, (__int64)"\n%12s%s", v31, v32, v33, v34, v35, v36, v37, v38);
          if ( v50 < 1 )
            return;
          v51 = 0LL;
          while ( 1 )
          {
            v52 = *v39;
            if ( v51 >= v52 )
              break;
            v53 = *(unsigned __int8 *)(*((_QWORD *)v39 + 1) + v51++);
            if ( v51 == (unsigned int)v52 )
              v54 = 10LL;
            else
              v54 = 58LL;
            BIO_printf(v15, (__int64)"%02x%c", a5, a6, a7, a8, a9, a10, a11, a12, v53, v54);
            if ( v55 < 1 )
              return;
          }
        }
        else
        {
          ASN1_INTEGER_get(v30);
          v40 = v39[1];
          BIO_printf(v15, (__int64)" %s%lu (%s0x%lx)\n", v41, v42, v43, v44, v45, v46, v47, v48);
          if ( v49 < 1 )
            return;
        }
      }
      if ( v14 & 8 || (X509_signature_print(v15, (__int64 *)v16[2], 0LL), v56 >= 1) )
      {
        if ( v14 & 0x10
          || (BIO_printf(v15, (__int64)"        Issuer:%c", a5, a6, a7, a8, a9, a10, a11, a12, v17), v57 >= 1)
          && (v58 = (unsigned __int64 **)X509_get_issuer_name(v122),
              X509_NAME_print_ex(v15, v58, v19, v12),
              !(v59 & 0x80000000))
          && (signed int)BIO_write(v15, (__int64)"\n", 1u) >= 1 )
        {
          if ( v14 & 0x20 )
            goto LABEL_52;
          if ( (signed int)BIO_write(v15, (__int64)"        Validity\n", 0x11u) < 1
            || (signed int)BIO_write(v15, (__int64)"            Not Before: ", 0x18u) < 1 )
          {
            return;
          }
          v68 = **(signed int ***)(*(_QWORD *)v122 + 32LL);
          v69 = v68[1];
          if ( v69 == 24 )
          {
            if ( !ASN1_GENERALIZEDTIME_print(v15, v68, v60, v61, v62, v63, v64, v65, v66, v67) )
              return;
          }
          else
          {
            if ( v69 != 23 )
              goto LABEL_49;
            if ( !ASN1_UTCTIME_print(v15, v68, v60, v61, v62, v63, v64, v65, v66, v67) )
              return;
          }
          if ( (signed int)BIO_write(v15, (__int64)"\n            Not After : ", 0x19u) < 1 )
            return;
          v78 = *(signed int **)(*(_QWORD *)(*(_QWORD *)v122 + 32LL) + 8LL);
          v79 = v78[1];
          if ( v79 == 24 )
          {
            if ( !ASN1_GENERALIZEDTIME_print(v15, v78, v70, v71, v72, v73, v74, v75, v76, v77) )
              return;
LABEL_51:
            if ( (signed int)BIO_write(v15, (__int64)"\n", 1u) < 1 )
              return;
LABEL_52:
            if ( !(v14 & 0x40) )
            {
              BIO_printf(v15, (__int64)"        Subject:%c", a5, a6, a7, a8, a9, a10, a11, a12, v17);
              if ( v80 < 1 )
                return;
              v81 = (unsigned __int64 **)X509_get_subject_name(v122);
              X509_NAME_print_ex(v15, v81, v19, v12);
              if ( v82 & 0x80000000 || (signed int)BIO_write(v15, (__int64)"\n", 1u) < 1 )
                return;
            }
            if ( !(v14 & 0x80) )
            {
              if ( (signed int)BIO_write(v15, (__int64)"        Subject Public Key Info:\n", 0x21u) < 1 )
                return;
              BIO_printf(v15, (__int64)"%12sPublic Key Algorithm: ", v83, v84, v85, v86, v87, v88, v89, v90, &unk_B8A4C);
              if ( v91 < 1 )
                return;
              i2a_ASN1_OBJECT(v15, **(_QWORD **)v16[6]);
              if ( v92 < 1 || (signed int)BIO_puts(v15, "\n") < 1 )
                return;
              X509_get_pubkey(v122);
              v102 = (int *)v93;
              if ( v93 )
              {
                EVP_PKEY_print_public(v15, v93, 16);
                EVP_PKEY_free(v102);
                if ( v14 & 0x1000 )
                  goto LABEL_72;
                goto LABEL_66;
              }
              BIO_printf(
                v15,
                (__int64)"%12sUnable to load Public Key\n",
                v94,
                v95,
                v96,
                v97,
                v98,
                v99,
                v100,
                v101,
                &unk_B8A4C);
              ERR_print_errors((__int64)v15);
            }
            if ( v14 & 0x1000 )
            {
LABEL_72:
              if ( !(v14 & 0x100) )
                X509V3_extensions_print(v15, (__int64)"X509v3 extensions", (unsigned __int64 *)v16[9], v14, 8u);
              if ( v14 & 0x200
                || (X509_signature_print(v15, *(__int64 **)(v122 + 8), *(unsigned int **)(v122 + 16)), v121 >= 1) )
              {
                if ( !(v14 & 0x400) )
                  X509_CERT_AUX_print(v15, *(unsigned __int64 ***)(v122 + 168), 0, a5, a6, a7, a8, a9, a10, a11, a12);
              }
              return;
            }
LABEL_66:
            if ( v16[7] )
            {
              BIO_printf(v15, (__int64)"%8sIssuer Unique ID: ", a5, a6, a7, a8, a9, a10, a11, a12, &unk_B8A4C);
              if ( v111 < 1
                || !X509_signature_dump(v15, (unsigned int *)v16[7], 12, v103, v104, v105, v106, v107, v108, v109, v110) )
              {
                return;
              }
            }
            if ( v16[8] )
            {
              BIO_printf(v15, (__int64)"%8sSubject Unique ID: ", a5, a6, a7, a8, a9, a10, a11, a12, &unk_B8A4C);
              if ( v120 < 1
                || !X509_signature_dump(v15, (unsigned int *)v16[8], 12, v112, v113, v114, v115, v116, v117, v118, v119) )
              {
                return;
              }
            }
            goto LABEL_72;
          }
          if ( v79 == 23 )
          {
            if ( !ASN1_UTCTIME_print(v15, v78, v70, v71, v72, v73, v74, v75, v76, v77) )
              return;
            goto LABEL_51;
          }
LABEL_49:
          BIO_write(v15, (__int64)"Bad time value", 0xEu);
          return;
        }
      }
    }
  }
}

//----- (00000000000AB0F8) ----------------------------------------------------
__int64 __fastcall X509_print_fp(__int64 a1, signed __int64 **a2)
{
  return X509_print_ex_fp(a1, a2, 0LL, 0);
}

//----- (00000000000AB104) ----------------------------------------------------
void __fastcall X509_print(_QWORD *a1, signed __int64 **a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  X509_print_ex(a1, a2, 0LL, 0, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (00000000000AB110) ----------------------------------------------------
void __fastcall X509_signature_print(_QWORD *a1, __int64 *a2, unsigned int *a3)
{
  __int64 *v3; // x21
  unsigned int *v4; // x20
  _QWORD *v5; // x19
  signed int v6; // w0
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  int v15; // w0
  _BOOL8 v16; // x0

  v3 = a2;
  v4 = a3;
  v5 = a1;
  if ( (signed int)BIO_puts(a1, "    Signature Algorithm: ") >= 1 )
  {
    i2a_ASN1_OBJECT(v5, *v3);
    if ( v6 >= 1 )
    {
      if ( (unsigned int)OBJ_obj2nid((unsigned int *)*v3) != 912 || (sub_AA7B8(v5, (unsigned __int64 *)v3, 9), v15) )
      {
        if ( v4 )
          X509_signature_dump(v5, v4, 9, v7, v8, v9, v10, v11, v12, v13, v14);
        else
          v16 = (signed int)BIO_puts(v5, "\n") > 0;
      }
    }
  }
}

//----- (00000000000AB1CC) ----------------------------------------------------
bool __fastcall ASN1_TIME_print(_QWORD *a1, signed int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  signed int v10; // w8

  v10 = a2[1];
  if ( v10 == 24 )
    return ASN1_GENERALIZEDTIME_print(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  if ( v10 == 23 )
    return ASN1_UTCTIME_print(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  BIO_write(a1, (__int64)"Bad time value", 0xEu);
  return 0LL;
}

//----- (00000000000AB20C) ----------------------------------------------------
void __fastcall X509_ocspid_print(_QWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // x20
  _QWORD *v11; // x19
  signed int v12; // w0
  __int64 v13; // x0
  int v14; // w0
  __int64 v15; // x22
  void *v16; // x21
  __int64 v17; // x0
  void *v18; // x0
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  int v27; // w0
  __int64 v28; // x24
  signed int v29; // w0
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  signed int v38; // w0
  signed int *v39; // x8
  __int64 v40; // x20
  __int64 v41; // x21
  void *v42; // x0
  double v43; // d0
  double v44; // d1
  double v45; // d2
  double v46; // d3
  double v47; // d4
  double v48; // d5
  double v49; // d6
  double v50; // d7
  int v51; // w0
  __int64 v52; // x21
  signed int v53; // w0
  char v54[20]; // [xsp+14h] [xbp-4Ch]
  __int64 v55; // [xsp+28h] [xbp-38h]

  v10 = a2;
  v11 = a1;
  v55 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  BIO_printf(a1, (__int64)"        Subject OCSP hash: ", a3, a4, a5, a6, a7, a8, a9, a10);
  if ( v12 >= 1 )
  {
    v13 = *(_QWORD *)(*(_QWORD *)v10 + 40LL);
    i2d_X509_NAME();
    v15 = v14;
    v16 = malloc(v14);
    if ( v16 )
    {
      v17 = *(_QWORD *)(*(_QWORD *)v10 + 40LL);
      i2d_X509_NAME();
      v18 = EVP_sha1();
      EVP_Digest((__int64)v16, v15, (__int64)v54, 0LL, (__int64)v18);
      if ( v27 )
      {
        v28 = 0LL;
        while ( 1 )
        {
          BIO_printf(v11, (__int64)"%02X", v19, v20, v21, v22, v23, v24, v25, v26, (unsigned __int8)v54[v28]);
          if ( v29 < 1 )
            break;
          if ( ++v28 > 19 )
          {
            free(v16);
            BIO_printf(v11, (__int64)"\n        Public key OCSP hash: ", v30, v31, v32, v33, v34, v35, v36, v37);
            if ( v38 >= 1 )
            {
              v39 = *(signed int **)(*(_QWORD *)(*(_QWORD *)v10 + 48LL) + 8LL);
              v40 = *((_QWORD *)v39 + 1);
              v41 = *v39;
              v42 = EVP_sha1();
              EVP_Digest(v40, v41, (__int64)v54, 0LL, (__int64)v42);
              if ( v51 )
              {
                v52 = 0LL;
                while ( 1 )
                {
                  BIO_printf(v11, (__int64)"%02X", v43, v44, v45, v46, v47, v48, v49, v50, (unsigned __int8)v54[v52]);
                  if ( v53 < 1 )
                    break;
                  if ( ++v52 > 19 )
                  {
                    BIO_printf(v11, (__int64)"\n", v43, v44, v45, v46, v47, v48, v49, v50);
                    goto LABEL_14;
                  }
                }
              }
            }
            goto LABEL_14;
          }
        }
      }
      free(v16);
    }
  }
LABEL_14:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}
// AB20C: using guessed type char var_4C[20];

//----- (00000000000AB3BC) ----------------------------------------------------
signed __int64 __fastcall ASN1_STRING_print(_QWORD *a1, __int64 a2)
{
  signed int *v2; // x20
  _QWORD *v3; // x19
  signed int v4; // w9
  __int64 v5; // x22
  __int64 v6; // x21
  signed int v7; // w2
  unsigned int v8; // w8
  char v9; // w10
  signed __int64 result; // x0
  char v11[80]; // [xsp+8h] [xbp-88h]
  __int64 v12; // [xsp+58h] [xbp-38h]

  v2 = (signed int *)a2;
  v3 = a1;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
    goto LABEL_21;
  v4 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 < 1 )
    goto LABEL_25;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = 0LL;
  v7 = 0;
  do
  {
    v8 = *(unsigned __int8 *)(v5 + v6);
    if ( v8 <= 0x7E )
    {
      if ( v8 <= 0x1F )
      {
        if ( v8 == 10 )
          v9 = 10;
        else
          v9 = 46;
        if ( v8 == 13 )
          LOBYTE(v8) = 13;
        else
          LOBYTE(v8) = v9;
      }
    }
    else
    {
      LOBYTE(v8) = 46;
    }
    v11[v7] = v8;
    if ( v7 < 79 )
    {
      ++v7;
    }
    else
    {
      if ( (signed int)BIO_write(v3, (__int64)v11, v7 + 1) < 1 )
        goto LABEL_21;
      v4 = *v2;
      v7 = 0;
    }
    ++v6;
  }
  while ( (signed int)v6 < v4 );
  if ( v7 < 1 || (signed int)BIO_write(v3, (__int64)v11, v7) >= 1 )
LABEL_25:
    result = 1LL;
  else
LABEL_21:
    result = 0LL;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// AB3BC: using guessed type char var_88[80];

//----- (00000000000AB4D4) ----------------------------------------------------
bool __fastcall ASN1_UTCTIME_print(_QWORD *a1, int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int v10; // w13
  unsigned __int8 *v11; // x14
  int v12; // w2
  int v13; // w3
  int v14; // w8
  int v15; // w11
  int v16; // w12
  int v17; // w15
  int v18; // w16
  int v19; // w17
  int v20; // w1
  _BYTE *v21; // x18
  int v22; // w10
  int v23; // w2
  int v24; // w3
  int v25; // w6
  _BOOL8 result; // x0
  int v27; // w0

  v10 = *a2;
  if ( *a2 < 2 )
    goto LABEL_36;
  v11 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  if ( (unsigned int)*v11 - 48 > 9 )
    goto LABEL_36;
  if ( (unsigned int)v11[1] - 48 > 9 )
    goto LABEL_36;
  if ( *a2 - 2 < 2 )
    goto LABEL_36;
  v12 = v11[2];
  if ( (unsigned int)(v12 - 48) > 9 )
    goto LABEL_36;
  v13 = v11[3];
  if ( (unsigned int)(v13 - 48) > 9 )
    goto LABEL_36;
  if ( v10 - 4 < 2 )
    goto LABEL_36;
  v14 = v11[4];
  if ( (unsigned int)(v14 - 48) > 9 )
    goto LABEL_36;
  v15 = v11[5];
  if ( (unsigned int)(v15 - 48) > 9 )
    goto LABEL_36;
  if ( v10 - 6 < 2 )
    goto LABEL_36;
  v16 = v11[6];
  if ( (unsigned int)(v16 - 48) > 9 )
    goto LABEL_36;
  v17 = v11[7];
  if ( (unsigned int)(v17 - 48) > 9 )
    goto LABEL_36;
  if ( v10 - 8 < 2 )
    goto LABEL_36;
  v18 = v11[8];
  if ( (unsigned int)(v18 - 48) > 9 )
    goto LABEL_36;
  v19 = v11[9];
  if ( (unsigned int)(v19 - 48) > 9 )
    goto LABEL_36;
  v20 = v10 - 10;
  v21 = v11 + 10;
  v22 = v13 + 10 * v12 - 528;
  if ( v10 - 10 < 2
    || (v23 = (unsigned __int8)*v21, (unsigned int)(v23 - 48) > 9)
    || (v24 = v11[11], (unsigned int)(v24 - 48) > 9) )
  {
    v25 = 0;
  }
  else
  {
    v20 = v10 - 12;
    v25 = v24 + 10 * v23 - 528;
    v21 = v11 + 12;
  }
  if ( v22 <= 12
    && v22
    && v15 + 10 * v14 - 528 <= 31
    && v15 + 10 * v14 != 528
    && v17 + 10 * v16 - 528 <= 23
    && v19 + 10 * v18 - 528 <= 59
    && v25 <= 60
    && (!v20 || v20 == 1 && *v21 == 90) )
  {
    BIO_printf(a1, (__int64)"%s %2d %02d:%02d:%02d %d%s", a3, a4, a5, a6, a7, a8, a9, a10, off_103E90[v22 - 1]);
    result = v27 > 0;
  }
  else
  {
LABEL_36:
    BIO_write(a1, (__int64)"Bad time value", 0xEu);
    result = 0LL;
  }
  return result;
}
// 103E90: using guessed type char *off_103E90[12];

//----- (00000000000AB700) ----------------------------------------------------
bool __fastcall ASN1_GENERALIZEDTIME_print(_QWORD *a1, signed int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  signed __int64 v10; // x8
  unsigned __int8 *v11; // x9
  int v12; // w11
  int v13; // w13
  int v14; // w14
  int v15; // w15
  int v16; // w10
  int v17; // w18
  int v18; // w12
  int v19; // w16
  int v20; // w17
  int v21; // w1
  int v22; // w2
  int v23; // w3
  unsigned int v24; // w10
  int v26; // w16
  int v27; // w12
  int v28; // w17
  int v29; // w11
  int v30; // w13
  int v31; // w14
  __int64 v32; // x6
  signed __int64 v33; // x13
  signed __int64 v34; // x14
  signed __int64 v35; // x7
  const char *v36; // x8
  int v37; // w0
  __int64 v38; // [xsp+8h] [xbp-28h]

  v10 = *a2;
  if ( (signed int)v10 < 12 )
    goto LABEL_35;
  v11 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  v12 = *v11;
  if ( (unsigned int)(v12 - 48) > 9 )
    goto LABEL_35;
  v13 = v11[1];
  if ( (unsigned int)(v13 - 48) > 9 )
    goto LABEL_35;
  v14 = v11[2];
  if ( (unsigned int)(v14 - 48) > 9 )
    goto LABEL_35;
  v15 = v11[3];
  if ( (unsigned int)(v15 - 48) > 9 )
    goto LABEL_35;
  v16 = v11[4];
  if ( (unsigned int)(v16 - 48) > 9 )
    goto LABEL_35;
  v17 = v11[5];
  if ( (unsigned int)(v17 - 48) > 9
    || (v18 = v11[6], (unsigned int)(v18 - 48) > 9)
    || (v19 = v11[7], (unsigned int)(v19 - 48) > 9)
    || (v20 = v11[8], (unsigned int)(v20 - 48) > 9)
    || (v21 = v11[9], (unsigned int)(v21 - 48) > 9)
    || (v22 = v11[10], (unsigned int)(v22 - 48) > 9)
    || (v23 = v11[11], (unsigned int)(v23 - 48) > 9)
    || (v24 = v17 + 10 * v16 - 529, v24 > 0xB) )
  {
LABEL_35:
    BIO_write(a1, (__int64)"Bad time value", 0xEu);
    return 0LL;
  }
  v26 = v19 + 10 * v18;
  v27 = v11[v10 - 1];
  v28 = v21 + 10 * v20;
  v29 = 100 * v13 + 1000 * v12 + 10 * v14 + v15 - 53328;
  if ( (signed int)v10 < 14
    || (v30 = v11[12], (unsigned int)(v30 - 48) > 9)
    || (v31 = v11[13], (unsigned int)(v31 - 48) > 9) )
  {
    v32 = 0LL;
  }
  else
  {
    v32 = (unsigned int)(v31 + 10 * v30 - 528);
    if ( (signed int)v10 >= 15 )
    {
      v33 = (signed __int64)(v11 + 14);
      if ( v11[14] == 46 )
      {
        if ( (signed int)v10 < 16 )
        {
          v35 = 1LL;
        }
        else
        {
          v34 = 15LL;
          do
          {
            if ( (unsigned int)v11[v34] - 48 > 9 )
              break;
            ++v34;
          }
          while ( v34 < v10 );
          v35 = (unsigned int)(v34 - 14);
        }
        goto LABEL_29;
      }
    }
  }
  v33 = 0LL;
  v35 = 0LL;
LABEL_29:
  v36 = (const char *)&unk_B8A4C;
  if ( v27 == 90 )
    v36 = " GMT";
  LODWORD(v38) = v29;
  BIO_printf(
    a1,
    (__int64)"%s %2d %02d:%02d:%02d%.*s %d%s",
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    off_103E90[v24],
    (unsigned int)(v26 - 528),
    (unsigned int)(v28 - 528),
    (unsigned int)(v23 + 10 * v22 - 528),
    v32,
    v35,
    v33,
    v38,
    v36);
  return v37 > 0;
}
// 103E90: using guessed type char *off_103E90[12];

//----- (00000000000AB930) ----------------------------------------------------
__int64 __fastcall X509_NAME_print(_QWORD *a1, unsigned __int64 **a2)
{
  _QWORD *v2; // x20
  unsigned __int8 *v3; // x0
  unsigned __int8 *v4; // x19
  __int64 v5; // x1
  unsigned __int8 *i; // x23
  int v7; // w8
  unsigned __int8 *v8; // x24
  int v9; // w8
  unsigned int v10; // w20

  v2 = a1;
  X509_NAME_oneline(a2, 0LL, 0);
  v4 = v3;
  if ( !v3 )
    return 0;
  if ( !*v3 )
  {
    free(v3);
    return 1;
  }
  v5 = (__int64)(v3 + 1);
  for ( i = v3 + 2; ; ++i )
  {
    v8 = i - 1;
    v7 = *(i - 1);
    if ( *(i - 1) )
    {
      if ( v7 != 47 )
        goto LABEL_13;
      if ( (unsigned int)*i - 65 > 0x19 )
        continue;
      v9 = i[1];
      if ( v9 != 61 && ((unsigned int)(v9 - 65) > 0x19 || i[2] != 61) )
        continue;
    }
    if ( (unsigned int)BIO_write(v2, v5, (signed int)v8 - (signed int)v5) != (_DWORD)v8 - (_DWORD)v5 )
      break;
    if ( !*v8 )
    {
LABEL_20:
      v10 = 1;
      goto LABEL_22;
    }
    if ( (unsigned int)BIO_write(v2, (__int64)", ", 2u) != 2 )
      break;
    v7 = *v8;
    v5 = (__int64)i;
LABEL_13:
    if ( !v7 )
      goto LABEL_20;
  }
  ERR_put_error(11, 0LL, 7, (__int64)"external/boringssl/src/crypto/x509/t_x509.c", 542);
  v10 = 0;
LABEL_22:
  free(v4);
  return v10;
}

//----- (00000000000ABA74) ----------------------------------------------------
void __fastcall X509_CERT_AUX_print(_QWORD *a1, unsigned __int64 **a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned int v11; // w21
  unsigned __int64 **v12; // x20
  _QWORD *v13; // x19
  unsigned __int64 v14; // x22
  char v15; // w8
  unsigned __int64 *v16; // x0
  _QWORD *v17; // x0
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  unsigned __int64 v26; // x22
  char v27; // w8
  unsigned __int64 *v28; // x0
  _QWORD *v29; // x0
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  unsigned __int64 *v38; // x8
  double v39; // d0
  double v40; // d1
  double v41; // d2
  double v42; // d3
  double v43; // d4
  double v44; // d5
  double v45; // d6
  double v46; // d7
  unsigned __int64 *v47; // x8
  __int64 v48; // x23
  unsigned __int64 v49; // x8
  const char *v50; // x2
  char v51; // [xsp+8h] [xbp-88h]
  __int64 v52; // [xsp+58h] [xbp-38h]

  v11 = a3;
  v12 = a2;
  v13 = a1;
  v52 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a2 )
    goto LABEL_28;
  if ( *a2 )
  {
    BIO_printf(
      a1,
      (__int64)"%*sTrusted Uses:\n%*s",
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11,
      a3,
      &unk_B8A4C,
      a3 + 2,
      &unk_B8A4C);
    if ( sk_num(*v12) )
    {
      v14 = 0LL;
      v15 = 0;
      do
      {
        if ( v15 & 1 )
          BIO_puts(v13, ", ");
        v16 = sk_value(*v12, v14);
        OBJ_obj2txt(&v51, 80, (unsigned int *)v16, 0);
        BIO_puts(v13, &v51);
        ++v14;
        v17 = sk_num(*v12);
        v15 = 1;
      }
      while ( v14 < (unsigned __int64)v17 );
    }
    BIO_puts(v13, "\n");
    if ( !v12[1] )
    {
LABEL_18:
      BIO_printf(v13, (__int64)"%*sNo Rejected Uses.\n", v18, v19, v20, v21, v22, v23, v24, v25, v11, &unk_B8A4C);
      v38 = v12[2];
      if ( !v38 )
        goto LABEL_20;
      goto LABEL_19;
    }
  }
  else
  {
    BIO_printf(a1, (__int64)"%*sNo Trusted Uses.\n", a4, a5, a6, a7, a8, a9, a10, a11, a3, &unk_B8A4C);
    if ( !v12[1] )
      goto LABEL_18;
  }
  BIO_printf(
    v13,
    (__int64)"%*sRejected Uses:\n%*s",
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    v11,
    &unk_B8A4C,
    v11 + 2,
    &unk_B8A4C);
  if ( sk_num(v12[1]) )
  {
    v26 = 0LL;
    v27 = 0;
    do
    {
      if ( v27 & 1 )
        BIO_puts(v13, ", ");
      v28 = sk_value(v12[1], v26);
      OBJ_obj2txt(&v51, 80, (unsigned int *)v28, 0);
      BIO_puts(v13, &v51);
      ++v26;
      v29 = sk_num(v12[1]);
      v27 = 1;
    }
    while ( v26 < (unsigned __int64)v29 );
  }
  BIO_puts(v13, "\n");
  v38 = v12[2];
  if ( !v38 )
    goto LABEL_20;
LABEL_19:
  BIO_printf(v13, (__int64)"%*sAlias: %s\n", v30, v31, v32, v33, v34, v35, v36, v37, v11, &unk_B8A4C, v38[1]);
LABEL_20:
  if ( v12[3] )
  {
    BIO_printf(v13, (__int64)"%*sKey Id: ", v30, v31, v32, v33, v34, v35, v36, v37, v11, &unk_B8A4C);
    v47 = v12[3];
    if ( *(_DWORD *)v47 >= 1 )
    {
      v48 = 0LL;
      do
      {
        v49 = v47[1];
        if ( v48 )
          v50 = ":";
        else
          v50 = (const char *)&unk_B8A4C;
        BIO_printf(v13, (__int64)"%s%02X", v39, v40, v41, v42, v43, v44, v45, v46, v50, *(unsigned __int8 *)(v49 + v48));
        v47 = v12[3];
        ++v48;
      }
      while ( (signed int)v48 < *(_DWORD *)v47 );
    }
    BIO_write(v13, (__int64)"\n", 1u);
  }
LABEL_28:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000ABD3C) ----------------------------------------------------
signed __int64 __fastcall PKCS8_pkey_set0(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, int a7)
{
  int v7; // w23
  __int64 v8; // x24
  __int64 v9; // x19
  int v10; // w20
  __int64 v11; // x21
  __int64 v12; // x22
  signed __int64 result; // x0
  _DWORD *v14; // x0
  _QWORD *v15; // x25
  int v16; // w1

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a2;
  v12 = a1;
  if ( a3 & 0x80000000 || (result = ASN1_INTEGER_set(*(_QWORD *)(a1 + 8), a3), (_DWORD)result) )
  {
    if ( v8 )
    {
      v14 = ASN1_OCTET_STRING_new();
      if ( !v14 )
        return 0LL;
      *((_QWORD *)v14 + 1) = v8;
      v15 = v14 + 2;
      *v14 = v7;
      if ( *(_DWORD *)v12 == 1 )
        v16 = 16;
      else
        v16 = 4;
      ASN1_TYPE_set(*(_QWORD *)(v12 + 24), v16, (__int64)v14);
    }
    else
    {
      v15 = 0LL;
    }
    if ( (unsigned int)X509_ALGOR_set0(*(_QWORD *)(v12 + 16), v11, v10, v9) )
    {
      result = 1LL;
    }
    else
    {
      result = 0LL;
      if ( v15 )
        *v15 = 0LL;
    }
  }
  return result;
}

//----- (00000000000ABE10) ----------------------------------------------------
signed __int64 __fastcall PKCS8_pkey_get0(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, __int64 a5)
{
  __int64 v5; // x8

  if ( a1 )
    *a1 = **(_QWORD **)(a5 + 16);
  v5 = *(_QWORD *)(a5 + 24);
  if ( *(_DWORD *)v5 == 16 )
  {
    *(_DWORD *)a5 = 1;
    if ( !a2 )
      goto LABEL_9;
LABEL_8:
    *a2 = *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8LL);
    *a3 = **(_DWORD **)(*(_QWORD *)(a5 + 24) + 8LL);
    goto LABEL_9;
  }
  if ( *(_DWORD *)v5 != 4 )
    return 0LL;
  *(_DWORD *)a5 = 0;
  if ( a2 )
    goto LABEL_8;
LABEL_9:
  if ( a4 )
    *a4 = *(_QWORD *)(a5 + 16);
  return 1LL;
}

//----- (00000000000ABE88) ----------------------------------------------------
bool __fastcall X509_signature_dump(_QWORD *a1, unsigned int *a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // x8
  __int64 v12; // x23
  int v13; // w20
  _QWORD *v14; // x19
  __int64 v15; // x26
  __int64 v16; // x21
  signed __int64 v17; // x24
  void *v18; // x3
  signed int v19; // w0

  v11 = *a2;
  v12 = *((_QWORD *)a2 + 1);
  v13 = a3;
  v14 = a1;
  v15 = 0LL;
  v16 = (signed int)v11;
  v17 = v11 - 1;
  while ( v15 < v16 )
  {
    if ( (_DWORD)v15 != 18
                      * ((unsigned int)(954437177LL * (signed int)v15 >> 34)
                       + ((unsigned __int64)(954437177LL * (signed int)v15) >> 63))
      || (signed int)BIO_write(v14, (__int64)"\n", 1u) >= 1 && (signed int)BIO_indent(v14, v13, v13) >= 1 )
    {
      v18 = v17 == v15 ? &unk_B8A4C : ":";
      BIO_printf(v14, (__int64)"%02x%s", a4, a5, a6, a7, a8, a9, a10, a11, *(unsigned __int8 *)(v12 + v15++), v18);
      if ( v19 >= 1 )
        continue;
    }
    return 0LL;
  }
  return (unsigned int)BIO_write(v14, (__int64)"\n", 1u) == 1;
}

//----- (00000000000ABFA0) ----------------------------------------------------
__int64 *__fastcall X509_to_X509_REQ(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  __int64 v4; // x21
  __int64 v5; // x22
  __int64 v6; // x0
  __int64 *v7; // x19
  __int64 v8; // x23
  _BYTE *v9; // x8
  __int64 v10; // x0
  __int64 v11; // x0
  int *v12; // x22
  int v13; // w23

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = X509_REQ_new();
  v7 = (__int64 *)v6;
  if ( !v6 )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_req.c", 78);
LABEL_10:
    X509_REQ_free((__int64)v7);
    return 0LL;
  }
  v8 = *(_QWORD *)v6;
  **(_DWORD **)(*(_QWORD *)v6 + 24LL) = 1;
  *(_QWORD *)(*(_QWORD *)(v8 + 24) + 8LL) = malloc(1uLL);
  v9 = *(_BYTE **)(*(_QWORD *)(v8 + 24) + 8LL);
  if ( !v9 )
    goto LABEL_10;
  *v9 = 0;
  v10 = X509_get_subject_name(v5);
  if ( !X509_REQ_set_subject_name((__int64)v7, v10) )
    goto LABEL_10;
  X509_get_pubkey(v5);
  v12 = (int *)v11;
  if ( !v11 )
    goto LABEL_10;
  v13 = X509_REQ_set_pubkey((__int64)v7, v11);
  EVP_PKEY_free(v12);
  if ( !v13 || v4 && !(unsigned int)X509_REQ_sign(v7, v4, v3) )
    goto LABEL_10;
  return v7;
}

//----- (00000000000AC09C) ----------------------------------------------------
void __fastcall X509_REQ_get_pubkey(__int64 a1)
{
  if ( a1 )
  {
    if ( *(_QWORD *)a1 )
      X509_PUBKEY_get(*(_QWORD *)(*(_QWORD *)a1 + 40LL));
  }
}

//----- (00000000000AC0B8) ----------------------------------------------------
__int64 __fastcall X509_REQ_check_private_key(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  int *v3; // x0
  int *v4; // x19
  int v5; // w8
  int v6; // w2
  __int16 v7; // w4
  unsigned int v8; // w20

  v2 = a2;
  if ( a1 && *(_QWORD *)a1 )
  {
    X509_PUBKEY_get(*(_QWORD *)(*(_QWORD *)a1 + 40LL));
    v4 = v3;
  }
  else
  {
    v4 = 0LL;
  }
  switch ( (unsigned int)EVP_PKEY_cmp((__int64)v4, v2) + 2 )
  {
    case 0u:
      v5 = *(_DWORD *)(v2 + 4);
      if ( v5 == 28 )
      {
        v6 = 104;
        v7 = 141;
      }
      else if ( v5 == 408 )
      {
        v6 = 15;
        v7 = 136;
      }
      else
      {
        v6 = 128;
        v7 = 144;
      }
      goto LABEL_14;
    case 1u:
      v6 = 115;
      v7 = 132;
      goto LABEL_14;
    case 2u:
      v6 = 116;
      v7 = 129;
LABEL_14:
      ERR_put_error(11, 0LL, v6, (__int64)"external/boringssl/src/crypto/x509/x509_req.c", v7);
      goto def_AC110;
    case 3u:
      v8 = 1;
      break;
    default:
def_AC110:
      v8 = 0;
      break;
  }
  EVP_PKEY_free(v4);
  return v8;
}

//----- (00000000000AC1B0) ----------------------------------------------------
signed __int64 __fastcall X509_REQ_extension_nid(int a1)
{
  int v1; // w9
  signed __int64 v2; // x11

  v1 = *off_106810;
  if ( !*off_106810 )
    return 0LL;
  v2 = 0x100000000LL;
  while ( v1 != a1 )
  {
    v1 = *(_DWORD *)(off_106810 + (v2 >> 30));
    v2 += 0x100000000LL;
    if ( !v1 )
      return 0LL;
  }
  return 1LL;
}

//----- (00000000000AC1F8) ----------------------------------------------------
__int64 X509_REQ_get_extension_nids()
{
  return off_106810;
}

//----- (00000000000AC204) ----------------------------------------------------
__int64 __fastcall X509_REQ_set_extension_nids(__int64 result)
{
  off_106810 = result;
  return result;
}

//----- (00000000000AC210) ----------------------------------------------------
unsigned __int64 *__fastcall X509_REQ_get_extensions(_QWORD *a1)
{
  _QWORD *v1; // x19
  __int64 v2; // x8
  unsigned __int64 *result; // x0
  __int64 v4; // x20
  int v5; // w8
  unsigned int *v6; // x20
  unsigned __int64 *v7; // x0
  unsigned __int64 *v8; // x19
  signed int *v9; // x8
  __int64 v10; // [xsp+0h] [xbp-20h]
  __int64 v11; // [xsp+8h] [xbp-18h]

  v1 = a1;
  v11 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !a1 )
    goto LABEL_16;
  v2 = *a1;
  result = 0LL;
  if ( *v1 )
  {
    v4 = off_106810;
    if ( off_106810 )
    {
      if ( !*off_106810 )
        goto LABEL_16;
      v5 = X509v3_get_ext_by_NID(*(unsigned __int64 **)(v2 + 48), *off_106810, -1);
      if ( v5 == -1 )
      {
        v6 = (unsigned int *)(v4 + 4);
        while ( *v6 )
        {
          v5 = X509v3_get_ext_by_NID(*(unsigned __int64 **)(*v1 + 48LL), *v6, -1);
          ++v6;
          if ( v5 != -1 )
            goto LABEL_9;
        }
        goto LABEL_16;
      }
LABEL_9:
      v7 = X509v3_get_ext(*(unsigned __int64 **)(*v1 + 48LL), v5);
      v8 = v7;
      if ( *((_DWORD *)v7 + 2) )
      {
        result = (unsigned __int64 *)v7[2];
        if ( !result )
          goto LABEL_17;
LABEL_14:
        if ( *(_DWORD *)result == 16 )
        {
          v9 = (signed int *)result[1];
          v10 = *((_QWORD *)v9 + 1);
          result = ASN1_item_d2i(0LL, (const void **)&v10, *v9, (unsigned __int8 *)&X509_EXTENSIONS_it);
          goto LABEL_17;
        }
LABEL_16:
        result = 0LL;
        goto LABEL_17;
      }
      result = sk_num((_QWORD *)v7[2]);
      if ( result )
      {
        result = sk_value((unsigned __int64 *)v8[2], 0LL);
        if ( result )
          goto LABEL_14;
      }
    }
  }
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000AC33C) ----------------------------------------------------
signed __int64 __fastcall X509_REQ_add_extensions_nid(__int64 *a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // w22
  __int64 *v4; // x21
  __int64 v5; // x20
  _QWORD *v6; // x0
  int v7; // w0
  __int64 v8; // x19
  unsigned __int64 *v9; // x0
  __int64 v10; // x0
  __int64 v11; // x8
  _QWORD *v12; // x0

  v3 = a3;
  v4 = a1;
  v5 = ASN1_TYPE_new();
  if ( v5 )
  {
    v6 = ASN1_STRING_new();
    *(_QWORD *)(v5 + 8) = v6;
    if ( v6 )
    {
      *(_DWORD *)v5 = 16;
      ASN1_item_i2d();
      **(_DWORD **)(v5 + 8) = v7;
      v8 = X509_ATTRIBUTE_new();
      if ( !v8 )
        goto LABEL_12;
      v9 = sk_new_null();
      *(_QWORD *)(v8 + 16) = v9;
      if ( !v9 || !sk_push(v9, v5) )
        goto LABEL_12;
      *(_DWORD *)(v8 + 8) = 0;
      OBJ_nid2obj(v3);
      *(_QWORD *)v8 = v10;
      v11 = *v4;
      if ( !*(_QWORD *)(*v4 + 48) )
      {
        v12 = sk_new_null();
        *(_QWORD *)(*v4 + 48) = v12;
        if ( !v12 )
        {
LABEL_14:
          v5 = 0LL;
          goto LABEL_12;
        }
        v11 = *v4;
      }
      if ( sk_push(*(unsigned __int64 **)(v11 + 48), v8) )
        return 1LL;
      goto LABEL_14;
    }
  }
  v8 = 0LL;
LABEL_12:
  X509_ATTRIBUTE_free(v8);
  ASN1_TYPE_free(v5);
  return 0LL;
}

//----- (00000000000AC430) ----------------------------------------------------
signed __int64 __fastcall X509_REQ_add_extensions(__int64 *a1, __int64 a2)
{
  return X509_REQ_add_extensions_nid(a1, a2, 0xACu);
}

//----- (00000000000AC438) ----------------------------------------------------
_QWORD *__fastcall X509_REQ_get_attr_count(__int64 a1)
{
  return X509at_get_attr_count(*(_QWORD **)(*(_QWORD *)a1 + 48LL));
}

//----- (00000000000AC444) ----------------------------------------------------
bool __fastcall X509_REQ_add1_attr(__int64 a1, __int64 a2)
{
  return X509at_add1_attr((void ***)(*(_QWORD *)a1 + 48LL), a2) != 0LL;
}

//----- (00000000000AC468) ----------------------------------------------------
bool __fastcall X509_REQ_add1_attr_by_OBJ(__int64 a1, __int64 a2, int a3, const char *a4, signed int a5)
{
  return X509at_add1_attr_by_OBJ((void ***)(*(_QWORD *)a1 + 48LL), a2, a3, a4, a5) != 0LL;
}

//----- (00000000000AC48C) ----------------------------------------------------
bool __fastcall X509_REQ_add1_attr_by_NID(__int64 a1, unsigned int a2, int a3, const char *a4, signed int a5)
{
  return X509at_add1_attr_by_NID((void ***)(*(_QWORD *)a1 + 48LL), a2, a3, a4, a5) != 0LL;
}

//----- (00000000000AC4B0) ----------------------------------------------------
bool __fastcall X509_REQ_add1_attr_by_txt(__int64 a1, const char *a2, int a3, const char *a4, signed int a5)
{
  return X509at_add1_attr_by_txt((void ***)(*(_QWORD *)a1 + 48LL), a2, a3, a4, a5) != 0LL;
}

//----- (00000000000AC4D4) ----------------------------------------------------
__int64 (__fastcall *__fastcall X509_TRUST_set_default(__int64 (__fastcall *a1)()))()
{
  __int64 (__fastcall *v1)(_QWORD, _QWORD, _QWORD); // x8

  v1 = off_106818;
  off_106818 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))a1;
  return (__int64 (__fastcall *)())v1;
}
// 106818: using guessed type __int64 (__fastcall *off_106818)(_QWORD, _QWORD, _QWORD);

//----- (00000000000AC4E8) ----------------------------------------------------
__int64 __fastcall X509_check_trust(__int64 a1, int a2, unsigned int a3)
{
  unsigned int v3; // w20
  unsigned int v4; // w21
  __int64 v5; // x19
  __int64 result; // x0
  __int64 v7; // x8
  unsigned __int64 *v8; // x0
  signed int v9; // w9
  __int64 v10; // [xsp+8h] [xbp-58h]
  int v11; // [xsp+10h] [xbp-50h]
  __int64 v12; // [xsp+38h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 == -1 )
  {
    result = 1LL;
    goto LABEL_17;
  }
  if ( a2 )
  {
    LODWORD(v7) = a2 - 1;
    if ( (unsigned int)(a2 - 1) > 7 )
    {
      v11 = a2;
      if ( !qword_107420
        || !(unsigned int)sk_find(qword_107420, &v10, (__int64)&v11)
        || (v9 = v10 + 8, (_DWORD)v10 == -9) )
      {
        result = off_106818(v4, v5, v3);
        goto LABEL_17;
      }
      if ( v9 & 0x80000000 )
      {
        v8 = 0LL;
        goto LABEL_9;
      }
      v7 = v9;
      if ( v9 > 7 )
      {
        v8 = sk_value((unsigned __int64 *)qword_107420, v9 - 8LL);
        goto LABEL_9;
      }
    }
    else
    {
      v7 = (signed int)v7;
    }
    v8 = (unsigned __int64 *)((char *)&unk_106820 + 40 * v7);
LABEL_9:
    result = ((__int64 (*)(void))v8[1])();
    goto LABEL_17;
  }
  result = sub_AC634(910, a1);
  if ( (_DWORD)result == 3 )
  {
    X509_check_purpose(v5, -1);
    result = (*(_DWORD *)(v5 + 64) >> 12) & 2 ^ 3u;
  }
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v12;
  return result;
}
// 106818: using guessed type __int64 (__fastcall *off_106818)(_QWORD, _QWORD, _QWORD);
// 107420: using guessed type __int64 qword_107420;

//----- (00000000000AC634) ----------------------------------------------------
signed __int64 __fastcall sub_AC634(int a1, __int64 a2)
{
  unsigned __int64 **v2; // x21
  int v3; // w19
  unsigned __int64 *v4; // x0
  unsigned __int64 v5; // x20
  unsigned __int64 *v6; // x0
  unsigned __int64 v7; // x20
  unsigned __int64 *v8; // x0

  v2 = *(unsigned __int64 ***)(a2 + 168);
  v3 = a1;
  if ( !v2 )
    return 3LL;
  v4 = v2[1];
  if ( !v4 || !sk_num(v4) )
  {
LABEL_7:
    if ( *v2 )
    {
      if ( !sk_num(*v2) )
        return 3LL;
      v7 = 0LL;
      while ( 1 )
      {
        v8 = sk_value(*v2, v7);
        if ( (unsigned int)OBJ_obj2nid((unsigned int *)v8) == v3 )
          break;
        if ( ++v7 >= (unsigned __int64)sk_num(*v2) )
          return 3LL;
      }
      return 1LL;
    }
    return 3LL;
  }
  v5 = 0LL;
  while ( 1 )
  {
    v6 = sk_value(v2[1], v5);
    if ( (unsigned int)OBJ_obj2nid((unsigned int *)v6) == v3 )
      return 2LL;
    if ( ++v5 >= (unsigned __int64)sk_num(v2[1]) )
      goto LABEL_7;
  }
}

//----- (00000000000AC6FC) ----------------------------------------------------
__int64 __fastcall sub_AC6FC(__int64 a1, __int64 a2)
{
  __int64 v2; // x19

  v2 = a2;
  X509_check_purpose(a2, -1);
  return (*(_DWORD *)(v2 + 64) >> 12) & 2 ^ 3u;
}

//----- (00000000000AC738) ----------------------------------------------------
signed __int64 __fastcall X509_TRUST_get_by_id(int a1)
{
  int v1; // w8
  signed __int64 result; // x0
  signed __int64 v3; // [xsp+8h] [xbp-38h]
  int v4; // [xsp+10h] [xbp-30h]
  __int64 v5; // [xsp+38h] [xbp-8h]

  v1 = a1;
  result = (unsigned int)(a1 - 1);
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)result >= 8 )
  {
    v4 = v1;
    if ( qword_107420 && (unsigned int)sk_find(qword_107420, &v3, (__int64)&v4) )
      result = (unsigned int)(v3 + 8);
    else
      result = 0xFFFFFFFFLL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 107420: using guessed type __int64 qword_107420;

//----- (00000000000AC7B4) ----------------------------------------------------
unsigned __int64 *__fastcall X509_TRUST_get0(signed int a1)
{
  if ( a1 & 0x80000000 )
    return 0LL;
  if ( a1 > 7 )
    return sk_value((unsigned __int64 *)qword_107420, a1 - 8LL);
  return (unsigned __int64 *)((char *)&unk_106820 + 40 * a1);
}
// 107420: using guessed type __int64 qword_107420;

//----- (00000000000AC800) ----------------------------------------------------
signed __int64 X509_TRUST_get_count()
{
  signed __int64 result; // x0

  if ( qword_107420 )
    result = (unsigned int)sk_num((_QWORD *)qword_107420) + 8;
  else
    result = 8LL;
  return result;
}
// 107420: using guessed type __int64 qword_107420;

//----- (00000000000AC82C) ----------------------------------------------------
signed __int64 __fastcall X509_TRUST_set(int *a1, int a2)
{
  int v2; // w19
  int *v3; // x20
  signed __int64 result; // x0
  signed __int64 v5; // [xsp+8h] [xbp-48h]
  int v6; // [xsp+10h] [xbp-40h]
  __int64 v7; // [xsp+38h] [xbp-18h]

  v2 = a2;
  v3 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a2 - 1) <= 7
    || (v6 = a2, qword_107420) && (unsigned int)sk_find(qword_107420, &v5, (__int64)&v6) && (_DWORD)v5 != -9 )
  {
    result = 1LL;
    *v3 = v2;
  }
  else
  {
    ERR_put_error(11, 0LL, 113, (__int64)"external/boringssl/src/crypto/x509/x509_trs.c", 170);
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// 107420: using guessed type __int64 qword_107420;

//----- (00000000000AC8DC) ----------------------------------------------------
signed __int64 __fastcall X509_TRUST_add(int a1, int a2, unsigned __int64 a3, const char *a4, int a5, unsigned __int64 a6)
{
  int v6; // w22
  unsigned __int64 v7; // x20
  int v8; // w21
  const char *v9; // x25
  unsigned __int64 v10; // x23
  int v11; // w24
  __int64 v12; // x8
  signed int v13; // w26
  unsigned __int64 *v14; // x19
  signed int v15; // w9
  unsigned __int64 *v16; // x0
  _BYTE *v17; // x25
  int v18; // w8
  unsigned int v19; // w24
  unsigned __int64 *v20; // x0
  signed __int64 result; // x0
  int v22; // w8
  int v23; // w8
  __int64 v24; // [xsp+8h] [xbp-78h]
  int v25; // [xsp+10h] [xbp-70h]
  __int64 v26; // [xsp+38h] [xbp-48h]

  v6 = a1;
  v7 = a6;
  v8 = a5;
  v9 = a4;
  v10 = a3;
  v11 = a2;
  LODWORD(v12) = a1 - 1;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)(a1 - 1) <= 7 )
  {
    v12 = (signed int)v12;
LABEL_3:
    v13 = 0;
    v14 = (unsigned __int64 *)((char *)&unk_106820 + 40 * v12);
    goto LABEL_12;
  }
  v25 = a1;
  if ( qword_107420 && (unsigned int)sk_find(qword_107420, &v24, (__int64)&v25) && (v15 = v24 + 8, (_DWORD)v24 != -9) )
  {
    if ( v15 & 0x80000000 )
    {
      v13 = 0;
      v14 = 0LL;
    }
    else
    {
      v12 = v15;
      if ( v15 <= 7 )
        goto LABEL_3;
      v14 = sk_value((unsigned __int64 *)qword_107420, v15 - 8LL);
      v13 = 0;
    }
  }
  else
  {
    v16 = (unsigned __int64 *)malloc(0x28uLL);
    v14 = v16;
    if ( !v16 )
    {
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_trs.c", 195);
      goto LABEL_24;
    }
    v13 = 1;
    *((_DWORD *)v16 + 1) = 1;
  }
LABEL_12:
  v17 = BUF_strdup(v9);
  if ( !v17 )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_trs.c", 205);
    result = 0LL;
    if ( !v13 )
      goto LABEL_25;
    goto LABEL_21;
  }
  v18 = *((_DWORD *)v14 + 1);
  v19 = v11 & 0xFFFFFFFC;
  if ( v18 & 2 )
  {
    free((void *)v14[2]);
    v18 = *((_DWORD *)v14 + 1);
  }
  v14[1] = v10;
  v14[2] = (unsigned __int64)v17;
  *((_DWORD *)v14 + 6) = v8;
  *(_DWORD *)v14 = v6;
  *((_DWORD *)v14 + 1) = v19 | v18 & 1 | 2;
  v14[4] = v7;
  if ( !v13 )
  {
    result = 1LL;
    goto LABEL_25;
  }
  v20 = (unsigned __int64 *)qword_107420;
  if ( !qword_107420 )
  {
    v20 = sk_new((__int64)sub_ACB30);
    qword_107420 = (__int64)v20;
    if ( !v20 )
    {
      ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_trs.c", 228);
      v23 = *((_DWORD *)v14 + 1);
      result = 0LL;
      if ( !(v23 & 1) )
        goto LABEL_25;
      if ( !(v23 & 2) )
        goto LABEL_21;
      goto LABEL_33;
    }
  }
  if ( !sk_push(v20, (__int64)v14) )
  {
    ERR_put_error(11, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/x509_trs.c", 233);
    v22 = *((_DWORD *)v14 + 1);
    result = 0LL;
    if ( !(v22 & 1) )
      goto LABEL_25;
    if ( !(v22 & 2) )
      goto LABEL_21;
LABEL_33:
    free((void *)v14[2]);
LABEL_21:
    free(v14);
LABEL_24:
    result = 0LL;
    goto LABEL_25;
  }
  result = 1LL;
LABEL_25:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v26;
  return result;
}
// 107420: using guessed type __int64 qword_107420;

//----- (00000000000ACB30) ----------------------------------------------------
__int64 __fastcall sub_ACB30(_DWORD **a1, _DWORD **a2)
{
  return (unsigned int)(**a1 - **a2);
}

//----- (00000000000ACB48) ----------------------------------------------------
void __fastcall sub_ACB48(__int64 a1)
{
  void *v1; // x19
  int v2; // w8

  v1 = (void *)a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 & 1 )
    {
      if ( v2 & 2 )
        free(*(void **)(a1 + 16));
      free(v1);
    }
  }
}

//----- (00000000000ACB8C) ----------------------------------------------------
void X509_TRUST_cleanup()
{
  __int64 v0; // x19
  int v1; // w8

  v0 = 0LL;
  do
  {
    if ( (_UNKNOWN *)((char *)&unk_106820 + v0) )
    {
      v1 = *(_DWORD *)((char *)&unk_106820 + v0 + 4);
      if ( v1 & 1 )
      {
        if ( v1 & 2 )
          free(*(void **)((char *)&unk_106820 + v0 + 16));
        free((char *)&unk_106820 + v0);
      }
    }
    v0 += 40LL;
  }
  while ( v0 != 320 );
  sk_pop_free((unsigned __int64 *)qword_107420, (void (*)(void))sub_ACB48);
  qword_107420 = 0LL;
}
// 107420: using guessed type __int64 qword_107420;

//----- (00000000000ACBFC) ----------------------------------------------------
signed __int64 __fastcall sub_ACBFC(__int64 a1, __int64 a2)
{
  __int64 v2; // x19
  _QWORD *v3; // x8

  v2 = a2;
  v3 = *(_QWORD **)(a2 + 168);
  if ( v3 && (*v3 || v3[1]) )
    return sub_AC634(*(_DWORD *)(a1 + 24), a2);
  X509_check_purpose(a2, -1);
  return (*(_DWORD *)(v2 + 64) >> 12) & 2 ^ 3u;
}

//----- (00000000000ACC64) ----------------------------------------------------
signed __int64 __fastcall sub_ACC64(__int64 a1, __int64 a2)
{
  signed __int64 result; // x0

  if ( *(_QWORD *)(a2 + 168) )
    result = sub_AC634(*(_DWORD *)(a1 + 24), a2);
  else
    result = 3LL;
  return result;
}

//----- (00000000000ACC7C) ----------------------------------------------------
signed __int64 __fastcall X509_REQ_set_version(signed __int64 result, __int64 a2)
{
  if ( result )
    result = ASN1_INTEGER_set(*(_QWORD *)(*(_QWORD *)result + 24LL), a2);
  return result;
}

//----- (00000000000ACC90) ----------------------------------------------------
bool __fastcall X509_REQ_set_subject_name(__int64 a1, __int64 a2)
{
  _BOOL8 result; // x0

  if ( a1 && *(_QWORD *)a1 )
    result = X509_NAME_set((__int64 *)(*(_QWORD *)a1 + 32LL), a2);
  else
    result = 0LL;
  return result;
}

//----- (00000000000ACCAC) ----------------------------------------------------
signed __int64 __fastcall X509_REQ_set_pubkey(__int64 a1, __int64 a2)
{
  signed __int64 result; // x0

  if ( a1 && *(_QWORD *)a1 )
    result = X509_PUBKEY_set((__int64 *)(*(_QWORD *)a1 + 40LL), a2);
  else
    result = 0LL;
  return result;
}

//----- (00000000000ACCC8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_ALGOR(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_ALGOR_it);
}

//----- (00000000000ACCD4) ----------------------------------------------------
void i2d_X509_ALGOR()
{
  ASN1_item_i2d();
}

//----- (00000000000ACCE0) ----------------------------------------------------
__int64 X509_ALGOR_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_ALGOR_it);
}

//----- (00000000000ACCEC) ----------------------------------------------------
void __fastcall X509_ALGOR_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_ALGOR_it);
}

//----- (00000000000ACCF8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_ALGORS(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_ALGORS_it);
}

//----- (00000000000ACD04) ----------------------------------------------------
void i2d_X509_ALGORS()
{
  ASN1_item_i2d();
}

//----- (00000000000ACD10) ----------------------------------------------------
void __fastcall X509_ALGOR_dup(__int64 a1)
{
  ASN1_item_dup((unsigned __int8 *)&X509_ALGOR_it, a1);
}

//----- (00000000000ACD28) ----------------------------------------------------
__int64 __fastcall X509_ALGOR_set0(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v4; // x20
  int v5; // w21
  __int64 v6; // x22
  __int64 v7; // x19
  __int64 result; // x0
  __int64 v9; // x0

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a1 )
    return 0LL;
  if ( a3 == -1 || *(_QWORD *)(a1 + 8) || (result = ASN1_TYPE_new(), (*(_QWORD *)(v7 + 8) = result) != 0LL) )
  {
    if ( *(_QWORD *)v7 )
      ASN1_OBJECT_free(*(void ***)v7);
    *(_QWORD *)v7 = v6;
    if ( v5 )
    {
      v9 = *(_QWORD *)(v7 + 8);
      if ( v5 == -1 )
      {
        if ( v9 )
        {
          ASN1_TYPE_free(v9);
          *(_QWORD *)(v7 + 8) = 0LL;
        }
      }
      else
      {
        ASN1_TYPE_set(v9, v5, v4);
      }
    }
    result = 1LL;
  }
  return result;
}

//----- (00000000000ACDC0) ----------------------------------------------------
_QWORD *__fastcall X509_ALGOR_get0(_QWORD *result, _DWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _DWORD *v4; // x8

  if ( result )
    *result = *a4;
  if ( a2 )
  {
    v4 = (_DWORD *)a4[1];
    if ( v4 )
    {
      *a2 = *v4;
      if ( a3 )
        *a3 = *(_QWORD *)(a4[1] + 8LL);
    }
    else
    {
      *a2 = -1;
    }
  }
  return result;
}

//----- (00000000000ACE00) ----------------------------------------------------
__int64 __fastcall X509_ALGOR_set_md(__int64 a1, __int64 a2)
{
  unsigned int *v2; // x19
  __int64 v3; // x20
  int v4; // w21
  unsigned int v5; // w0
  __int64 v6; // x0

  v2 = (unsigned int *)a2;
  v3 = a1;
  if ( EVP_MD_flags(a2) & 2 )
    v4 = 1;
  else
    v4 = 5;
  v5 = X509_TRUST_get_trust(v2);
  OBJ_nid2obj(v5);
  return X509_ALGOR_set0(v3, v6, v4, 0LL);
}

//----- (00000000000ACE58) ----------------------------------------------------
__int64 __fastcall X509_ALGOR_cmp(__int64 *a1, __int64 *a2)
{
  __int64 *v2; // x19
  __int64 *v3; // x20
  __int64 result; // x0
  unsigned __int64 v5; // x0
  __int64 v6; // x1

  v2 = a2;
  v3 = a1;
  result = OBJ_cmp(*a1, *a2);
  if ( !(_DWORD)result )
  {
    v5 = v3[1];
    v6 = v2[1];
    if ( v5 | v6 )
      result = ASN1_TYPE_cmp((int *)v5, v6);
    else
      result = 0LL;
  }
  return result;
}

//----- (00000000000ACEA8) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_X509_VAL(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&X509_VAL_it);
}

//----- (00000000000ACEB4) ----------------------------------------------------
void i2d_X509_VAL()
{
  ASN1_item_i2d();
}

//----- (00000000000ACEC0) ----------------------------------------------------
__int64 X509_VAL_new()
{
  return ASN1_item_new((unsigned __int8 *)&X509_VAL_it);
}

//----- (00000000000ACECC) ----------------------------------------------------
void __fastcall X509_VAL_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&X509_VAL_it);
}

//----- (00000000000ACED8) ----------------------------------------------------
__int64 __fastcall X509_policy_tree_level_count(__int64 result)
{
  if ( result )
    result = *(unsigned int *)(result + 8);
  return result;
}

//----- (00000000000ACEE4) ----------------------------------------------------
signed __int64 __fastcall X509_policy_tree_get0_level(__int64 a1, int a2)
{
  __int64 v2; // x8
  signed __int64 result; // x0

  v2 = a1;
  result = 0LL;
  if ( v2 && !(a2 & 0x80000000) )
  {
    if ( *(_DWORD *)(v2 + 8) <= a2 )
      result = 0LL;
    else
      result = *(_QWORD *)v2 + 32LL * a2;
  }
  return result;
}

//----- (00000000000ACF18) ----------------------------------------------------
__int64 __fastcall X509_policy_tree_get0_policies(__int64 result)
{
  if ( result )
    result = *(_QWORD *)(result + 24);
  return result;
}

//----- (00000000000ACF24) ----------------------------------------------------
__int64 __fastcall X509_policy_tree_get0_user_policies(__int64 result)
{
  __int64 *v1; // x8

  if ( result )
  {
    if ( *(_BYTE *)(result + 40) & 2 )
      v1 = (__int64 *)(result + 24);
    else
      v1 = (__int64 *)(result + 32);
    result = *v1;
  }
  return result;
}

//----- (00000000000ACF44) ----------------------------------------------------
__int64 __fastcall X509_policy_level_node_count(__int64 result)
{
  _QWORD *v1; // x8
  __int64 v2; // x19

  if ( result )
  {
    v1 = *(_QWORD **)(result + 8);
    v2 = *(_QWORD *)(result + 16);
    result = v2 != 0;
    if ( v1 )
    {
      LODWORD(result) = (unsigned __int64)sk_num(v1);
      if ( v2 )
        result = (unsigned int)(result + 1);
      else
        result = (unsigned int)result;
    }
  }
  return result;
}

//----- (00000000000ACF80) ----------------------------------------------------
unsigned __int64 *__fastcall X509_policy_level_get0_node(__int64 a1, int a2)
{
  __int64 v2; // x8

  if ( a1 )
  {
    v2 = *(_QWORD *)(a1 + 16);
    if ( v2 )
    {
      if ( !a2 )
        return (unsigned __int64 *)v2;
      --a2;
    }
    return sk_value(*(unsigned __int64 **)(a1 + 8), a2);
  }
  return 0LL;
}

//----- (00000000000ACFC4) ----------------------------------------------------
__int64 __fastcall X509_policy_node_get0_policy(__int64 result)
{
  if ( result )
    result = *(_QWORD *)(*(_QWORD *)result + 8LL);
  return result;
}

//----- (00000000000ACFD4) ----------------------------------------------------
__int64 __fastcall X509_policy_node_get0_qualifiers(__int64 result)
{
  if ( result )
    result = *(_QWORD *)(*(_QWORD *)result + 16LL);
  return result;
}

//----- (00000000000ACFE4) ----------------------------------------------------
_QWORD *sub_ACFE4()
{
  return sk_new((__int64)sub_ACFF0);
}

//----- (00000000000ACFF0) ----------------------------------------------------
__int64 __fastcall sub_ACFF0(__int64 a1, __int64 a2)
{
  return OBJ_cmp(*(_QWORD *)(**(_QWORD **)a1 + 8LL), *(_QWORD *)(**(_QWORD **)a2 + 8LL));
}

//----- (00000000000AD00C) ----------------------------------------------------
unsigned __int64 *__fastcall sub_AD00C(__int64 a1, __int64 a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 *result; // x0
  unsigned __int64 v4; // [xsp+8h] [xbp-58h]
  char *v5; // [xsp+10h] [xbp-50h]
  char v6; // [xsp+28h] [xbp-38h]
  __int64 v7; // [xsp+30h] [xbp-30h]
  __int64 v8; // [xsp+48h] [xbp-18h]

  v2 = (unsigned __int64 *)a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a2;
  v5 = &v6;
  if ( (unsigned int)sk_find(a1, (signed __int64 *)&v4, (__int64)&v5) )
    result = sk_value(v2, v4);
  else
    result = 0LL;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000AD084) ----------------------------------------------------
unsigned __int64 *__fastcall sub_AD084(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x20
  __int64 v4; // x19
  __int64 v5; // x21
  unsigned __int64 v6; // x22
  unsigned __int64 *v7; // x0
  unsigned __int64 *v8; // x23

  v3 = a1;
  v4 = a3;
  v5 = a2;
  if ( !sk_num(*(_QWORD **)(a1 + 8)) )
    return 0LL;
  v6 = 0LL;
  while ( 1 )
  {
    v7 = sk_value(*(unsigned __int64 **)(v3 + 8), v6);
    v8 = v7;
    if ( v7[1] == v5 && !(unsigned int)OBJ_cmp(*(_QWORD *)(*v7 + 8), v4) )
      break;
    if ( ++v6 >= (unsigned __int64)sk_num(*(_QWORD **)(v3 + 8)) )
      return 0LL;
  }
  return v8;
}

//----- (00000000000AD114) ----------------------------------------------------
void *__fastcall sub_AD114(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x23
  __int64 v5; // x22
  __int64 v6; // x20
  __int64 v7; // x21
  _QWORD *v8; // x0
  void *v9; // x19
  unsigned __int64 *v10; // x0
  unsigned __int64 *v11; // x0

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = malloc(0x18uLL);
  v9 = v8;
  if ( !v8 )
    return v9;
  *v8 = v7;
  v8[1] = v6;
  *((_DWORD *)v8 + 4) = 0;
  if ( !v4 )
  {
LABEL_10:
    if ( !v5 )
      goto LABEL_14;
    goto LABEL_11;
  }
  if ( (unsigned int)OBJ_obj2nid(*(unsigned int **)(v7 + 8)) != 746 )
  {
    v10 = *(unsigned __int64 **)(v4 + 8);
    if ( !v10 )
    {
      v10 = sk_new((__int64)sub_ACFF0);
      *(_QWORD *)(v4 + 8) = v10;
      if ( !v10 )
        goto LABEL_16;
    }
    if ( !sk_push(v10, (__int64)v9) )
      goto LABEL_16;
    goto LABEL_10;
  }
  if ( *(_QWORD *)(v4 + 16) )
    goto LABEL_16;
  *(_QWORD *)(v4 + 16) = v9;
  if ( v5 )
  {
LABEL_11:
    v11 = *(unsigned __int64 **)(v5 + 16);
    if ( v11 || (v11 = sk_new_null(), (*(_QWORD *)(v5 + 16) = v11) != 0LL) )
    {
      if ( sk_push(v11, v7) )
        goto LABEL_14;
    }
LABEL_16:
    free(v9);
    return 0LL;
  }
LABEL_14:
  if ( v6 )
    ++*(_DWORD *)(v6 + 16);
  return v9;
}

//----- (00000000000AD200) ----------------------------------------------------
_QWORD *__fastcall sub_AD200(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // x21
  __int64 v4; // x19
  _QWORD *result; // x0
  unsigned __int64 v6; // x20
  unsigned __int64 *v7; // x0

  v3 = *a2;
  v4 = a3;
  if ( *(_BYTE *)(a1 + 25) & 4 || !(*(_BYTE *)v3 & 3) )
    return (_QWORD *)((unsigned int)OBJ_cmp(*(_QWORD *)(v3 + 8), a3) == 0);
  result = sk_num(*(_QWORD **)(v3 + 24));
  if ( result )
  {
    v6 = 0LL;
    while ( 1 )
    {
      v7 = sk_value(*(unsigned __int64 **)(v3 + 24), v6);
      if ( !(unsigned int)OBJ_cmp((__int64)v7, v4) )
        break;
      if ( ++v6 >= (unsigned __int64)sk_num(*(_QWORD **)(v3 + 24)) )
        return 0LL;
    }
    result = (_QWORD *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00000000000AD29C) ----------------------------------------------------
__int64 __fastcall sub_AD29C(__int64 a1, signed int **a2, __int64 a3)
{
  signed int **v3; // x19
  char *v4; // x20
  unsigned __int64 *v5; // x1
  unsigned __int8 **v6; // x8
  char *v7; // x19
  __int64 result; // x0
  __int64 v9; // [xsp+0h] [xbp-20h]
  __int64 v10; // [xsp+8h] [xbp-18h]

  v3 = a2;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v9 = a3;
  if ( *a2 )
  {
    v4 = sub_99E68(*((unsigned __int8 **)*a2 + 1), **a2);
    X509V3_add_value("keyid", v4, (unsigned __int64 **)&v9);
    free(v4);
  }
  v5 = (unsigned __int64 *)v3[1];
  if ( v5 )
    v9 = i2v_GENERAL_NAMES(0LL, v5, v9);
  v6 = (unsigned __int8 **)v3[2];
  if ( v6 )
  {
    v7 = sub_99E68(v6[1], *(signed int *)v6);
    X509V3_add_value("serial", v7, (unsigned __int64 **)&v9);
    free(v7);
  }
  result = v9;
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000AD36C) ----------------------------------------------------
__int64 __fastcall sub_AD36C(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  char v4; // w28
  char v5; // w27
  unsigned __int64 v6; // x21
  unsigned __int64 *v7; // x25
  const char *v8; // x26
  const char *v9; // x0
  const char *v10; // x0
  __int64 v11; // x20
  int v12; // w8
  unsigned __int64 *v13; // x0
  unsigned __int64 *v14; // x19
  __int64 v15; // x3
  __int64 v16; // x4
  __int64 v17; // x5
  __int64 v18; // x6
  __int64 v19; // x7
  _QWORD *v20; // x22
  int v22; // w2
  __int16 v23; // w4
  __int64 v24; // x21
  __int64 v25; // x20
  __int64 v26; // x0
  __int64 v27; // x0
  __int64 v28; // x0
  _BYTE *v29; // x0
  unsigned __int64 *v30; // x23
  __int64 v31; // x24
  int v32; // w2
  __int16 v33; // w4
  __int64 v34; // [xsp+0h] [xbp-60h]
  __int64 v35; // [xsp+8h] [xbp-58h]

  v3 = a3;
  v35 = a2;
  if ( sk_num(a3) )
  {
    v4 = 0;
    v5 = 0;
    v6 = 0LL;
    while ( 1 )
    {
      v7 = sk_value(v3, v6);
      v8 = (const char *)v7[1];
      if ( (unsigned int)strcmp((const char *)v7[1], "keyid") )
      {
        if ( (unsigned int)strcmp(v8, "issuer") )
        {
          ERR_put_error(20, 0LL, 159, (__int64)"external/boringssl/src/crypto/x509v3/v3_akey.c", 145);
          ERR_add_error_data(2u, (__int64)"name=", v7[1], v15, v16, v17, v18, v19, v34);
          return 0LL;
        }
        v9 = (const char *)v7[2];
        if ( v9 )
        {
          if ( (unsigned int)strcmp(v9, "always") )
            v5 = 1;
          else
            v5 = 2;
        }
        else
        {
          v5 = 1;
        }
      }
      else
      {
        v10 = (const char *)v7[2];
        if ( v10 )
        {
          if ( (unsigned int)strcmp(v10, "always") )
            v4 = 1;
          else
            v4 = 2;
        }
        else
        {
          v4 = 1;
        }
      }
      if ( ++v6 >= (unsigned __int64)sk_num(v3) )
        goto LABEL_20;
    }
  }
  v5 = 0;
  v4 = 0;
LABEL_20:
  if ( v35 )
  {
    v11 = *(_QWORD *)(v35 + 8);
    if ( v11 )
    {
      if ( v4 )
      {
        v12 = X509_get_ext_by_NID(v11, 0x52u, -1);
        if ( v12 & 0x80000000 || (v13 = X509_get_ext(v11, v12)) == 0LL )
          v14 = 0LL;
        else
          v14 = X509V3_EXT_d2i((unsigned int **)v13);
        if ( v4 == 2 && !v14 )
        {
          v22 = 155;
          v23 = 165;
          goto LABEL_30;
        }
      }
      else
      {
        v14 = 0LL;
      }
      if ( v5 == 2 || v5 != 0 && v14 == 0LL )
      {
        v26 = X509_get_issuer_name(v11);
        X509_NAME_dup(v26);
        v24 = v27;
        v28 = X509_get_serialNumber(v11);
        v29 = ASN1_STRING_dup(v28);
        v25 = (__int64)v29;
        if ( !v24 || !v29 )
        {
          v32 = 154;
          v33 = 174;
          goto LABEL_49;
        }
      }
      else
      {
        v24 = 0LL;
        v25 = 0LL;
      }
      v20 = (_QWORD *)AUTHORITY_KEYID_new();
      if ( !v20 )
      {
LABEL_50:
        X509_NAME_free(v24);
        ASN1_STRING_free(v25);
        ASN1_STRING_free((__int64)v14);
        return 0LL;
      }
      if ( !v24 )
      {
        v30 = 0LL;
        goto LABEL_52;
      }
      v30 = sk_new_null();
      if ( v30 )
      {
        v31 = GENERAL_NAME_new();
        if ( v31 )
        {
          if ( sk_push(v30, v31) )
          {
            *(_DWORD *)v31 = 4;
            *(_QWORD *)(v31 + 8) = v24;
LABEL_52:
            *v20 = v14;
            v20[1] = v30;
            v20[2] = v25;
            return (__int64)v20;
          }
        }
      }
      v32 = 65;
      v33 = 186;
LABEL_49:
      ERR_put_error(20, 0LL, v32, (__int64)"external/boringssl/src/crypto/x509v3/v3_akey.c", v33);
      goto LABEL_50;
    }
    if ( *(_DWORD *)v35 == 1 )
      return AUTHORITY_KEYID_new();
  }
  v22 = 140;
  v23 = 154;
LABEL_30:
  ERR_put_error(20, 0LL, v22, (__int64)"external/boringssl/src/crypto/x509v3/v3_akey.c", v23);
  return 0LL;
}

//----- (00000000000AD690) ----------------------------------------------------
__int64 __fastcall i2v_GENERAL_NAMES(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x19
  unsigned __int64 v5; // x21
  unsigned __int64 *v6; // x0
  __int64 v7; // x3
  __int64 v8; // x4
  __int64 v9; // x5
  __int64 v10; // x6
  __int64 v11; // x7

  v3 = a2;
  v4 = a3;
  if ( sk_num(a2) )
  {
    v5 = 0LL;
    do
    {
      v6 = sk_value(v3, v5);
      v4 = i2v_GENERAL_NAME((__int64)v6, (__int64)v6, v4, v7, v8, v9, v10, v11);
      ++v5;
    }
    while ( v5 < (unsigned __int64)sk_num(v3) );
  }
  if ( !v4 )
    v4 = (__int64)sk_new_null();
  return v4;
}

//----- (00000000000AD708) ----------------------------------------------------
unsigned __int64 *__fastcall sub_AD708(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x21
  __int64 v5; // x22
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x23
  unsigned __int64 *v8; // x27
  __int64 v9; // x8
  const char *v10; // x0
  const char *v11; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sk_new_null();
  if ( !v6 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 319);
    return v6;
  }
  if ( sk_num(v3) )
  {
    v7 = 0LL;
    do
    {
      v8 = sk_value(v3, v7);
      if ( (unsigned int)sub_9A0D4((const char *)v8[1], "email")
        || (v10 = (const char *)v8[2]) == 0LL
        || (unsigned int)strcmp(v10, "copy") )
      {
        if ( (unsigned int)sub_9A0D4((const char *)v8[1], "email")
          || (v11 = (const char *)v8[2]) == 0LL
          || (unsigned int)strcmp(v11, "move") )
        {
          v9 = v2i_GENERAL_NAME_ex(0LL, v5, v4, (__int64)v8, 0);
          if ( !v9 )
            goto LABEL_17;
          sk_push(v6, v9);
        }
        else if ( !(unsigned int)sub_AE464(v4, v6, 1) )
        {
LABEL_17:
          sk_pop_free(v6, (void (*)(void))GENERAL_NAME_free);
          return 0LL;
        }
      }
      else if ( !(unsigned int)sub_AE464(v4, v6, 0) )
      {
        goto LABEL_17;
      }
      ++v7;
    }
    while ( v7 < (unsigned __int64)sk_num(v3) );
  }
  return v6;
}

//----- (00000000000AD880) ----------------------------------------------------
unsigned __int64 *__fastcall sub_AD880(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x21
  __int64 v5; // x22
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x23
  const char *v8; // x0
  __int64 v9; // x0
  int v10; // w8
  unsigned __int64 *v11; // x0
  unsigned __int64 *v12; // x0
  unsigned __int64 *v13; // x26
  unsigned __int64 v14; // x27
  unsigned __int64 *v15; // x0
  unsigned __int64 *v16; // x26
  __int64 v17; // x8
  int v18; // w2
  __int16 v19; // w4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sk_new_null();
  if ( !v6 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 249);
    return v6;
  }
  if ( sk_num(v3) )
  {
    v7 = 0LL;
    do
    {
      v16 = sk_value(v3, v7);
      if ( (unsigned int)sub_9A0D4((const char *)v16[1], "issuer")
        || (v8 = (const char *)v16[2]) == 0LL
        || (unsigned int)strcmp(v8, "copy") )
      {
        v17 = v2i_GENERAL_NAME_ex(0LL, v5, v4, (__int64)v16, 0);
        if ( !v17 )
          goto LABEL_27;
        sk_push(v6, v17);
      }
      else
      {
        if ( !v4 )
          goto LABEL_24;
        if ( *(_DWORD *)v4 != 1 )
        {
          v9 = *(_QWORD *)(v4 + 8);
          if ( !v9 )
          {
LABEL_24:
            v18 = 141;
            v19 = 283;
            goto LABEL_26;
          }
          v10 = X509_get_ext_by_NID(v9, 0x55u, -1);
          if ( !(v10 & 0x80000000) )
          {
            v11 = X509_get_ext(*(_QWORD *)(v4 + 8), v10);
            if ( !v11 || (v12 = X509V3_EXT_d2i((unsigned int **)v11), (v13 = v12) == 0LL) )
            {
              v18 = 136;
              v19 = 291;
              goto LABEL_26;
            }
            if ( sk_num(v12) )
            {
              v14 = 0LL;
              while ( 1 )
              {
                v15 = sk_value(v13, v14);
                if ( !sk_push(v6, (__int64)v15) )
                  break;
                if ( ++v14 >= (unsigned __int64)sk_num(v13) )
                  goto LABEL_16;
              }
              v18 = 65;
              v19 = 298;
LABEL_26:
              ERR_put_error(20, 0LL, v18, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", v19);
LABEL_27:
              sk_pop_free(v6, (void (*)(void))GENERAL_NAME_free);
              return 0LL;
            }
LABEL_16:
            sk_free((void **)v13);
          }
        }
      }
      ++v7;
    }
    while ( v7 < (unsigned __int64)sk_num(v3) );
  }
  return v6;
}

//----- (00000000000ADA84) ----------------------------------------------------
__int64 __fastcall i2v_GENERAL_NAME(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  const char *v8; // x0
  char *v9; // x1
  __int64 v10; // x8
  const char *v11; // x0
  __int64 v12; // x9
  unsigned __int8 *v13; // x21
  __int64 v14; // x22
  __int64 result; // x0
  __int64 v16; // [xsp+0h] [xbp-150h]
  __int64 v17; // [xsp+8h] [xbp-148h]
  char v18; // [xsp+10h] [xbp-140h]
  char v19; // [xsp+18h] [xbp-138h]
  __int64 v20; // [xsp+118h] [xbp-38h]

  v20 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = a3;
  switch ( *(_DWORD *)a2 )
  {
    case 0:
      v8 = "othername";
      v9 = "<unsupported>";
      goto LABEL_19;
    case 1:
      v10 = *(_QWORD *)(a2 + 8);
      v11 = "email";
      goto LABEL_9;
    case 2:
      v10 = *(_QWORD *)(a2 + 8);
      v11 = "DNS";
      goto LABEL_9;
    case 3:
      v8 = "X400Name";
      v9 = "<unsupported>";
      goto LABEL_19;
    case 4:
      X509_NAME_oneline(*(unsigned __int64 ***)(a2 + 8), &v19, 256);
      v8 = "DirName";
      goto LABEL_18;
    case 5:
      v8 = "EdiPartyName";
      v9 = "<unsupported>";
      goto LABEL_19;
    case 6:
      v10 = *(_QWORD *)(a2 + 8);
      v11 = "URI";
LABEL_9:
      X509V3_add_value_uchar(v11, *(_QWORD *)(v10 + 8), &v17);
      goto def_ADAC8;
    case 7:
      v12 = *(_QWORD *)(a2 + 8);
      v13 = *(unsigned __int8 **)(v12 + 8);
      if ( *(_DWORD *)v12 == 16 )
      {
        v14 = 0LL;
        v19 = 0;
        do
        {
          BIO_snprintf(
            (__int64)&v18,
            5LL,
            (__int64)"%X",
            v13[v14 + 1] | ((unsigned int)v13[v14] << 8),
            a5,
            a6,
            a7,
            a8,
            v16);
          __strcat_chk();
          if ( (_DWORD)v14 == 14 )
            break;
          __strcat_chk();
          v14 += 2LL;
        }
        while ( (_DWORD)v14 != 16 );
      }
      else
      {
        if ( *(_DWORD *)v12 != 4 )
        {
          v8 = "IP Address";
          v9 = "<invalid>";
          goto LABEL_19;
        }
        BIO_snprintf((__int64)&v19, 256LL, (__int64)"%d.%d.%d.%d", *v13, v13[1], v13[2], v13[3], a8, v16);
      }
      v8 = "IP Address";
LABEL_18:
      v9 = &v19;
LABEL_19:
      X509V3_add_value(v8, v9, (unsigned __int64 **)&v17);
def_ADAC8:
      result = v17;
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v20;
      return result;
    case 8:
      i2t_ASN1_OBJECT(&v19, 256, *(unsigned int **)(a2 + 8));
      v8 = "Registered ID";
      goto LABEL_18;
    default:
      goto def_ADAC8;
  }
}
// 9962C: using guessed type __int64 __fastcall X509V3_add_value_uchar(_QWORD, _QWORD, _QWORD);

//----- (00000000000ADC88) ----------------------------------------------------
signed __int64 __fastcall GENERAL_NAME_print(_QWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // x20
  _QWORD *v11; // x19
  const char *v12; // x1
  __int64 v13; // x8
  const char *v14; // x1
  __int64 v15; // x9
  unsigned __int8 *v16; // x21
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  double v25; // d0
  double v26; // d1
  double v27; // d2
  double v28; // d3
  double v29; // d4
  double v30; // d5
  double v31; // d6
  double v32; // d7
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  double v49; // d0
  double v50; // d1
  double v51; // d2
  double v52; // d3
  double v53; // d4
  double v54; // d5
  double v55; // d6
  double v56; // d7
  double v57; // d0
  double v58; // d1
  double v59; // d2
  double v60; // d3
  double v61; // d4
  double v62; // d5
  double v63; // d6
  double v64; // d7
  double v65; // d0
  double v66; // d1
  double v67; // d2
  double v68; // d3
  double v69; // d4
  double v70; // d5
  double v71; // d6
  double v72; // d7
  double v73; // d0
  double v74; // d1
  double v75; // d2
  double v76; // d3
  double v77; // d4
  double v78; // d5
  double v79; // d6
  double v80; // d7

  v10 = a2;
  v11 = a1;
  switch ( *(_DWORD *)a2 )
  {
    case 0:
      v12 = "othername:<unsupported>";
      goto LABEL_16;
    case 1:
      v13 = *(_QWORD *)(a2 + 8);
      v14 = "email:%s";
      goto LABEL_9;
    case 2:
      v13 = *(_QWORD *)(a2 + 8);
      v14 = "DNS:%s";
      goto LABEL_9;
    case 3:
      v12 = "X400Name:<unsupported>";
      goto LABEL_16;
    case 4:
      BIO_printf(a1, (__int64)"DirName: ", a3, a4, a5, a6, a7, a8, a9, a10);
      X509_NAME_print_ex(v11, *(unsigned __int64 ***)(v10 + 8), 0, 8520479LL);
      return 1LL;
    case 5:
      v12 = "EdiPartyName:<unsupported>";
      goto LABEL_16;
    case 6:
      v13 = *(_QWORD *)(a2 + 8);
      v14 = "URI:%s";
LABEL_9:
      BIO_printf(a1, (__int64)v14, a3, a4, a5, a6, a7, a8, a9, a10, *(_QWORD *)(v13 + 8));
      break;
    case 7:
      v15 = *(_QWORD *)(a2 + 8);
      v16 = *(unsigned __int8 **)(v15 + 8);
      if ( *(_DWORD *)v15 == 16 )
      {
        BIO_printf(a1, (__int64)"IP Address", a3, a4, a5, a6, a7, a8, a9, a10);
        BIO_printf(v11, (__int64)":%X", v17, v18, v19, v20, v21, v22, v23, v24, v16[1] | ((unsigned int)*v16 << 8));
        BIO_printf(v11, (__int64)":%X", v25, v26, v27, v28, v29, v30, v31, v32, v16[3] | ((unsigned int)v16[2] << 8));
        BIO_printf(v11, (__int64)":%X", v33, v34, v35, v36, v37, v38, v39, v40, v16[5] | ((unsigned int)v16[4] << 8));
        BIO_printf(v11, (__int64)":%X", v41, v42, v43, v44, v45, v46, v47, v48, v16[7] | ((unsigned int)v16[6] << 8));
        BIO_printf(v11, (__int64)":%X", v49, v50, v51, v52, v53, v54, v55, v56, v16[9] | ((unsigned int)v16[8] << 8));
        BIO_printf(v11, (__int64)":%X", v57, v58, v59, v60, v61, v62, v63, v64, v16[11] | ((unsigned int)v16[10] << 8));
        BIO_printf(v11, (__int64)":%X", v65, v66, v67, v68, v69, v70, v71, v72, v16[13] | ((unsigned int)v16[12] << 8));
        BIO_printf(v11, (__int64)":%X", v73, v74, v75, v76, v77, v78, v79, v80, v16[15] | ((unsigned int)v16[14] << 8));
        BIO_puts(v11, "\n");
      }
      else if ( *(_DWORD *)v15 == 4 )
      {
        BIO_printf(a1, (__int64)"IP Address:%d.%d.%d.%d", a3, a4, a5, a6, a7, a8, a9, a10, *v16, v16[1], v16[2], v16[3]);
      }
      else
      {
        v12 = "IP Address:<invalid>";
LABEL_16:
        BIO_printf(a1, (__int64)v12, a3, a4, a5, a6, a7, a8, a9, a10);
      }
      break;
    case 8:
      BIO_printf(a1, (__int64)"Registered ID", a3, a4, a5, a6, a7, a8, a9, a10);
      i2a_ASN1_OBJECT(v11, *(_QWORD *)(v10 + 8));
      break;
    default:
      return 1LL;
  }
  return 1LL;
}

//----- (00000000000ADEBC) ----------------------------------------------------
unsigned __int64 *__fastcall v2i_GENERAL_NAMES(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x21
  __int64 v5; // x22
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x23
  unsigned __int64 *v8; // x0
  __int64 v9; // x8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sk_new_null();
  if ( v6 )
  {
    if ( sk_num(v3) )
    {
      v7 = 0LL;
      while ( 1 )
      {
        v8 = sk_value(v3, v7);
        v9 = v2i_GENERAL_NAME_ex(0LL, v5, v4, (__int64)v8, 0);
        if ( !v9 )
          break;
        sk_push(v6, v9);
        if ( ++v7 >= (unsigned __int64)sk_num(v3) )
          return v6;
      }
      sk_pop_free(v6, (void (*)(void))GENERAL_NAME_free);
      v6 = 0LL;
    }
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 410);
  }
  return v6;
}

//----- (00000000000ADF94) ----------------------------------------------------
__int64 __fastcall v2i_GENERAL_NAME(__int64 a1, __int64 a2, __int64 a3)
{
  return v2i_GENERAL_NAME_ex(0LL, a1, a2, a3, 0);
}

//----- (00000000000ADFB8) ----------------------------------------------------
__int64 __fastcall v2i_GENERAL_NAME_ex(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  const char *v5; // x21
  int v6; // w19
  __int64 v7; // x20
  __int64 v8; // x22
  const char *v9; // x23
  __int64 v10; // x1
  __int64 v11; // x3
  __int64 v12; // x4
  __int64 v13; // x5
  __int64 v14; // x6
  __int64 v15; // x7
  int v17; // w3
  __int64 v18; // [xsp+0h] [xbp-30h]

  v5 = *(const char **)(a4 + 16);
  v6 = a5;
  v7 = a3;
  v8 = a1;
  if ( !v5 )
  {
    ERR_put_error(20, 0LL, 137, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 534);
    return 0LL;
  }
  v9 = *(const char **)(a4 + 8);
  if ( (unsigned int)sub_9A0D4(*(const char **)(a4 + 8), "email") )
  {
    if ( (unsigned int)sub_9A0D4(v9, "URI") )
    {
      if ( (unsigned int)sub_9A0D4(v9, "DNS") )
      {
        if ( (unsigned int)sub_9A0D4(v9, "RID") )
        {
          if ( (unsigned int)sub_9A0D4(v9, "IP") )
          {
            if ( (unsigned int)sub_9A0D4(v9, "dirName") )
            {
              if ( (unsigned int)sub_9A0D4(v9, "otherName") )
              {
                ERR_put_error(20, 0LL, 160, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 553);
                ERR_add_error_data(2u, (__int64)"name=", (__int64)v9, v11, v12, v13, v14, v15, v18);
                return 0LL;
              }
              v17 = 0;
            }
            else
            {
              v17 = 4;
            }
          }
          else
          {
            v17 = 7;
          }
        }
        else
        {
          v17 = 8;
        }
      }
      else
      {
        v17 = 2;
      }
    }
    else
    {
      v17 = 6;
    }
  }
  else
  {
    v17 = 1;
  }
  return a2i_GENERAL_NAME(v8, v10, v7, v17, v5, v6);
}

//----- (00000000000AE130) ----------------------------------------------------
__int64 __fastcall a2i_GENERAL_NAME(__int64 a1, __int64 a2, __int64 a3, int a4, const char *a5, int a6)
{
  int v6; // w24
  const char *v7; // x21
  int v8; // w22
  __int64 v9; // x23
  __int64 v10; // x20
  __int64 v11; // x19
  _DWORD *v12; // x23
  int v13; // w0
  int v14; // w2
  __int16 v15; // w4
  char *v16; // x24
  __int64 v17; // x0
  __int64 v18; // x0
  signed __int64 v19; // x24
  char *v20; // x0
  char *v21; // x23
  size_t v22; // x24
  __int64 v23; // x0
  unsigned __int64 **v24; // x24
  unsigned __int64 *v25; // x25
  __int64 v26; // x0
  __int64 v27; // x0
  __int64 v28; // x0
  int v29; // w2
  __int16 v30; // w4
  __int64 v31; // x3
  __int64 v32; // x4
  __int64 v33; // x5
  __int64 v34; // x6
  __int64 v35; // x7
  __int64 v36; // x3
  __int64 v37; // x4
  __int64 v38; // x5
  __int64 v39; // x6
  __int64 v40; // x7
  __int64 v42; // [xsp+0h] [xbp-40h]

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a1;
  if ( !a5 )
  {
    ERR_put_error(20, 0LL, 137, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 440);
    return 0LL;
  }
  v11 = a1;
  if ( a1 || (v11 = GENERAL_NAME_new()) != 0 )
  {
    switch ( v8 )
    {
      case 0:
        v16 = strchr(v7, 59);
        if ( v16 )
        {
          v17 = OTHERNAME_new();
          *(_QWORD *)(v11 + 8) = v17;
          if ( v17 )
          {
            ASN1_TYPE_free(*(_QWORD *)(v17 + 8));
            ASN1_generate_v3(v16 + 1, v9);
            *(_QWORD *)(*(_QWORD *)(v11 + 8) + 8LL) = v18;
            if ( v18 )
            {
              v19 = (unsigned __int64)(unsigned int)((_DWORD)v16 - (_DWORD)v7) << 32;
              v20 = (char *)malloc((v19 + 0x100000000LL) >> 32);
              v21 = v20;
              if ( v20 )
              {
                v22 = v19 >> 32;
                strncpy(v20, v7, v22);
                v21[v22] = 0;
                OBJ_txt2obj(v21, 0);
                **(_QWORD **)(v11 + 8) = v23;
                free(v21);
                if ( **(_QWORD **)(v11 + 8) )
                  goto LABEL_28;
              }
            }
          }
        }
        v14 = 148;
        v15 = 494;
        goto LABEL_35;
      case 1:
      case 2:
      case 6:
        v12 = ASN1_STRING_type_new(22);
        *(_QWORD *)(v11 + 8) = v12;
        if ( v12 )
        {
          v13 = strlen(v7);
          if ( (unsigned int)ASN1_STRING_set((__int64)v12, v7, v13) )
            goto LABEL_28;
        }
        v14 = 65;
        v15 = 507;
        goto LABEL_35;
      case 4:
        v24 = (unsigned __int64 **)X509_NAME_new();
        if ( v24 )
        {
          v25 = (unsigned __int64 *)X509V3_get_section(v9);
          if ( v25 )
          {
            if ( (unsigned int)X509V3_NAME_from_section(v24, v25, 4097) )
            {
              *(_QWORD *)(v11 + 8) = v24;
              X509V3_section_free(v9, (__int64)v25);
              goto LABEL_28;
            }
          }
          else
          {
            ERR_put_error(20, 0LL, 153, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 599);
            ERR_add_error_data(2u, (__int64)"section=", (__int64)v7, v36, v37, v38, v39, v40, v42);
          }
        }
        else
        {
          v25 = 0LL;
        }
        X509_NAME_free((__int64)v24);
        X509V3_section_free(v9, (__int64)v25);
        v14 = 105;
        v15 = 487;
LABEL_35:
        ERR_put_error(20, 0LL, v14, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", v15);
        if ( !v10 )
          goto LABEL_36;
        return 0LL;
      case 7:
        if ( v6 )
        {
          a2i_IPADDRESS_NC(v7);
          *(_QWORD *)(v11 + 8) = v26;
          if ( !v26 )
          {
LABEL_30:
            v29 = 100;
            v30 = 479;
LABEL_31:
            ERR_put_error(20, 0LL, v29, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", v30);
            ERR_add_error_data(2u, (__int64)"value=", (__int64)v7, v31, v32, v33, v34, v35, v42);
            if ( !v10 )
LABEL_36:
              GENERAL_NAME_free(v11);
            return 0LL;
          }
        }
        else
        {
          v28 = a2i_IPADDRESS(v7);
          *(_QWORD *)(v11 + 8) = v28;
          if ( !v28 )
            goto LABEL_30;
        }
LABEL_28:
        *(_DWORD *)v11 = v8;
        return v11;
      case 8:
        OBJ_txt2obj(v7, 0);
        if ( v27 )
        {
          *(_QWORD *)(v11 + 8) = v27;
          *(_DWORD *)v11 = v8;
          return v11;
        }
        v29 = 101;
        v30 = 465;
        goto LABEL_31;
      default:
        v14 = 161;
        v15 = 499;
        goto LABEL_35;
    }
  }
  ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 449);
  return v11;
}

//----- (00000000000AE464) ----------------------------------------------------
signed __int64 __fastcall sub_AE464(__int64 a1, unsigned __int64 *a2, int a3)
{
  int v3; // w19
  unsigned __int64 *v4; // x20
  unsigned __int64 **v6; // x21
  __int64 v7; // x8
  signed int v8; // w22
  unsigned __int64 *v9; // x0
  __int64 v10; // x24
  __int64 v11; // x0
  _BYTE *v12; // x23
  __int64 v13; // x24

  v3 = a3;
  v4 = a2;
  if ( !a1 )
    goto LABEL_24;
  if ( *(_DWORD *)a1 == 1 )
    return 1LL;
  if ( *(_QWORD *)(a1 + 16) )
  {
    v6 = (unsigned __int64 **)X509_get_subject_name(*(_QWORD *)(a1 + 16));
    goto LABEL_8;
  }
  v7 = *(_QWORD *)(a1 + 24);
  if ( !v7 )
  {
LABEL_24:
    ERR_put_error(20, 0LL, 145, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 359);
    v12 = 0LL;
LABEL_18:
    v13 = 0LL;
LABEL_19:
    GENERAL_NAME_free(v13);
    ASN1_STRING_free((__int64)v12);
    return 0LL;
  }
  v6 = *(unsigned __int64 ***)(*(_QWORD *)v7 + 32LL);
LABEL_8:
  v8 = -1;
  while ( 1 )
  {
    v8 = X509_NAME_get_index_by_NID(v6, 0x30u, v8);
    if ( v8 & 0x80000000 )
      return 1LL;
    v9 = X509_NAME_get_entry(v6, v8);
    v10 = (__int64)v9;
    v11 = X509_policy_node_get0_parent((__int64)v9);
    v12 = ASN1_STRING_dup(v11);
    if ( v3 )
    {
      X509_NAME_delete_entry(v6, v8);
      X509_NAME_ENTRY_free(v10);
      --v8;
    }
    if ( !v12 || (v13 = GENERAL_NAME_new()) == 0 )
    {
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 380);
      goto LABEL_18;
    }
    *(_QWORD *)(v13 + 8) = v12;
    *(_DWORD *)v13 = 1;
    if ( !sk_push(v4, v13) )
    {
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_alt.c", 387);
      v12 = 0LL;
      goto LABEL_19;
    }
  }
}

//----- (00000000000AE5E0) ----------------------------------------------------
__int64 __fastcall sub_AE5E0(__int64 a1, int *a2, __int64 a3)
{
  unsigned __int64 v3; // x20
  int *v4; // x19
  __int64 result; // x0
  __int64 v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = a2;
  v7 = *(_QWORD *)(v3 + 40);
  v6 = a3;
  X509V3_add_value_bool("CA", *a2, (unsigned __int64 **)&v6);
  X509V3_add_value_int("pathlen", *((unsigned __int8 ***)v4 + 1), (unsigned __int64 **)&v6);
  result = v6;
  *(_QWORD *)(v3 + 40);
  return result;
}

//----- (00000000000AE654) ----------------------------------------------------
__int64 __fastcall sub_AE654(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x19
  unsigned __int64 v5; // x21
  __int64 *v6; // x25
  const char *v7; // x26
  __int64 v8; // x7
  __int64 v10; // [xsp+0h] [xbp-40h]

  v3 = a3;
  v4 = ASN1_item_new((unsigned __int8 *)&BASIC_CONSTRAINTS_it);
  if ( !v4 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_bcons.c", 112);
    return v4;
  }
  if ( sk_num(v3) )
  {
    v5 = 0LL;
    do
    {
      v6 = (__int64 *)sk_value(v3, v5);
      v7 = (const char *)v6[1];
      if ( (unsigned int)strcmp((const char *)v6[1], "CA") )
      {
        if ( (unsigned int)strcmp(v7, "pathlen") )
        {
          ERR_put_error(20, 0LL, 123, (__int64)"external/boringssl/src/crypto/x509v3/v3_bcons.c", 124);
          ERR_add_error_data(6u, (__int64)"section:", *v6, (__int64)",name:", v6[1], (__int64)",value:", v6[2], v8, v10);
LABEL_13:
          ASN1_item_free(v4, (unsigned __int8 *)&BASIC_CONSTRAINTS_it);
          return 0LL;
        }
        if ( !(unsigned int)X509V3_get_value_int((__int64)v6, (_QWORD *)(v4 + 8)) )
          goto LABEL_13;
      }
      else if ( !(unsigned int)X509V3_get_value_bool((__int64)v6, (_DWORD *)v4) )
      {
        goto LABEL_13;
      }
      ++v5;
    }
    while ( v5 < (unsigned __int64)sk_num(v3) );
  }
  return v4;
}

//----- (00000000000AE7AC) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_BASIC_CONSTRAINTS(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&BASIC_CONSTRAINTS_it);
}

//----- (00000000000AE7B8) ----------------------------------------------------
void i2d_BASIC_CONSTRAINTS()
{
  ASN1_item_i2d();
}

//----- (00000000000AE7C4) ----------------------------------------------------
__int64 BASIC_CONSTRAINTS_new()
{
  return ASN1_item_new((unsigned __int8 *)&BASIC_CONSTRAINTS_it);
}

//----- (00000000000AE7D0) ----------------------------------------------------
void __fastcall BASIC_CONSTRAINTS_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&BASIC_CONSTRAINTS_it);
}

//----- (00000000000AE7DC) ----------------------------------------------------
__int64 __fastcall i2v_ASN1_BIT_STRING(__int64 result, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 v5; // x8
  __int64 v6; // [xsp+0h] [xbp-20h]
  __int64 v7; // [xsp+8h] [xbp-18h]

  v3 = a2;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = a3;
  v4 = *(_QWORD *)(result + 96);
  if ( *(_QWORD *)(v4 + 8) )
  {
    do
    {
      result = ASN1_BIT_STRING_get_bit(v3, *(_DWORD *)v4);
      if ( (_DWORD)result )
        result = X509V3_add_value(*(const char **)(v4 + 8), 0LL, (unsigned __int64 **)&v6);
      v5 = *(_QWORD *)(v4 + 32);
      v4 += 24LL;
    }
    while ( v5 );
    a3 = v6;
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v7 )
    result = a3;
  return result;
}

//----- (00000000000AE868) ----------------------------------------------------
signed int *__fastcall v2i_ASN1_BIT_STRING(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  __int64 v3; // x21
  unsigned __int64 *v4; // x20
  signed int *v5; // x19
  unsigned __int64 v6; // x22
  unsigned __int64 *v7; // x0
  __int64 v8; // x8
  __int64 *v9; // x23
  const char *v10; // x25
  const char *v11; // x24
  signed __int64 v12; // x26
  __int64 v13; // x7
  __int64 v15; // [xsp+0h] [xbp-40h]

  v3 = a1;
  v4 = a3;
  v5 = ASN1_STRING_type_new(3);
  if ( v5 )
  {
    if ( sk_num(v4) )
    {
      v6 = 0LL;
      while ( 1 )
      {
        v7 = sk_value(v4, v6);
        v8 = *(_QWORD *)(v3 + 96);
        v9 = (__int64 *)v7;
        v10 = *(const char **)(v8 + 8);
        if ( !v10 )
        {
LABEL_15:
          ERR_put_error(20, 0LL, 156, (__int64)"external/boringssl/src/crypto/x509v3/v3_bitst.c", 134);
          ERR_add_error_data(
            6u,
            (__int64)"section:",
            *v9,
            (__int64)",name:",
            v9[1],
            (__int64)",value:",
            v9[2],
            v13,
            v15);
          goto LABEL_16;
        }
        v11 = (const char *)v7[1];
        v12 = v8 + 16;
        while ( (unsigned int)strcmp(*(const char **)v12, v11) && (unsigned int)strcmp(v10, v11) )
        {
          v10 = *(const char **)(v12 + 16);
          v12 += 24LL;
          if ( !v10 )
            goto LABEL_15;
        }
        if ( !(unsigned int)ASN1_BIT_STRING_set_bit(v5, *(_DWORD *)(v12 - 16), 1) )
          break;
        if ( !*(_QWORD *)(v12 - 8) )
          goto LABEL_15;
        if ( ++v6 >= (unsigned __int64)sk_num(v4) )
          return v5;
      }
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_bitst.c", 126);
LABEL_16:
      ASN1_STRING_free((__int64)v5);
      v5 = 0LL;
    }
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_bitst.c", 117);
  }
  return v5;
}

//----- (00000000000AE9DC) ----------------------------------------------------
void __fastcall X509V3_EXT_nconf(__int64 *a1, __int64 a2, const char *a3, const char *a4)
{
  const char *v4; // x22
  __int64 *v5; // x21
  const char *v6; // x19
  __int64 v7; // x20
  int v8; // w23
  const char *v9; // x22
  int v10; // t1
  int v11; // w8
  int v12; // w0
  const char *v13; // x22
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  const char *v17; // [xsp+0h] [xbp-40h]
  __int64 v18; // [xsp+8h] [xbp-38h]

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v17 = a4;
  if ( strlen(a4) >= 9 )
  {
    if ( (unsigned int)strncmp(v4, "critical,", 9uLL) )
    {
      v8 = 0;
    }
    else
    {
      v9 = v4 + 8;
      do
        v10 = *((unsigned __int8 *)v9++ + 1);
      while ( (unsigned int)isspace(v10) );
      v8 = 1;
      v17 = v9;
    }
  }
  else
  {
    v8 = 0;
  }
  v11 = sub_AEB28(&v17);
  if ( v11 )
  {
    sub_AEBD8(v6, v17, v8, v11, v7);
  }
  else
  {
    v12 = (unsigned __int64)OBJ_sn2nid(v6);
    v13 = v17;
    if ( !sub_AEDA0(v5, v7, v12, v8, v17) )
    {
      ERR_put_error(20, 0LL, 110, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 98);
      ERR_add_error_data(
        4u,
        (__int64)"name=",
        (__int64)v6,
        (__int64)", value=",
        (__int64)v13,
        v14,
        v15,
        v16,
        (__int64)v17);
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000AEB28) ----------------------------------------------------
__int64 __fastcall sub_AEB28(const char **a1)
{
  _QWORD *v1; // x19
  const char *v2; // x20
  signed __int64 v3; // x22
  unsigned int v4; // w21
  signed __int64 v5; // x20
  int v6; // t1

  v1 = a1;
  v2 = *a1;
  if ( strlen(*a1) < 4 || (v3 = 4LL, (unsigned int)strncmp(v2, "DER:", 4uLL)) )
  {
    if ( strlen(v2) < 5 )
      return 0;
    v3 = 5LL;
    if ( (unsigned int)strncmp(v2, "ASN1:", 5uLL) )
      return 0;
    v4 = 2;
  }
  else
  {
    v4 = 1;
  }
  v5 = (signed __int64)&v2[v3 - 1];
  do
    v6 = *(unsigned __int8 *)(v5++ + 1);
  while ( (unsigned int)isspace(v6) );
  *v1 = v5;
  return v4;
}

//----- (00000000000AEBD8) ----------------------------------------------------
void __fastcall sub_AEBD8(const char *a1, const char *a2, int a3, int a4, __int64 a5)
{
  const char *v5; // x21
  __int64 v6; // x23
  int v7; // w24
  int v8; // w20
  const char *v9; // x22
  void **v10; // x0
  void **v11; // x19
  _BYTE *v12; // x22
  __int64 v13; // x3
  __int64 v14; // x4
  __int64 v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  const char *v18; // x1
  __int64 v19; // x2
  _BYTE *v20; // x0
  int v21; // w0
  _DWORD *v22; // x0
  __int64 v23; // x21
  __int64 v24; // [xsp+0h] [xbp-50h]
  __int64 v25; // [xsp+8h] [xbp-48h]
  _BYTE *v26; // [xsp+10h] [xbp-40h]
  __int64 v27; // [xsp+18h] [xbp-38h]

  v5 = a2;
  v6 = a5;
  v7 = a4;
  v8 = a3;
  v9 = a1;
  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v25 = 0LL;
  OBJ_txt2obj(a1, 0);
  v11 = v10;
  if ( !v10 )
  {
    ERR_put_error(20, 0LL, 113, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 275);
    v18 = "name=";
    v19 = (__int64)v9;
LABEL_13:
    ERR_add_error_data(2u, (__int64)v18, v19, v13, v14, v15, v16, v17, v24);
    v12 = 0LL;
    v23 = 0LL;
    goto LABEL_14;
  }
  if ( v7 == 2 )
  {
    v26 = 0LL;
    ASN1_generate_v3(v5, v6);
    v12 = v20;
    if ( v20 )
    {
      i2d_ASN1_TYPE();
      v25 = v21;
      ASN1_TYPE_free((__int64)v12);
      v12 = v26;
    }
    if ( !v12 )
      goto LABEL_12;
  }
  else if ( v7 != 1 || (v12 = sub_99F20(v5, &v25)) == 0LL )
  {
LABEL_12:
    ERR_put_error(20, 0LL, 116, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 286);
    v18 = "value=";
    v19 = (__int64)v5;
    goto LABEL_13;
  }
  v22 = ASN1_STRING_type_new(4);
  v23 = (__int64)v22;
  if ( v22 )
  {
    *((_QWORD *)v22 + 1) = v12;
    *v22 = v25;
    X509_EXTENSION_create_by_OBJ(0LL, (__int64)v11, v8, (__int64)v22);
    v12 = 0LL;
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 292);
  }
LABEL_14:
  ASN1_OBJECT_free(v11);
  ASN1_STRING_free(v23);
  if ( v12 )
    free(v12);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v27;
}

//----- (00000000000AEDA0) ----------------------------------------------------
__int64 __fastcall sub_AEDA0(__int64 *a1, __int64 a2, int a3, int a4, const char *a5)
{
  const char *v5; // x22
  int v6; // w20
  unsigned int v7; // w19
  __int64 v8; // x23
  __int64 *v9; // x24
  unsigned __int64 *v10; // x0
  __int64 v11; // x21
  unsigned __int64 *v12; // x24
  int v13; // w2
  __int16 v14; // w4
  __int64 v15; // x19
  __int64 (*v17)(void); // x8
  __int64 v18; // x23
  unsigned __int8 *v19; // x1
  __int64 v20; // x0
  __int64 v21; // x0
  __int64 v22; // x5
  __int64 v23; // x6
  __int64 v24; // x7
  __int64 v25; // x0
  __int64 v26; // x3
  __int64 v27; // x4
  __int64 v28; // x5
  __int64 v29; // x6
  __int64 v30; // x7
  __int64 v31; // [xsp+0h] [xbp-30h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( !a3 )
  {
    v13 = 158;
    v14 = 128;
    goto LABEL_9;
  }
  v10 = X509V3_EXT_get_nid(a3);
  v11 = (__int64)v10;
  if ( !v10 )
  {
    v13 = 157;
    v14 = 132;
    goto LABEL_9;
  }
  if ( !v10[9] )
  {
    v17 = (__int64 (*)(void))v10[7];
    if ( v17 )
      goto LABEL_32;
    v17 = (__int64 (*)(void))v10[11];
    if ( !v17 )
    {
      ERR_put_error(20, 0LL, 115, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 165);
      OBJ_nid2sn(v7);
      ERR_add_error_data(2u, (__int64)"name=", v25, v26, v27, v28, v29, v30, v31);
      return 0LL;
    }
    if ( *(_QWORD *)(v8 + 48) && *(_QWORD *)(v8 + 40) )
    {
LABEL_32:
      v18 = v17();
      if ( v18 )
        goto LABEL_20;
      return 0LL;
    }
    v13 = 139;
    v14 = 159;
LABEL_9:
    ERR_put_error(20, 0LL, v13, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", v14);
    return 0LL;
  }
  if ( *v5 == 64 )
  {
    v12 = (unsigned __int64 *)sub_A5C14(v9, (__int64)(v5 + 1));
    if ( !v12 )
    {
LABEL_22:
      ERR_put_error(20, 0LL, 121, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 142);
      OBJ_nid2sn(v7);
      ERR_add_error_data(4u, (__int64)"name=", v21, (__int64)",section=", (__int64)v5, v22, v23, v24, v31);
      if ( *v5 != 64 )
        sk_pop_free(v12, (void (*)(void))X509V3_conf_free);
      return 0LL;
    }
  }
  else
  {
    v12 = X509V3_parse_list(v5);
    if ( !v12 )
      goto LABEL_22;
  }
  if ( !sk_num(v12) )
    goto LABEL_22;
  v18 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64 *))(v11 + 72))(v11, v8, v12);
  if ( *v5 != 64 )
    sk_pop_free(v12, (void (*)(void))X509V3_conf_free);
  if ( !v18 )
    return 0LL;
LABEL_20:
  sub_AF14C(v11, v7, v6, v18);
  v19 = *(unsigned __int8 **)(v11 + 8);
  v15 = v20;
  if ( v19 )
    ASN1_item_free(v18, v19);
  else
    (*(void (__fastcall **)(__int64))(v11 + 24))(v18);
  return v15;
}

//----- (00000000000AEFDC) ----------------------------------------------------
void __fastcall X509V3_EXT_nconf_nid(__int64 *a1, __int64 a2, unsigned int a3, const char *a4)
{
  const char *v4; // x22
  __int64 *v5; // x21
  unsigned int v6; // w20
  __int64 v7; // x19
  int v8; // w22
  const char *v9; // x22
  int v10; // t1
  int v11; // w23
  const char *v12; // x0
  const char *v13; // [xsp+0h] [xbp-40h]
  __int64 v14; // [xsp+8h] [xbp-38h]

  v4 = a4;
  v5 = a1;
  v6 = a3;
  v7 = a2;
  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v13 = a4;
  if ( strlen(a4) >= 9 )
  {
    if ( (unsigned int)strncmp(v4, "critical,", 9uLL) )
    {
      v8 = 0;
    }
    else
    {
      v9 = v4 + 8;
      do
        v10 = *((unsigned __int8 *)v9++ + 1);
      while ( (unsigned int)isspace(v10) );
      v13 = v9;
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  v11 = sub_AEB28(&v13);
  if ( v11 )
  {
    OBJ_nid2sn(v6);
    sub_AEBD8(v12, v13, v8, v11, v7);
  }
  else
  {
    sub_AEDA0(v5, v7, v6, v8, v13);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000AF0DC) ----------------------------------------------------
void __fastcall X509V3_EXT_i2d(int a1, int a2, __int64 a3)
{
  __int64 v3; // x19
  int v4; // w20
  unsigned int v5; // w21
  unsigned __int64 *v6; // x0

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = X509V3_EXT_get_nid(a1);
  if ( v6 )
    sub_AF14C((__int64)v6, v5, v4, v3);
  else
    ERR_put_error(20, 0LL, 157, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 225);
}

//----- (00000000000AF14C) ----------------------------------------------------
void __fastcall sub_AF14C(__int64 a1, unsigned int a2, int a3, __int64 a4)
{
  __int64 v4; // x23
  int v5; // w19
  __int64 v6; // x21
  unsigned int v7; // w20
  int v8; // w0
  int v9; // w22
  int v10; // w0
  void *v11; // x0
  _DWORD *v12; // x21
  __int64 v13; // x8
  void *v14; // [xsp+8h] [xbp-48h]
  __int64 v15; // [xsp+10h] [xbp-40h]
  __int64 v16; // [xsp+18h] [xbp-38h]

  v4 = a1;
  v5 = a3;
  v6 = a4;
  v16 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v7 = a2;
  if ( *(_QWORD *)(a1 + 8) )
  {
    v15 = 0LL;
    ASN1_item_i2d();
    v9 = v8;
    if ( v8 & 0x80000000 )
      goto LABEL_9;
  }
  else
  {
    v10 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 40))(a4, 0LL);
    v9 = v10;
    v11 = malloc(v10);
    v15 = (__int64)v11;
    if ( !v11 )
    {
LABEL_9:
      ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 214);
      goto LABEL_10;
    }
    v14 = v11;
    (*(void (__fastcall **)(__int64, void **))(v4 + 40))(v6, &v14);
  }
  v12 = ASN1_STRING_type_new(4);
  if ( !v12 )
    goto LABEL_9;
  v13 = v15;
  *v12 = v9;
  *((_QWORD *)v12 + 1) = v13;
  if ( !X509_EXTENSION_create_by_NID(0LL, v7, v5, (__int64)v12) )
    goto LABEL_9;
  ASN1_STRING_free((__int64)v12);
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000AF274) ----------------------------------------------------
signed __int64 __fastcall X509V3_EXT_add_nconf_sk(__int64 *a1, __int64 a2, __int64 a3, void ***a4)
{
  __int64 v4; // x20
  void ***v5; // x19
  __int64 *v6; // x21
  unsigned __int64 *v7; // x0
  unsigned __int64 *v8; // x22
  unsigned __int64 v9; // x23
  unsigned __int64 *v10; // x0
  __int64 v11; // x0
  __int64 v12; // x24

  v4 = a2;
  v5 = a4;
  v6 = a1;
  v7 = (unsigned __int64 *)sub_A5C14(a1, a3);
  v8 = v7;
  if ( v7 )
  {
    if ( !sk_num(v7) )
      return 1LL;
    v9 = 0LL;
    while ( 1 )
    {
      v10 = sk_value(v8, v9);
      X509V3_EXT_nconf(v6, v4, (const char *)v10[1], (const char *)v10[2]);
      v12 = v11;
      if ( !v11 )
        break;
      if ( v5 )
        X509v3_add_ext(v5, v11, -1);
      X509_EXTENSION_free(v12);
      if ( ++v9 >= (unsigned __int64)sk_num(v8) )
        return 1LL;
    }
  }
  return 0LL;
}

//----- (00000000000AF328) ----------------------------------------------------
signed __int64 __fastcall X509V3_EXT_add_nconf(__int64 *a1, __int64 a2, __int64 a3, void ***a4)
{
  if ( a4 )
    a4 = (void ***)(*a4 + 9);
  return X509V3_EXT_add_nconf_sk(a1, a2, a3, a4);
}

//----- (00000000000AF338) ----------------------------------------------------
signed __int64 __fastcall X509V3_EXT_CRL_add_nconf(__int64 *a1, __int64 a2, __int64 a3, void ***a4)
{
  if ( a4 )
    a4 = (void ***)(*a4 + 6);
  return X509V3_EXT_add_nconf_sk(a1, a2, a3, a4);
}

//----- (00000000000AF348) ----------------------------------------------------
void __fastcall X509V3_EXT_REQ_add_nconf(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // x19
  __int64 v5; // x8
  void ***v6; // x21
  int v7; // w20
  unsigned __int64 *v8; // [xsp+0h] [xbp-30h]
  __int64 v9; // [xsp+8h] [xbp-28h]

  v4 = a4;
  v5 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a4 )
    v6 = (void ***)&v8;
  else
    v6 = 0LL;
  v9 = v5;
  v8 = 0LL;
  v7 = X509V3_EXT_add_nconf_sk(a1, a2, a3, v6);
  if ( v6 && v7 )
  {
    X509_REQ_add_extensions(v4, (__int64)v8);
    sk_pop_free(v8, (void (*)(void))X509_EXTENSION_free);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000AF3E4) ----------------------------------------------------
__int64 __fastcall X509V3_get_string(__int64 a1)
{
  __int64 (**v1)(void); // x8

  if ( *(_QWORD *)(a1 + 48) )
  {
    v1 = *(__int64 (***)(void))(a1 + 40);
    if ( v1 )
    {
      if ( *v1 )
        return (*v1)();
    }
  }
  ERR_put_error(20, 0LL, 147, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 395);
  return 0LL;
}

//----- (00000000000AF434) ----------------------------------------------------
__int64 __fastcall X509V3_get_section(__int64 a1)
{
  __int64 v1; // x8
  __int64 (*v2)(void); // x2

  if ( *(_QWORD *)(a1 + 48) )
  {
    v1 = *(_QWORD *)(a1 + 40);
    if ( v1 )
    {
      v2 = *(__int64 (**)(void))(v1 + 8);
      if ( v2 )
        return v2();
    }
  }
  ERR_put_error(20, 0LL, 147, (__int64)"external/boringssl/src/crypto/x509v3/v3_conf.c", 406);
  return 0LL;
}

//----- (00000000000AF484) ----------------------------------------------------
__int64 __fastcall X509V3_string_free(__int64 result, __int64 a2)
{
  __int64 (__fastcall *v2)(_QWORD); // x2

  if ( a2 )
  {
    v2 = *(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(result + 40) + 16LL);
    if ( v2 )
      result = v2(*(_QWORD *)(result + 48));
  }
  return result;
}

//----- (00000000000AF4A0) ----------------------------------------------------
__int64 __fastcall X509V3_section_free(__int64 result, __int64 a2)
{
  __int64 (__fastcall *v2)(_QWORD); // x2

  if ( a2 )
  {
    v2 = *(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(result + 40) + 24LL);
    if ( v2 )
      result = v2(*(_QWORD *)(result + 48));
  }
  return result;
}

//----- (00000000000AF4BC) ----------------------------------------------------
__int64 __fastcall X509V3_set_nconf(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 40) = off_104588;
  *(_QWORD *)(result + 48) = a2;
  return result;
}
// 104588: using guessed type __int64 (__fastcall *off_104588[2])();

//----- (00000000000AF4CC) ----------------------------------------------------
__int64 __fastcall X509V3_set_ctx(__int64 result, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)
{
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 16) = a3;
  *(_QWORD *)(result + 24) = a4;
  *(_QWORD *)(result + 32) = a5;
  *(_DWORD *)result = a6;
  return result;
}

//----- (00000000000AF4E4) ----------------------------------------------------
_BYTE *__fastcall i2s_ASN1_ENUMERATED_TABLE(__int64 a1, signed __int64 a2)
{
  unsigned __int8 **v2; // x19
  __int64 v3; // x20
  signed __int64 v4; // x0
  __int64 v5; // x9
  const char *v6; // x8

  v2 = (unsigned __int8 **)a2;
  v3 = a1;
  v4 = ASN1_ENUMERATED_get(a2);
  v5 = *(_QWORD *)(v3 + 96);
  v6 = *(const char **)(v5 + 8);
  if ( !v6 )
    return (_BYTE *)i2s_ASN1_ENUMERATED(v3, v2);
  while ( v4 != *(_DWORD *)v5 )
  {
    v6 = *(const char **)(v5 + 32);
    v5 += 24LL;
    if ( !v6 )
      return (_BYTE *)i2s_ASN1_ENUMERATED(v3, v2);
  }
  return BUF_strdup(v6);
}

//----- (00000000000AF548) ----------------------------------------------------
_QWORD *__fastcall sub_AF548(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 *v3; // x19
  __int64 v4; // x20
  _QWORD *result; // x0
  unsigned __int64 v6; // x20
  unsigned __int64 *v7; // x0
  __int64 v8; // [xsp+0h] [xbp-70h]
  char v9; // [xsp+8h] [xbp-68h]
  __int64 v10; // [xsp+58h] [xbp-18h]

  v3 = a2;
  v4 = a3;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = a3;
  result = sk_num(a2);
  if ( result )
  {
    v6 = 0LL;
    do
    {
      v7 = sk_value(v3, v6);
      i2t_ASN1_OBJECT(&v9, 80, (unsigned int *)v7);
      X509V3_add_value(0LL, &v9, (unsigned __int64 **)&v8);
      ++v6;
      result = sk_num(v3);
    }
    while ( v6 < (unsigned __int64)result );
    v4 = v8;
  }
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v10 )
    result = (_QWORD *)v4;
  return result;
}

//----- (00000000000AF5F0) ----------------------------------------------------
unsigned __int64 *__fastcall sub_AF5F0(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  unsigned __int64 *v4; // x19
  unsigned __int64 v5; // x21
  unsigned __int64 *v6; // x0
  __int64 *v7; // x22
  const char *v8; // x0
  __int64 v9; // x0
  __int64 v10; // x7
  __int64 v12; // [xsp+0h] [xbp-20h]

  v3 = a3;
  v4 = sk_new_null();
  if ( v4 )
  {
    if ( sk_num(v3) )
    {
      v5 = 0LL;
      while ( 1 )
      {
        v6 = sk_value(v3, v5);
        v7 = (__int64 *)v6;
        v8 = (const char *)v6[2];
        if ( !v8 )
          v8 = (const char *)v7[1];
        OBJ_txt2obj(v8, 0);
        if ( !v9 )
          break;
        sk_push(v4, v9);
        if ( ++v5 >= (unsigned __int64)sk_num(v3) )
          return v4;
      }
      sk_pop_free(v4, (void (*)(void))ASN1_OBJECT_free);
      ERR_put_error(20, 0LL, 129, (__int64)"external/boringssl/src/crypto/x509v3/v3_extku.c", 141);
      ERR_add_error_data(6u, (__int64)"section:", *v7, (__int64)",name:", v7[1], (__int64)",value:", v7[2], v10, v12);
      v4 = 0LL;
    }
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_extku.c", 129);
  }
  return v4;
}

//----- (00000000000AF6FC) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_EXTENDED_KEY_USAGE(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&EXTENDED_KEY_USAGE_it);
}

//----- (00000000000AF708) ----------------------------------------------------
void i2d_EXTENDED_KEY_USAGE()
{
  ASN1_item_i2d();
}

//----- (00000000000AF714) ----------------------------------------------------
__int64 EXTENDED_KEY_USAGE_new()
{
  return ASN1_item_new((unsigned __int8 *)&EXTENDED_KEY_USAGE_it);
}

//----- (00000000000AF720) ----------------------------------------------------
void __fastcall EXTENDED_KEY_USAGE_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&EXTENDED_KEY_USAGE_it);
}

//----- (00000000000AF72C) ----------------------------------------------------
_BYTE *__fastcall sub_AF72C(__int64 a1, const void **a2)
{
  const void **v2; // x19
  size_t v3; // x21
  _BYTE *v4; // x0
  _BYTE *v5; // x20

  v2 = a2;
  if ( !a2 )
    return 0LL;
  v3 = *(signed int *)a2;
  if ( !(_DWORD)v3 )
    return 0LL;
  v4 = malloc(v3 + 1);
  v5 = v4;
  if ( v4 )
  {
    memcpy(v4, v2[1], v3);
    v5[*(signed int *)v2] = 0;
  }
  else
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_ia5.c", 95);
  }
  return v5;
}

//----- (00000000000AF7B0) ----------------------------------------------------
_DWORD *__fastcall sub_AF7B0(__int64 a1, __int64 a2, const char *a3)
{
  const char *v3; // x20
  _DWORD *v4; // x19
  int v5; // w0
  int v6; // w2
  __int16 v7; // w4

  v3 = a3;
  if ( !a3 )
  {
    v6 = 124;
    v7 = 108;
    goto LABEL_7;
  }
  v4 = ASN1_STRING_type_new(22);
  if ( !v4 )
  {
LABEL_5:
    v6 = 65;
    v7 = 120;
LABEL_7:
    ERR_put_error(20, 0LL, v6, (__int64)"external/boringssl/src/crypto/x509v3/v3_ia5.c", v7);
    return 0LL;
  }
  v5 = strlen(v3);
  if ( !(unsigned int)ASN1_STRING_set((__int64)v4, v3, v5) )
  {
    ASN1_STRING_free((__int64)v4);
    goto LABEL_5;
  }
  return v4;
}

//----- (00000000000AF840) ----------------------------------------------------
void __fastcall sub_AF840(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x21
  __int64 v5; // x19
  unsigned __int64 v6; // x22
  unsigned __int64 *v7; // x0
  unsigned int **v8; // x24
  __int64 v9; // x3
  __int64 v10; // x4
  __int64 v11; // x5
  __int64 v12; // x6
  __int64 v13; // x7
  unsigned __int64 *v14; // x0
  unsigned __int64 *v15; // x0
  unsigned int *v16; // x2
  unsigned __int64 *v17; // x24
  int v18; // w25
  signed __int64 v19; // x26
  _BYTE *v20; // x0
  _BYTE *v21; // x25
  char v22; // [xsp+8h] [xbp-A8h]
  __int64 v23; // [xsp+58h] [xbp-58h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v23 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( sk_num(a2) )
  {
    v6 = 0LL;
    while ( 1 )
    {
      v7 = sk_value(v3, v6);
      v8 = (unsigned int **)v7;
      v14 = (unsigned __int64 *)i2v_GENERAL_NAME(v4, v7[1], v5, v9, v10, v11, v12, v13);
      v5 = (__int64)v14;
      if ( !v14 )
        goto LABEL_8;
      v15 = sk_value(v14, v6);
      v16 = *v8;
      v17 = v15;
      i2t_ASN1_OBJECT(&v22, 80, v16);
      v18 = __strlen_chk();
      v19 = (signed __int64)(((unsigned __int64)((unsigned int)strlen((const char *)v17[1]) + v18) << 32) + 21474836480LL) >> 32;
      v20 = malloc(v19);
      v21 = v20;
      if ( !v20 )
      {
        ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_info.c", 135);
        goto LABEL_10;
      }
      BUF_strlcpy(v20, &v22, v19);
      BUF_strlcat(v21, " - ", v19);
      BUF_strlcat(v21, (const char *)v17[1], v19);
      free((void *)v17[1]);
      v17[1] = (unsigned __int64)v21;
      if ( ++v6 >= (unsigned __int64)sk_num(v3) )
        goto LABEL_10;
    }
  }
  if ( !v5 )
LABEL_8:
    sk_new_null();
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000AF9D4) ----------------------------------------------------
void __fastcall sub_AF9D4(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // x20
  __int64 v4; // x21
  __int64 v5; // x22
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x23
  unsigned __int64 *v8; // x26
  _QWORD *v9; // x25
  char *v10; // x0
  int v11; // w27
  unsigned __int64 v12; // x28
  signed __int64 v13; // x28
  char *v14; // x0
  char *v15; // x27
  __int64 v16; // x0
  int v17; // w2
  __int16 v18; // w4
  __int64 v19; // x3
  __int64 v20; // x4
  __int64 v21; // x5
  __int64 v22; // x6
  __int64 v23; // x7
  __int64 v24; // [xsp+0h] [xbp-70h]
  char *v25; // [xsp+8h] [xbp-68h]
  unsigned __int64 v26; // [xsp+10h] [xbp-60h]
  __int64 v27; // [xsp+18h] [xbp-58h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v6 = sk_new_null();
  if ( !v6 )
  {
    ERR_put_error(20, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509v3/v3_info.c", 163);
    goto LABEL_18;
  }
  if ( sk_num(v3) )
  {
    v7 = 0LL;
    while ( 1 )
    {
      v8 = sk_value(v3, v7);
      v9 = (_QWORD *)ASN1_item_new((unsigned __int8 *)&ACCESS_DESCRIPTION_it);
      if ( !v9 || !sk_push(v6, (__int64)v9) )
        break;
      v10 = strchr((const char *)v8[1], 59);
      v11 = (signed int)v10;
      if ( !v10 )
      {
        v17 = 135;
        v18 = 175;
        goto LABEL_16;
      }
      v12 = v8[1];
      v25 = v10 + 1;
      v26 = v8[2];
      if ( !v2i_GENERAL_NAME_ex(v9[1], v5, v4, (__int64)&v24, 0) )
        goto LABEL_17;
      v13 = (unsigned __int64)(unsigned int)(v11 - v12) << 32;
      v14 = (char *)malloc((v13 + 0x100000000LL) >> 32);
      v15 = v14;
      if ( !v14 )
      {
        v17 = 65;
        v18 = 184;
        goto LABEL_16;
      }
      strncpy(v14, (const char *)v8[1], v13 >> 32);
      v15[v13 >> 32] = 0;
      OBJ_txt2obj(v15, 0);
      *v9 = v16;
      if ( !v16 )
      {
        ERR_put_error(20, 0LL, 101, (__int64)"external/boringssl/src/crypto/x509v3/v3_info.c", 191);
        ERR_add_error_data(2u, (__int64)"value=", (__int64)v15, v19, v20, v21, v22, v23, v24);
        free(v15);
LABEL_17:
        sk_pop_free(v6, (void (*)(void))ACCESS_DESCRIPTION_free);
        goto LABEL_18;
      }
      free(v15);
      if ( ++v7 >= (unsigned __int64)sk_num(v3) )
        goto LABEL_18;
    }
    v17 = 65;
    v18 = 170;
LABEL_16:
    ERR_put_error(20, 0LL, v17, (__int64)"external/boringssl/src/crypto/x509v3/v3_info.c", v18);
    goto LABEL_17;
  }
LABEL_18:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v27;
}

//----- (00000000000AFC08) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_ACCESS_DESCRIPTION(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&ACCESS_DESCRIPTION_it);
}

//----- (00000000000AFC14) ----------------------------------------------------
void i2d_ACCESS_DESCRIPTION()
{
  ASN1_item_i2d();
}

//----- (00000000000AFC20) ----------------------------------------------------
__int64 ACCESS_DESCRIPTION_new()
{
  return ASN1_item_new((unsigned __int8 *)&ACCESS_DESCRIPTION_it);
}

//----- (00000000000AFC2C) ----------------------------------------------------
void __fastcall ACCESS_DESCRIPTION_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&ACCESS_DESCRIPTION_it);
}

//----- (00000000000AFC38) ----------------------------------------------------
unsigned __int64 *__fastcall d2i_AUTHORITY_INFO_ACCESS(unsigned __int64 **a1, const void **a2, __int64 a3)
{
  return ASN1_item_d2i(a1, a2, a3, (unsigned __int8 *)&AUTHORITY_INFO_ACCESS_it);
}

//----- (00000000000AFC44) ----------------------------------------------------
void i2d_AUTHORITY_INFO_ACCESS()
{
  ASN1_item_i2d();
}

//----- (00000000000AFC50) ----------------------------------------------------
__int64 AUTHORITY_INFO_ACCESS_new()
{
  return ASN1_item_new((unsigned __int8 *)&AUTHORITY_INFO_ACCESS_it);
}

//----- (00000000000AFC5C) ----------------------------------------------------
void __fastcall AUTHORITY_INFO_ACCESS_free(__int64 a1)
{
  ASN1_item_free(a1, (unsigned __int8 *)&AUTHORITY_INFO_ACCESS_it);
}

//----- (00000000000AFC68) ----------------------------------------------------
signed __int64 __fastcall i2a_ACCESS_DESCRIPTION(_QWORD *a1, __int64 *a2)
{
  i2a_ASN1_OBJECT(a1, *a2);
  return 2LL;
}

//----- (00000000000AFC84) ----------------------------------------------------
void __fastcall sub_AFC84(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  s2i_ASN1_INTEGER(a1, a3);
}

//----- (00000000000AFC8C) ----------------------------------------------------
_QWORD *__fastcall X509V3_EXT_val_prn(_QWORD *result, unsigned __int64 *a2, unsigned int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  int v12; // w19
  unsigned int v13; // w20
  unsigned __int64 *v14; // x21
  _QWORD *v15; // x22
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  unsigned __int64 v24; // x23
  unsigned __int64 *v25; // x0
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  const char *v34; // x2
  const char *v35; // x3

  v12 = a4;
  v13 = a3;
  v14 = a2;
  v15 = result;
  if ( a2 )
  {
    if ( !a4 || !sk_num(a2) )
    {
      BIO_printf(v15, (__int64)"%*s", a5, a6, a7, a8, a9, a10, a11, a12, v13, &unk_B8A4C);
      if ( !sk_num(v14) )
        BIO_puts(v15, "<EMPTY>\n");
    }
    result = sk_num(v14);
    if ( result )
    {
      v24 = 0LL;
      while ( 1 )
      {
        if ( v12 )
        {
          BIO_printf(v15, (__int64)"%*s", v16, v17, v18, v19, v20, v21, v22, v23, v13, &unk_B8A4C);
        }
        else if ( v24 )
        {
          BIO_printf(v15, (__int64)", ", v16, v17, v18, v19, v20, v21, v22, v23);
        }
        v25 = sk_value(v14, v24);
        v34 = (const char *)v25[1];
        v35 = (const char *)v25[2];
        if ( !v34 )
          break;
        if ( v35 )
        {
          BIO_printf(v15, (__int64)"%s:%s", v26, v27, v28, v29, v30, v31, v32, v33);
          if ( !v12 )
            goto LABEL_20;
          goto LABEL_19;
        }
        BIO_puts(v15, v34);
        if ( v12 )
          goto LABEL_19;
LABEL_20:
        ++v24;
        result = sk_num(v14);
        if ( v24 >= (unsigned __int64)result )
          return result;
      }
      BIO_puts(v15, v35);
      if ( !v12 )
        goto LABEL_20;
LABEL_19:
      BIO_puts(v15, "\n");
      goto LABEL_20;
    }
  }
  return result;
}

//----- (00000000000AFDF4) ----------------------------------------------------
void __fastcall X509V3_EXT_print(_QWORD *a1, unsigned int **a2, unsigned int a3, unsigned int a4)
{
  unsigned int **v4; // x23
  _QWORD *v5; // x22
  unsigned int v6; // w20
  unsigned int v7; // w24
  unsigned __int64 *v8; // x0
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  unsigned __int64 *v17; // x19
  unsigned int *v18; // x8
  unsigned __int8 *v19; // x3
  __int64 v20; // x2
  unsigned __int64 *v21; // x21
  int v22; // w8
  const char *v23; // x1
  __int64 (__fastcall *v24)(unsigned __int64 *, unsigned __int64 *); // x8
  void *v25; // x23
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  unsigned __int8 *v34; // x1
  int v35; // w8
  __int64 (__fastcall *v36)(unsigned __int64 *, unsigned __int64 *, _QWORD); // x8
  double v37; // d0
  double v38; // d1
  double v39; // d2
  double v40; // d3
  double v41; // d4
  double v42; // d5
  double v43; // d6
  double v44; // d7
  __int64 (__fastcall *v45)(unsigned __int64 *, unsigned __int64 *, _QWORD *, _QWORD); // x8
  _BOOL4 v46; // w20
  __int64 v47; // [xsp+0h] [xbp-40h]
  __int64 v48; // [xsp+8h] [xbp-38h]

  v4 = a2;
  v5 = a1;
  v6 = a4;
  v7 = a3;
  v48 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8 = X509V3_EXT_get(a2);
  v17 = v8;
  if ( v8 )
  {
    v18 = v4[2];
    v47 = *((_QWORD *)v18 + 1);
    v19 = (unsigned __int8 *)v8[1];
    v20 = (signed int)*v18;
    if ( v19 )
    {
      v21 = ASN1_item_d2i(0LL, (const void **)&v47, v20, v19);
      if ( !v21 )
      {
LABEL_14:
        v35 = (v7 >> 16) & 0xF;
        if ( (unsigned int)(v35 - 2) >= 2 )
        {
          if ( v35 && v35 == 1 )
          {
            v23 = "%*s<Parse Error>";
            goto LABEL_18;
          }
          goto LABEL_33;
        }
LABEL_20:
        BIO_hexdump(v5, *((_QWORD *)v4[2] + 1), (signed int)*v4[2], v6);
        goto LABEL_33;
      }
    }
    else
    {
      v21 = (unsigned __int64 *)((__int64 (__fastcall *)(_QWORD, __int64 *, __int64))v8[4])(0LL, &v47, v20);
      if ( !v21 )
        goto LABEL_14;
    }
    v24 = (__int64 (__fastcall *)(unsigned __int64 *, unsigned __int64 *))v17[6];
    if ( v24 )
    {
      v25 = (void *)v24(v17, v21);
      if ( v25 )
      {
        BIO_printf(v5, (__int64)"%*s%s", v26, v27, v28, v29, v30, v31, v32, v33, v6, &unk_B8A4C, v25);
        sk_pop_free(0LL, (void (*)(void))X509V3_conf_free);
        free(v25);
        v34 = (unsigned __int8 *)v17[1];
        if ( !v34 )
          goto LABEL_32;
        goto LABEL_31;
      }
    }
    else
    {
      v36 = (__int64 (__fastcall *)(unsigned __int64 *, unsigned __int64 *, _QWORD))v17[8];
      if ( v36 )
      {
        v25 = (void *)v36(v17, v21, 0LL);
        if ( v25 )
          X509V3_EXT_val_prn(
            v5,
            (unsigned __int64 *)v25,
            v6,
            *((_DWORD *)v17 + 1) & 4,
            v37,
            v38,
            v39,
            v40,
            v41,
            v42,
            v43,
            v44);
      }
      else
      {
        v45 = (__int64 (__fastcall *)(unsigned __int64 *, unsigned __int64 *, _QWORD *, _QWORD))v17[10];
        if ( v45 )
        {
          v25 = 0LL;
          v46 = (unsigned __int64)v45(v17, v21, v5, v6) != 0;
        }
        else
        {
          v25 = 0LL;
        }
      }
    }
    sk_pop_free((unsigned __int64 *)v25, (void (*)(void))X509V3_conf_free);
    v34 = (unsigned __int8 *)v17[1];
    if ( !v34 )
    {
LABEL_32:
      ((void (__fastcall *)(unsigned __int64 *))v17[3])(v21);
      goto LABEL_33;
    }
LABEL_31:
    ASN1_item_free((__int64)v21, v34);
    goto LABEL_33;
  }
  v22 = (v7 >> 16) & 0xF;
  if ( (unsigned int)(v22 - 2) < 2 )
    goto LABEL_20;
  if ( v22 && v22 == 1 )
  {
    v23 = "%*s<Not Supported>";
LABEL_18:
    BIO_printf(v5, (__int64)v23, v9, v10, v11, v12, v13, v14, v15, v16, v6, &unk_B8A4C);
  }
LABEL_33:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000B005C) ----------------------------------------------------
signed __int64 __fastcall X509V3_extensions_print(_QWORD *a1, __int64 a2, unsigned __int64 *a3, unsigned int a4, unsigned int a5)
{
  unsigned __int64 *v5; // x21
  _QWORD *v6; // x22
  unsigned int v7; // w19
  unsigned int v8; // w20
  __int64 v9; // x23
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  unsigned __int64 v18; // x23
  unsigned int v19; // w24
  unsigned __int64 *v20; // x28
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  signed int v29; // w0
  _QWORD *v30; // x0
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  char *v39; // x2
  signed int v40; // w0
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  int v49; // w0

  v5 = a3;
  v6 = a1;
  v7 = a5;
  v8 = a4;
  v9 = a2;
  if ( !sk_num(a3) )
    return 1LL;
  if ( v9 )
  {
    BIO_printf(v6, (__int64)"%*s%s:\n", v10, v11, v12, v13, v14, v15, v16, v17, v7, &unk_B8A4C, v9);
    v7 += 4;
  }
  if ( !sk_num(v5) )
    return 1LL;
  v18 = 0LL;
  v19 = v7 + 4;
  while ( 1 )
  {
    v20 = sk_value(v5, v18);
    if ( v7 )
    {
      BIO_printf(v6, (__int64)"%*s", v21, v22, v23, v24, v25, v26, v27, v28, v7, &unk_B8A4C);
      if ( v29 < 1 )
        break;
    }
    v30 = sk_num(v20);
    i2a_ASN1_OBJECT(v6, (__int64)v30);
    v39 = (unsigned int)X509_EXTENSION_get_critical((__int64)v20) ? "critical" : &unk_B8A4C;
    BIO_printf(v6, (__int64)": %s\n", v31, v32, v33, v34, v35, v36, v37, v38, v39);
    if ( v40 < 1 )
      break;
    X509V3_EXT_print(v6, (unsigned int **)v20, v8, v19);
    if ( !v49 )
    {
      BIO_printf(v6, (__int64)"%*s", v41, v42, v43, v44, v45, v46, v47, v48, v19, &unk_B8A4C);
      ASN1_STRING_print(v6, v20[2]);
    }
    if ( (signed int)BIO_write(v6, (__int64)"\n", 1u) <= 0 )
      break;
    if ( ++v18 >= (unsigned __int64)sk_num(v5) )
      return 1LL;
  }
  return 0LL;
}

//----- (00000000000B01EC) ----------------------------------------------------
__int64 __fastcall X509V3_EXT_print_fp(__int64 a1, unsigned int **a2, unsigned int a3, unsigned int a4)
{
  unsigned int **v4; // x20
  unsigned int v5; // w19
  unsigned int v6; // w22
  _QWORD *v7; // x0
  __int64 v8; // x21
  unsigned int v9; // w0
  unsigned int v10; // w19

  v4 = a2;
  v5 = a4;
  v6 = a3;
  v7 = BIO_new_fp(a1, 0);
  v8 = (__int64)v7;
  if ( !v7 )
    return 0LL;
  X509V3_EXT_print(v7, v4, v6, v5);
  v10 = v9;
  BIO_free(v8);
  return v10;
}

//----- (00000000000B0254) ----------------------------------------------------
void __fastcall ASN1_mbstring_copy(__int64 *a1, const char *a2, signed int a3, int a4, __int64 a5)
{
  ASN1_mbstring_ncopy(a1, a2, a3, a4, a5, 0LL, 0LL);
}

//----- (00000000000B0260) ----------------------------------------------------
void __fastcall ASN1_mbstring_ncopy(__int64 *a1, const char *a2, signed int a3, int a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // x22
  __int64 v8; // x23
  __int64 v9; // x25
  int v10; // w20
  signed int v11; // w21
  char *v12; // x19
  __int64 *v13; // x24
  int v14; // w27
  char *v15; // x25
  signed int v16; // w26
  int v17; // w0
  int v18; // w2
  __int16 v19; // w4
  __int64 v20; // x4
  __int64 v21; // x5
  __int64 v22; // x6
  __int64 v23; // x7
  __int64 v24; // x3
  __int64 v25; // x4
  __int64 v26; // x5
  __int64 v27; // x6
  __int64 v28; // x7
  const char *v29; // x1
  __int64 v30; // x4
  __int64 v31; // x5
  __int64 v32; // x6
  __int64 v33; // x7
  int v34; // w22
  unsigned int v35; // w25
  __int64 v36; // x23
  void *v37; // x0
  signed int v38; // w26
  _DWORD *v39; // x0
  __int64 (__fastcall *v40)(unsigned __int64, __int64); // x24
  int v41; // w28
  char *v42; // x25
  signed int v43; // w24
  unsigned __int64 v44; // x2
  unsigned int v45; // t1
  __int64 v46; // x9
  __int64 v47; // x8
  __int64 v48; // x2
  int v49; // w0
  _BYTE *v50; // x8
  __int64 v51; // [xsp+0h] [xbp-90h]
  __int64 v52; // [xsp+0h] [xbp-90h]
  _BYTE *v53; // [xsp+8h] [xbp-88h]
  __int64 v54; // [xsp+10h] [xbp-80h]
  unsigned __int64 v55; // [xsp+18h] [xbp-78h]
  __int64 v56; // [xsp+38h] [xbp-58h]

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = (char *)a2;
  v13 = a1;
  v56 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v54 = a5;
  if ( a3 == -1 )
    v11 = strlen(a2);
  if ( !v9 )
    v54 = 10246LL;
  v14 = v11;
  switch ( v10 )
  {
    case 4096:
      v14 = 0;
      if ( !v11 )
        goto LABEL_18;
      v15 = v12;
      v16 = v11;
      while ( 1 )
      {
        v17 = UTF8_getc(v15, v16, &v55);
        if ( v17 & 0x80000000 )
          break;
        v16 -= v17;
        v15 += v17;
        ++v14;
        if ( !v16 )
          goto LABEL_18;
      }
      v18 = 150;
      v19 = 133;
      goto LABEL_34;
    case 4097:
      goto LABEL_18;
    case 4098:
      if ( !(v11 & 1) )
      {
        v14 = v11 >> 1;
        goto LABEL_18;
      }
      v18 = 142;
      v19 = 114;
      goto LABEL_34;
    case 4100:
      if ( !(v11 & 3) )
      {
        v14 = v11 >> 2;
LABEL_18:
        if ( v8 >= 1 && v14 < v8 )
        {
          ERR_put_error(12, 0LL, 174, (__int64)"external/boringssl/src/crypto/asn1/a_mbstr.c", 148);
          BIO_snprintf((__int64)&v55, 32LL, (__int64)"%ld", v8, v20, v21, v22, v23, v51);
          v29 = "minsize=";
LABEL_24:
          ERR_add_error_data(2u, (__int64)v29, (__int64)&v55, v24, v25, v26, v27, v28, v52);
          goto LABEL_35;
        }
        if ( v7 >= 1 && v14 > v7 )
        {
          ERR_put_error(12, 0LL, 173, (__int64)"external/boringssl/src/crypto/asn1/a_mbstr.c", 155);
          BIO_snprintf((__int64)&v55, 32LL, (__int64)"%ld", v7, v30, v31, v32, v33, v51);
          v29 = "maxsize=";
          goto LABEL_24;
        }
        if ( sub_B0768(v12, v11, v10, (__int64 (__fastcall *)(unsigned __int64, __int64))sub_B08C0, (__int64)&v54) & 0x80000000 )
        {
          v18 = 126;
          v19 = 163;
          goto LABEL_34;
        }
        if ( v54 & 2 )
        {
          v35 = 4097;
          v34 = 19;
          if ( !v13 )
            goto LABEL_35;
        }
        else if ( v54 & 0x10 )
        {
          v35 = 4097;
          v34 = 22;
          if ( !v13 )
            goto LABEL_35;
        }
        else if ( v54 & 4 )
        {
          v35 = 4097;
          v34 = 20;
          if ( !v13 )
            goto LABEL_35;
        }
        else if ( v54 & 0x800 )
        {
          v35 = 4098;
          v34 = 30;
          if ( !v13 )
            goto LABEL_35;
        }
        else
        {
          v34 = ((unsigned int)(v54 & 0x100) >> 4) | 0xC;
          v35 = ((unsigned int)(v54 & 0x100) >> 6) | 0x1000;
          if ( !v13 )
            goto LABEL_35;
        }
        v36 = *v13;
        if ( *v13 )
        {
          v37 = *(void **)(v36 + 8);
          if ( v37 )
          {
            *(_DWORD *)v36 = 0;
            free(v37);
            *(_QWORD *)(v36 + 8) = 0LL;
          }
          v38 = 0;
          *(_DWORD *)(v36 + 4) = v34;
          if ( v35 != v10 )
            goto LABEL_53;
        }
        else
        {
          v39 = ASN1_STRING_type_new(v34);
          v36 = (__int64)v39;
          if ( !v39 )
          {
            v18 = 65;
            v19 = 200;
            goto LABEL_34;
          }
          v38 = 1;
          *v13 = (__int64)v39;
          if ( v35 != v10 )
          {
LABEL_53:
            v40 = 0LL;
            v41 = 0;
            switch ( v35 & 7 )
            {
              case 0u:
                v41 = 0;
                if ( v11 )
                {
                  v42 = v12;
                  v43 = v11;
                  do
                  {
                    switch ( v10 )
                    {
                      case 4100:
                        v43 -= 4;
                        v55 = (unsigned __int64)(unsigned __int8)*v42 << 24;
                        v55 = v55 & 0xFFFFFFFFFF00FFFFLL | ((unsigned __int64)(unsigned __int8)v42[1] << 16);
                        v55 = v55 & 0xFFFFFFFFFFFF00FFLL | ((unsigned __int64)(unsigned __int8)v42[2] << 8);
                        v46 = (unsigned __int8)v42[3];
                        v42 += 4;
                        v44 = v55 | v46;
                        v55 |= v46;
                        break;
                      case 4098:
                        v47 = (unsigned __int8)*v42;
                        v43 -= 2;
                        v55 = v47 << 8;
                        v48 = (unsigned __int8)v42[1];
                        v42 += 2;
                        v44 = v48 & 0xFFFFFFFFFFFF00FFLL | ((unsigned __int64)(unsigned __int8)v47 << 8);
                        v55 = v44;
                        break;
                      case 4097:
                        v45 = (unsigned __int8)*v42++;
                        v44 = v45;
                        --v43;
                        v55 = v45;
                        break;
                      default:
                        v49 = UTF8_getc(v42, v43, &v55);
                        if ( v49 & 0x80000000 )
                          goto LABEL_65;
                        v44 = v55;
                        v43 -= v49;
                        v42 += v49;
                        break;
                    }
                    v41 += UTF8_putc(0LL, -1, v44);
                  }
                  while ( v43 );
                }
LABEL_65:
                v40 = (__int64 (__fastcall *)(unsigned __int64, __int64))sub_B0A10;
                break;
              case 1u:
                v40 = (__int64 (__fastcall *)(unsigned __int64, __int64))sub_B099C;
                v41 = v14;
                break;
              case 2u:
                v41 = 2 * v14;
                v40 = (__int64 (__fastcall *)(unsigned __int64, __int64))sub_B09B8;
                break;
              case 4u:
                v41 = 4 * v14;
                v40 = (__int64 (__fastcall *)(unsigned __int64, __int64))sub_B09DC;
                break;
              default:
                break;
            }
            v53 = malloc(v41 + 1);
            if ( v53 )
            {
              *(_DWORD *)v36 = v41;
              v50 = v53;
              *(_QWORD *)(v36 + 8) = v53;
              v50[v41] = 0;
              sub_B0768(v12, v11, v10, v40, (__int64)&v53);
              goto LABEL_35;
            }
            if ( v38 )
              ASN1_STRING_free(v36);
            v18 = 65;
            v19 = 240;
            goto LABEL_34;
          }
        }
        if ( (unsigned int)ASN1_STRING_set(v36, v12, v11) )
          goto LABEL_35;
        v18 = 65;
        v19 = 208;
        goto LABEL_34;
      }
      v18 = 149;
      v19 = 122;
LABEL_34:
      ERR_put_error(12, 0LL, v18, (__int64)"external/boringssl/src/crypto/asn1/a_mbstr.c", v19);
LABEL_35:
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v56;
      return;
    default:
      v18 = 182;
      v19 = 143;
      goto LABEL_34;
  }
}
// B0A10: using guessed type __int64 __fastcall sub_B0A10();

//----- (00000000000B0768) ----------------------------------------------------
__int64 __fastcall sub_B0768(char *a1, signed int a2, int a3, __int64 (__fastcall *a4)(unsigned __int64, __int64), __int64 a5)
{
  __int64 v5; // x19
  __int64 (__fastcall *v6)(unsigned __int64, __int64); // x20
  int v7; // w21
  signed int v8; // w22
  char *v9; // x23
  unsigned int v10; // t1
  __int64 v11; // x9
  __int64 v12; // x8
  __int64 v13; // x9
  int v14; // w0
  __int64 result; // x0
  unsigned __int64 v16; // [xsp+0h] [xbp-50h]
  __int64 v17; // [xsp+8h] [xbp-48h]

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  while ( v8 )
  {
    switch ( v7 )
    {
      case 4100:
        v8 -= 4;
        v16 = (unsigned __int64)(unsigned __int8)*v9 << 24;
        v16 = v16 & 0xFFFFFFFFFF00FFFFLL | ((unsigned __int64)(unsigned __int8)v9[1] << 16);
        v16 = v16 & 0xFFFFFFFFFFFF00FFLL | ((unsigned __int64)(unsigned __int8)v9[2] << 8);
        v11 = (unsigned __int8)v9[3];
        v9 += 4;
        v16 |= v11;
        if ( v6 )
          goto LABEL_13;
        break;
      case 4098:
        v12 = (unsigned __int8)*v9;
        v8 -= 2;
        v16 = v12 << 8;
        v13 = (unsigned __int8)v9[1];
        v9 += 2;
        v16 = v13 & 0xFFFFFFFFFFFF00FFLL | ((unsigned __int64)(unsigned __int8)v12 << 8);
        if ( v6 )
          goto LABEL_13;
        break;
      case 4097:
        v10 = (unsigned __int8)*v9++;
        --v8;
        v16 = v10;
        if ( v6 )
          goto LABEL_13;
        break;
      default:
        v14 = UTF8_getc(v9, v8, &v16);
        if ( v14 & 0x80000000 )
        {
          result = 0xFFFFFFFFLL;
          goto LABEL_16;
        }
        v8 -= v14;
        v9 += v14;
        if ( v6 )
        {
LABEL_13:
          result = v6(v16, v5);
          if ( (signed int)result < 1 )
            goto LABEL_16;
          break;
        }
        break;
    }
  }
  result = 1LL;
LABEL_16:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v17;
  return result;
}

//----- (00000000000B08C0) ----------------------------------------------------
signed __int64 __fastcall sub_B08C0(unsigned __int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 v3; // x21
  unsigned __int64 v4; // x20
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  signed __int64 result; // x0

  v2 = a2;
  v3 = *a2;
  v4 = a1;
  if ( *a2 & 2
    && (a1 > 0x7F
     || (_DWORD)a1 != 32 && (unsigned int)(a1 - 48) >= 0xA && (a1 & 0xFFFFFFDF) - 65 >= 0x1A && !__strchr_chk()) )
  {
    v3 &= 0xFFFFFFFFFFFFFFFDLL;
  }
  v5 = v3 & 0xFFFFFFFFFFFFFFEFLL;
  if ( !((v4 > 0x7F) & (v3 >> 4) & 1) )
    v5 = v3;
  if ( (v4 > 0xFF) & (v5 >> 2) & 1 )
    v5 &= 0xFFFFFFFFFFFFFFFBLL;
  if ( (v4 >> 16 != 0) & (v5 >> 11) & 1 )
    v6 = v5 & 0xFFFFFFFFFFFFF7FFLL;
  else
    v6 = v5;
  if ( !v6 )
    return 0xFFFFFFFFLL;
  result = 1LL;
  *v2 = v6;
  return result;
}

//----- (00000000000B099C) ----------------------------------------------------
signed __int64 __fastcall sub_B099C(char a1, _BYTE **a2)
{
  signed __int64 result; // x0

  **a2 = a1;
  result = 1LL;
  ++*a2;
  return result;
}

//----- (00000000000B09B8) ----------------------------------------------------
signed __int64 __fastcall sub_B09B8(__int16 a1, _BYTE **a2)
{
  _BYTE *v2; // x8
  signed __int64 result; // x0

  v2 = *a2;
  *v2 = HIBYTE(a1);
  v2[1] = a1;
  result = 1LL;
  *a2 += 2;
  return result;
}

//----- (00000000000B09DC) ----------------------------------------------------
signed __int64 __fastcall sub_B09DC(int a1, _BYTE **a2)
{
  _BYTE *v2; // x8
  signed __int64 result; // x0

  v2 = *a2;
  *v2 = HIBYTE(a1);
  v2[1] = BYTE2(a1);
  v2[2] = BYTE1(a1);
  v2[3] = a1;
  result = 1LL;
  *a2 += 4;
  return result;
}

//----- (00000000000B0A54) ----------------------------------------------------
signed __int64 __fastcall UTF8_getc(char *a1, signed int a2, unsigned __int64 *a3)
{
  char v3; // w8
  signed __int64 result; // x0
  char v5; // w9
  unsigned __int64 v6; // x8
  char v7; // w9
  char v8; // w10
  unsigned __int64 v9; // x8
  char v10; // w9
  char v11; // w10
  char v12; // w11
  unsigned __int64 v13; // x8
  char v14; // w9
  char v15; // w10
  char v16; // w11
  char v17; // w12
  unsigned __int64 v18; // x8
  char v19; // w9
  char v20; // w10
  char v21; // w11
  char v22; // w12
  char v23; // w13
  unsigned __int64 v24; // x8

  if ( a2 < 1 )
    return 0LL;
  v3 = *a1;
  if ( *a1 & 0x80 )
  {
    if ( (v3 & 0xE0) == 192 )
    {
      if ( a2 >= 2 )
      {
        v5 = a1[1];
        if ( (v5 & 0xC0) == 128 )
        {
          v6 = ((v3 & 0x1Fu) << 6) & 0xFFFFFFFFFFFFFFC0LL | v5 & 0x3F;
          if ( v6 >= 0x80 )
          {
            result = 2LL;
            *a3 = v6;
          }
          else
          {
            result = 4294967292LL;
          }
        }
        else
        {
          result = 4294967293LL;
        }
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    else if ( (v3 & 0xF0) == 224 )
    {
      if ( a2 >= 3 )
      {
        v7 = a1[1];
        if ( (v7 & 0xC0) == 128 )
        {
          v8 = a1[2];
          if ( (v8 & 0xC0) == 128 )
          {
            v9 = (((v3 & 0xFu) << 12) & 0xFFFFFFFFFFFFF03FLL | ((unsigned __int64)(v7 & 0x3F) << 6)) & 0xFFFFFFFFFFFFFFC0LL | v8 & 0x3F;
            if ( v9 >= 0x800 )
            {
              result = 3LL;
              *a3 = v9;
            }
            else
            {
              result = 4294967292LL;
            }
          }
          else
          {
            result = 4294967293LL;
          }
        }
        else
        {
          result = 4294967293LL;
        }
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    else if ( (v3 & 0xF8) == 240 )
    {
      if ( a2 >= 4 )
      {
        v10 = a1[1];
        if ( (v10 & 0xC0) == 128 )
        {
          v11 = a1[2];
          if ( (v11 & 0xC0) == 128 )
          {
            v12 = a1[3];
            if ( (v12 & 0xC0) == 128 )
            {
              v13 = ((((unsigned __int64)(*a1 & 7) << 18) & 0xFFFFFFFFFFFC0FFFLL | ((unsigned __int64)(v10 & 0x3F) << 12)) & 0xFFFFFFFFFFFFF03FLL | ((unsigned __int64)(v11 & 0x3F) << 6)) & 0xFFFFFFFFFFFFFFC0LL | v12 & 0x3F;
              if ( v13 >= 0x10000 )
              {
                result = 4LL;
                *a3 = v13;
              }
              else
              {
                result = 4294967292LL;
              }
            }
            else
            {
              result = 4294967293LL;
            }
          }
          else
          {
            result = 4294967293LL;
          }
        }
        else
        {
          result = 4294967293LL;
        }
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    else if ( (v3 & 0xFC) == 248 )
    {
      if ( a2 >= 5 )
      {
        v14 = a1[1];
        if ( (v14 & 0xC0) == 128 )
        {
          v15 = a1[2];
          if ( (v15 & 0xC0) == 128 )
          {
            v16 = a1[3];
            if ( (v16 & 0xC0) == 128 )
            {
              v17 = a1[4];
              if ( (v17 & 0xC0) == 128 )
              {
                v18 = (((((*a1 & 3) << 24) & 0xFF03FFFF | ((v14 & 0x3F) << 18)) & 0xFFFC0FFF | ((v15 & 0x3F) << 12)) & 0xFFFFF03F | ((v16 & 0x3F) << 6)) & 0xFFFFFFC0 | (unsigned __int64)(v17 & 0x3F);
                if ( v18 >= 0x200000 )
                {
                  result = 5LL;
                  *a3 = v18;
                }
                else
                {
                  result = 4294967292LL;
                }
              }
              else
              {
                result = 4294967293LL;
              }
            }
            else
            {
              result = 4294967293LL;
            }
          }
          else
          {
            result = 4294967293LL;
          }
        }
        else
        {
          result = 4294967293LL;
        }
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    else if ( (v3 & 0xFE) == 252 )
    {
      if ( a2 >= 6 )
      {
        v19 = a1[1];
        if ( (v19 & 0xC0) == 128 )
        {
          v20 = a1[2];
          if ( (v20 & 0xC0) == 128 )
          {
            v21 = a1[3];
            if ( (v21 & 0xC0) == 128 )
            {
              v22 = a1[4];
              if ( (v22 & 0xC0) == 128 )
              {
                v23 = a1[5];
                if ( (v23 & 0xC0) == 128 )
                {
                  v24 = ((((((*a1 & 1) << 30) & 0xC0FFFFFF | ((v19 & 0x3F) << 24)) & 0xFF03FFFF | ((v20 & 0x3F) << 18)) & 0xFFFC0FFF | ((v21 & 0x3F) << 12)) & 0xFFFFF03F | ((v22 & 0x3F) << 6)) & 0xFFFFFFC0 | (unsigned __int64)(v23 & 0x3F);
                  if ( v24 >> 26 )
                  {
                    result = 6LL;
                    *a3 = v24;
                  }
                  else
                  {
                    result = 4294967292LL;
                  }
                }
                else
                {
                  result = 4294967293LL;
                }
              }
              else
              {
                result = 4294967293LL;
              }
            }
            else
            {
              result = 4294967293LL;
            }
          }
          else
          {
            result = 4294967293LL;
          }
        }
        else
        {
          result = 4294967293LL;
        }
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      result = 4294967294LL;
    }
  }
  else
  {
    result = 1LL;
    *a3 = v3 & 0x7F;
  }
  return result;
}

//----- (00000000000B0D88) ----------------------------------------------------
signed __int64 __fastcall UTF8_putc(_BYTE *a1, signed int a2, unsigned __int64 a3)
{
  signed __int64 result; // x0
  unsigned int v4; // w8

  if ( a1 )
  {
    if ( a2 < 1 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    a2 = 6;
  }
  if ( a3 > 0x7F )
  {
    if ( a3 > 0x7FF )
    {
      if ( a3 >> 16 )
      {
        if ( a3 >> 21 )
        {
          if ( a3 >> 26 )
          {
            if ( a2 < 6 )
              v4 = 1;
            else
              v4 = 6;
            if ( a2 >= 6 && a1 != 0LL )
            {
              *a1 = ((unsigned int)a3 >> 30) & 1 | 0xFC;
              v4 = 6;
              a1[1] = BYTE3(a3) & 0x3F | 0x80;
              a1[2] = ((unsigned int)a3 >> 18) & 0x3F | 0x80;
              a1[3] = ((unsigned int)a3 >> 12) & 0x3F | 0x80;
              a1[4] = ((unsigned int)a3 >> 6) & 0x3F | 0x80;
              a1[5] = a3 & 0x3F | 0x80;
            }
          }
          else
          {
            if ( a2 < 5 )
              v4 = 1;
            else
              v4 = 5;
            if ( a2 >= 5 && a1 != 0LL )
            {
              *a1 = BYTE3(a3) & 3 | 0xF8;
              a1[1] = ((unsigned int)a3 >> 18) & 0x3F | 0x80;
              a1[2] = ((unsigned int)a3 >> 12) & 0x3F | 0x80;
              a1[3] = ((unsigned int)a3 >> 6) & 0x3F | 0x80;
              a1[4] = a3 & 0x3F | 0x80;
              return 5LL;
            }
          }
        }
        else
        {
          if ( a2 < 4 )
            v4 = 1;
          else
            v4 = 4;
          if ( a2 >= 4 && a1 != 0LL )
          {
            *a1 = ((unsigned int)a3 >> 18) & 7 | 0xF0;
            a1[1] = ((unsigned int)a3 >> 12) & 0x3F | 0x80;
            a1[2] = ((unsigned int)a3 >> 6) & 0x3F | 0x80;
            a1[3] = a3 & 0x3F | 0x80;
            return 4LL;
          }
        }
      }
      else
      {
        if ( a2 < 3 )
          v4 = 1;
        else
          v4 = 3;
        if ( a2 >= 3 && a1 != 0LL )
        {
          *a1 = ((unsigned __int16)a3 >> 12) | 0xE0;
          a1[1] = ((unsigned int)a3 >> 6) & 0x3F | 0x80;
          a1[2] = a3 & 0x3F | 0x80;
          return 3LL;
        }
      }
    }
    else
    {
      if ( a2 < 2 )
        v4 = 1;
      else
        v4 = 2;
      if ( a2 >= 2 && a1 != 0LL )
      {
        *a1 = ((unsigned int)a3 >> 6) & 0x1F | 0xC0;
        a1[1] = a3 & 0x3F | 0x80;
        return 2LL;
      }
    }
    result = v4;
  }
  else
  {
    if ( a1 )
      *a1 = a3;
    result = 1LL;
  }
  return result;
}

//----- (00000000000B0F8C) ----------------------------------------------------
const char *__fastcall ASN1_tag2str(unsigned int a1)
{
  unsigned int v1; // w8
  const char *result; // x0

  if ( (a1 | 8) == 266 )
    v1 = a1 & 0xFFFFFEFF;
  else
    v1 = a1;
  if ( v1 <= 0x1E )
    result = off_104E10[v1];
  else
    result = "(unknown)";
  return result;
}
// 104E10: using guessed type char *off_104E10[31];

//----- (00000000000B0FC0) ----------------------------------------------------
_QWORD *__fastcall ASN1_item_pack(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // x22
  _QWORD *v4; // x19
  _QWORD *v5; // x0
  void *v6; // x0
  _QWORD *v7; // x22
  int v8; // w0
  int v9; // w2
  __int16 v10; // w4

  v3 = a3;
  if ( !a3 || (v4 = (_QWORD *)*a3) == 0LL )
  {
    v5 = ASN1_STRING_new();
    v4 = v5;
    if ( !v5 )
    {
      ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/asn1/asn_pack.c", 70);
      return v4;
    }
    if ( v3 )
      *v3 = v5;
  }
  v7 = v4 + 1;
  v6 = (void *)v4[1];
  if ( v6 )
  {
    free(v6);
    *v7 = 0LL;
  }
  ASN1_item_i2d();
  *(_DWORD *)v4 = v8;
  if ( !v8 )
  {
    v9 = 112;
    v10 = 84;
    goto LABEL_12;
  }
  if ( !*v7 )
  {
    v9 = 65;
    v10 = 88;
LABEL_12:
    ERR_put_error(12, 0LL, v9, (__int64)"external/boringssl/src/crypto/asn1/asn_pack.c", v10);
    v4 = 0LL;
  }
  return v4;
}

//----- (00000000000B109C) ----------------------------------------------------
void __fastcall ASN1_item_unpack(signed int *a1, unsigned __int8 *a2)
{
  __int64 v2; // [xsp+0h] [xbp-20h]
  __int64 v3; // [xsp+8h] [xbp-18h]

  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = *((_QWORD *)a1 + 1);
  if ( !ASN1_item_d2i(0LL, (const void **)&v2, *a1, a2) )
    ERR_put_error(12, 0LL, 109, (__int64)"external/boringssl/src/crypto/asn1/asn_pack.c", 103);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000B1128) ----------------------------------------------------
bool __fastcall BIO_hexdump(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4)
{
  unsigned __int64 v4; // x19
  __int64 v5; // x20
  unsigned int v6; // w28
  unsigned __int64 v7; // x22
  char v8; // w10
  char v9; // w11
  char v10; // w9
  char v11; // w10
  char v12; // w9
  char v13; // w10
  char v14; // w8
  unsigned __int64 v15; // x8
  unsigned int v16; // w2
  char v17; // w9
  char v18; // w10
  char v19; // w8
  signed __int64 v20; // x9
  int v21; // w8
  unsigned int v22; // w8
  signed int v23; // w9
  unsigned int v24; // w2
  _BOOL8 result; // x0
  _QWORD *v26; // [xsp+8h] [xbp-98h]
  __int64 v27; // [xsp+10h] [xbp-90h]
  __int64 v28; // [xsp+18h] [xbp-88h]
  __int64 v29; // [xsp+20h] [xbp-80h]
  unsigned __int64 v30; // [xsp+28h] [xbp-78h]
  __int64 v31; // [xsp+30h] [xbp-70h]
  int v32; // [xsp+3Ch] [xbp-64h]
  char v33; // [xsp+40h] [xbp-60h]
  char v34; // [xsp+41h] [xbp-5Fh]
  char v35; // [xsp+42h] [xbp-5Eh]
  char v36; // [xsp+43h] [xbp-5Dh]
  char v37; // [xsp+44h] [xbp-5Ch]
  char v38; // [xsp+45h] [xbp-5Bh]
  __int64 v39; // [xsp+48h] [xbp-58h]

  v4 = a3;
  v5 = a2;
  v39 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v30 = 0LL;
  v31 = 0LL;
  v28 = 0LL;
  v29 = 0LL;
  v26 = a1;
  v27 = 0LL;
  LODWORD(v31) = a4;
  if ( !a3 )
  {
LABEL_30:
    result = 1LL;
    goto LABEL_32;
  }
  v6 = 0;
  v7 = 0LL;
  do
  {
    if ( !v6 )
    {
      BIO_indent(v26, v31, -1);
      v8 = a0123456789abcd_1[(v30 >> 24) & 0xF];
      v9 = a0123456789abcd_1[(v30 >> 20) & 0xF];
      LOBYTE(v32) = a0123456789abcd_1[(unsigned int)v30 >> 28];
      BYTE1(v32) = v8;
      v10 = a0123456789abcd_1[(v30 >> 16) & 0xF];
      v11 = a0123456789abcd_1[(unsigned __int16)v30 >> 12];
      BYTE2(v32) = v9;
      v38 = 32;
      HIBYTE(v32) = v10;
      v33 = v11;
      v12 = a0123456789abcd_1[(v30 >> 8) & 0xF];
      v13 = a0123456789abcd_1[(unsigned __int8)v30 >> 4];
      v14 = a0123456789abcd_1[v30 & 0xF];
      v37 = 32;
      v34 = v12;
      v35 = v13;
      v36 = v14;
      if ( BIO_write(v26, (__int64)&v32, 0xAu) & 0x80000000 )
        goto LABEL_31;
      v6 = HIDWORD(v29);
    }
    v15 = *(unsigned __int8 *)(v5 + v7);
    v16 = 3;
    v17 = a0123456789abcd_1[v15 >> 4];
    v18 = a0123456789abcd_1[v15 & 0xF];
    v19 = 32;
    BYTE2(v32) = 32;
    LOBYTE(v32) = v17;
    BYTE1(v32) = v18;
    if ( v6 == 7 )
    {
      v16 = 4;
      v20 = 3LL;
    }
    else
    {
      if ( v6 != 15 )
        goto LABEL_11;
      v16 = 5;
      v19 = 124;
      v20 = 4LL;
      HIBYTE(v32) = 32;
    }
    *((_BYTE *)&v32 + v20) = v19;
LABEL_11:
    if ( BIO_write(v26, (__int64)&v32, v16) & 0x80000000 )
      goto LABEL_31;
    v21 = *(unsigned __int8 *)(v5 + v7);
    if ( (unsigned int)(v21 - 32) > 0x5E )
      LOBYTE(v21) = 46;
    *((_BYTE *)&v26 + HIDWORD(v29) + 8) = v21;
    v6 = HIDWORD(v29) + 1;
    HIDWORD(v29) = v6;
    ++v30;
    if ( v6 == 16 )
    {
      LOWORD(v29) = 2684;
      if ( BIO_write(v26, (__int64)&v27, 0x12u) & 0x80000000 )
      {
LABEL_31:
        result = 0LL;
        goto LABEL_32;
      }
      v6 = 0;
      HIDWORD(v29) = 0;
    }
    ++v7;
  }
  while ( v7 < v4 );
  if ( !v6 )
    goto LABEL_30;
  v32 = 538976288;
  v33 = 124;
  if ( v6 > 0xF )
  {
LABEL_29:
    *((_BYTE *)&v27 + v6) = 124;
    *((_BYTE *)&v27 + v6 + 1) = 10;
    result = (signed int)BIO_write(v26, (__int64)&v27, v6 + 2) >= 0;
  }
  else
  {
    v22 = v6;
    while ( 1 )
    {
      v23 = v22 == 15 ? 5 : 3;
      v24 = v22 == 7 ? 4 : v23;
      if ( BIO_write(v26, (__int64)&v32, v24) & 0x80000000 )
        break;
      v22 = HIDWORD(v29) + 1;
      HIDWORD(v29) = v22;
      if ( v22 >= 0x10 )
        goto LABEL_29;
    }
    result = 0LL;
  }
LABEL_32:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v39;
  return result;
}

//----- (00000000000B13DC) ----------------------------------------------------
__int64 __fastcall CBS_asn1_ber_to_der(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3; // x19
  _QWORD *v4; // x20
  __int64 v5; // x21
  __int64 result; // x0
  __int64 v7; // x0
  char v8; // [xsp+4h] [xbp-4Ch]
  __int64 v9[4]; // [xsp+8h] [xbp-48h]
  __int64 v10; // [xsp+28h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = sub_B14B0(a1, &v8, 0);
  if ( (_DWORD)result )
  {
    if ( v8 )
    {
      v7 = EVP_CIPHER_CTX_get_app_data(v5);
      if ( !(unsigned int)CBB_init(v9, v7)
        || !(unsigned int)sub_B1608(v5, v9, 0, 0, 0)
        || !(unsigned int)CBB_finish((__int64)v9, v4, v3) )
      {
        CBB_cleanup(v9);
        result = 0LL;
        goto LABEL_9;
      }
    }
    else
    {
      *v4 = 0LL;
      *v3 = 0LL;
    }
    result = 1LL;
  }
LABEL_9:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000B14B0) ----------------------------------------------------
__int64 __fastcall sub_B14B0(__int64 a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // w20
  _BYTE *v4; // x19
  __int64 v5; // x21
  __int64 result; // x0
  __int64 v7; // x22
  __int64 v8; // x0
  unsigned int v9; // w20
  __int64 v10; // x0
  unsigned __int64 v11; // x1
  __int64 v12; // x0
  unsigned int v13; // w8
  unsigned __int64 v14; // [xsp+8h] [xbp-58h]
  int v15; // [xsp+14h] [xbp-4Ch]
  __int64 v16[2]; // [xsp+18h] [xbp-48h]
  unsigned __int8 *v17[2]; // [xsp+28h] [xbp-38h]
  __int64 v18; // [xsp+38h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a3 <= 0x800 )
  {
    v7 = lh_num_items(a1);
    v8 = EVP_CIPHER_CTX_get_app_data(v5);
    CBS_init(v17, v7, v8);
    *v4 = 0;
    if ( EVP_CIPHER_CTX_get_app_data((__int64)v17) )
    {
      v9 = v3 + 1;
      while ( 1 )
      {
        result = (__int64)CBS_get_any_ber_asn1_element(v17, (char *)v16, &v15, (signed __int64 *)&v14);
        if ( !(_DWORD)result )
          break;
        v10 = EVP_CIPHER_CTX_get_app_data((__int64)v16);
        v11 = v14;
        if ( v10 == v14 )
        {
          if ( v14 )
          {
            v12 = lh_num_items((__int64)v16);
            v11 = v14;
            if ( *(unsigned __int8 *)(v12 + v14 - 1) == 128 )
            {
LABEL_19:
              result = 1LL;
              *v4 = 1;
              break;
            }
          }
        }
        if ( v15 & 0x20 )
        {
          if ( !(v15 & 0xC0) )
          {
            v13 = (v15 + 14) & 0x1F;
            if ( v13 <= 0x1A && !((0x3F9E860uLL >> v13) & 1) )
              goto LABEL_19;
          }
          result = CBS_skip(v16, v11);
          if ( !(_DWORD)result )
            break;
          result = sub_B14B0(v16, v4, v9);
          if ( !(_DWORD)result )
            break;
        }
        if ( !EVP_CIPHER_CTX_get_app_data((__int64)v17) )
          goto LABEL_16;
      }
    }
    else
    {
LABEL_16:
      result = 1LL;
    }
  }
  else
  {
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v18;
  return result;
}

//----- (00000000000B1608) ----------------------------------------------------
__int64 __fastcall sub_B1608(__int64 result, __int64 *a2, unsigned int a3, unsigned __int8 a4, unsigned int a5)
{
  _BOOL4 v5; // w24
  unsigned __int8 v6; // w19
  unsigned int v7; // w20
  __int64 *v8; // x21
  unsigned __int8 **v9; // x22
  int v10; // w27
  unsigned int v11; // w23
  int v12; // w2
  unsigned int v13; // w25
  char ***v14; // x26
  unsigned int v15; // w8
  int v16; // w8
  __int64 v17; // x0
  unsigned __int64 v18; // x1
  __int64 v19; // x0
  signed int v20; // w28
  const void *v21; // x25
  __int64 v22; // x0
  char v23; // [xsp+8h] [xbp-98h]
  unsigned __int64 v24; // [xsp+28h] [xbp-78h]
  int v25; // [xsp+34h] [xbp-6Ch]
  __int64 v26[2]; // [xsp+38h] [xbp-68h]
  __int64 v27; // [xsp+48h] [xbp-58h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = (unsigned __int8 **)result;
  v27 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a5 > 0x800 )
  {
    v5 = 0;
    goto LABEL_48;
  }
  v10 = a4;
  v11 = a5 + 1;
  while ( 1 )
  {
    result = EVP_CIPHER_CTX_get_app_data((__int64)v9);
    if ( !result )
      break;
    result = (__int64)CBS_get_any_ber_asn1_element(v9, (char *)v26, &v25, (signed __int64 *)&v24);
    if ( (_DWORD)result )
    {
      if ( v24 == 2 )
      {
        result = EVP_CIPHER_CTX_get_app_data((__int64)v26);
        if ( result == 2 )
        {
          result = lh_num_items((__int64)v26);
          if ( !*(_WORD *)result )
          {
            v20 = 1;
            v5 = v10;
            goto LABEL_42;
          }
        }
      }
      v12 = v25;
      if ( v7 )
      {
        v13 = v7;
        v14 = (char ***)v8;
        if ( (v25 & 0xFFFFFFDF) == v7 )
          goto LABEL_23;
      }
      else
      {
        if ( v25 & 0x20 )
        {
          if ( v25 & 0xC0 || (v15 = (v25 + 14) & 0x1F, v15 > 0x1A) )
            v16 = 0;
          else
            v16 = dword_DDD10[v15];
          if ( v16 )
            v13 = v25 & 0xFFFFFFDF;
          else
            v13 = 0;
          if ( v16 )
            v12 = v25 & 0xFFFFFFDF;
        }
        else
        {
          v13 = 0;
        }
        v14 = (char ***)&v23;
        result = CBB_add_asn1(v8, (__int64 *)&v23, v12);
        if ( (_DWORD)result )
        {
LABEL_23:
          v17 = EVP_CIPHER_CTX_get_app_data((__int64)v26);
          v18 = v24;
          if ( v17 == v24 )
          {
            if ( v24 )
            {
              v19 = lh_num_items((__int64)v26);
              v18 = v24;
              if ( *(unsigned __int8 *)(v19 + v24 - 1) == 128 )
              {
                v20 = 1;
                result = sub_B1608(v9, v14, v13, 1LL, v11);
                if ( (_DWORD)result )
                {
                  result = CBB_flush(v8);
                  if ( !(_DWORD)result )
                    v5 = 0;
                  if ( (_DWORD)result )
                    v20 = 2;
                  else
                    v20 = 1;
                }
                else
                {
                  v5 = 0;
                }
                goto LABEL_42;
              }
            }
          }
          result = CBS_skip(v26, v18);
          if ( (_DWORD)result )
          {
            if ( v25 & 0x20 )
            {
              result = sub_B1608(v26, v14, v13, 0LL, v11);
              if ( (_DWORD)result )
              {
LABEL_38:
                result = CBB_flush(v8);
                v20 = result == 0;
                if ( !(_DWORD)result )
                  v5 = 0;
                goto LABEL_42;
              }
            }
            else
            {
              v21 = (const void *)lh_num_items((__int64)v26);
              v22 = EVP_CIPHER_CTX_get_app_data((__int64)v26);
              result = CBB_add_bytes(v14, v21, v22);
              if ( (_DWORD)result )
                goto LABEL_38;
            }
          }
          goto LABEL_41;
        }
      }
    }
LABEL_41:
    v5 = 0;
    v20 = 1;
LABEL_42:
    if ( v20 == 1 )
      goto LABEL_48;
  }
  v5 = v6 == 0;
LABEL_48:
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v27 )
    result = (unsigned int)v5;
  return result;
}

//----- (00000000000B187C) ----------------------------------------------------
signed __int64 __fastcall CBS_get_asn1_implicit_string(unsigned __int8 **a1, char *a2, _QWORD *a3, int a4, int a5)
{
  int v5; // w22
  char *v6; // x20
  int v7; // w21
  _QWORD *v8; // x19
  unsigned __int8 **v9; // x23
  signed __int64 result; // x0
  __int64 v11; // x0
  const void *v12; // x22
  __int64 v13; // x0
  __int64 v14; // [xsp+8h] [xbp-88h]
  __int64 v15; // [xsp+10h] [xbp-80h]
  char v16; // [xsp+18h] [xbp-78h]
  unsigned __int8 *v17[2]; // [xsp+28h] [xbp-68h]
  char **v18[4]; // [xsp+38h] [xbp-58h]
  __int64 v19; // [xsp+58h] [xbp-38h]

  v5 = a4;
  v6 = a2;
  v7 = a5;
  v8 = a3;
  v9 = a1;
  v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( CBS_peek_asn1_tag(a1, a4) )
  {
    *v8 = 0LL;
    result = CBS_get_asn1(v9, v6, v5);
  }
  else
  {
    v11 = EVP_CIPHER_CTX_get_app_data((__int64)v9);
    if ( !(unsigned int)CBB_init(v18, v11) || !(unsigned int)CBS_get_asn1(v9, (char *)v17, v5 | 0x20u) )
      goto LABEL_11;
    while ( EVP_CIPHER_CTX_get_app_data((__int64)v17) )
    {
      if ( (unsigned int)CBS_get_asn1(v17, &v16, v7) )
      {
        v12 = (const void *)lh_num_items((__int64)&v16);
        v13 = EVP_CIPHER_CTX_get_app_data((__int64)&v16);
        if ( (unsigned int)CBB_add_bytes(v18, v12, v13) )
          continue;
      }
      goto LABEL_11;
    }
    if ( (unsigned int)CBB_finish((__int64)v18, &v15, &v14) )
    {
      CBS_init(v6, v15, v14);
      result = 1LL;
      *v8 = v15;
    }
    else
    {
LABEL_11:
      CBB_cleanup((__int64 *)v18);
      result = 0LL;
    }
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}

//----- (00000000000B19BC) ----------------------------------------------------
__int64 __fastcall DH_check_pub_key(__int64 *a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v3; // x20
  __int64 v4; // x21
  __int64 *v5; // x22
  _DWORD *v6; // x0
  __int64 v7; // x19
  _QWORD *v8; // x0
  __int64 v9; // x23
  __int64 v10; // x2
  int v11; // w0
  unsigned int v12; // w20

  v3 = a3;
  v4 = a2;
  v5 = a1;
  *a3 = 0;
  v6 = BN_CTX_new();
  v7 = (__int64)v6;
  if ( !v6 )
    return 0;
  BN_CTX_start((__int64)v6);
  v8 = BN_CTX_get(v7);
  v9 = (__int64)v8;
  if ( !v8 || !(unsigned int)BN_set_word((__int64)v8, 1LL) )
    goto LABEL_21;
  if ( (signed int)BN_cmp(v4, v9) <= 0 )
    *v3 |= 1u;
  if ( !BN_copy(v9, *v5) || !(unsigned int)BN_sub_word(v9, 1uLL) )
    goto LABEL_21;
  if ( !(BN_cmp(v4, v9) & 0x80000000) )
    *v3 |= 2u;
  v10 = v5[13];
  if ( !v10 )
    goto LABEL_14;
  BN_mod_exp_mont(v9, v4, v10, *v5, v7, 0LL);
  if ( !v11 )
  {
LABEL_21:
    v12 = 0;
    goto LABEL_16;
  }
  if ( !BN_is_one(v9) )
    *v3 |= 4u;
LABEL_14:
  v12 = 1;
LABEL_16:
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  return v12;
}

//----- (00000000000B1AE8) ----------------------------------------------------
__int64 __fastcall DH_check(__int64 *a1, int *a2)
{
  int *v2; // x20
  __int64 *v3; // x21
  _DWORD *v4; // x0
  _DWORD *v5; // x19
  _QWORD *v6; // x22
  _QWORD *v7; // x23
  __int64 v8; // x24
  void **v9; // x0
  int v10; // w0
  __int64 v11; // x0
  int v12; // w8
  unsigned int v13; // w20
  signed __int64 v15; // x0
  int v16; // w0
  signed __int64 v17; // x0
  signed int v18; // w8
  int v19; // w0
  int v20; // w0
  int v21; // w8

  v2 = a2;
  v3 = a1;
  *a2 = 0;
  v4 = BN_CTX_new();
  v5 = v4;
  if ( !v4 )
    return 0;
  BN_CTX_start((__int64)v4);
  v6 = BN_CTX_get((__int64)v5);
  if ( !v6 || (v7 = BN_CTX_get((__int64)v5)) == 0LL )
  {
    v13 = 0;
    goto LABEL_18;
  }
  v8 = v3[1];
  if ( v3[13] )
  {
    v9 = BN_value_one();
    if ( (signed int)BN_cmp(v8, (__int64)v9) < 1 || !(BN_cmp(v3[1], *v3) & 0x80000000) )
      goto LABEL_52;
    BN_mod_exp_mont((__int64)v6, v3[1], v3[13], *v3, (__int64)v5, 0LL);
    if ( !v16 )
      goto LABEL_29;
    if ( !BN_is_one((__int64)v6) )
LABEL_52:
      *v2 |= 8u;
    v10 = BN_is_prime_ex(v3[13], 0, v5, 0LL);
    if ( v10 & 0x80000000 )
    {
      v13 = 0;
      goto LABEL_18;
    }
    if ( !v10 )
      *v2 |= 0x10u;
    if ( (unsigned int)BN_div(v6, (__int64)v7, *v3, v3[13], (__int64)v5) )
    {
      if ( !BN_is_one((__int64)v7) )
        *v2 |= 0x20u;
      v11 = v3[14];
      if ( !v11 || !(unsigned int)BN_cmp(v11, (__int64)v6) )
        goto LABEL_38;
      v12 = *v2 | 0x40;
      goto LABEL_37;
    }
LABEL_29:
    v13 = 0;
    goto LABEL_18;
  }
  if ( !BN_is_word(v3[1], 2LL) )
  {
    if ( BN_is_word(v3[1], 5LL) )
    {
      v17 = BN_mod_word((__int64 *)*v3, 0xAuLL);
      if ( v17 == -1 )
        goto LABEL_49;
      if ( v17 == 3 || v17 == 7 )
        goto LABEL_38;
      v18 = 8;
    }
    else
    {
      v18 = 4;
    }
    v12 = *v2 | v18;
    goto LABEL_37;
  }
  v15 = BN_mod_word((__int64 *)*v3, 0x18uLL);
  if ( v15 == -1 )
    goto LABEL_29;
  if ( v15 != 11 )
  {
    v12 = *v2 | 8;
LABEL_37:
    *v2 = v12;
  }
LABEL_38:
  v19 = BN_is_prime_ex(*v3, 0, v5, 0LL);
  if ( !(v19 & 0x80000000) )
  {
    if ( !v19 )
    {
      v21 = *v2 | 1;
      goto LABEL_47;
    }
    if ( v3[13] )
    {
LABEL_48:
      v13 = 1;
      goto LABEL_18;
    }
    if ( (unsigned int)BN_rshift1((__int64)v6, *v3) )
    {
      v20 = BN_is_prime_ex((__int64)v6, 0, v5, 0LL);
      if ( !(v20 & 0x80000000) )
      {
        if ( !v20 )
        {
          v21 = *v2 | 2;
LABEL_47:
          *v2 = v21;
          goto LABEL_48;
        }
        goto LABEL_48;
      }
    }
LABEL_49:
    v13 = 0;
    goto LABEL_18;
  }
  v13 = 0;
LABEL_18:
  BN_CTX_end((__int64)v5);
  BN_CTX_free((__int64)v5);
  return v13;
}

//----- (00000000000B1D68) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestSignInit(__int64 a1, _QWORD *a2, __int64 a3, int *a4, __int64 a5)
{
  __int64 v5; // x21
  signed __int64 result; // x0
  __int64 v7; // x20
  _QWORD *v8; // x22

  v5 = a1;
  result = *(_QWORD *)(a1 + 16);
  v7 = a3;
  v8 = a2;
  if ( result || (result = (signed __int64)EVP_PKEY_CTX_new(a5, a4), (*(_QWORD *)(v5 + 16) = result) != 0LL) )
  {
    *(_QWORD *)(v5 + 24) = off_104F08;
    if ( v7 )
    {
      result = EVP_PKEY_sign_init((_DWORD *)result);
      if ( (_DWORD)result )
      {
        result = EVP_PKEY_CTX_set_signature_md(*(__int64 **)(v5 + 16));
        if ( (_DWORD)result )
        {
          if ( v8 )
            *v8 = *(_QWORD *)(v5 + 16);
          result = (unsigned int)EVP_DigestInit_ex((__int64 *)v5, v7) != 0;
        }
      }
    }
    else
    {
      ERR_put_error(6, 0LL, 119, (__int64)"external/boringssl/src/crypto/evp/digestsign.c", 81);
      result = 0LL;
    }
  }
  return result;
}
// 104F08: using guessed type __int64 (__fastcall *off_104F08[2])();

//----- (00000000000B1E48) ----------------------------------------------------
void EVP_DigestVerifyInit()
{
  JUMPOUT(&loc_B1D70);
}

//----- (00000000000B1E54) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestSignFinal(__int64 *a1, __int64 a2)
{
  __int64 *v2; // x21
  _BOOL4 v3; // w19
  signed __int64 result; // x0
  int v5; // [xsp+4h] [xbp-8Ch]
  void *v6[4]; // [xsp+8h] [xbp-88h]
  char v7; // [xsp+28h] [xbp-68h]
  __int64 v8; // [xsp+68h] [xbp-28h]

  v2 = a1;
  v8 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 )
  {
    EVP_MD_CTX_init(v6);
    if ( (unsigned int)EVP_MD_CTX_copy_ex(v6, v2) && (unsigned int)EVP_DigestFinal_ex(v6, (__int64)&v7, &v5) )
      v3 = (unsigned __int64)EVP_PKEY_sign((_DWORD *)v2[2]) != 0;
    else
      v3 = 0;
    result = EVP_MD_CTX_cleanup(v6);
    if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v8 )
      result = (unsigned int)v3;
  }
  else
  {
    X509_TRUST_get_flags(*a1);
    result = EVP_PKEY_sign((_DWORD *)v2[2]);
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  }
  return result;
}

//----- (00000000000B1F4C) ----------------------------------------------------
signed __int64 __fastcall EVP_DigestVerifyFinal(__int64 a1)
{
  __int64 v1; // x21
  _BOOL4 v2; // w19
  signed __int64 result; // x0
  int v4; // [xsp+4h] [xbp-8Ch]
  void *v5[4]; // [xsp+8h] [xbp-88h]
  char v6; // [xsp+28h] [xbp-68h]
  __int64 v7; // [xsp+68h] [xbp-28h]

  v1 = a1;
  v7 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_MD_CTX_init(v5);
  if ( (unsigned int)EVP_MD_CTX_copy_ex(v5, (_QWORD *)v1) && (unsigned int)EVP_DigestFinal_ex(v5, (__int64)&v6, &v4) )
    v2 = (unsigned __int64)EVP_PKEY_verify(*(_DWORD **)(v1 + 16)) != 0;
  else
    v2 = 0;
  result = EVP_MD_CTX_cleanup(v5);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v7 )
    result = (unsigned int)v2;
  return result;
}

//----- (00000000000B2004) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_print_public(_QWORD *a1, __int64 a2, int a3)
{
  int *v3; // x9
  int v4; // w10
  _QWORD *v5; // x19
  __int64 (*v6)(void); // x4
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7

  v3 = &dword_106960;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = a1;
  if ( dword_106960 == v4 )
    goto LABEL_11;
  if ( dword_106980 == v4 )
  {
    v6 = (__int64 (*)(void))off_106988;
    if ( !off_106988 )
      goto LABEL_8;
    return v6();
  }
  v3 = &dword_1069A0;
  if ( dword_1069A0 == v4 )
  {
LABEL_11:
    v6 = (__int64 (*)(void))*((_QWORD *)v3 + 1);
    if ( v6 )
      return v6();
  }
LABEL_8:
  BIO_indent(a1, a3, 128);
  BIO_printf(v5, (__int64)"%s algorithm unsupported\n", v8, v9, v10, v11, v12, v13, v14, v15, "Public Key");
  return 1LL;
}
// 106960: using guessed type int dword_106960;
// 106980: using guessed type int dword_106980;
// 106988: using guessed type void *off_106988;
// 1069A0: using guessed type int dword_1069A0;

//----- (00000000000B20B0) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_print_private(_QWORD *a1, __int64 a2, int a3)
{
  int *v3; // x9
  int v4; // w10
  _QWORD *v5; // x19
  __int64 (*v6)(void); // x4
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7

  v3 = &dword_106960;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = a1;
  if ( dword_106960 == v4 )
    goto LABEL_11;
  if ( dword_106980 == v4 )
  {
    v6 = (__int64 (*)(void))off_106990;
    if ( !off_106990 )
      goto LABEL_8;
    return v6();
  }
  v3 = &dword_1069A0;
  if ( dword_1069A0 == v4 )
  {
LABEL_11:
    v6 = (__int64 (*)(void))*((_QWORD *)v3 + 2);
    if ( v6 )
      return v6();
  }
LABEL_8:
  BIO_indent(a1, a3, 128);
  BIO_printf(v5, (__int64)"%s algorithm unsupported\n", v8, v9, v10, v11, v12, v13, v14, v15, "Private Key");
  return 1LL;
}
// 106960: using guessed type int dword_106960;
// 106980: using guessed type int dword_106980;
// 106990: using guessed type void *off_106990;
// 1069A0: using guessed type int dword_1069A0;

//----- (00000000000B215C) ----------------------------------------------------
signed __int64 __fastcall EVP_PKEY_print_params(_QWORD *a1, __int64 a2, int a3)
{
  int *v3; // x9
  int v4; // w10
  _QWORD *v5; // x19
  __int64 (*v6)(void); // x4
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7

  v3 = &dword_106960;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = a1;
  if ( dword_106960 == v4 )
    goto LABEL_11;
  if ( dword_106980 == v4 )
  {
    v6 = (__int64 (*)(void))off_106998;
    if ( !off_106998 )
      goto LABEL_8;
    return v6();
  }
  v3 = &dword_1069A0;
  if ( dword_1069A0 == v4 )
  {
LABEL_11:
    v6 = (__int64 (*)(void))*((_QWORD *)v3 + 3);
    if ( v6 )
      return v6();
  }
LABEL_8:
  BIO_indent(a1, a3, 128);
  BIO_printf(v5, (__int64)"%s algorithm unsupported\n", v8, v9, v10, v11, v12, v13, v14, v15, "Parameters");
  return 1LL;
}
// B215C: could not find valid save-restore pair for x20
// B215C: could not find valid save-restore pair for x21
// B215C: could not find valid save-restore pair for x22
// B215C: could not find valid save-restore pair for x23
// B215C: could not find valid save-restore pair for x24
// B215C: could not find valid save-restore pair for x25
// B215C: could not find valid save-restore pair for x26
// B215C: could not find valid save-restore pair for x27
// B215C: could not find valid save-restore pair for x28
// 106960: using guessed type int dword_106960;
// 106980: using guessed type int dword_106980;
// 106998: using guessed type void *off_106998;
// 1069A0: using guessed type int dword_1069A0;

//----- (00000000000B26D4) ----------------------------------------------------
signed __int64 __fastcall sub_B26D4(_QWORD *a1, __int64 a2, __int64 **a3, _BYTE *a4, int a5)
{
  int v5; // w21
  _BYTE *v6; // x20
  __int64 **v7; // x23
  __int64 v8; // x22
  _QWORD *v9; // x19
  signed __int64 result; // x0
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  int v19; // w0
  __int64 v20; // x4
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  int v29; // w0
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  const char *v38; // x3
  signed int v39; // w0
  int v40; // w0
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  int v49; // w8
  __int64 v50; // x23
  signed __int64 v51; // x27
  __int64 v52; // x8
  __int64 v53; // x28
  signed __int64 v54; // x22
  const char *v55; // x3
  signed int v56; // w0
  signed int v57; // w8

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( !a3 )
    return 1LL;
  result = BIO_indent(a1, a5, 128);
  if ( !(_DWORD)result )
    return result;
  if ( BN_is_zero((__int64)v7) )
  {
    BIO_printf(v9, (__int64)"%s 0\n", v11, v12, v13, v14, v15, v16, v17, v18, v8);
    return v19 > 0;
  }
  if ( (unsigned int)BN_num_bytes((__int64)v7) <= 8 )
  {
    BN_is_negative((__int64)v7);
    v20 = **v7;
    BIO_printf(v9, (__int64)"%s %s%lu (%s0x%lx)\n", v21, v22, v23, v24, v25, v26, v27, v28, v8);
    if ( v29 > 0 )
      return 1LL;
    return 0LL;
  }
  *v6 = 0;
  if ( BN_is_negative((__int64)v7) )
    v38 = " (Negative)";
  else
    v38 = (const char *)&unk_B8A4C;
  BIO_printf(v9, (__int64)"%s%s", v30, v31, v32, v33, v34, v35, v36, v37, v8, v38);
  if ( v39 < 1 )
    return 0LL;
  v40 = BN_bn2bin((__int64)v7, v6 + 1);
  v49 = (char)v6[1];
  v50 = 0LL;
  if ( v49 < 0 )
    v51 = (signed __int64)v6;
  else
    v51 = (signed __int64)(v6 + 1);
  v52 = v40 + ((v49 & 0x80u) >> 7);
  v53 = (signed int)v52;
  v54 = v52 - 1;
  while ( v50 < v53 )
  {
    if ( (_DWORD)v50 == 15 * ((signed int)v50 / 15) )
    {
      if ( (signed int)BIO_puts(v9, "\n") < 1 )
        return 0LL;
      result = BIO_indent(v9, v5 + 4, 128);
      if ( !(_DWORD)result )
        return result;
    }
    if ( v54 == v50 )
      v55 = (const char *)&unk_B8A4C;
    else
      v55 = ":";
    BIO_printf(v9, (__int64)"%02x%s", v41, v42, v43, v44, v45, v46, v47, v48, *(unsigned __int8 *)(v51 + v50), v55);
    v57 = v56;
    result = 0LL;
    ++v50;
    if ( v57 < 1 )
      return result;
  }
  if ( (signed int)BIO_write(v9, (__int64)"\n", 1u) >= 1 )
    return 1LL;
  return 0LL;
}

//----- (00000000000B2DF0) ----------------------------------------------------
signed __int64 __fastcall OBJ_find_sigid_algs(signed int a1, _DWORD *a2, _DWORD *a3)
{
  signed int v3; // w8
  signed __int64 result; // x0
  signed __int64 v5; // x8

  v3 = a1;
  result = 0LL;
  if ( v3 > 792 )
  {
    switch ( v3 )
    {
      case 793:
        v5 = 12LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 794:
        v5 = 13LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 795:
        v5 = 14LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 796:
        v5 = 15LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 797:
      case 798:
      case 799:
      case 800:
      case 801:
        return result;
      case 802:
        v5 = 9LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 803:
        v5 = 10LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      default:
        if ( v3 != 912 )
          return result;
        v5 = 16LL;
        if ( !a2 )
          goto LABEL_47;
        break;
    }
    goto LABEL_46;
  }
  if ( v3 > 395 )
  {
    switch ( v3 )
    {
      case 668:
        v5 = 4LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 669:
        v5 = 5LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 670:
        v5 = 6LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      case 671:
        v5 = 3LL;
        if ( !a2 )
          goto LABEL_47;
        goto LABEL_46;
      default:
        if ( v3 == 396 )
        {
          v5 = 0LL;
          if ( !a2 )
            goto LABEL_47;
          goto LABEL_46;
        }
        if ( v3 != 416 )
          return result;
        v5 = 11LL;
        if ( a2 )
          goto LABEL_46;
        break;
    }
    goto LABEL_47;
  }
  if ( v3 <= 69 )
  {
    if ( v3 == 8 )
    {
      v5 = 1LL;
      if ( !a2 )
        goto LABEL_47;
    }
    else
    {
      if ( v3 != 65 )
        return result;
      v5 = 2LL;
      if ( !a2 )
        goto LABEL_47;
    }
    goto LABEL_46;
  }
  if ( v3 == 70 )
  {
    v5 = 8LL;
    if ( !a2 )
      goto LABEL_47;
    goto LABEL_46;
  }
  if ( v3 != 113 )
    return result;
  v5 = 7LL;
  if ( a2 )
LABEL_46:
    *a2 = *((_DWORD *)&unk_DDDB8 + 3 * v5 + 1);
LABEL_47:
  if ( a3 )
    *a3 = *((_DWORD *)&unk_DDDB8 + 3 * v5 + 2);
  return 1LL;
}

//----- (00000000000B2F8C) ----------------------------------------------------
signed __int64 __fastcall OBJ_find_sigid_by_algs(_DWORD *a1, int a2, int a3)
{
  unsigned __int64 v3; // x9
  int *v4; // x8

  v3 = 0LL;
  v4 = &dword_DDDC0;
  while ( *(v4 - 1) != a2 || *v4 != a3 )
  {
    ++v3;
    v4 += 3;
    if ( v3 >= 0x11 )
      return 0LL;
  }
  if ( a1 )
    *a1 = *(v4 - 2);
  return 1LL;
}
// DDDC0: using guessed type int dword_DDDC0;

//----- (00000000000B2FE8) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_B2FE8(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, unsigned int a6, unsigned __int64 a7, char *a8, __int64 a9)
{
  char *v9; // x20
  unsigned __int64 v10; // x22
  unsigned int v11; // w23
  unsigned __int64 v12; // x28
  __int64 v13; // x26
  unsigned __int64 v14; // x19
  __int64 v15; // x24
  unsigned __int64 v16; // x21
  unsigned __int64 v17; // x22
  size_t v18; // x19
  char *v19; // x0
  char *v20; // x20
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x10
  __int64 v23; // x11
  unsigned __int64 v24; // x8
  char *v25; // x12
  __int128 v26; // q0 OVERLAPPED
  signed __int64 v27; // x13
  __int128 v28; // q1
  char *v29; // x13
  char *v30; // x9
  char *v31; // x10
  char v32; // t1
  signed __int64 v33; // x8
  unsigned __int64 v34; // x25
  unsigned __int64 v35; // x27
  unsigned __int64 v36; // x24
  int v37; // w2
  __int16 v38; // w4
  unsigned __int64 v39; // x22
  unsigned __int64 v40; // x8
  _BYTE *v41; // x0
  size_t v42; // x1
  unsigned __int64 v43; // x8
  unsigned __int64 v44; // x9
  unsigned __int64 v45; // x10
  char v46; // w11
  char v47; // w12
  _BYTE *v48; // x13
  unsigned __int64 v49; // x9
  unsigned __int64 v50; // x10
  char v51; // w12
  char v52; // w13
  _BYTE *v53; // x14
  signed __int64 v54; // x10
  _BYTE *v55; // x8
  char v56; // w11
  signed int v57; // w22
  size_t v58; // x24
  unsigned __int64 v59; // x8
  unsigned __int64 v60; // x9
  unsigned __int64 v61; // x9
  char v62; // w10
  char v63; // w11
  char *v64; // x12
  size_t v65; // x8
  char *v66; // x9
  signed int v67; // w11
  unsigned __int64 v68; // x10
  unsigned int v69; // w11
  void *v70; // x21
  unsigned __int64 v71; // [xsp+10h] [xbp-1F0h]
  unsigned __int64 v72; // [xsp+18h] [xbp-1E8h]
  _BYTE *v73; // [xsp+18h] [xbp-1E8h]
  size_t v74; // [xsp+20h] [xbp-1E0h]
  unsigned __int64 v75; // [xsp+28h] [xbp-1D8h]
  char *v76; // [xsp+30h] [xbp-1D0h]
  __int64 v77; // [xsp+38h] [xbp-1C8h]
  unsigned int v78; // [xsp+44h] [xbp-1BCh]
  void *v79[4]; // [xsp+48h] [xbp-1B8h]
  char v80[128]; // [xsp+68h] [xbp-198h]
  char v81[64]; // [xsp+E8h] [xbp-118h]
  int8x16x2_t v82; // 0:q2.16,16:q3.16

  v9 = a8;
  v10 = a7;
  v11 = a6;
  v12 = a4;
  v13 = a3;
  v14 = a2;
  v15 = a1;
  v77 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a6 )
  {
    EVP_MD_CTX_init(v79);
    if ( !v15 )
    {
      v76 = v9;
      v20 = 0LL;
      v18 = 0LL;
      goto LABEL_20;
    }
    v16 = v10;
    v17 = 2 * v14;
    if ( 2 * v14 < v14 || v17 == -2LL )
      goto LABEL_28;
    v18 = v17 + 2;
    v76 = v9;
    v19 = (char *)malloc(v17 + 2);
    v20 = v19;
    if ( !v19 )
    {
      ERR_put_error(19, 0LL, 65, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", 83);
      goto LABEL_28;
    }
    if ( v17 )
    {
      v21 = ((v17 - 1) >> 1) + 1;
      if ( v21 > 0x1F && (v22 = v21 & 0xFFFFFFFFFFFFFFE0LL) != 0 )
      {
        v23 = 0LL;
        v24 = 2 * v22;
        v25 = v19 + 32;
        v26 = 0uLL;
        do
        {
          v27 = v15 + (v23 & 0x7FFFFFFFFFFFFFE0LL);
          v82.val[1] = *(int8x16_t *)v27;
          v28 = *(_OWORD *)(v27 + 16);
          v29 = v25 - 32;
          v23 += 32LL;
          v82.val[0] = 0uLL;
          vst2q_s8(v29, v82);
          vst2q_s8(v25, *(int8x16x2_t *)&v26);
          v25 += 64;
        }
        while ( v22 != v23 );
        if ( v21 == v22 )
          goto LABEL_19;
      }
      else
      {
        v24 = 0LL;
      }
      v30 = (char *)(v15 + (v24 >> 1));
      do
      {
        v31 = &v19[v24];
        *v31 = 0;
        v32 = *v30++;
        v24 += 2LL;
        v31[1] = v32;
      }
      while ( v24 < v17 );
    }
LABEL_19:
    v19[v17] = 0;
    v33 = v17 | 1;
    v10 = v16;
    v19[v33] = 0;
LABEL_20:
    v34 = X509_VERIFY_PARAM_get_depth(a9);
    if ( v34 )
      __memset_chk();
    v35 = v12 + v34 - 1;
    if ( v35 < v12 || (v36 = v18 + v34 - 1, v36 < v18) )
    {
      v37 = 69;
      v38 = 142;
LABEL_25:
      ERR_put_error(19, 0LL, v37, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", v38);
      goto LABEL_26;
    }
    v75 = v10;
    v39 = v35 / v34 * v34;
    v40 = v36 / v34 * v34;
    if ( __CFADD__(v40, v39) )
    {
      v37 = 69;
      v38 = 149;
      goto LABEL_25;
    }
    v72 = v36 / v34 * v34;
    v74 = v40 + v39;
    v41 = malloc(v40 + v39);
    v42 = v74;
    if ( v74 && !v41 )
    {
      v37 = 65;
      v38 = 155;
      goto LABEL_25;
    }
    v43 = v35 - v39;
    if ( v39 )
    {
      if ( v39 == 1 )
      {
        v44 = 0LL;
        do
        {
LABEL_44:
          v41[v44] = *(_BYTE *)(v13 + v44 - v44 / v12 * v12);
          ++v44;
        }
        while ( v43 - v34 - v12 + v44 != -1LL );
        goto LABEL_45;
      }
      v44 = v39 & 0xFFFFFFFFFFFFFFFELL;
      if ( !(v39 & 0xFFFFFFFFFFFFFFFELL) )
        goto LABEL_44;
      v45 = 0LL;
      do
      {
        v46 = *(_BYTE *)(v13 + v45 - v45 / v12 * v12);
        v47 = *(_BYTE *)(v13 + v45 + 1 - (v45 + 1) / v12 * v12);
        v48 = &v41[v45];
        v45 += 2LL;
        *v48 = v46;
        v48[1] = v47;
      }
      while ( v45 != v44 );
      if ( v39 != v44 )
        goto LABEL_44;
    }
LABEL_45:
    if ( !v72 )
      goto LABEL_54;
    if ( v72 == 1 )
    {
      v49 = 0LL;
    }
    else
    {
      v49 = v72 & 0xFFFFFFFFFFFFFFFELL;
      if ( v72 & 0xFFFFFFFFFFFFFFFELL )
      {
        v50 = 0LL;
        do
        {
          v51 = v20[v50 - v50 / v18 * v18];
          v52 = v20[v50 + 1 - (v50 + 1) / v18 * v18];
          v53 = &v41[v34 + v12 - v43 + v50];
          v50 += 2LL;
          *(v53 - 1) = v51;
          *v53 = v52;
        }
        while ( v50 != v49 );
        if ( v72 == v49 )
        {
LABEL_54:
          if ( v75 )
          {
            v73 = v41;
            if ( (unsigned int)EVP_DigestInit_ex((__int64 *)v79, a9) )
            {
              v71 = v34 & 0xFFFFFFFFFFFFFFFELL;
              do
              {
                if ( !(unsigned int)EVP_DigestUpdate((__int64)v79)
                  || !(unsigned int)EVP_DigestUpdate((__int64)v79)
                  || !(unsigned int)EVP_DigestFinal_ex(v79, (__int64)v81, &v78) )
                {
                  break;
                }
                if ( v11 >= 2 )
                {
                  v57 = 1;
                  while ( (unsigned int)EVP_DigestInit_ex((__int64 *)v79, a9)
                       && (unsigned int)EVP_DigestUpdate((__int64)v79)
                       && (unsigned int)EVP_DigestFinal_ex(v79, (__int64)v81, &v78) )
                  {
                    if ( ++v57 >= v11 )
                      goto LABEL_66;
                  }
                  break;
                }
LABEL_66:
                if ( v75 >= v78 )
                  v58 = v78;
                else
                  v58 = v75;
                if ( v58 )
                  memcpy(v76, v81, v58);
                if ( v75 == v58 )
                  break;
                if ( v34 )
                {
                  v59 = v78;
                  if ( v34 >= 2 )
                  {
                    v61 = 0LL;
                    do
                    {
                      v62 = v81[v61 - v61 / v59 * v59];
                      v63 = v81[v61 + 1 - (v61 + 1) / v59 * v59];
                      v64 = &v80[v61];
                      v61 += 2LL;
                      *v64 = v62;
                      v64[1] = v63;
                    }
                    while ( v61 != v71 );
                    v60 = v34 & 0xFFFFFFFFFFFFFFFELL;
                    if ( v34 == v71 )
                      goto LABEL_79;
                  }
                  else
                  {
                    v60 = 0LL;
                  }
                  do
                  {
                    v80[v60] = v81[v60 - v60 / v59 * v59];
                    ++v60;
                  }
                  while ( v34 != v60 );
                }
LABEL_79:
                v76 += v58;
                if ( v74 )
                {
                  v65 = 0LL;
                  do
                  {
                    if ( v34 )
                    {
                      v66 = &v73[v65];
                      v67 = 1;
                      v68 = v34 - 1;
                      do
                      {
                        v69 = (unsigned __int8)v66[v68] + v67 + (unsigned __int8)v80[v68];
                        v66[v68] = v69;
                        v67 = v69 >> 8;
                        --v68;
                      }
                      while ( v68 < v34 );
                    }
                    v65 += v34;
                  }
                  while ( v65 < v74 );
                }
                v75 -= v58;
              }
              while ( (unsigned int)EVP_DigestInit_ex((__int64 *)v79, a9) );
            }
            v41 = v73;
            v42 = v74;
            if ( !v73 )
            {
LABEL_26:
              if ( v20 )
              {
LABEL_27:
                OPENSSL_cleanse(v20, v18);
                free(v20);
              }
LABEL_28:
              EVP_MD_CTX_cleanup(v79);
              goto LABEL_29;
            }
          }
          else if ( !v41 )
          {
            goto LABEL_26;
          }
          v70 = v41;
          OPENSSL_cleanse(v41, v42);
          free(v70);
          if ( !v20 )
            goto LABEL_28;
          goto LABEL_27;
        }
      }
    }
    v54 = v49 + 1;
    v55 = &v41[v34 + v49 + v12 - 1 - v43];
    do
    {
      v56 = v20[v54 - 1 - (v54 - 1) / v18 * v18];
      ++v54;
      *v55++ = v56;
    }
    while ( v72 + 1 != v54 );
    goto LABEL_54;
  }
  ERR_put_error(19, 0LL, 129, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", 106);
LABEL_29:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v77;
}
// B2FE8: variables would overlap: q0.16 and q0.32
// B2FE8: using guessed type char var_118[64];
// B2FE8: using guessed type char var_198[128];

//----- (00000000000B35E0) ----------------------------------------------------
signed __int64 __fastcall sub_B35E0(_QWORD *a1, _QWORD *a2, unsigned __int8 **a3, __int64 a4, __int64 a5, char *a6, size_t a7)
{
  _QWORD *v7; // x20
  size_t v8; // x21
  char *v9; // x22
  unsigned __int8 **v10; // x24
  _QWORD *v11; // x19
  signed __int64 v12; // x8
  int v13; // w2
  __int16 v14; // w4
  void *v15; // x23
  int v16; // w2
  __int16 v17; // w4
  unsigned int v18; // w19
  signed __int64 result; // x0
  int v20; // [xsp+8h] [xbp-108h]
  int v21; // [xsp+Ch] [xbp-104h]
  __int64 v22[2]; // [xsp+10h] [xbp-100h]
  void *v23[19]; // [xsp+20h] [xbp-F0h]
  __int64 v24; // [xsp+B8h] [xbp-58h]

  v7 = a1;
  v8 = a7;
  v9 = a6;
  v10 = a3;
  v11 = a2;
  v24 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  EVP_CIPHER_CTX_init(v23);
  if ( !(unsigned int)CBS_get_asn1(v10, (char *)v22, 6) )
  {
    v13 = 104;
    v14 = 363;
LABEL_18:
    ERR_put_error(19, 0LL, v13, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", v14);
    v18 = 0;
LABEL_19:
    v15 = 0LL;
    goto LABEL_20;
  }
  if ( CBS_mem_equal(v22, (__int64)&unk_104F1C, 10LL) )
  {
    v12 = 0LL;
  }
  else if ( CBS_mem_equal(v22, (__int64)&unk_104F44, 10LL) )
  {
    v12 = 1LL;
  }
  else if ( CBS_mem_equal(v22, (__int64)&unk_104F6C, 10LL) )
  {
    v12 = 2LL;
  }
  else
  {
    if ( !CBS_mem_equal(v22, (__int64)&unk_104F94, 9LL) )
    {
LABEL_16:
      v13 = 119;
      v14 = 375;
      goto LABEL_18;
    }
    v12 = 3LL;
  }
  if ( !(_UNKNOWN *)((char *)&unk_104F18 + 40 * v12) )
    goto LABEL_16;
  if ( !(*((unsigned int (**)(void))&unk_104F18 + 5 * v12 + 4))() )
  {
    v13 = 109;
    v14 = 380;
    goto LABEL_18;
  }
  v15 = malloc(v8);
  if ( !v15 )
  {
    v16 = 65;
    v17 = 386;
    goto LABEL_23;
  }
  if ( v8 >> 31 )
  {
    v16 = 69;
    v17 = 391;
LABEL_23:
    ERR_put_error(19, 0LL, v16, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", v17);
    v18 = 0;
    goto LABEL_20;
  }
  if ( (unsigned int)EVP_DecryptUpdate((signed int *)v23, v15, &v21, v9, v8)
    && (unsigned int)EVP_DecryptFinal_ex((__int64 *)v23, (unsigned __int64)v15 + v21, (unsigned int *)&v20) )
  {
    *v7 = v15;
    *v11 = v20 + (signed __int64)v21;
    v18 = 1;
    goto LABEL_19;
  }
  v18 = 0;
LABEL_20:
  free(v15);
  result = EVP_CIPHER_CTX_cleanup(v23);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v24 )
    result = v18;
  return result;
}

//----- (00000000000B3830) ----------------------------------------------------
void __fastcall PKCS8_parse_encrypted_private_key(unsigned __int8 **a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  char *v5; // x21
  __int64 v6; // x0
  void *v7; // x20
  size_t v8; // x21
  unsigned __int8 *v9[2]; // [xsp+8h] [xbp-78h]
  size_t v10; // [xsp+18h] [xbp-68h]
  void *v11; // [xsp+20h] [xbp-60h]
  char v12; // [xsp+28h] [xbp-58h]
  unsigned __int8 *v13[2]; // [xsp+38h] [xbp-48h]
  unsigned __int8 *v14[2]; // [xsp+48h] [xbp-38h]
  __int64 v15; // [xsp+58h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a1, (char *)v14, 48)
    && (unsigned int)CBS_get_asn1(v14, (char *)v13, 48)
    && (unsigned int)CBS_get_asn1(v14, &v12, 4)
    && !EVP_CIPHER_CTX_get_app_data((__int64)v14) )
  {
    v5 = (char *)lh_num_items((__int64)&v12);
    v6 = EVP_CIPHER_CTX_get_app_data((__int64)&v12);
    if ( (unsigned int)sub_B35E0(&v11, &v10, v13, v4, v3, v5, v6) )
    {
      v8 = v10;
      v7 = v11;
      CBS_init(v9, (__int64)v11, v10);
      EVP_parse_private_key(v9);
      OPENSSL_cleanse(v7, v8);
      free(v7);
    }
  }
  else
  {
    ERR_put_error(19, 0LL, 104, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", 420);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v15;
}

//----- (00000000000B395C) ----------------------------------------------------
signed __int64 __fastcall PKCS8_marshal_encrypted_private_key(__int64 *a1, int a2, __int64 a3, __int64 a4, unsigned __int64 a5, const void *a6, size_t a7, unsigned int a8, __int64 a9)
{
  __int64 *v9; // x20
  unsigned int v10; // w25
  size_t v11; // x21
  const void *v12; // x24
  unsigned __int64 v13; // x22
  __int64 v14; // x23
  int v15; // w27
  void *v16; // x19
  char *v17; // x26
  _BOOL4 v18; // w20
  char *v19; // x0
  signed __int64 result; // x0
  void *v21; // x0
  int v22; // w0
  int v23; // w2
  __int16 v24; // w4
  int v25; // w0
  unsigned __int64 v26; // x21
  unsigned __int64 v27; // x21
  int v28; // [xsp+0h] [xbp-1F0h]
  int v29; // [xsp+4h] [xbp-1ECh]
  __int64 v30; // [xsp+8h] [xbp-1E8h]
  char v31; // [xsp+10h] [xbp-1E0h]
  __int64 v32[4]; // [xsp+30h] [xbp-1C0h]
  __int64 v33[4]; // [xsp+50h] [xbp-1A0h]
  unsigned __int64 v34; // [xsp+70h] [xbp-180h]
  char *v35; // [xsp+78h] [xbp-178h]
  char **v36[4]; // [xsp+80h] [xbp-170h]
  char v37; // [xsp+A0h] [xbp-150h]
  char **v38[4]; // [xsp+C0h] [xbp-130h]
  char v39; // [xsp+E0h] [xbp-110h]
  unsigned int *v40[19]; // [xsp+100h] [xbp-F0h]
  __int64 v41; // [xsp+198h] [xbp-58h]

  v9 = a1;
  v10 = a8;
  v11 = a7;
  v12 = a6;
  v13 = a5;
  v14 = a4;
  v15 = a2;
  v41 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v34 = 0LL;
  v35 = 0LL;
  EVP_CIPHER_CTX_init(v40);
  v16 = 0LL;
  if ( !v12 )
  {
    if ( !v11 )
      v11 = 8LL;
    v21 = malloc(v11);
    v16 = v21;
    if ( !v21 || !(unsigned int)RAND_pseudo_bytes((signed __int64)v21, v11) )
    {
LABEL_11:
      v18 = 0;
      v19 = v35;
      if ( !v35 )
        goto LABEL_13;
      goto LABEL_12;
    }
    v12 = v16;
  }
  if ( (signed int)v10 < 1 )
    v10 = 2048;
  if ( !(unsigned int)CBB_init(v33, 0x80uLL)
    || !(unsigned int)EVP_marshal_private_key((__int64)v33, a9)
    || !(unsigned int)CBB_finish((__int64)v33, &v35, &v34) )
  {
    CBB_cleanup(v33);
    goto LABEL_11;
  }
  if ( !(unsigned int)CBB_add_asn1(v9, v32, 0x30u) )
    goto LABEL_11;
  v17 = (char *)&unk_104F18;
  switch ( v15 )
  {
    case 144:
      v17 = (char *)&unk_104F40;
      goto LABEL_26;
    case 145:
    case 147:
    case 148:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
      goto LABEL_23;
    case 146:
      v17 = (char *)&unk_104F68;
      goto LABEL_26;
    case 149:
      goto LABEL_26;
    case 161:
      v17 = (char *)&unk_104F90;
LABEL_26:
      v25 = CBB_add_asn1(v32, (__int64 *)&v39, 0x30u);
      if ( v25 )
      {
        v25 = CBB_add_asn1((__int64 *)&v39, (__int64 *)v38, 6u);
        if ( v25 )
        {
          v25 = CBB_add_bytes(v38, v17 + 4, (unsigned __int8)v17[14]);
          if ( v25 )
          {
            v25 = CBB_add_asn1((__int64 *)&v39, (__int64 *)&v37, 0x30u);
            if ( v25 )
            {
              v25 = CBB_add_asn1((__int64 *)&v37, (__int64 *)v36, 4u);
              if ( v25 )
              {
                v25 = CBB_add_bytes(v36, v12, v11);
                if ( v25 )
                {
                  v25 = CBB_add_asn1_uint64((__int64 *)&v37, v10);
                  if ( v25 )
                  {
                    v25 = CBB_flush(v32);
                    if ( v25 )
                      sub_B3E04((__int64)v17, v40, v10, v14, v13, (__int64)v12, v11, 1);
                  }
                }
              }
            }
          }
        }
      }
      if ( v25 )
        goto LABEL_36;
      goto LABEL_11;
    default:
      if ( v15 != -1 )
      {
LABEL_23:
        v23 = 119;
        v24 = 332;
LABEL_38:
        ERR_put_error(19, 0LL, v23, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", v24);
        goto LABEL_11;
      }
      sub_B4F1C(v32, v40, (unsigned int *)&unk_104F18, v10, v14, v13, v12, v11);
      if ( !v22 )
        goto LABEL_11;
LABEL_36:
      v26 = v34;
      v27 = v26 + (unsigned int)EVP_MD_CTX_size((__int64)v40);
      if ( v27 < v34 )
      {
        v23 = 118;
        v24 = 497;
        goto LABEL_38;
      }
      if ( !(unsigned int)CBB_add_asn1(v32, (__int64 *)&v31, 4u)
        || !(unsigned int)CBB_reserve((__int64 *)&v31, &v30, v27)
        || !(unsigned int)EVP_CipherUpdate((signed int *)v40, v30, &v29, v35, v34)
        || !(unsigned int)EVP_CipherFinal_ex((__int64 *)v40, v30 + v29, &v28)
        || !(unsigned int)CBB_did_write((__int64 *)&v31, v28 + (signed __int64)v29) )
      {
        goto LABEL_11;
      }
      v18 = (unsigned __int64)CBB_flush(v9) != 0;
      v19 = v35;
      if ( !v35 )
        goto LABEL_13;
      break;
  }
LABEL_12:
  OPENSSL_cleanse(v19, v34);
  free(v35);
LABEL_13:
  free(v16);
  result = EVP_CIPHER_CTX_cleanup((void **)v40);
  if ( *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == v41 )
    result = (unsigned int)v18;
  return result;
}

//----- (00000000000B3CC4) ----------------------------------------------------
void __fastcall sub_B3CC4(__int64 a1, unsigned int **a2, __int64 a3, unsigned __int64 a4, unsigned __int8 **a5)
{
  __int64 v5; // x23
  __int64 v6; // x20
  unsigned int **v7; // x21
  __int64 v8; // x22
  unsigned __int64 v9; // x19
  int v10; // w2
  __int16 v11; // w4
  unsigned int v12; // w23
  __int64 v13; // x24
  __int64 v14; // x0
  __int64 v15; // [xsp+0h] [xbp-60h]
  char v16; // [xsp+8h] [xbp-58h]
  unsigned __int8 *v17[2]; // [xsp+18h] [xbp-48h]
  __int64 v18; // [xsp+28h] [xbp-38h]

  v5 = (__int64)a5;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = a4;
  v18 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)CBS_get_asn1(a5, (char *)v17, 48)
    && (unsigned int)CBS_get_asn1(v17, &v16, 4)
    && (unsigned int)CBS_get_asn1_uint64(v17, (unsigned __int64 *)&v15)
    && !EVP_CIPHER_CTX_get_app_data((__int64)v17)
    && !EVP_CIPHER_CTX_get_app_data(v5) )
  {
    v12 = v15;
    if ( (unsigned __int64)(v15 - 1) < 0xFFFFFFFF )
    {
      v13 = lh_num_items((__int64)&v16);
      v14 = EVP_CIPHER_CTX_get_app_data((__int64)&v16);
      sub_B3E04(v8, v7, v12, v6, v9, v13, v14, 0);
      goto LABEL_8;
    }
    v10 = 129;
    v11 = 268;
  }
  else
  {
    v10 = 104;
    v11 = 263;
  }
  ERR_put_error(19, 0LL, v10, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", v11);
LABEL_8:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v18;
}

//----- (00000000000B3E04) ----------------------------------------------------
void __fastcall sub_B3E04(__int64 a1, unsigned int **a2, unsigned int a3, __int64 a4, unsigned __int64 a5, __int64 a6, unsigned __int64 a7, int a8)
{
  __int64 v8; // x22
  int v9; // w19
  unsigned __int64 v10; // x21
  __int64 v11; // x23
  unsigned __int64 v12; // x24
  __int64 v13; // x26
  unsigned int v14; // w25
  unsigned int **v15; // x20
  __int64 v16; // x0
  __int64 (*v17)(void); // x8
  unsigned int *v18; // x22
  __int64 v19; // x27
  unsigned int v20; // w0
  int v21; // w0
  unsigned int v22; // w0
  int v23; // w0
  char v24; // [xsp+8h] [xbp-A8h]
  char v25; // [xsp+18h] [xbp-98h]
  __int64 v26; // [xsp+58h] [xbp-58h]

  v8 = a1;
  v9 = a8;
  v10 = a7;
  v26 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = a6;
  v12 = a5;
  v13 = a4;
  v14 = a3;
  v15 = a2;
  v16 = (*(__int64 (**)(void))(a1 + 16))();
  v17 = *(__int64 (**)(void))(v8 + 24);
  v18 = (unsigned int *)v16;
  v19 = v17();
  v20 = EVP_MD_flags((__int64)v18);
  sub_B2FE8(v13, v12, v11, v10, 1LL, v14, v20, &v25, v19);
  if ( v21 && (v22 = EVP_CIPHER_iv_length((__int64)v18), sub_B2FE8(v13, v12, v11, v10, 2LL, v14, v22, &v24, v19), v23) )
  {
    EVP_CipherInit_ex(v15, v18, 0LL, (__int64)&v25, &v24, v9);
    OPENSSL_cleanse(&v25, 0x40uLL);
    OPENSSL_cleanse(&v24, 0x10uLL);
  }
  else
  {
    ERR_put_error(19, 0LL, 110, (__int64)"external/boringssl/src/crypto/pkcs8/pkcs8.c", 243);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000B3F68) ----------------------------------------------------
void __fastcall ASN1_generate_nconf(const char *a1, __int64 *a2)
{
  const char *v2; // x19
  __int64 v3; // [xsp+0h] [xbp-50h]
  __int64 v4; // [xsp+38h] [xbp-18h]

  v2 = a1;
  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a2 )
  {
    X509V3_set_nconf((__int64)&v3, (__int64)a2);
    a2 = &v3;
  }
  ASN1_generate_v3(v2, (__int64)a2);
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000B3FC8) ----------------------------------------------------
void __fastcall ASN1_generate_v3(const char *a1, __int64 a2)
{
  __int64 v2; // x21
  int v3; // w20
  __int64 v4; // x19
  unsigned __int64 *v5; // x22
  unsigned __int64 *v6; // x0
  unsigned __int64 *v7; // x23
  unsigned __int64 v8; // x19
  unsigned __int64 *v9; // x0
  __int64 v10; // x8
  unsigned __int8 *v11; // x21
  int v12; // w22
  __int64 v13; // x0
  __int64 v14; // x19
  int v15; // w22
  void *v16; // x0
  int v17; // w0
  int v18; // w24
  int v19; // w0
  _DWORD *v20; // x0
  __int64 v21; // x0
  int v22; // w0
  int v23; // w2
  __int16 v24; // w4
  int v25; // w2
  __int16 v26; // w4
  __int64 v27; // x0
  _QWORD *v28; // x0
  _BYTE *v29; // x0
  _QWORD *v30; // x0
  __int64 v31; // x0
  __int64 v32; // x3
  __int64 v33; // x4
  __int64 v34; // x5
  __int64 v35; // x6
  __int64 v36; // x7
  int v37; // w0
  int v38; // w20
  char v39; // w0
  int v40; // w21
  signed int v41; // w1
  int v42; // w22
  void *v43; // x20
  void *v44; // x0
  signed int v45; // w23
  int v46; // w19
  __int64 *v47; // x24
  signed int v48; // w2
  signed __int64 v49; // x1
  int v50; // w0
  __int64 v51; // x19
  char *v52; // x0
  int v53; // w23
  signed int *v54; // x24
  char *v55; // x8
  bool v56; // zf
  int v57; // w1
  __int64 v58; // [xsp+0h] [xbp-290h]
  char v59; // [xsp+8h] [xbp-288h]
  char v60; // [xsp+Ch] [xbp-284h]
  __int64 v61; // [xsp+10h] [xbp-280h]
  void *v62; // [xsp+18h] [xbp-278h]
  void *v63; // [xsp+20h] [xbp-270h]
  char *v64; // [xsp+28h] [xbp-268h]
  void *v65; // [xsp+30h] [xbp-260h]
  __int64 v66; // [xsp+38h] [xbp-258h]
  unsigned __int8 *v67; // [xsp+40h] [xbp-250h]
  __int64 v68; // [xsp+48h] [xbp-248h]
  int v69; // [xsp+50h] [xbp-240h]
  int v70; // [xsp+54h] [xbp-23Ch]
  unsigned __int8 *v71; // [xsp+58h] [xbp-238h]
  __int64 v72; // [xsp+70h] [xbp-220h]
  int v73; // [xsp+240h] [xbp-50h]
  __int64 v74; // [xsp+248h] [xbp-48h]

  v2 = a2;
  v74 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v63 = 0LL;
  v61 = 0LL;
  v68 = -1LL;
  v70 = 1;
  v73 = 0;
  if ( (unsigned int)sub_A5CC4(
                       a1,
                       0x2Cu,
                       1,
                       (__int64 (__fastcall *)(const char *, __int64, __int64))sub_B47E4,
                       (__int64)&v68) )
    goto LABEL_2;
  v3 = v69;
  if ( (v69 & 0xFFFFFFFE) == 16 )
  {
    if ( !v2 )
    {
      ERR_put_error(12, 0LL, 170, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", 171);
      goto LABEL_2;
    }
    v4 = (__int64)v71;
    v65 = 0LL;
    v5 = sk_new_null();
    if ( !v5 )
    {
      v14 = 0LL;
      v7 = 0LL;
      v16 = v65;
      if ( !v65 )
        goto LABEL_72;
      goto LABEL_71;
    }
    if ( v4 )
    {
      v6 = (unsigned __int64 *)X509V3_get_section(v2);
      v7 = v6;
      if ( !v6 )
        goto LABEL_36;
      if ( sk_num(v6) )
      {
        v8 = 0LL;
        while ( 1 )
        {
          v9 = sk_value(v7, v8);
          v10 = ASN1_generate_v3(v9[2], v2);
          if ( !v10 )
            break;
          if ( !sk_push(v5, v10) )
          {
            v14 = 0LL;
            goto LABEL_70;
          }
          if ( ++v8 >= (unsigned __int64)sk_num(v7) )
            goto LABEL_28;
        }
LABEL_36:
        v14 = 0LL;
        v16 = v65;
        if ( !v65 )
          goto LABEL_72;
        goto LABEL_71;
      }
    }
    else
    {
      v7 = 0LL;
    }
LABEL_28:
    if ( v3 == 17 )
    {
      i2d_ASN1_SET_ANY();
      v18 = v17;
      if ( v17 & 0x80000000 )
        goto LABEL_36;
    }
    else
    {
      i2d_ASN1_SEQUENCE_ANY();
      v18 = v19;
      if ( v19 & 0x80000000 )
        goto LABEL_36;
    }
    v14 = ASN1_TYPE_new();
    if ( v14 )
    {
      v20 = ASN1_STRING_type_new(v3);
      *(_QWORD *)(v14 + 8) = v20;
      if ( v20 )
      {
        *(_DWORD *)v14 = v3;
        *((_QWORD *)v20 + 1) = v65;
        **(_DWORD **)(v14 + 8) = v18;
        v65 = 0LL;
        if ( !v5 )
        {
LABEL_74:
          if ( v7 )
          {
            X509V3_section_free(v2, (__int64)v7);
            if ( !v14 )
              goto LABEL_2;
            goto LABEL_94;
          }
          goto LABEL_93;
        }
LABEL_73:
        sk_pop_free(v5, (void (*)(void))ASN1_TYPE_free);
        goto LABEL_74;
      }
    }
LABEL_70:
    v16 = v65;
    if ( !v65 )
    {
LABEL_72:
      if ( !v5 )
        goto LABEL_74;
      goto LABEL_73;
    }
LABEL_71:
    free(v16);
    goto LABEL_72;
  }
  v11 = v71;
  v12 = v70;
  v13 = ASN1_TYPE_new();
  v14 = v13;
  if ( !v13 )
  {
    ERR_put_error(12, 0LL, 65, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", 636);
    if ( !v14 )
      goto LABEL_2;
    goto LABEL_94;
  }
  if ( !v11 )
    v11 = (unsigned __int8 *)&unk_B8A4C;
  switch ( v3 )
  {
    case 1:
      if ( v12 != 1 )
      {
        v23 = 161;
        v24 = 654;
        goto LABEL_89;
      }
      v65 = 0LL;
      v66 = 0LL;
      v67 = v11;
      if ( (unsigned int)X509V3_get_value_bool((__int64)&v65, (_DWORD *)(v13 + 8)) )
        goto LABEL_40;
      v25 = 125;
      v26 = 661;
      goto LABEL_91;
    case 2:
    case 10:
      if ( v12 != 1 )
      {
        v23 = 139;
        v24 = 669;
        goto LABEL_89;
      }
      s2i_ASN1_INTEGER(0LL, v11);
      *(_QWORD *)(v14 + 8) = v27;
      if ( v27 )
        goto LABEL_40;
      v25 = 130;
      v26 = 673;
      goto LABEL_91;
    case 3:
    case 4:
      v28 = ASN1_STRING_new();
      *(_QWORD *)(v14 + 8) = v28;
      if ( !v28 )
      {
        v23 = 65;
        v24 = 743;
        goto LABEL_89;
      }
      if ( v12 == 1 )
      {
        ASN1_STRING_set((__int64)v28, (const char *)v11, -1);
        if ( v3 != 3 )
          goto LABEL_40;
        goto LABEL_81;
      }
      if ( v12 == 3 )
      {
        v29 = sub_99F20((const char *)v11, &v64);
        if ( v29 )
        {
          *(_QWORD *)(*(_QWORD *)(v14 + 8) + 8LL) = v29;
          **(_DWORD **)(v14 + 8) = (_DWORD)v64;
          *(_DWORD *)(*(_QWORD *)(v14 + 8) + 4LL) = v3;
          if ( v3 != 3 )
            goto LABEL_40;
LABEL_81:
          *(_QWORD *)(*(_QWORD *)(v14 + 8) + 16LL) &= 0xFFFFFFFFFFFFFFF0LL;
          *(_QWORD *)(*(_QWORD *)(v14 + 8) + 16LL) |= 8uLL;
          goto LABEL_40;
        }
        v25 = 128;
        v26 = 750;
        goto LABEL_91;
      }
      if ( v3 == 3 && v12 == 4 )
      {
        if ( (unsigned int)sub_A5CC4(
                             (const char *)v11,
                             0x2Cu,
                             1,
                             (__int64 (__fastcall *)(const char *, __int64, __int64))sub_B4E38,
                             (__int64)v28) )
        {
LABEL_40:
          *(_DWORD *)v14 = v3;
          if ( !v14 )
            goto LABEL_2;
          goto LABEL_94;
        }
        v25 = 151;
        v26 = 764;
LABEL_91:
        ERR_put_error(12, 0LL, v25, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", v26);
        ERR_add_error_data(2u, (__int64)"string=", (__int64)v11, v32, v33, v34, v35, v36, v58);
        goto LABEL_92;
      }
      v23 = 124;
      v24 = 770;
LABEL_89:
      ERR_put_error(12, 0LL, v23, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", v24);
LABEL_92:
      ASN1_TYPE_free(v14);
      v14 = 0LL;
LABEL_93:
      if ( !v14 )
        goto LABEL_2;
LABEL_94:
      if ( (_DWORD)v68 == -1 && !v73 )
        goto LABEL_2;
      i2d_ASN1_TYPE();
      v38 = v37;
      ASN1_TYPE_free(v14);
      v65 = v63;
      if ( (_DWORD)v68 == -1 )
      {
        v42 = 0;
        v40 = v38;
        goto LABEL_105;
      }
      v39 = ASN1_get_object((unsigned __int8 **)&v65, &v61, &v60, (int *)&v59, v38);
      if ( !(v39 & 0x80) )
      {
        v40 = v38 - (_DWORD)v65 + (_DWORD)v63;
        if ( v39 & 1 )
        {
          v41 = 0;
          v61 = 0LL;
          v42 = 2;
        }
        else
        {
          v41 = v61;
          v42 = v39 & 0x20;
        }
        v38 = ASN1_object_size(0, v41, v68);
LABEL_105:
        v45 = v73;
        if ( v73 >= 1 )
        {
          v46 = 0;
          v47 = &v68 + 3 * v73 + 2;
          do
          {
            v48 = *((_DWORD *)v47 - 4);
            v49 = *((signed int *)v47 - 1) + (signed __int64)v38;
            *v47 = v49;
            v47 -= 3;
            v50 = ASN1_object_size(0, v49, v48);
            v45 = v73;
            v38 = v50;
            ++v46;
          }
          while ( v46 < v73 );
        }
        v51 = v38;
        v52 = (char *)malloc(v38);
        v43 = v52;
        if ( v52 )
        {
          v64 = v52;
          if ( v45 >= 1 )
          {
            v53 = 0;
            v54 = (signed int *)&v72;
            do
            {
              ASN1_put_object(&v64, *(v54 - 2), *v54, *(v54 - 4), *(v54 - 3));
              if ( *(v54 - 1) )
              {
                v55 = v64++;
                *v55 = 0;
              }
              ++v53;
              v54 += 6;
            }
            while ( v53 < v73 );
          }
          if ( (_DWORD)v68 != -1 )
          {
            if ( HIDWORD(v68) )
              v56 = 0;
            else
              v56 = (v68 & 0xFFFFFFFE) == 16;
            if ( v56 )
              v57 = 32;
            else
              v57 = v42;
            ASN1_put_object(&v64, v57, v61, v68, SBYTE4(v68));
          }
          if ( v40 )
            memcpy(v64, v65, v40);
          v62 = v43;
          d2i_ASN1_TYPE(0LL, (const void **)&v62, v51);
          v44 = v63;
          if ( !v63 )
            goto LABEL_128;
        }
        else
        {
          v44 = v63;
          if ( !v63 )
            goto LABEL_128;
        }
        goto LABEL_127;
      }
      v43 = 0LL;
      v44 = v63;
      if ( v63 )
LABEL_127:
        free(v44);
LABEL_128:
      if ( v43 )
        free(v43);
LABEL_2:
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v74;
      return;
    case 5:
      if ( !*v11 )
        goto LABEL_40;
      v23 = 133;
      v24 = 647;
      goto LABEL_89;
    case 6:
      if ( v12 != 1 )
      {
        v23 = 165;
        v24 = 680;
        goto LABEL_89;
      }
      OBJ_txt2obj((const char *)v11, 0);
      *(_QWORD *)(v14 + 8) = v31;
      if ( v31 )
        goto LABEL_40;
      v25 = 134;
      v26 = 684;
      goto LABEL_91;
    case 12:
    case 18:
    case 19:
    case 20:
    case 22:
    case 26:
    case 27:
    case 28:
    case 30:
      if ( v12 == 1 )
      {
        v15 = 4097;
      }
      else
      {
        if ( v12 != 2 )
        {
          v23 = 127;
          v24 = 726;
          goto LABEL_89;
        }
        v15 = 4096;
      }
      v21 = ASN1_tag2bit(v3);
      ASN1_mbstring_copy((__int64 *)(v14 + 8), (const char *)v11, -1, v15, v21);
      if ( v22 > 0 )
        goto LABEL_40;
      v25 = 65;
      v26 = 732;
      goto LABEL_91;
    case 23:
    case 24:
      if ( v12 != 1 )
      {
        v23 = 176;
        v24 = 692;
        goto LABEL_89;
      }
      v30 = ASN1_STRING_new();
      *(_QWORD *)(v14 + 8) = v30;
      if ( v30 )
      {
        if ( (unsigned int)ASN1_STRING_set((__int64)v30, (const char *)v11, -1) )
        {
          *(_DWORD *)(*(_QWORD *)(v14 + 8) + 4LL) = v3;
          if ( (unsigned int)ASN1_TIME_check(*(signed int **)(v14 + 8)) )
            goto LABEL_40;
          v25 = 138;
          v26 = 705;
        }
        else
        {
          v25 = 65;
          v26 = 700;
        }
      }
      else
      {
        v25 = 65;
        v26 = 696;
      }
      goto LABEL_91;
    default:
      v25 = 188;
      v26 = 783;
      goto LABEL_91;
  }
}

//----- (00000000000B47E4) ----------------------------------------------------
signed __int64 __fastcall sub_B47E4(const char *a1, signed int a2, int *a3)
{
  int *v3; // x19
  signed int v4; // w22
  const char *v5; // x21
  __int64 v6; // x8
  int v7; // w23
  const char *v8; // x20
  signed __int64 result; // x0
  const char *v10; // x8
  int v11; // w0
  unsigned int v12; // w25
  size_t v13; // x24
  char **v14; // x27
  __int64 v15; // x3
  __int64 v16; // x4
  __int64 v17; // x5
  __int64 v18; // x6
  __int64 v19; // x7
  int v20; // w8
  int v21; // w2
  __int16 v22; // w4
  __int64 v23; // x8
  int v24; // w9
  int *v25; // x10
  __int64 v26; // x8
  int v27; // w9
  int *v28; // x10
  __int64 v29; // x8
  signed int v30; // w9
  signed int *v31; // x10
  signed int v32; // w9
  __int64 v33; // x8
  __int64 v34; // kr00_8
  int v35; // w11
  signed __int64 v36; // x8
  signed __int64 v37; // x8
  signed __int64 v38; // x9
  __int64 v39; // [xsp+0h] [xbp-60h]
  __int64 v40; // [xsp+8h] [xbp-58h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v40 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    if ( a2 < 1 )
    {
LABEL_6:
      v7 = 0;
      v8 = 0LL;
    }
    else
    {
      v6 = 0LL;
      while ( a1[v6] != 58 )
      {
        if ( (signed int)++v6 >= a2 )
          goto LABEL_6;
      }
      v10 = &a1[v6];
      v8 = v10 + 1;
      v7 = a2 + (_DWORD)a1 - ((_DWORD)v10 + 1);
      v4 = (_DWORD)v10 - (_DWORD)a1;
    }
    v11 = v4;
    if ( v4 == -1 )
      v11 = strlen(v5);
    v12 = 0;
    v13 = v11;
    v14 = &off_104FC8;
    qword_107428 = (__int64)&off_104FB8;
    while ( (_DWORD)v13 != *((_DWORD *)v14 - 2) || (unsigned int)strncmp(*(v14 - 2), v5, v13) )
    {
      ++v12;
      qword_107428 = (__int64)v14;
      v14 += 2;
      if ( v12 >= 0x31 )
        goto LABEL_15;
    }
    v20 = *((_DWORD *)v14 - 1);
    if ( v20 == -1 )
    {
LABEL_15:
      ERR_put_error(12, 0LL, 185, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", 307);
      ERR_add_error_data(2u, (__int64)"tag=", (__int64)v5, v15, v16, v17, v18, v19, v39);
      goto LABEL_16;
    }
    if ( !(v20 & 0x10000) )
    {
      v3[2] = v20;
      *((_QWORD *)v3 + 2) = v8;
      if ( v8 )
      {
        result = 0LL;
        goto LABEL_17;
      }
      if ( !v5[v4] )
      {
        result = 0LL;
        goto LABEL_17;
      }
      v21 = 155;
      v22 = 318;
LABEL_43:
      ERR_put_error(12, 0LL, v21, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", v22);
LABEL_16:
      result = 0xFFFFFFFFLL;
      goto LABEL_17;
    }
    switch ( v20 )
    {
      case 65537:
        if ( *v3 != -1 )
        {
          v21 = 131;
          v22 = 329;
          goto LABEL_43;
        }
        if ( !(unsigned int)sub_B4CD4(v8, v7, v3, v3 + 1) )
          goto LABEL_16;
        goto def_B497C;
      case 65538:
        if ( !(unsigned int)sub_B4CD4(v8, v7, (_DWORD *)&v39 + 1, (signed int *)&v39) )
          goto LABEL_16;
        if ( *v3 != -1 )
        {
          v21 = 129;
          v22 = 518;
          goto LABEL_43;
        }
        v33 = v3[126];
        if ( (_DWORD)v33 == 20 )
        {
LABEL_42:
          v21 = 110;
          v22 = 523;
          goto LABEL_43;
        }
        v34 = v39;
        v35 = v33 + 1;
        v36 = (signed __int64)&v3[6 * v33];
        v3[126] = v35;
        *(_DWORD *)(v36 + 24) = HIDWORD(v34);
        *(_DWORD *)(v36 + 28) = v34;
        *(_QWORD *)(v36 + 32) = 1LL;
        goto def_B497C;
      case 65540:
        v23 = v3[126];
        if ( (_DWORD)v23 == 20 )
          goto LABEL_42;
        v24 = *v3;
        v3[126] = v23 + 1;
        v25 = &v3[6 * v23 + 6];
        if ( v24 == -1 )
        {
          *v25 = 3;
          v3[6 * v23 + 7] = 0;
        }
        else
        {
          *v25 = v24;
          v3[6 * v23 + 7] = v3[1];
          *(_QWORD *)v3 = -1LL;
        }
        v37 = (signed __int64)&v3[6 * v23];
        v38 = 0x100000000LL;
        goto LABEL_65;
      case 65541:
        v26 = v3[126];
        if ( (_DWORD)v26 == 20 )
          goto LABEL_42;
        v27 = *v3;
        v3[126] = v26 + 1;
        v28 = &v3[6 * v26 + 6];
        if ( v27 == -1 )
        {
          *v28 = 4;
          v3[6 * v26 + 7] = 0;
        }
        else
        {
          *v28 = v27;
          v3[6 * v26 + 7] = v3[1];
          *(_QWORD *)v3 = -1LL;
        }
        *(_QWORD *)&v3[6 * v26 + 8] = 0LL;
        goto def_B497C;
      case 65542:
        v29 = v3[126];
        if ( (_DWORD)v29 == 20 )
          goto LABEL_42;
        v30 = *v3;
        v3[126] = v29 + 1;
        v31 = &v3[6 * v29 + 6];
        if ( v30 != -1 )
          goto LABEL_51;
        v32 = 16;
        goto LABEL_63;
      case 65543:
        v29 = v3[126];
        if ( (_DWORD)v29 == 20 )
          goto LABEL_42;
        v30 = *v3;
        v3[126] = v29 + 1;
        v31 = &v3[6 * v29 + 6];
        if ( v30 == -1 )
        {
          v32 = 17;
LABEL_63:
          *v31 = v32;
          v3[6 * v29 + 7] = 0;
        }
        else
        {
LABEL_51:
          *v31 = v30;
          v3[6 * v29 + 7] = v3[1];
          *(_QWORD *)v3 = -1LL;
        }
        v37 = (signed __int64)&v3[6 * v29];
        v38 = 1LL;
LABEL_65:
        *(_QWORD *)(v37 + 32) = v38;
        goto def_B497C;
      case 65544:
        if ( !v8 )
        {
          v21 = 182;
          v22 = 366;
          goto LABEL_43;
        }
        if ( (unsigned int)strncmp(v8, "ASCII", 5uLL) )
        {
          if ( (unsigned int)strncmp(v8, "UTF8", 4uLL) )
          {
            if ( (unsigned int)strncmp(v8, "HEX", 3uLL) )
            {
              if ( (unsigned int)strncmp(v8, "BITLIST", 7uLL) )
              {
                v21 = 182;
                v22 = 378;
                goto LABEL_43;
              }
              v3[3] = 4;
            }
            else
            {
              v3[3] = 3;
            }
          }
          else
          {
            v3[3] = 2;
          }
        }
        else
        {
          v3[3] = 1;
        }
def_B497C:
        result = 1LL;
        break;
      default:
        goto def_B497C;
    }
  }
  else
  {
    result = 0LL;
  }
LABEL_17:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v40;
  return result;
}
// 104FB8: using guessed type char *off_104FB8;
// 104FC8: using guessed type char *;
// 107428: using guessed type __int64 qword_107428;

//----- (00000000000B4CD4) ----------------------------------------------------
signed __int64 __fastcall sub_B4CD4(const char *a1, int a2, _DWORD *a3, signed int *a4)
{
  signed int *v4; // x19
  _DWORD *v5; // x22
  int v6; // w20
  const char *v7; // x21
  unsigned __int64 v8; // x0
  char *v9; // x8
  signed __int64 result; // x0
  char v11; // w9
  signed int v12; // w8
  __int64 v13; // x3
  __int64 v14; // x4
  __int64 v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  __int64 v18; // [xsp+0h] [xbp-40h]
  char *v19; // [xsp+8h] [xbp-38h]
  char v20; // [xsp+14h] [xbp-2Ch]
  char v21; // [xsp+15h] [xbp-2Bh]
  __int64 v22; // [xsp+18h] [xbp-28h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v8 = strtoul(a1, &v19, 10);
    v9 = v19;
    if ( v19 && *v19 && v19 > &v7[v6] )
    {
      result = 0LL;
    }
    else if ( v8 & 0x8000000000000000LL )
    {
      ERR_put_error(12, 0LL, 145, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", 401);
      result = 0LL;
    }
    else
    {
      *v5 = v8;
      if ( v9 && v6 + (_DWORD)v7 != (_DWORD)v9 )
      {
        v11 = *v9;
        v12 = 64;
        switch ( 64 )
        {
          case 0:
            goto LABEL_13;
          case 2:
            v12 = 128;
            goto LABEL_13;
          case 15:
            v12 = 192;
            goto LABEL_13;
          case 20:
            v12 = 0;
            goto LABEL_13;
          default:
            v20 = v11;
            v21 = 0;
            ERR_put_error(12, 0LL, 144, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", 432);
            ERR_add_error_data(2u, (__int64)"Char=", (__int64)&v20, v13, v14, v15, v16, v17, v18);
            result = 0LL;
            break;
        }
      }
      else
      {
        v12 = 128;
LABEL_13:
        result = 1LL;
        *v4 = v12;
      }
    }
  }
  else
  {
    result = 0LL;
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v22;
  return result;
}

//----- (00000000000B4E38) ----------------------------------------------------
void __fastcall sub_B4E38(const char *a1, int a2, signed int *a3)
{
  signed int *v3; // x19
  int v4; // w20
  const char *v5; // x21
  unsigned __int64 v6; // x0
  int v7; // w2
  __int16 v8; // w4
  const char *v9; // [xsp+0h] [xbp-30h]
  __int64 v10; // [xsp+8h] [xbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v10 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( a1 )
  {
    v6 = strtoul(a1, (char **)&v9, 10);
    if ( !v9 || !*v9 || v9 == &v5[v4] )
    {
      if ( v6 & 0x8000000000000000LL )
      {
        v7 = 145;
        v8 = 810;
        goto LABEL_9;
      }
      if ( !(unsigned int)ASN1_BIT_STRING_set_bit(v3, v6, 1) )
      {
        v7 = 65;
        v8 = 814;
LABEL_9:
        ERR_put_error(12, 0LL, v7, (__int64)"external/boringssl/src/crypto/x509/asn1_gen.c", v8);
        goto LABEL_10;
      }
    }
  }
LABEL_10:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000B4F1C) ----------------------------------------------------
void __fastcall sub_B4F1C(__int64 *a1, unsigned int **a2, unsigned int *a3, unsigned int a4, __int64 a5, unsigned __int64 a6, const void *a7, size_t a8)
{
  __int64 v8; // x24
  __int64 *v9; // x26
  size_t v10; // x19
  const void *v11; // x20
  unsigned __int64 v12; // x21
  __int64 v13; // x22
  unsigned int v14; // w23
  unsigned int **v15; // x25
  signed int v16; // w27
  unsigned int v17; // w0
  unsigned int v18; // w0
  signed __int64 v19; // x27
  int v20; // w2
  __int16 v21; // w4
  unsigned int v22; // w0
  unsigned int v23; // w0
  __int64 v24[4]; // [xsp+18h] [xbp-188h]
  char **v25[4]; // [xsp+38h] [xbp-168h]
  char v26; // [xsp+58h] [xbp-148h]
  char **v27[4]; // [xsp+78h] [xbp-128h]
  char v28; // [xsp+98h] [xbp-108h]
  char v29; // [xsp+B8h] [xbp-E8h]
  char **v30[4]; // [xsp+D8h] [xbp-C8h]
  char v31; // [xsp+F8h] [xbp-A8h]
  char **v32[4]; // [xsp+118h] [xbp-88h]
  char v33; // [xsp+138h] [xbp-68h]
  __int64 v34; // [xsp+148h] [xbp-58h]

  v8 = (__int64)a3;
  v9 = a1;
  v10 = a8;
  v11 = a7;
  v12 = a6;
  v13 = a5;
  v14 = a4;
  v15 = a2;
  v34 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v16 = X509_TRUST_get_trust(a3);
  if ( !v16 )
  {
    v20 = 102;
    v21 = 166;
    goto LABEL_23;
  }
  v17 = EVP_CIPHER_iv_length(v8);
  if ( (unsigned int)RAND_pseudo_bytes((signed __int64)&v33, v17) )
  {
    if ( (unsigned int)CBB_add_asn1(v9, (__int64 *)&v31, 0x30u) )
    {
      if ( (unsigned int)CBB_add_asn1((__int64 *)&v31, (__int64 *)v30, 6u) )
      {
        if ( (unsigned int)CBB_add_bytes(v30, &unk_DDFB8, 9uLL) )
        {
          if ( (unsigned int)CBB_add_asn1((__int64 *)&v31, (__int64 *)&v29, 0x30u) )
          {
            if ( (unsigned int)CBB_add_asn1((__int64 *)&v29, (__int64 *)&v28, 0x30u) )
            {
              if ( (unsigned int)CBB_add_asn1((__int64 *)&v28, (__int64 *)v27, 6u) )
              {
                if ( (unsigned int)CBB_add_bytes(v27, &unk_DDFC1, 9uLL) )
                {
                  if ( (unsigned int)CBB_add_asn1((__int64 *)&v28, (__int64 *)&v26, 0x30u) )
                  {
                    if ( (unsigned int)CBB_add_asn1((__int64 *)&v26, (__int64 *)v25, 4u) )
                    {
                      if ( (unsigned int)CBB_add_bytes(v25, v11, v10) )
                      {
                        if ( (unsigned int)CBB_add_asn1_uint64((__int64 *)&v26, v14) )
                        {
                          if ( v16 != 37
                            || (v18 = EVP_MD_flags(v8), (unsigned int)CBB_add_asn1_uint64((__int64 *)&v26, v18)) )
                          {
                            if ( (unsigned int)CBB_add_asn1((__int64 *)&v29, v24, 0x30u) )
                            {
                              if ( v16 <= 418 )
                              {
                                if ( v16 == 37 )
                                {
                                  v19 = 0LL;
                                  goto LABEL_32;
                                }
                                if ( v16 == 44 )
                                {
                                  v19 = 1LL;
                                  goto LABEL_32;
                                }
                              }
                              else
                              {
                                switch ( v16 )
                                {
                                  case 419:
                                    v19 = 2LL;
                                    goto LABEL_32;
                                  case 423:
                                    v19 = 3LL;
                                    goto LABEL_32;
                                  case 427:
                                    v19 = 4LL;
LABEL_32:
                                    if ( (unsigned int)CBB_add_asn1(v24, (__int64 *)v32, 6u) )
                                    {
                                      if ( (unsigned int)CBB_add_bytes(
                                                           v32,
                                                           (char *)&unk_1052C8 + 24 * v19,
                                                           *((unsigned __int8 *)&unk_1052C8 + 24 * v19 + 9)) )
                                      {
                                        if ( (unsigned int)CBB_flush(v24) )
                                        {
                                          if ( (unsigned int)CBB_add_asn1(v24, (__int64 *)v32, 4u) )
                                          {
                                            v22 = EVP_CIPHER_iv_length(v8);
                                            if ( (unsigned int)CBB_add_bytes(v32, &v33, v22) )
                                            {
                                              if ( (unsigned int)CBB_flush(v9) )
                                              {
                                                v23 = EVP_CIPHER_iv_length(v8);
                                                sub_B5224(v15, v8, v14, v13, v12, (__int64)v11, v10, &v33, v23, 1);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    goto LABEL_24;
                                }
                              }
                              v20 = 127;
                              v21 = 138;
LABEL_23:
                              ERR_put_error(
                                19,
                                0LL,
                                v20,
                                (__int64)"external/boringssl/src/crypto/pkcs8/p5_pbev2.c",
                                v21);
                              goto LABEL_24;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_24:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v34;
}

//----- (00000000000B5224) ----------------------------------------------------
void __fastcall sub_B5224(unsigned int **a1, __int64 a2, unsigned int a3, __int64 a4, unsigned __int64 a5, __int64 a6, __int64 a7, const void *a8, __int64 a9, int a10)
{
  unsigned int *v10; // x20
  unsigned int **v11; // x21
  const void *v12; // x19
  __int64 v13; // x22
  __int64 v14; // x23
  unsigned __int64 v15; // x24
  __int64 v16; // x26
  unsigned int v17; // w25
  unsigned int v18; // w0
  _BOOL4 v19; // w19
  char v20; // [xsp+8h] [xbp-98h]
  __int64 v21; // [xsp+48h] [xbp-58h]

  v10 = (unsigned int *)a2;
  v11 = a1;
  v12 = a8;
  v13 = a7;
  v14 = a6;
  v15 = a5;
  v16 = a4;
  v17 = a3;
  v21 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (unsigned int)EVP_CIPHER_iv_length(a2) == a9 )
  {
    v18 = EVP_MD_flags((__int64)v10);
    if ( PKCS5_PBKDF2_HMAC_SHA1(v16, v15, v14, v13, v17, v18, (int8x16_t *)&v20) )
      v19 = (unsigned __int64)EVP_CipherInit_ex(v11, v10, 0LL, (__int64)&v20, v12, a10) != 0;
    OPENSSL_cleanse(&v20, 0x40uLL);
  }
  else
  {
    ERR_put_error(19, 0LL, 107, (__int64)"external/boringssl/src/crypto/pkcs8/p5_pbev2.c", 148);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
}

//----- (00000000000B534C) ----------------------------------------------------
void __fastcall sub_B534C(__int64 a1, unsigned int **a2, __int64 a3, unsigned __int64 a4, unsigned __int8 **a5)
{
  __int64 v5; // x22
  __int64 v6; // x20
  unsigned int **v7; // x21
  unsigned __int64 v8; // x19
  int v9; // w2
  __int16 v10; // w4
  signed __int64 v11; // x8
  __int64 v12; // x22
  __int64 v13; // x23
  unsigned int v14; // w23
  __int64 v15; // x24
  __int64 v16; // x25
  const void *v17; // x26
  __int64 v18; // x0
  char v19; // [xsp+10h] [xbp-100h]
  __int64 v20[2]; // [xsp+20h] [xbp-F0h]
  __int64 v21; // [xsp+30h] [xbp-E0h]
  __int64 v22; // [xsp+40h] [xbp-D0h]
  char v23; // [xsp+48h] [xbp-C8h]
  unsigned __int8 *v24[2]; // [xsp+58h] [xbp-B8h]
  __int64 v25[2]; // [xsp+68h] [xbp-A8h]
  unsigned __int8 *v26[2]; // [xsp+78h] [xbp-98h]
  __int64 v27[2]; // [xsp+88h] [xbp-88h]
  unsigned __int8 *v28[2]; // [xsp+98h] [xbp-78h]
  unsigned __int8 *v29[2]; // [xsp+A8h] [xbp-68h]
  __int64 v30; // [xsp+B8h] [xbp-58h]

  v5 = (__int64)a5;
  v6 = a3;
  v7 = a2;
  v8 = a4;
  v30 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( !(unsigned int)CBS_get_asn1(a5, (char *)v29, 48)
    || EVP_CIPHER_CTX_get_app_data(v5)
    || !(unsigned int)CBS_get_asn1(v29, (char *)v28, 48)
    || !(unsigned int)CBS_get_asn1(v29, (char *)v26, 48)
    || EVP_CIPHER_CTX_get_app_data((__int64)v29)
    || !(unsigned int)CBS_get_asn1(v28, (char *)v27, 6)
    || !(unsigned int)CBS_get_asn1(v26, (char *)v25, 6) )
  {
    v9 = 104;
    v10 = 219;
    goto LABEL_4;
  }
  if ( !CBS_mem_equal(v27, (__int64)&unk_DDFC1, 9LL) )
  {
    v9 = 128;
    v10 = 225;
    goto LABEL_4;
  }
  if ( CBS_mem_equal(v25, (__int64)&unk_1052C8, 8LL) )
  {
    v11 = 0LL;
  }
  else if ( CBS_mem_equal(v25, (__int64)&unk_1052E0, 8LL) )
  {
    v11 = 1LL;
  }
  else if ( CBS_mem_equal(v25, (__int64)&unk_1052F8, 9LL) )
  {
    v11 = 2LL;
  }
  else if ( CBS_mem_equal(v25, (__int64)&unk_105310, 9LL) )
  {
    v11 = 3LL;
  }
  else
  {
    if ( !CBS_mem_equal(v25, (__int64)&unk_105328, 9LL) )
    {
LABEL_28:
      v9 = 127;
      v10 = 232;
      goto LABEL_4;
    }
    v11 = 4LL;
  }
  v12 = (*((__int64 (**)(void))&unk_1052C8 + 3 * v11 + 2))();
  if ( !v12 )
    goto LABEL_28;
  if ( (unsigned int)CBS_get_asn1(v28, (char *)v24, 48)
    && !EVP_CIPHER_CTX_get_app_data((__int64)v28)
    && (unsigned int)CBS_get_asn1(v24, &v23, 4)
    && (unsigned int)CBS_get_asn1_uint64(v24, (unsigned __int64 *)&v22) )
  {
    if ( (unsigned __int64)(v22 - 1) < 0xFFFFFFFF )
    {
      if ( CBS_peek_asn1_tag(v24, 2) )
      {
        if ( !(unsigned int)CBS_get_asn1_uint64(v24, (unsigned __int64 *)&v21) )
        {
          v9 = 104;
          v10 = 257;
          goto LABEL_4;
        }
        v13 = v21;
        if ( v13 != (unsigned int)EVP_MD_flags(v12) )
        {
          v9 = 125;
          v10 = 262;
          goto LABEL_4;
        }
      }
      if ( EVP_CIPHER_CTX_get_app_data((__int64)v24) )
      {
        if ( !(unsigned int)CBS_get_asn1(v24, (char *)&v21, 48)
          || !(unsigned int)CBS_get_asn1((unsigned __int8 **)&v21, (char *)v20, 6)
          || EVP_CIPHER_CTX_get_app_data((__int64)v24) )
        {
          v9 = 104;
          v10 = 272;
          goto LABEL_4;
        }
        if ( !CBS_mem_equal(v20, (__int64)&unk_DDFCA, 8LL) )
        {
          v9 = 130;
          v10 = 279;
          goto LABEL_4;
        }
        if ( !(unsigned int)CBS_get_asn1((unsigned __int8 **)&v21, &v19, 5)
          || EVP_CIPHER_CTX_get_app_data((__int64)&v19)
          || EVP_CIPHER_CTX_get_app_data((__int64)&v21) )
        {
          v9 = 104;
          v10 = 288;
          goto LABEL_4;
        }
      }
      if ( (unsigned int)CBS_get_asn1(v26, (char *)&v21, 4) && !EVP_CIPHER_CTX_get_app_data((__int64)v26) )
      {
        v14 = v22;
        v15 = lh_num_items((__int64)&v23);
        v16 = EVP_CIPHER_CTX_get_app_data((__int64)&v23);
        v17 = (const void *)lh_num_items((__int64)&v21);
        v18 = EVP_CIPHER_CTX_get_app_data((__int64)&v21);
        sub_B5224(v7, v12, v14, v6, v8, v15, v16, v17, v18, 0);
        goto LABEL_5;
      }
      v9 = 130;
      v10 = 300;
    }
    else
    {
      v9 = 129;
      v10 = 248;
    }
  }
  else
  {
    v9 = 104;
    v10 = 243;
  }
LABEL_4:
  ERR_put_error(19, 0LL, v9, (__int64)"external/boringssl/src/crypto/pkcs8/p5_pbev2.c", v10);
LABEL_5:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) != v30;
}

//----- (00000000000B579C) ----------------------------------------------------
bool __fastcall PKCS5_PBKDF2_HMAC(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, unsigned __int64 a7, int8x16_t *a8)
{
  __int64 v8; // x25
  __int64 v9; // x27
  int8x16_t *v10; // x20
  unsigned __int64 v11; // x21
  unsigned int v12; // w19
  unsigned __int64 v13; // x26
  unsigned __int64 v14; // x24
  unsigned int v15; // w27
  int8x16_t *v16; // x10
  unsigned int v17; // w10
  size_t v18; // x25
  unsigned __int64 v19; // x28
  unsigned int v20; // w22
  unsigned __int64 v21; // x8
  int8x16_t *v22; // x9
  unsigned __int64 v23; // x8
  int8x16_t v24; // q0
  int8x16_t v25; // q1
  int8x16_t v26; // q1
  _BOOL8 result; // x0
  char *v28; // x0
  char v29; // [xsp+30h] [xbp-170h]
  __int64 v30[13]; // [xsp+98h] [xbp-108h]
  char v31; // [xsp+104h] [xbp-9Ch]
  char v32; // [xsp+105h] [xbp-9Bh]
  char v33; // [xsp+106h] [xbp-9Ah]
  char v34; // [xsp+107h] [xbp-99h]
  char v35[64]; // [xsp+108h] [xbp-98h]
  char v36[64]; // [xsp+118h] [xbp-88h]
  __int64 v37; // [xsp+148h] [xbp-58h]

  v8 = a6;
  v9 = a1;
  v10 = a8;
  v11 = a7;
  v12 = a5;
  v13 = a2;
  v37 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v14 = X509_TRUST_get_flags(a6);
  HMAC_CTX_init(v30);
  if ( !HMAC_Init_ex(v30, v9, v13, v8) )
  {
LABEL_28:
    v28 = (char *)v30;
LABEL_30:
    HMAC_CTX_cleanup(v28);
    result = 0LL;
    goto LABEL_31;
  }
  if ( v11 )
  {
    v15 = 1;
    while ( 1 )
    {
      v17 = v15 >> 8;
      if ( v11 <= v14 )
        v18 = v11;
      else
        v18 = v14;
      v31 = HIBYTE(v15);
      v32 = BYTE2(v15);
      v33 = v17;
      v34 = v15;
      if ( !(unsigned int)HMAC_CTX_copy(&v29, v30) )
        goto LABEL_28;
      if ( !(unsigned int)HMAC_Update((__int64)&v29)
        || !(unsigned int)HMAC_Update((__int64)&v29)
        || !(unsigned int)HMAC_Final((__int64)&v29, (__int64)v35, 0LL) )
      {
        break;
      }
      HMAC_CTX_cleanup(&v29);
      if ( v18 )
        memcpy(v10, v35, v18);
      if ( v12 >= 2 )
      {
        v19 = v18 & 0xFFFFFFFFFFFFFFE0LL;
        v20 = 1;
        do
        {
          if ( !(unsigned int)HMAC_CTX_copy(&v29, v30) )
            goto LABEL_28;
          if ( !(unsigned int)HMAC_Update((__int64)&v29) || !(unsigned int)HMAC_Final((__int64)&v29, (__int64)v35, 0LL) )
            goto LABEL_29;
          HMAC_CTX_cleanup(&v29);
          if ( v18 )
          {
            if ( v18 < 0x20 || v19 == 0 || v10 < (int8x16_t *)(&v34 + v18 + 1) && v35 < (char *)v10 + v18 )
            {
              v21 = 0LL;
            }
            else
            {
              v22 = v10 + 1;
              v16 = (int8x16_t *)v36;
              v23 = v18 & 0xFFFFFFFFFFFFFFE0LL;
              do
              {
                v24 = v16[-1];
                v25 = *v16;
                v16 += 2;
                v23 -= 32LL;
                v26 = veorq_s8(*v22, v25);
                v22[-1] = veorq_s8(v22[-1], v24);
                *v22 = v26;
                v22 += 2;
              }
              while ( v23 );
              v21 = v18 & 0xFFFFFFFFFFFFFFE0LL;
              if ( v18 == v19 )
                goto LABEL_25;
            }
            do
            {
              *((_BYTE *)v10->n128_u64 + v21) ^= v35[v21];
              ++v21;
            }
            while ( v21 < v18 );
          }
LABEL_25:
          ++v20;
        }
        while ( v20 < v12 );
      }
      v11 -= v18;
      ++v15;
      v10 = (int8x16_t *)((char *)v10 + v18);
      if ( !v11 )
        goto LABEL_27;
    }
LABEL_29:
    HMAC_CTX_cleanup(v30);
    v28 = &v29;
    goto LABEL_30;
  }
LABEL_27:
  HMAC_CTX_cleanup(v30);
  result = v12 != 0;
LABEL_31:
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  return result;
}
// B579C: using guessed type char var_98[64];

//----- (00000000000B5A48) ----------------------------------------------------
bool __fastcall PKCS5_PBKDF2_HMAC_SHA1(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, unsigned int a5, unsigned __int64 a6, int8x16_t *a7)
{
  int8x16_t *v7; // x19
  unsigned __int64 v8; // x20
  unsigned int v9; // w21
  __int64 v10; // x22
  __int64 v11; // x23
  unsigned __int64 v12; // x24
  __int64 v13; // x25
  void *v14; // x0

  v7 = a7;
  v8 = a6;
  v9 = a5;
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  v14 = EVP_sha1();
  return PKCS5_PBKDF2_HMAC(v13, v12, v11, v10, v9, (__int64)v14, v8, v7);
}

//----- (00000000000B5AB8) ----------------------------------------------------
unsigned __int64 __fastcall _udivti3(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // x4
  unsigned __int64 v5; // x6
  unsigned __int64 v6; // x5
  signed __int64 v7; // x3
  signed __int64 v8; // x3
  unsigned __int64 v9; // x1
  signed __int64 v10; // x8
  signed __int64 v11; // x2
  unsigned __int64 v12; // x7
  unsigned __int64 v13; // x0
  __int128 v14; // t2
  unsigned __int64 v15; // x0
  signed __int64 v16; // x7
  unsigned __int64 v17; // x0
  unsigned __int64 v18; // x3
  signed __int64 v19; // x1
  unsigned __int64 v20; // x0
  unsigned __int64 v21; // x4
  signed __int64 v22; // x2
  signed __int64 v23; // x2
  char v24; // w7
  unsigned __int64 v25; // x2
  unsigned __int64 v26; // x5
  unsigned __int64 v27; // x3
  unsigned __int64 v28; // x2
  unsigned __int64 v29; // x9
  unsigned __int64 v30; // x1
  unsigned __int64 v31; // x8
  unsigned __int64 v32; // x0
  __int128 v33; // t2
  unsigned __int64 v34; // x0
  unsigned __int64 v35; // x7
  unsigned __int64 v36; // x2
  unsigned __int64 v37; // x3
  signed __int64 v38; // x8
  signed __int64 v39; // x0
  unsigned __int64 v40; // x5
  unsigned __int64 v41; // x2
  __int128 v42; // t2
  unsigned __int64 v43; // x2
  unsigned __int64 v44; // x8
  signed __int64 v45; // x5
  unsigned __int64 v46; // x7
  unsigned __int64 v47; // x3
  signed __int64 v48; // x4
  signed __int64 v49; // x4
  char v50; // w7
  unsigned __int64 v51; // x3
  unsigned __int64 v52; // x6
  unsigned __int64 v53; // x1
  unsigned __int64 v54; // x5
  unsigned __int64 v55; // x2
  signed __int64 v56; // x10
  signed __int64 v57; // x4
  unsigned __int64 v58; // x9
  unsigned __int64 v59; // x6
  __int128 v60; // t2
  unsigned __int64 v61; // x6
  signed __int64 v62; // x9
  unsigned __int64 v63; // x5
  unsigned __int64 v64; // x8
  signed __int64 v65; // x6
  unsigned __int64 v66; // x1
  __int64 v67; // x3
  unsigned __int64 v68; // x2
  unsigned __int64 v69; // x1
  unsigned __int64 v70; // x8
  unsigned __int64 v71; // x3
  unsigned __int64 v72; // x5
  unsigned __int64 v73; // x2
  unsigned __int64 v74; // x5

  v4 = a3;
  v5 = a1;
  v6 = a2;
  if ( a4 )
  {
    if ( a4 > a2 )
    {
      v21 = 0LL;
    }
    else
    {
      v48 = 56LL;
      do
      {
        if ( (a4 >> v48) & 0xFF )
          break;
        v48 -= 8LL;
      }
      while ( v48 );
      v49 = _clz_tab[a4 >> v48] + v48;
      v50 = 64 - v49;
      if ( v49 == 64 )
      {
        v21 = (a1 >= a3) | (unsigned __int8)(a2 > a4);
      }
      else
      {
        v51 = (a4 << v50) | (a3 >> v49);
        v52 = a2 >> v49;
        v53 = (a2 << v50) | (a1 >> v49);
        v54 = v51 >> 32;
        v55 = a3 << v50;
        v56 = v52 / (v51 >> 32);
        v57 = v56;
        v58 = v56 * (unsigned int)v51;
        *((_QWORD *)&v60 + 1) = v52 - v56 * (v51 >> 32);
        *(_QWORD *)&v60 = v53;
        v59 = v60 >> 32;
        if ( v59 < v58 )
        {
          v59 += v51;
          if ( v59 >= v51 && v59 < v58 )
          {
            v57 = v56 - 2;
            v59 += v51;
          }
          else
          {
            v57 = v56 - 1;
          }
        }
        v61 = v59 - v58;
        v62 = v61 / v54;
        v63 = v61 - v61 / v54 * v54;
        v64 = v62 * (unsigned int)v51;
        v65 = v62;
        v66 = (unsigned int)v53 | (v63 << 32);
        if ( v66 < v64 )
        {
          v66 += v51;
          if ( v66 >= v51 && v66 < v64 )
          {
            v65 = v62 - 2;
            v66 += v51;
          }
          else
          {
            v65 = v62 - 1;
          }
        }
        v21 = v65 | (v57 << 32);
        v67 = (unsigned int)v55;
        v68 = v55 >> 32;
        v69 = v66 - v64;
        v70 = (unsigned int)v21 * v67;
        v71 = (v21 >> 32) * v67;
        v72 = (v21 >> 32) * v68;
        v73 = v71 + (unsigned int)v21 * v68 + (v70 >> 32);
        if ( v73 < v71 )
          v72 += 0x100000000LL;
        v74 = v72 + (v73 >> 32);
        if ( v74 > v69 || v74 == v69 && (unsigned int)v70 + (v73 << 32) > a1 << v50 )
          --v21;
      }
    }
  }
  else if ( a3 <= a2 )
  {
    if ( !a3 )
      v4 = 1 / 0uLL;
    v22 = 56LL;
    do
    {
      if ( (v4 >> v22) & 0xFF )
        break;
      v22 -= 8LL;
    }
    while ( v22 );
    v23 = _clz_tab[v4 >> v22] + v22;
    v24 = 64 - v23;
    if ( v23 == 64 )
    {
      v25 = a2 - v4;
    }
    else
    {
      v4 <<= v24;
      v26 = a2 >> v23;
      v27 = a1 >> v23;
      v28 = v4 >> 32;
      v5 = a1 << v24;
      v29 = v26 / (v4 >> 32);
      v30 = (a2 << v24) | v27;
      v31 = v29 * (unsigned int)v4;
      *((_QWORD *)&v33 + 1) = v26 - v29 * (v4 >> 32);
      *(_QWORD *)&v33 = v30;
      v32 = v33 >> 32;
      if ( v32 < v31 )
      {
        v32 += v4;
        if ( v32 >= v4 && v32 < v31 )
          v32 += v4;
      }
      v34 = v32 - v31;
      v35 = v34 / v28 * (unsigned int)v4;
      v36 = (unsigned int)v30 | ((v34 - v34 / v28 * v28) << 32);
      if ( v36 < v35 )
      {
        v36 += v4;
        if ( v36 >= v4 && v36 < v35 )
          v36 += v4;
      }
      v25 = v36 - v35;
    }
    v37 = v4 >> 32;
    v38 = v25 / (v4 >> 32);
    v39 = v38;
    v40 = v38 * (unsigned int)v4;
    *((_QWORD *)&v42 + 1) = v25 - v38 * (v4 >> 32);
    *(_QWORD *)&v42 = v5;
    v41 = v42 >> 32;
    if ( v41 < v40 )
    {
      v41 += v4;
      if ( v41 >= v4 && v41 < v40 )
      {
        v39 = v38 - 2;
        v41 += v4;
      }
      else
      {
        v39 = v38 - 1;
      }
    }
    v43 = v41 - v40;
    v44 = v43 / v37;
    v45 = v43 / v37;
    v46 = v43 / v37 * (unsigned int)v4;
    v47 = (unsigned int)v5 | ((v43 - v43 / v37 * v37) << 32);
    if ( v47 < v46 )
    {
      if ( v47 + v4 >= v4 && v47 + v4 < v46 )
        v45 = v44 - 2;
      else
        v45 = v44 - 1;
    }
    v21 = v45 | (v39 << 32);
  }
  else
  {
    v7 = 56LL;
    do
    {
      if ( (a3 >> v7) & 0xFF )
        break;
      v7 -= 8LL;
    }
    while ( v7 );
    v8 = 64 - v7 - _clz_tab[a3 >> v7];
    if ( v8 )
    {
      v4 = a3 << v8;
      v6 = (a1 >> (64 - (unsigned __int8)v8)) | (a2 << v8);
      v5 = a1 << v8;
    }
    v9 = v4 >> 32;
    v10 = v6 / (v4 >> 32);
    v11 = v10;
    v12 = v10 * (unsigned int)v4;
    *((_QWORD *)&v14 + 1) = v6 - v10 * (v4 >> 32);
    *(_QWORD *)&v14 = v5;
    v13 = v14 >> 32;
    if ( v13 < v12 )
    {
      v13 += v4;
      if ( v13 >= v4 && v13 < v12 )
      {
        v11 = v10 - 2;
        v13 += v4;
      }
      else
      {
        v11 = v10 - 1;
      }
    }
    v15 = v13 - v12;
    v16 = v15 / v9;
    v17 = v15 - v15 / v9 * v9;
    v18 = v16 * (unsigned int)v4;
    v19 = v16;
    v20 = (unsigned int)v5 | (v17 << 32);
    if ( v20 < v18 )
    {
      if ( v20 + v4 >= v4 && v20 + v4 < v18 )
        v19 = v16 - 2;
      else
        v19 = v16 - 1;
    }
    v21 = v19 | (v11 << 32);
  }
  return v21;
}

//----- (00000000000B5ED8) ----------------------------------------------------
unsigned __int64 __fastcall _umodti3(unsigned __int64 result, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // x7
  unsigned __int64 v5; // x4
  unsigned __int64 v6; // x6
  signed __int64 v7; // x8
  signed __int64 v8; // x8
  unsigned __int64 v9; // x0
  unsigned __int64 v10; // x2
  unsigned __int64 v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x1
  __int128 v14; // t2
  unsigned __int64 v15; // x1
  unsigned __int64 v16; // x3
  unsigned __int64 v17; // x1
  unsigned __int64 v18; // x7
  unsigned __int64 v19; // x1
  signed __int64 v20; // x6
  signed __int64 v21; // x6
  unsigned __int64 v22; // x1
  unsigned __int64 v23; // x3
  unsigned __int64 v24; // x5
  unsigned __int64 v25; // x1
  unsigned __int64 v26; // x5
  unsigned __int64 v27; // x0
  unsigned __int64 v28; // x3
  unsigned __int64 v29; // x0
  unsigned __int64 v30; // x3
  __int128 v31; // t2
  unsigned __int64 v32; // x3
  unsigned __int64 v33; // x0
  unsigned __int64 v34; // x1
  unsigned __int64 v35; // x2
  unsigned __int64 v36; // x0
  unsigned __int64 v37; // x1
  unsigned __int64 v38; // x0
  unsigned __int64 v39; // x1
  __int128 v40; // t2
  unsigned __int64 v41; // x1
  unsigned __int64 v42; // x0
  unsigned __int64 v43; // x1
  signed __int64 v44; // x5
  signed __int64 v45; // x8
  char v46; // w7
  unsigned __int64 v47; // x9
  unsigned __int64 v48; // x3
  unsigned __int64 v49; // x4
  signed __int64 v50; // x11
  unsigned __int64 v51; // x1
  unsigned __int64 v52; // x2
  unsigned __int64 v53; // x0
  signed __int64 v54; // x6
  unsigned __int64 v55; // x10
  unsigned __int64 v56; // x3
  __int128 v57; // t2
  unsigned __int64 v58; // x3
  signed __int64 v59; // x10
  unsigned __int64 v60; // x4
  unsigned __int64 v61; // x5
  signed __int64 v62; // x3
  unsigned __int64 v63; // x4
  unsigned __int64 v64; // x6
  unsigned __int64 v65; // x5
  __int64 v66; // x4
  unsigned __int64 v67; // x3
  unsigned __int64 v68; // x1
  unsigned __int64 v69; // x6
  unsigned __int64 v70; // x4
  unsigned __int64 v71; // x6
  unsigned __int64 v72; // x4
  unsigned __int64 v73; // x2
  unsigned __int64 v74; // x6
  bool v75; // cf
  bool v76; // zf
  signed __int64 v77; // x3
  unsigned __int64 v78; // x4
  unsigned __int64 v79; // x5
  unsigned __int64 v80; // x4
  signed __int64 v81; // x1

  v4 = a3;
  v5 = result;
  v6 = a2;
  if ( a4 )
  {
    v44 = 56LL;
    if ( a4 <= a2 )
    {
      do
      {
        if ( (a4 >> v44) & 0xFF )
          break;
        v44 -= 8LL;
      }
      while ( v44 );
      v45 = _clz_tab[a4 >> v44] + v44;
      v46 = 64 - v45;
      if ( v45 == 64 )
      {
        if ( result >= a3 || a2 > a4 )
          v5 = result - a3;
        result = v5;
      }
      else
      {
        v47 = (a4 << v46) | (a3 >> v45);
        v48 = a2 >> v45;
        v49 = v47 >> 32;
        v50 = (a2 >> v45) / (v47 >> 32);
        v51 = (a2 << v46) | (result >> v45);
        v52 = a3 << v46;
        v53 = result << v46;
        v54 = v50;
        v55 = v50 * (unsigned int)v47;
        *((_QWORD *)&v57 + 1) = v48 - v50 * (v47 >> 32);
        *(_QWORD *)&v57 = v51;
        v56 = v57 >> 32;
        if ( v56 < v55 )
        {
          v56 += v47;
          if ( v56 >= v47 && v56 < v55 )
          {
            v54 = v50 - 2;
            v56 += v47;
          }
          else
          {
            v54 = v50 - 1;
          }
        }
        v58 = v56 - v55;
        v59 = v58 / v49;
        v60 = v58 - v58 / v49 * v49;
        v61 = v59 * (unsigned int)v47;
        v62 = v59;
        v63 = (unsigned int)v51 | (v60 << 32);
        if ( v63 < v61 )
        {
          v63 += v47;
          if ( v63 >= v47 && v63 < v61 )
          {
            v62 = v59 - 2;
            v63 += v47;
          }
          else
          {
            v62 = v59 - 1;
          }
        }
        v64 = v62 | (v54 << 32);
        v65 = v63 - v61;
        v66 = (unsigned int)v64;
        v64 >>= 32;
        v67 = v66 * (unsigned int)v52;
        v68 = v64 * (unsigned int)v52;
        v69 = v64 * (v52 >> 32);
        v70 = v68 + v66 * (v52 >> 32) + (v67 >> 32);
        if ( v70 < v68 )
          v69 += 0x100000000LL;
        v71 = v69 + (v70 >> 32);
        v72 = (unsigned int)v67 + (v70 << 32);
        if ( v71 > v65 || v71 == v65 && v72 > v53 )
        {
          v73 = v72 - v52;
          v74 = v71 - v47;
          v75 = v73 >= v72;
          v76 = v73 == v72;
          v72 = v73;
          if ( !v76 && v75 )
            v77 = 1LL;
          else
            v77 = 0LL;
          v71 = v74 - v77;
        }
        v78 = v53 - v72;
        v79 = v65 - v71;
        v75 = v78 >= v53;
        v76 = v78 == v53;
        v80 = v78 >> v46;
        if ( !v76 && v75 )
          v81 = 1LL;
        else
          v81 = 0LL;
        result = ((v79 - v81) << v45) | v80;
      }
    }
  }
  else
  {
    if ( a3 <= a2 )
    {
      if ( !a3 )
        v4 = 1 / 0uLL;
      v20 = 56LL;
      do
      {
        if ( (v4 >> v20) & 0xFF )
          break;
        v20 -= 8LL;
      }
      while ( v20 );
      v21 = _clz_tab[v4 >> v20] + v20;
      LOBYTE(v8) = 64 - v21;
      if ( v21 == 64 )
      {
        v22 = a2 - v4;
      }
      else
      {
        v4 <<= v8;
        v23 = a2 >> v21;
        v24 = a2 << v8;
        v25 = v4 >> 32;
        v26 = v24 | (result >> v21);
        v5 = result << v8;
        v27 = v23 / (v4 >> 32);
        v28 = v23 - v27 * (v4 >> 32);
        v29 = v27 * (unsigned int)v4;
        *((_QWORD *)&v31 + 1) = v28;
        *(_QWORD *)&v31 = v26;
        v30 = v31 >> 32;
        if ( v30 < v29 )
        {
          v30 += v4;
          if ( v30 >= v4 && v30 < v29 )
            v30 += v4;
        }
        v32 = v30 - v29;
        v33 = v32 / v25 * (unsigned int)v4;
        v34 = (unsigned int)v26 | ((v32 - v32 / v25 * v25) << 32);
        if ( v34 < v33 )
        {
          v34 += v4;
          if ( v34 >= v4 && v34 < v33 )
            v34 += v4;
        }
        v22 = v34 - v33;
      }
      v35 = v4 >> 32;
      v36 = v22 / (v4 >> 32);
      v37 = v22 - v36 * (v4 >> 32);
      v38 = v36 * (unsigned int)v4;
      *((_QWORD *)&v40 + 1) = v37;
      *(_QWORD *)&v40 = v5;
      v39 = v40 >> 32;
      if ( v39 < v38 )
      {
        v39 += v4;
        if ( v39 >= v4 && v39 < v38 )
          v39 += v4;
      }
      v41 = v39 - v38;
      v42 = v41 / v35 * (unsigned int)v4;
      v43 = (unsigned int)v5 | ((v41 - v41 / v35 * v35) << 32);
      if ( v43 < v42 )
      {
        v43 += v4;
        if ( v43 >= v4 && v43 < v42 )
          v43 += v4;
      }
      v19 = v43 - v42;
    }
    else
    {
      v7 = 56LL;
      do
      {
        if ( (a3 >> v7) & 0xFF )
          break;
        v7 -= 8LL;
      }
      while ( v7 );
      v8 = 64 - v7 - _clz_tab[a3 >> v7];
      if ( v8 )
      {
        v4 = a3 << v8;
        v6 = (result >> (64 - (unsigned __int8)v8)) | (a2 << v8);
        v5 = result << v8;
      }
      v9 = v4 >> 32;
      v10 = v6 / (v4 >> 32);
      v11 = v6 - v10 * (v4 >> 32);
      v12 = v10 * (unsigned int)v4;
      *((_QWORD *)&v14 + 1) = v11;
      *(_QWORD *)&v14 = v5;
      v13 = v14 >> 32;
      if ( v13 < v12 )
      {
        v13 += v4;
        if ( v13 >= v4 && v13 < v12 )
          v13 += v4;
      }
      v15 = v13 - v12;
      v16 = v15 / v9 * (unsigned int)v4;
      v17 = (unsigned int)v5 | ((v15 - v15 / v9 * v9) << 32);
      if ( v17 < v16 )
      {
        v17 += v4;
        if ( v17 >= v4 )
        {
          v18 = v17 + v4;
          if ( v17 < v16 )
            v17 = v18;
        }
      }
      v19 = v17 - v16;
    }
    result = v19 >> v8;
  }
  return result;
}

#error "There were 8 decompilation failure(s) on 2370 function(s)"
